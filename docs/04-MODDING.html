<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Modding System - Iron Curtain — Design Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Design docs for a Rust-native Red Alert RTS engine">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-245f6587.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-0698f107.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Iron Curtain — Design Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/DK26/iron-curtain-design-docs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>
                        <a href="https://github.com/DK26/iron-curtain-design-docs/edit/main/src/04-MODDING.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <span class=fa-svg id="git-edit-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M421.7 220.3l-11.3 11.3-22.6 22.6-205 205c-6.6 6.6-14.8 11.5-23.8 14.1L30.8 511c-8.4 2.5-17.5 .2-23.7-6.1S-1.5 489.7 1 481.2L38.7 353.1c2.6-9 7.5-17.2 14.1-23.8l205-205 22.6-22.6 11.3-11.3 33.9 33.9 62.1 62.1 33.9 33.9zM96 353.9l-9.3 9.3c-.9 .9-1.6 2.1-2 3.4l-25.3 86 86-25.3c1.3-.4 2.5-1.1 3.4-2l9.3-9.3H112c-8.8 0-16-7.2-16-16V353.9zM453.3 19.3l39.4 39.4c25 25 25 65.5 0 90.5l-14.5 14.5-22.6 22.6-11.3 11.3-33.9-33.9-62.1-62.1L314.3 67.7l11.3-11.3 22.6-22.6 14.5-14.5c25-25 65.5-25 90.5 0z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="04--modding-system"><a class="header" href="#04--modding-system">04 — Modding System</a></h1>
<p><strong>Keywords:</strong> modding, YAML Lua WASM tiers, <code>ic mod</code> CLI, mod profiles, virtual namespace, Workshop packages, campaigns, export, compatibility, OpenRA mod migration, selective install</p>
<h2 id="three-tier-architecture"><a class="header" href="#three-tier-architecture">Three-Tier Architecture</a></h2>
<pre><code>Ease of use ▲
             │  ┌─────────────────────────┐
             │  │  YAML rules / data       │  ← 80% of mods (Tier 1)
             │  │  (units, weapons, maps)  │
             │  ├─────────────────────────┤
             │  │  Lua scripts             │  ← missions, AI, abilities (Tier 2)
             │  │  (event hooks, triggers) │
             │  ├─────────────────────────┤
             │  │  WASM modules            │  ← new mechanics, total conversions (Tier 3)
             │  │  (Rust/C/AssemblyScript) │
             │  └─────────────────────────┘
Power      ▼
</code></pre>
<p>Each tier is optional. A modder who wants to change tank cost never sees code. A modder building a total conversion uses WASM.</p>
<p><strong>Tier coverage validated by OpenRA mods:</strong> Analysis of six major OpenRA community mods (see <code>research/openra-mod-architecture-analysis.md</code>) confirms the 80/20 split and reveals precise boundaries between tiers. YAML (Tier 1) covers unit stats, weapon definitions, faction variants, inheritance overrides, and prerequisite trees. But every mod that goes beyond stat changes — even faction reskins — eventually needs code (C# in OpenRA, WASM in IC). The validated breakdown:</p>
<ul>
<li><strong>60–80% YAML</strong> — Values, inheritance trees, faction variants, prerequisite DAGs, veterancy tables, weapon definitions, visual sequences. Some mods (Romanovs-Vengeance) achieve substantial new content purely through YAML template extension.</li>
<li><strong>15–30% code</strong> — Custom mechanics (mind control, temporal weapons, mirage disguise, new locomotors), custom format loaders, replacement production systems, and world-level systems (radiation layers, weather). In IC, this is Tier 2 (Lua for scripting) and Tier 3 (WASM for mechanics).</li>
<li><strong>5–10% engine patches</strong> — OpenRA mods sometimes require forking the engine (e.g., OpenKrush replaces 16 complete mechanic modules). IC’s Tier 3 WASM modules + trait abstraction (D041) are designed to eliminate this need entirely — no fork, ever.</li>
</ul>
<h2 id="tier-1-data-driven-yaml-rules"><a class="header" href="#tier-1-data-driven-yaml-rules">Tier 1: Data-Driven (YAML Rules)</a></h2>
<h3 id="decision-real-yaml-not-miniyaml"><a class="header" href="#decision-real-yaml-not-miniyaml">Decision: Real YAML, Not MiniYAML</a></h3>
<p>OpenRA uses “MiniYAML” — a custom dialect that uses tabs, has custom inheritance (<code>^</code>, <code>@</code>), and doesn’t comply with the YAML spec. Standard parsers choke on it.</p>
<p><strong>Our approach:</strong> Standard YAML with <code>serde_yaml</code>, inheritance resolved at load time.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li><code>serde</code> + <code>serde_yaml</code> → typed Rust struct deserialization for free</li>
<li>Every text editor has YAML support, linters, formatters</li>
<li>JSON-schema validation catches errors before the game loads</li>
<li>No custom parser to maintain</li>
</ul>
<h3 id="example-unit-definition"><a class="header" href="#example-unit-definition">Example Unit Definition</a></h3>
<pre><code class="language-yaml"># units/allies/infantry.yaml
units:
  rifle_infantry:
    inherits: _base_soldier
    display:
      name: "Rifle Infantry"
      icon: e1icon
      sequences: e1
    llm:
      summary: "Cheap expendable anti-infantry scout"
      role: [anti_infantry, scout, garrison]
      strengths: [cheap, fast_to_build, effective_vs_infantry]
      weaknesses: [fragile, useless_vs_armor, no_anti_air]
      tactical_notes: &gt;
        Best used in groups of 5+ for early harassment or
        garrisoning buildings. Not cost-effective against
        anything armored. Pair with anti-tank units.
      counters: [tank, apc, attack_dog]
      countered_by: [tank, flamethrower, grenadier]
    buildable:
      cost: 100
      time: 5.0
      queue: infantry
      prerequisites: [barracks]
    health:
      max: 50
      armor: none
    mobile:
      speed: 56
      locomotor: foot
    combat:
      weapon: m1_carbine
      attack_sequence: shoot
</code></pre>
<h4 id="unit-definition-features"><a class="header" href="#unit-definition-features">Unit Definition Features</a></h4>
<p>The YAML unit definition system supports several patterns informed by SC2’s data model (see <code>research/blizzard-github-analysis.md</code> § Part 2):</p>
<p><strong>Stable IDs:</strong> Every unit type, weapon, ability, and upgrade has a stable numeric ID in addition to its string name. Stable IDs are assigned at mod-load time from a deterministic hash of the string name. Replays, network orders, and the analysis event stream reference entities by stable ID for compactness. When a mod renames a unit, backward compatibility is maintained via an explicit <code>aliases</code> list:</p>
<pre><code class="language-yaml">units:
  medium_tank:
    id: 0x1A3F   # optional: override auto-assigned stable ID
    aliases: [med_tank, medium]  # old names still resolve
</code></pre>
<p><strong>Multi-weapon units:</strong> Units can mount multiple weapons with independent targeting, cooldowns, and target filters — matching C&amp;C’s original design where units like the Cruiser have separate anti-ground and anti-air weapons:</p>
<pre><code class="language-yaml">combat:
  weapons:
    - weapon: cruiser_cannon
      turret: primary
      target_filter: [ground, structure]
    - weapon: aa_flak
      turret: secondary
      target_filter: [air]
</code></pre>
<p><strong>Attribute tags:</strong> Units carry attribute tags that affect damage calculations via versus tables. Tags are open-ended strings — game modules define their own sets. The RA1 module uses tags modeled on both C&amp;C’s original armor types and SC2’s attribute system:</p>
<pre><code class="language-yaml">attributes: [armored, mechanical]  # used by damage bonus lookups
</code></pre>
<p>Weapons can declare per-attribute damage bonuses:</p>
<pre><code class="language-yaml">weapons:
  at_missile:
    damage: 60
    damage_bonuses:
      - attribute: armored
        bonus: 30   # +30 damage vs armored targets
      - attribute: light
        bonus: -10  # reduced damage vs light targets
</code></pre>
<h3 id="conditional-modifiers"><a class="header" href="#conditional-modifiers">Conditional Modifiers</a></h3>
<p>Beyond static <code>damage_bonuses</code>, any numeric stat can carry <strong>conditional modifiers</strong> — declarative rules that adjust values based on runtime conditions, attributes, or game state. This is IC’s <strong>Tier 1.5</strong>: more powerful than static YAML data, but still pure data (no Lua required). Inspired by <a href="https://github.com/yairm210/Unciv">Unciv’s “Uniques” system</a> and building on D028’s condition and multiplier systems.</p>
<p><strong>Syntax:</strong> Each modifier specifies an effect, a magnitude, and one or more conditions:</p>
<pre><code class="language-yaml"># Unit definition with conditional modifiers
heavy_tank:
  inherits: _base_vehicle
  health:
    hp: 400
    armor: heavy
  mobile:
    speed: 4
    modifiers:
      - stat: speed
        bonus: +2
        conditions: [on_road]           # +2 speed on roads
      - stat: speed
        multiply: 0.5
        conditions: [on_snow]           # half speed on snow
  combat:
    modifiers:
      - stat: damage
        multiply: 1.25
        conditions: [veterancy &gt;= 1]    # 25% damage boost at vet 1+
      - stat: range
        bonus: +1
        conditions: [deployed]          # +1 range when deployed
      - stat: reload
        multiply: 0.8
        conditions: [near_ally_repair]  # 20% faster reload near repair facility
</code></pre>
<p><strong>Filter types:</strong> Conditions use typed filters matching D028’s <code>ConditionId</code> system:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Filter Type</th><th>Examples</th><th>Resolves Against</th></tr>
</thead>
<tbody>
<tr><td><strong>state</strong></td><td><code>deployed</code>, <code>moving</code>, <code>idle</code>, <code>damaged</code></td><td>Entity condition bitset</td></tr>
<tr><td><strong>terrain</strong></td><td><code>on_road</code>, <code>on_snow</code>, <code>on_water</code>, <code>in_garrison</code></td><td>Cell terrain type</td></tr>
<tr><td><strong>attribute</strong></td><td><code>vs [armored]</code>, <code>vs [infantry]</code>, <code>vs [air]</code></td><td>Target attribute tags</td></tr>
<tr><td><strong>veterancy</strong></td><td><code>veterancy &gt;= 1</code>, <code>veterancy == 3</code></td><td>Entity veterancy level</td></tr>
<tr><td><strong>proximity</strong></td><td><code>near_ally_repair</code>, <code>near_enemy</code>, <code>near_structure</code></td><td>Spatial query (cached/ticked)</td></tr>
<tr><td><strong>global</strong></td><td><code>superweapon_active</code>, <code>low_power</code></td><td>Player-level game state</td></tr>
</tbody>
</table>
</div>
<p><strong>Rust resolution:</strong> At runtime, conditional modifiers feed directly into D028’s <code>StatModifiers</code> component. The YAML loader converts each modifier entry into a <code>(source, stat, modifier_value, condition)</code> tuple:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A single conditional modifier parsed from YAML.
pub struct ConditionalModifier {
    pub stat: StatId,
    pub effect: ModifierEffect,        // Bonus(FixedPoint) or Multiply(FixedPoint)
    pub conditions: Vec&lt;ConditionRef&gt;, // all must be active (AND logic)
}

/// Modifier stack is evaluated per-tick for active entities.
/// Static modifiers (no conditions) are resolved once at spawn.
/// Conditional modifiers re-evaluate when any referenced condition changes.
pub fn resolve_stat(base: FixedPoint, modifiers: &amp;[ConditionalModifier], conditions: &amp;Conditions) -&gt; FixedPoint {
    let mut value = base;
    for m in modifiers {
        if m.conditions.iter().all(|c| conditions.is_active(c)) {
            match m.effect {
                ModifierEffect::Bonus(b) =&gt; value += b,
                ModifierEffect::Multiply(f) =&gt; value = value * f,
            }
        }
    }
    value
}
<span class="boring">}</span></code></pre>
<p><strong>Evaluation order:</strong> Bonuses apply first (additive), then multipliers (multiplicative), matching D028’s modifier stack semantics. Within each category, modifiers apply in YAML declaration order.</p>
<p><strong>Why this matters for modders:</strong> Conditional modifiers let 80% of gameplay customization stay in pure YAML. A modder can create veterancy bonuses, terrain effects, proximity auras, deploy-mode stat changes, and attribute-based damage scaling without writing a single line of Lua. Only novel mechanics (custom AI behaviors, unique ability sequencing, campaign scripting) require escalating to Tier 2 (Lua) or Tier 3 (WASM).</p>
<h3 id="inheritance-system"><a class="header" href="#inheritance-system">Inheritance System</a></h3>
<p>Templates use <code>_</code> prefix convention (not spawnable units):</p>
<pre><code class="language-yaml"># templates/_base_soldier.yaml
_base_soldier:
  mobile:
    locomotor: foot
    turn_speed: 5
  health:
    armor: none
  selectable:
    bounds: [12, 18]
    voice: generic_infantry
</code></pre>
<p>Inheritance is resolved at load time in Rust. Fields from <code>_base_soldier</code> are merged, then overridden by the child definition.</p>
<h3 id="balance-presets"><a class="header" href="#balance-presets">Balance Presets</a></h3>
<p>The same inheritance system powers <strong>switchable balance presets</strong> (D019). Presets are alternate YAML directories that override unit/weapon/structure values:</p>
<pre><code>rules/
├── units/              # base definitions (always loaded)
├── weapons/
├── structures/
└── presets/
    ├── classic/        # EA source code values (DEFAULT)
    │   ├── units/
    │   │   └── tanya.yaml    # cost: 1200, health: 125, weapon_range: 5, ...
    │   └── weapons/
    ├── openra/         # OpenRA competitive balance
    │   ├── units/
    │   │   └── tanya.yaml    # cost: 1400, health: 80, weapon_range: 3, ...
    │   └── weapons/
    └── remastered/     # Remastered Collection tweaks
        └── ...
</code></pre>
<p><strong>How it works:</strong></p>
<ol>
<li>Engine loads base definitions from <code>rules/</code></li>
<li>Engine loads the selected preset directory, overriding matching fields via inheritance</li>
<li>Preset YAML files only contain fields that differ — everything else falls through to base</li>
</ol>
<pre><code class="language-yaml"># rules/presets/openra/units/tanya.yaml
# Only overrides what OpenRA changes — rest inherits from base definition
tanya:
  inherits: _base_tanya       # base definition with display, sequences, AI metadata, etc.
  buildable:
    cost: 1400                 # OpenRA nerfed from 1200
  health:
    max: 80                    # OpenRA nerfed from 125
  combat:
    weapon: tanya_pistol_nerfed  # references an OpenRA-balanced weapon definition
</code></pre>
<p><strong>Lobby integration:</strong> Preset is selected in the game lobby alongside map and faction. All players in a multiplayer game use the same preset (enforced by the sim). The preset name is embedded in replays.</p>
<p>See <code>decisions/09d/D019-balance-presets.md</code> for full rationale.</p>
<h3 id="rust-deserialization"><a class="header" href="#rust-deserialization">Rust Deserialization</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Deserialize)]
struct UnitDef {
    inherits: Option&lt;String&gt;,
    display: DisplayInfo,
    llm: Option&lt;LlmMeta&gt;,
    buildable: Option&lt;BuildableInfo&gt;,
    health: HealthInfo,
    mobile: Option&lt;MobileInfo&gt;,
    combat: Option&lt;CombatInfo&gt;,
}

/// LLM-readable metadata for any game resource.
/// Consumed by ic-llm (mission generation), ic-ai (skirmish AI),
/// and workshop search (semantic matching).
#[derive(Deserialize, Serialize)]
struct LlmMeta {
    summary: String,                    // one-line natural language description
    role: Vec&lt;String&gt;,                  // semantic tags: anti_infantry, scout, siege, etc.
    strengths: Vec&lt;String&gt;,             // what this unit is good at
    weaknesses: Vec&lt;String&gt;,            // what this unit is bad at
    tactical_notes: Option&lt;String&gt;,     // free-text tactical guidance for LLM
    counters: Vec&lt;String&gt;,              // unit types this is effective against
    countered_by: Vec&lt;String&gt;,          // unit types that counter this
}
<span class="boring">}</span></code></pre>
<h3 id="miniyaml-migration--runtime-loading"><a class="header" href="#miniyaml-migration--runtime-loading">MiniYAML Migration &amp; Runtime Loading</a></h3>
<p><strong>Converter tool:</strong> <code>ra-formats</code> includes a <code>miniyaml2yaml</code> CLI converter that translates existing OpenRA mod data to standard YAML. Available for permanent, clean migration.</p>
<p><strong>Runtime loading (D025):</strong> MiniYAML files also load directly at runtime — no pre-conversion required. When <code>ra-formats</code> detects tab-indented content with <code>^</code> inheritance or <code>@</code> suffixes, it auto-converts in memory. The result is identical to what the converter would produce. This means existing OpenRA mods can be dropped into IC and played immediately.</p>
<pre><code>┌─────────────────────────────────────────────────────────┐
│           MiniYAML Loading Pipeline                     │
│                                                         │
│  .yaml file ──→ Format detection                        │
│                   │                                     │
│                   ├─ Standard YAML → serde_yaml parse   │
│                   │                                     │
│                   └─ MiniYAML detected                  │
│                       │                                 │
│                       ├─ MiniYAML parser (tabs, ^, @)   │
│                       ├─ Intermediate tree              │
│                       ├─ Alias resolution (D023)        │
│                       └─ Typed Rust structs             │
│                                                         │
│  Both paths produce identical output.                   │
│  Runtime conversion adds ~10-50ms per mod (cached).     │
└─────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="openra-vocabulary-aliases-d023"><a class="header" href="#openra-vocabulary-aliases-d023">OpenRA Vocabulary Aliases (D023)</a></h3>
<p>OpenRA trait names are accepted as aliases for IC-native YAML keys. Both forms are valid:</p>
<pre><code class="language-yaml"># OpenRA-style (accepted via alias)
rifle_infantry:
    Armament:
        Weapon: M1Carbine
    Valued:
        Cost: 100

# IC-native style (preferred)
rifle_infantry:
    combat:
        weapon: m1_carbine
    buildable:
        cost: 100
</code></pre>
<p>The alias registry lives in <code>ra-formats</code> and maps all ~130 OpenRA trait names to IC components. When an alias is used, parsing succeeds with a deprecation warning: <code>"Armament" is accepted but deprecated; prefer "combat"</code>. Warnings can be suppressed per-mod.</p>
<h3 id="openra-mod-manifest-loading-d026"><a class="header" href="#openra-mod-manifest-loading-d026">OpenRA Mod Manifest Loading (D026)</a></h3>
<p>IC can parse OpenRA’s <code>mod.yaml</code> manifest format directly. Point IC at an existing OpenRA mod directory:</p>
<pre><code class="language-bash"># Run an OpenRA mod directly (auto-converts at load time)
ic mod run --openra-dir /path/to/openra-mod/

# Import for permanent migration
ic mod import /path/to/openra-mod/ --output ./my-ic-mod/
</code></pre>
<p>Sections like <code>Rules</code>, <code>Sequences</code>, <code>Weapons</code>, <code>Maps</code>, <code>Voices</code>, <code>Music</code> are mapped to IC equivalents. <code>Assemblies</code> (C# DLLs) are flagged as warnings — units using unavailable traits get placeholder rendering.</p>
<p><strong>OpenRA mod composition patterns and IC’s alternative:</strong> OpenRA mods compose functionality by stacking C# DLL assemblies. Romanovs-Vengeance loads <strong>five DLLs simultaneously</strong> (Common, Cnc, D2k, RA2, AttacqueSuperior) to combine cross-game components. OpenKrush uses <code>Include:</code> directives to compose modular content directories, each with their own rules, sequences, and assets. This DLL-stacking approach works but creates fragile version dependencies — a new OpenRA release can break all mods simultaneously.</p>
<p>IC’s mod composition replaces DLL stacking with a layered mod dependency system (see Mod Load Order below) combined with WASM modules for new mechanics. Instead of stacking opaque DLLs, mods declare explicit dependencies and the engine resolves load order deterministically. Cross-game component reuse (D029) works through the engine’s first-party component library — no need to import foreign game module DLLs just to access a carrier/spawner system or mind control mechanic.</p>
<h3 id="why-not-toml--ron--json"><a class="header" href="#why-not-toml--ron--json">Why Not TOML / RON / JSON?</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Verdict</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>TOML</td><td>Reject</td><td>Awkward for deeply nested game data</td></tr>
<tr><td>RON</td><td>Reject</td><td>Modders won’t know it, thin editor support</td></tr>
<tr><td>JSON</td><td>Reject</td><td>Too verbose, no comments, miserable for hand-editing</td></tr>
<tr><td>YAML</td><td>Accept</td><td>Human-readable, universal tooling, serde integration</td></tr>
</tbody>
</table>
</div>
<h3 id="mod-load-order--conflict-resolution"><a class="header" href="#mod-load-order--conflict-resolution">Mod Load Order &amp; Conflict Resolution</a></h3>
<p>When multiple mods modify the same game data, deterministic load order and explicit conflict handling are essential. Bethesda taught the modding world this lesson: Skyrim’s 200+ mod setups are only viable because community tools (LOOT, xEdit, Bashed Patches) compensate for Bethesda’s vague native load order. IC builds deterministic conflict resolution into the engine from day one — no third-party tools required.</p>
<p><strong>Three-phase data loading (from Factorio):</strong> Factorio’s mod loading uses three sequential phases — <code>data.lua</code> (define new prototypes), <code>data-updates.lua</code> (modify prototypes defined by other mods), <code>data-final-fixes.lua</code> (final overrides that run after all mods) — which eliminates load-order conflicts for the vast majority of mod interactions. IC should adopt an analogous three-phase approach for YAML/Lua mod loading:</p>
<ol>
<li><strong>Define phase:</strong> Mods declare new actors, weapons, and rules (additive only — no overrides)</li>
<li><strong>Modify phase:</strong> Mods modify definitions from earlier mods (explicit dependency required)</li>
<li><strong>Final-fixes phase:</strong> Balance patches and compatibility layers apply last-wins overrides</li>
</ol>
<p>This structure means a mod that defines new units and a mod that rebalances existing units don’t conflict — they run in different phases by design. Factorio’s 8,000+ mod ecosystem validates that three-phase loading scales to massive mod counts. See <code>research/mojang-wube-modding-analysis.md</code> § Factorio.</p>
<p><strong>Load order rules:</strong></p>
<ol>
<li><strong>Engine defaults</strong> load first (built-in RA1/TD rules).</li>
<li><strong>Balance preset</strong> (D019) overlays next.</li>
<li><strong>Mods</strong> load in dependency-graph order — if mod A depends on mod B, B loads first.</li>
<li><strong>Mods with no dependency relationship</strong> between them load in lexicographic order by mod ID. Deterministic tiebreaker — no ambiguity.</li>
<li><strong>Within a mod</strong>, files load in directory order, then alphabetical within each directory.</li>
</ol>
<p><strong>Multiplayer enforcement:</strong> In multiplayer, the lobby enforces identical mod sets, versions, and load order across all clients before the game starts (see <code>03-NETCODE.md</code> § <code>GameListing.required_mods</code>). The deterministic load order is sufficient <em>because</em> divergent mod configurations are rejected at join time — there is no scenario where two clients resolve the same mods differently.</p>
<p><strong>Conflict behavior (same YAML key modified by two mods):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scenario</th><th>Behavior</th><th>Rationale</th></tr>
</thead>
<tbody>
<tr><td>Two mods set different values for the same field on the same unit</td><td>Last-wins (later in load order) + warning in <code>ic mod check</code></td><td>Modders need to know about the collision</td></tr>
<tr><td>Mod adds a new field to a unit also modified by another mod</td><td>Merge — both additions survive</td><td>Non-conflicting additions are safe</td></tr>
<tr><td>Mod deletes a field that another mod modifies</td><td>Delete wins + warning</td><td>Explicit deletion is intentional</td></tr>
<tr><td>Two mods define the same new unit ID</td><td>Error — refuses to load</td><td>Ambiguous identity is never acceptable</td></tr>
</tbody>
</table>
</div>
<p><strong>Tooling:</strong></p>
<ul>
<li><code>ic mod check-conflicts [mod1] [mod2] ...</code> — reports all field-level conflicts between a set of mods before launch. Shows which mod “wins” each conflict and why.</li>
<li><code>ic mod load-order [mod1] [mod2] ...</code> — prints the resolved load order with dependency graph visualization.</li>
<li>In-game mod manager shows conflict warnings with “which mod wins” detail when enabling mods.</li>
</ul>
<p><strong>Conflict override file (optional):</strong></p>
<p>For advanced setups, a <code>conflicts.yaml</code> file in the <strong>game’s user configuration directory</strong> (next to <code>settings.toml</code>) lets the player explicitly resolve conflicts in their personal setup. This is a per-user file — it is not distributed with mods or modpacks, and it is not synced in multiplayer. Players who want to share their conflict resolutions can distribute the file manually or include it in a modpack manifest (the <code>modpack.conflicts</code> field serves the same purpose for published modpacks):</p>
<pre><code class="language-yaml"># conflicts.yaml — explicit conflict resolution
overrides:
  - unit: heavy_tank
    field: health.max
    use_mod: "alice/tank-rebalance"     # force this mod's value
    reason: "Prefer Alice's balance for heavy tanks"
  - unit: rifle_infantry
    field: buildable.cost
    use_mod: "bob/economy-overhaul"
</code></pre>
<p>This is the manual equivalent of Bethesda’s Bashed Patches — but declarative, version-controlled, and shareable.</p>
<h3 id="mod-profiles--virtual-asset-namespace-d062"><a class="header" href="#mod-profiles--virtual-asset-namespace-d062">Mod Profiles &amp; Virtual Asset Namespace (D062)</a></h3>
<p>The load order, active mod set, conflict resolutions, and experience settings (D033) compose into a <strong>mod profile</strong> — a named, hashable, switchable YAML file that captures a complete mod configuration:</p>
<pre><code class="language-yaml"># &lt;data_dir&gt;/profiles/tournament-s5.yaml
profile:
  name: "Tournament Season 5"
  game_module: ra1
sources:
  - id: "official/tournament-balance"
    version: "=1.3.0"
  - id: "official/hd-sprites"
    version: "=2.0.1"
conflicts:
  - unit: heavy_tank
    field: health.max
    use_source: "official/tournament-balance"
experience:
  balance: classic
  theme: remastered
  pathfinding: ic_default
fingerprint: null  # computed at activation
</code></pre>
<p>When a profile is activated, the engine builds a <strong>virtual asset namespace</strong> — a resolved lookup table mapping every logical asset path to a content-addressed blob (D049 local CAS) and every YAML rule to its merged value. The namespace fingerprint (SHA-256 of sorted entries) serves as a single-value compatibility check in multiplayer lobbies and replay playback. See <code>decisions/09c-modding.md</code> § D062 for the full design: namespace struct, Bevy <code>AssetSource</code> integration, lobby fingerprint verification, editor hot-swap, and the relationship between local profiles and published modpacks (D030).</p>
<p><strong>Phase:</strong> Load order engine support in Phase 2 (part of YAML rule loading). <code>VirtualNamespace</code> struct and fingerprinting in Phase 2. <code>ic profile</code> CLI in Phase 4. Lobby fingerprint verification in Phase 5. Conflict detection CLI in Phase 4 (with <code>ic</code> CLI). In-game mod manager with profile dropdown in Phase 6a.</p>
<h2 id="tier-2-lua-scripting"><a class="header" href="#tier-2-lua-scripting">Tier 2: Lua Scripting</a></h2>
<h3 id="decision-lua-over-python"><a class="header" href="#decision-lua-over-python">Decision: Lua over Python</a></h3>
<p><strong>Why Lua:</strong></p>
<ul>
<li>Tiny runtime (~200KB)</li>
<li>Designed for embedding — exists for this purpose</li>
<li>Deterministic (provide fixed-point math bindings, no floats)</li>
<li>Trivially sandboxable (control exactly what functions are available)</li>
<li>Industry standard: Factorio, WoW, Garry’s Mod, Dota 2, Roblox</li>
<li><code>mlua</code> or <code>rlua</code> crates are mature</li>
<li>Any modder can learn in an afternoon</li>
</ul>
<p><strong>Why NOT Python:</strong></p>
<ul>
<li>Floating-point non-determinism breaks lockstep multiplayer</li>
<li>GC pauses (reintroduces the problem Rust solves)</li>
<li>50-100x slower than native (hot paths run every tick for every unit)</li>
<li>Embedding CPython is heavy (~15-30MB)</li>
<li>Sandboxing is basically unsolvable — security disaster for community mods</li>
<li><code>import os; os.system("rm -rf /")</code> is one mod away</li>
</ul>
<h3 id="lua-api--strict-superset-of-openra-d024"><a class="header" href="#lua-api--strict-superset-of-openra-d024">Lua API — Strict Superset of OpenRA (D024)</a></h3>
<p>Iron Curtain’s Lua API is a <strong>strict superset</strong> of OpenRA’s 16 global objects. All OpenRA Lua missions run unmodified — same function names, same parameter signatures, same return types.</p>
<p><strong>OpenRA-compatible globals (all supported identically):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Global</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Actor</code></td><td>Create, query, manipulate actors</td></tr>
<tr><td><code>Map</code></td><td>Terrain, bounds, spatial queries</td></tr>
<tr><td><code>Trigger</code></td><td>Event hooks (OnKilled, AfterDelay)</td></tr>
<tr><td><code>Media</code></td><td>Audio, video, text display</td></tr>
<tr><td><code>Player</code></td><td>Player state, resources, diplomacy</td></tr>
<tr><td><code>Reinforcements</code></td><td>Spawn units at edges/drops</td></tr>
<tr><td><code>Camera</code></td><td>Pan, position, shake</td></tr>
<tr><td><code>DateTime</code></td><td>Game time queries</td></tr>
<tr><td><code>Objectives</code></td><td>Mission objective management</td></tr>
<tr><td><code>Lighting</code></td><td>Global lighting control</td></tr>
<tr><td><code>UserInterface</code></td><td>UI text, notifications</td></tr>
<tr><td><code>Utils</code></td><td>Math, random, table utilities</td></tr>
<tr><td><code>Beacon</code></td><td>Map beacon management</td></tr>
<tr><td><code>Radar</code></td><td>Radar ping control</td></tr>
<tr><td><code>HSLColor</code></td><td>Color construction</td></tr>
<tr><td><code>WDist</code></td><td>Distance unit conversion</td></tr>
</tbody>
</table>
</div>
<p><strong>IC-exclusive extensions (additive, no conflicts):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Global</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Campaign</code></td><td>Branching campaign state (D021)</td></tr>
<tr><td><code>Weather</code></td><td>Dynamic weather control (D022)</td></tr>
<tr><td><code>Layer</code></td><td>Map layer activation/deactivation — dynamic map expansion, phase reveals, camera bounds changes. Layers group terrain, entities, and triggers into named sets that can be activated/deactivated at runtime. See § Dynamic Mission Flow below for the full API.</td></tr>
<tr><td><code>SubMap</code></td><td>Sub-map transitions — enter building interiors, underground sections, or alternate map views mid-mission. Main map state freezes while sub-map is active. See § Dynamic Mission Flow below for the full API.</td></tr>
<tr><td><code>Region</code></td><td>Named region queries</td></tr>
<tr><td><code>Var</code></td><td>Mission/campaign variable access</td></tr>
<tr><td><code>Workshop</code></td><td>Mod metadata queries</td></tr>
<tr><td><code>LLM</code></td><td>LLM integration hooks (Phase 7)</td></tr>
<tr><td><code>Achievement</code></td><td>Achievement trigger/query API (D036)</td></tr>
<tr><td><code>Tutorial</code></td><td>Tutorial step management, contextual hints, UI highlighting, camera focus, build/order restrictions for pedagogical pacing (D065). Available in all game modes — modders use it to build tutorial sequences in custom campaigns. See <code>decisions/09g/D065-tutorial.md</code> for the full API.</td></tr>
<tr><td><code>Ai</code></td><td>AI scripting primitives (Phase 4) — force composition, resource ratios, patrol/attack commands; inspired by Stratagus’s proven Lua AI API (<code>AiForce</code>, <code>AiSetCollect</code>, <code>AiWait</code> pattern — see <code>research/stratagus-stargus-opencraft-analysis.md</code>). Enables Tier 2 modders to write custom AI behaviors without Tier 3 WASM.</td></tr>
</tbody>
</table>
</div>
<p>Each actor reference exposes properties matching its components (<code>.Health</code>, <code>.Location</code>, <code>.Owner</code>, <code>.Move()</code>, <code>.Attack()</code>, <code>.Stop()</code>, <code>.Guard()</code>, <code>.Deploy()</code>, etc.) — identical to OpenRA’s actor property groups.</p>
<p><strong>In-game command system (inspired by Mojang’s Brigadier):</strong> Mojang’s Brigadier parser (3,668★, MIT) defines commands as a typed tree where each node is an argument with a parser, suggestions, and permission checks. This architecture — tree-based, type-safe, permission-aware, with mod-injected commands — is the model for IC’s in-game console and chat commands. Mods should be able to register custom commands (e.g., <code>/spawn</code>, <code>/weather</code>, <code>/teleport</code> for mission scripting) using the same tree-based architecture, with tab-completion suggestions generated from the command tree. See <code>research/mojang-wube-modding-analysis.md</code> § Brigadier and <code>decisions/09g/D058-command-console.md</code> for the full command console design.</p>
<h3 id="api-design-principle-runtime-independent-api-surface"><a class="header" href="#api-design-principle-runtime-independent-api-surface">API Design Principle: Runtime-Independent API Surface</a></h3>
<p>The Lua API is defined as an <strong>engine-level abstraction</strong>, independent of the Lua VM implementation. This lesson comes from Valve’s Source Engine VScript architecture (see <code>research/valve-github-analysis.md</code> § 2.3): VScript defined a scripting API abstraction layer so the same mod scripts work across Squirrel, Lua, and Python backends — the <em>API surface</em> is the stable contract, not the VM runtime.</p>
<p>For IC, this means:</p>
<ol>
<li>
<p><strong>The API specification is the contract.</strong> The 16 OpenRA-compatible globals and IC extensions are defined by their function signatures, parameter types, return types, and side effects — not by <code>mlua</code> implementation details. A mod that calls <code>Actor.Create("tank", pos)</code> depends on the API spec, not on how <code>mlua</code> dispatches the call.</p>
</li>
<li>
<p><strong><code>mlua</code> is an implementation detail, not an API boundary.</strong> The <code>mlua</code> crate is deeply integrated and switching Lua VM implementations (LuaJIT, Luau, or a future alternative) would be a substantial engineering effort. But mod scripts should never need to change when the VM implementation changes — they interact with the API surface, which is stable.</p>
</li>
<li>
<p><strong>WASM mods use the same API.</strong> Tier 3 WASM modules access the equivalent API through host functions (see WASM Host API below). The function names, parameters, and semantics are identical. A mission modder can prototype in Lua (Tier 2) and port to WASM (Tier 3) by translating syntax, not by learning a different API.</p>
</li>
<li>
<p><strong>The API surface is testable independently.</strong> Integration tests define expected behavior per-function (“<code>Actor.Create</code> with valid parameters returns an actor reference; with invalid parameters returns nil and logs a warning”). These tests validate any VM backend — they test the specification, not <code>mlua</code> internals.</p>
</li>
</ol>
<p>This principle ensures the modding ecosystem survives VM transitions, just as VScript mods survived Valve’s backend switches. The API is the asset; the runtime is replaceable.</p>
<h3 id="lua-api-examples"><a class="header" href="#lua-api-examples">Lua API Examples</a></h3>
<pre><code class="language-lua">-- Mission scripting
function OnPlayerEnterArea(player, area)
  if area == "bridge_crossing" then
    SpawnReinforcements("allies", {"Tank", "Tank"}, "north")
    PlayEVA("reinforcements_arrived")
  end
end

-- Custom unit behavior
Hooks.OnUnitCreated("ChronoTank", function(unit)
  unit:AddAbility("chronoshift", {
    cooldown = 120,
    range = 15,
    onActivate = function(target_cell)
      PlayEffect("chrono_flash", unit.position)
      unit:Teleport(target_cell)
      PlayEffect("chrono_flash", target_cell)
    end
  })
end)

-- Idle unit automation (inspired by SC2's OnUnitIdle callback —
-- see research/blizzard-github-analysis.md § Part 6)
Hooks.OnUnitIdle("Harvester", function(unit)
  -- Automatically send idle harvesters back to the nearest ore field
  local ore = Map.FindClosestResource(unit.position, "ore")
  if ore then
    unit:Harvest(ore)
  end
end)
</code></pre>
<h3 id="lua-sandbox-rules"><a class="header" href="#lua-sandbox-rules">Lua Sandbox Rules</a></h3>
<ul>
<li>Only engine-provided functions available (no <code>io</code>, <code>os</code>, <code>require</code> from filesystem)</li>
<li><code>os.time()</code>, <code>os.clock()</code>, <code>os.date()</code> are removed entirely — Lua scripts read game time via <code>Trigger.GetTick()</code> and <code>DateTime.GameTime</code></li>
<li>Fixed-point math provided via engine bindings (no raw floats)</li>
<li>Execution resource limits per tick (see <code>LuaExecutionLimits</code> below)</li>
<li>Memory limits per mod</li>
</ul>
<p><strong>Lua standard library inclusion policy</strong> (precedent: Stratagus selectively loads stdlib modules, excluding <code>io</code> and <code>package</code> in release builds — see <code>research/stratagus-stargus-opencraft-analysis.md</code> §6). IC is stricter:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Lua stdlib</th><th>Loaded</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><code>base</code></td><td>✅ selective</td><td><code>print</code> redirected to engine log; <code>dofile</code>, <code>loadfile</code>, <code>load</code> <strong>removed</strong> (arbitrary code execution vectors)</td></tr>
<tr><td><code>table</code></td><td>✅</td><td>Safe — table manipulation only</td></tr>
<tr><td><code>string</code></td><td>✅</td><td>Safe — string operations only</td></tr>
<tr><td><code>math</code></td><td>✅ modified</td><td><code>math.random</code> <strong>removed</strong> — replaced by <code>Utils.RandomInteger()</code> from engine’s deterministic PRNG</td></tr>
<tr><td><code>coroutine</code></td><td>✅</td><td>Useful for mission scripting flow control</td></tr>
<tr><td><code>utf8</code></td><td>✅</td><td>Safe — Unicode string handling (Lua 5.4)</td></tr>
<tr><td><code>io</code></td><td>❌</td><td>Filesystem access — never loaded in sandbox</td></tr>
<tr><td><code>os</code></td><td>❌</td><td><code>os.execute()</code>, <code>os.remove()</code>, <code>os.rename()</code> are dangerous; entire module excluded</td></tr>
<tr><td><code>package</code></td><td>❌</td><td>Module loading from filesystem — never loaded in sandbox</td></tr>
<tr><td><code>debug</code></td><td>❌</td><td>Can inspect/modify internals, bypass sandboxing; development-only if needed</td></tr>
</tbody>
</table>
</div>
<p><strong>Determinism note:</strong> Lua’s internal number type is <code>f64</code>, but this does not affect sim determinism. Lua has <strong>read-only access</strong> to game state and <strong>write access exclusively through orders</strong> (and campaign state writes like <code>Campaign.set_flag()</code>, which are themselves deterministic because they execute at the same pipeline step on every client). The sim processes orders deterministically — Lua cannot directly modify sim components. Lua evaluation produces identical results across all clients because it runs at the same point in the system pipeline (the <code>triggers</code> step, see system execution order in <code>02-ARCHITECTURE.md</code>), with the same game state as input, on every tick. Any Lua-driven campaign state mutations are applied deterministically within this step, ensuring save/load and replay consistency.</p>
<p><strong>Additional determinism safeguards:</strong></p>
<ul>
<li><strong>String hashing → deterministic <code>pairs()</code>:</strong> Lua’s internal string hash uses a randomized seed by default (since Lua 5.3.3). The sandbox initializes <code>mlua</code> with a fixed seed, making hash table slot ordering identical across all clients. Combined with our deterministic pipeline (same code, same state, same insertion order on every client), this makes <code>pairs()</code> iteration order deterministic without modification. No sorted wrapper is needed — <code>pairs()</code> runs at native speed (zero overhead). For mod authors who want <em>explicit</em> ordering for gameplay clarity (e.g., “process units alphabetically”), the engine provides <code>Utils.SortedPairs(t)</code> — but this is a convenience for readability, not a determinism requirement. <code>ipairs()</code> is already deterministic (sequential integer keys) and should be preferred for array-style tables.</li>
<li><strong>Garbage collection timing:</strong> Lua’s GC is configured with a fixed-step incremental mode (<code>LUA_GCINC</code>) with identical parameters on all clients. Finalizers (<code>__gc</code> metamethods) are disabled in the sandbox — mods cannot register them. This eliminates GC-timing-dependent side effects.</li>
<li><strong><code>math.random()</code>:</strong> Removed from the sandbox. Mods use the engine-provided <code>Utils.RandomInteger(min, max)</code> which draws from the sim’s deterministic PRNG.</li>
</ul>
<h3 id="lua-execution-resource-limits"><a class="header" href="#lua-execution-resource-limits">Lua Execution Resource Limits</a></h3>
<p>WASM mods have <code>WasmExecutionLimits</code> (see Tier 3 below). Lua scripts need equivalent protection — without execution budgets, a Lua <code>while true do end</code> would block the deterministic tick indefinitely, freezing all clients in lockstep.</p>
<p>The <code>mlua</code> crate supports instruction count hooks via <code>Lua::set_hook(HookTriggers::every_nth_instruction(N), callback)</code>. The engine uses this to enforce per-tick execution budgets:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Per-tick execution budget for Lua scripts, enforced via mlua instruction hooks.
/// Exceeding the instruction limit terminates the script's current callback —
/// the sim continues without the script's remaining contributions for that tick.
/// A warning is logged and the mod is flagged for the host.
pub struct LuaExecutionLimits {
    pub max_instructions_per_tick: u32,    // mlua instruction hook fires at this count
    pub max_memory_bytes: usize,           // mlua memory limit callback
    pub max_entity_spawns_per_tick: u32,   // Mirrors WASM limit — prevents chain-reactive spawns
    pub max_orders_per_tick: u32,          // Prevents order pipeline flooding
    pub max_host_calls_per_tick: u32,      // Bounds engine API call volume
}

impl Default for LuaExecutionLimits {
    fn default() -&gt; Self {
        Self {
            max_instructions_per_tick: 1_000_000,  // ~1M Lua instructions — generous for missions
            max_memory_bytes: 8 * 1024 * 1024,     // 8 MB (Lua is lighter than WASM)
            max_entity_spawns_per_tick: 32,
            max_orders_per_tick: 64,
            max_host_calls_per_tick: 1024,
        }
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Why this matters:</strong> The same reasoning as WASM limits applies. In deterministic lockstep, a runaway Lua script on one client blocks the tick for all players (everyone waits for the slowest client). The instruction limit ensures Lua callbacks complete in bounded time. Because the limit is deterministic (same instruction budget, same cutoff point), all clients agree on when a script is terminated — no desync.</p>
<p><strong>Mod authors can request higher limits</strong> via their mod manifest, same as WASM mods. The lobby displays requested limits and players can accept or reject. Campaign/mission scripts bundled with the game use elevated limits since they are trusted first-party content.</p>
<blockquote>
<p><strong>Security (V39):</strong> Three edge cases in Lua limit enforcement: <code>string.rep</code> memory amplification (allocates before limit fires), coroutine instruction counter resets at yield/resume, and <code>pcall</code> suppressing limit violation errors. Mitigations: intercept <code>string.rep</code> with pre-allocation size check, verify instruction counting spans coroutines, make limit violations non-catchable (fatal to script context, not Lua errors). See <code>06-SECURITY.md</code> § Vulnerability 39.</p>
</blockquote>
<h2 id="tier-3-wasm-modules"><a class="header" href="#tier-3-wasm-modules">Tier 3: WASM Modules</a></h2>
<h3 id="rationale"><a class="header" href="#rationale">Rationale</a></h3>
<ul>
<li>Near-native performance for complex mods</li>
<li>Perfectly sandboxed by design (WASM’s memory model)</li>
<li>Deterministic execution (critical for multiplayer)</li>
<li>Modders write in Rust, C, Go, AssemblyScript, or even Python compiled to WASM</li>
<li><code>wasmtime</code> or <code>wasmer</code> crates</li>
</ul>
<h3 id="browser-build-limitation-wasm-on-wasm"><a class="header" href="#browser-build-limitation-wasm-on-wasm">Browser Build Limitation (WASM-on-WASM)</a></h3>
<p>When IC is compiled to WASM for the browser target (Phase 7), Tier 3 WASM mods present a fundamental problem: <code>wasmtime</code> does not compile to <code>wasm32-unknown-unknown</code>. The game itself is running as WASM in the browser — it cannot embed a full WASM runtime to run mod WASM modules inside itself.</p>
<p><strong>Implications:</strong></p>
<ul>
<li><strong>Browser builds support Tier 1 (YAML) and Tier 2 (Lua) mods only.</strong> Lua via <code>mlua</code> compiles to WASM and executes as interpreted bytecode within the browser build. YAML is pure data.</li>
<li><strong>Tier 3 WASM mods are desktop/server-only</strong> (native builds where <code>wasmtime</code> runs normally).</li>
<li><strong>Multiplayer between browser and desktop clients</strong> is not affected by this limitation <em>for the base game</em> — the sim, networking, and all built-in systems are native Rust compiled to WASM. The limitation only matters when a lobby requires a Tier 3 mod; browser clients cannot join such lobbies.</li>
</ul>
<p><strong>Future mitigation:</strong> A WASM interpreter written in pure Rust (e.g., <code>wasmi</code>) can itself compile to <code>wasm32-unknown-unknown</code>, enabling Tier 3 mods in the browser at reduced performance (~10-50x slower than native <code>wasmtime</code>). This is acceptable for lightweight WASM mods (AI strategies, format loaders) but likely too slow for complex pathfinder or render mods. When/if this becomes viable, the engine would use <code>wasmtime</code> on native builds and <code>wasmi</code> on browser builds — same mod binary, different execution speed. This is a Phase 7+ concern.</p>
<p><strong>Lobby enforcement:</strong> Servers advertise their Tier 3 support level. Browser clients filter the server browser to show only lobbies they can join. A lobby requiring a Tier 3 WASM mod displays a platform restriction badge.</p>
<h3 id="wasm-host-api-security-boundary"><a class="header" href="#wasm-host-api-security-boundary">WASM Host API (Security Boundary)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The WASM host functions are the ONLY API mods can call.
// The API surface IS the security boundary.

#[wasm_host_fn]
fn get_unit_position(unit_id: u32) -&gt; Option&lt;(i32, i32)&gt; {
    let unit = sim.get_unit(unit_id)?;
    // CHECK: is this unit visible to the mod's player?
    if !sim.is_visible_to(mod_player, unit.position) {
        return None;  // Mod cannot see fogged units
    }
    Some(unit.position)
}

// There is no get_all_units() function.
// There is no get_enemy_state() function.
<span class="boring">}</span></code></pre>
<h3 id="mod-capabilities-system"><a class="header" href="#mod-capabilities-system">Mod Capabilities System</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ModCapabilities {
    pub read_own_state: bool,
    pub read_visible_state: bool,
    // Can NEVER read fogged state (API doesn't exist)
    pub issue_orders: bool,           // For AI mods
    pub render: bool,                 // For render mods (ic_render_* API)
    pub pathfinding: bool,            // For pathfinder mods (ic_pathfind_* API)
    pub ai_strategy: bool,            // For AI mods (ic_ai_* API + AiStrategy trait)
    pub filesystem: FileAccess,       // Usually None
    pub network: NetworkAccess,       // Usually None
}

pub enum NetworkAccess {
    None,                          // Most mods
    AllowList(Vec&lt;String&gt;),        // UI mods fetching assets
    // NEVER unrestricted
}
<span class="boring">}</span></code></pre>
<blockquote>
<p><strong>Security (V43):</strong> Domain-based <code>AllowList</code> is vulnerable to DNS rebinding — an approved domain can be re-pointed to <code>127.0.0.1</code> or <code>192.168.x.x</code> after capability review. Mitigations: block RFC 1918/loopback/link-local IP ranges after DNS resolution, pin DNS at mod load time, validate resolved IP on every request. See <code>06-SECURITY.md</code> § Vulnerability 43.</p>
</blockquote>
<h3 id="wasm-execution-resource-limits"><a class="header" href="#wasm-execution-resource-limits">WASM Execution Resource Limits</a></h3>
<p>Capability-based API controls <em>what</em> a mod can do. Execution resource limits control <em>how much</em>. Without them, a mod could consume unbounded CPU or spawn unbounded entities — degrading performance for all players and potentially overwhelming the network layer (Bryant &amp; Saiedian 2021 documented this in Risk of Rain 2: “procedurally generated effects combined to produce unintended chain-reactive behavior which may ultimately overwhelm the ability for game clients to render objects or handle sending/receiving of game update messages”).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Per-tick execution budget enforced by the WASM runtime (wasmtime fuel metering).
/// Exceeding any limit terminates the mod's tick callback early — the sim continues
/// without the mod's remaining contributions for that tick.
pub struct WasmExecutionLimits {
    pub fuel_per_tick: u64,              // wasmtime fuel units (~1 per wasm instruction)
    pub max_memory_bytes: usize,         // WASM linear memory cap (default: 16 MB)
    pub max_entity_spawns_per_tick: u32, // Prevents chain-reactive entity explosions (default: 32)
    pub max_orders_per_tick: u32,        // AI mods can't flood the order pipeline (default: 64)
    pub max_host_calls_per_tick: u32,    // Bounds API call volume (default: 1024)
}

impl Default for WasmExecutionLimits {
    fn default() -&gt; Self {
        Self {
            fuel_per_tick: 1_000_000,       // ~1M instructions — generous for most mods
            max_memory_bytes: 16 * 1024 * 1024,  // 16 MB
            max_entity_spawns_per_tick: 32,
            max_orders_per_tick: 64,
            max_host_calls_per_tick: 1024,
        }
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Why this matters for multiplayer:</strong> In deterministic lockstep, all clients run the same mods. A mod that consumes excessive CPU causes tick overruns on slower machines, triggering adaptive run-ahead increases for everyone. A mod that spawns hundreds of entities per tick inflates state size and network traffic. The execution limits prevent a single mod from degrading the experience — and because the limits are deterministic (same fuel budget, same cutoff point), all clients agree on when a mod is throttled.</p>
<p><strong>Mod authors can request higher limits</strong> via their mod manifest. The lobby displays requested limits and players can accept or reject. Tournament/ranked play enforces stricter defaults.</p>
<h3 id="wasm-rendering-api-surface"><a class="header" href="#wasm-rendering-api-surface">WASM Rendering API Surface</a></h3>
<p>Tier 3 WASM mods that replace the visual presentation (e.g., a 3D render mod) need a well-defined rendering API surface. These are the WASM host functions exposed for render mods — they are the <em>only</em> way a WASM mod can draw to the screen.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// === Render Host API (ic_render_* namespace) ===
// Available only to mods with ModCapabilities.render = true

/// Register a custom Renderable implementation for an actor type.
#[wasm_host_fn] fn ic_render_register(actor_type: &amp;str, renderable_id: u32);

/// Draw a sprite at a world position (default renderer).
#[wasm_host_fn] fn ic_render_draw_sprite(
    sprite_id: u32, frame: u32, position: WorldPos, facing: u8, palette: u32
);

/// Draw a 3D mesh at a world position (Bevy 3D pipeline).
#[wasm_host_fn] fn ic_render_draw_mesh(
    mesh_handle: u32, position: WorldPos, rotation: [i32; 4], scale: [i32; 3]
);

/// Draw a line (debug overlays, targeting lines).
#[wasm_host_fn] fn ic_render_draw_line(
    start: WorldPos, end: WorldPos, color: u32, width: f32
);

/// Play a skeletal animation on a mesh entity.
#[wasm_host_fn] fn ic_render_play_animation(
    mesh_handle: u32, animation_name: &amp;str, speed: f32, looping: bool
);

/// Set camera position and mode.
#[wasm_host_fn] fn ic_render_set_camera(
    position: WorldPos, mode: CameraMode, fov: Option&lt;f32&gt;
);

/// Screen-to-world conversion (for input mapping).
#[wasm_host_fn] fn ic_render_screen_to_world(
    screen_x: f32, screen_y: f32
) -&gt; Option&lt;WorldPos&gt;;

/// Load an asset (sprite sheet, mesh, texture) by path.
/// Returns a handle ID for use in draw calls.
#[wasm_host_fn] fn ic_render_load_asset(path: &amp;str) -&gt; Option&lt;u32&gt;;

/// Spawn a particle effect at a position.
#[wasm_host_fn] fn ic_render_spawn_particles(
    effect_id: u32, position: WorldPos, duration: u32
);

pub enum CameraMode {
    Isometric,          // fixed angle, zoom via OrthographicProjection.scale
    FreeLook,           // full 3D rotation, zoom via camera distance
    Orbital { target: WorldPos },  // orbit a point, zoom via distance
}
// Zoom behavior is controlled by the GameCamera resource (02-ARCHITECTURE.md § Camera).
// WASM render mods that provide a custom ScreenToWorld impl interpret the zoom value
// appropriately for their camera type (orthographic scale vs. dolly distance vs. FOV).
<span class="boring">}</span></code></pre>
<p><strong>Render mod registration:</strong> A render mod implements the <code>Renderable</code> and <code>ScreenToWorld</code> traits (see <code>02-ARCHITECTURE.md</code> § “3D Rendering as a Mod”). It registers via <code>ic_render_register()</code> for each actor type it handles. Unregistered actor types fall through to the default sprite renderer. This allows <strong>partial</strong> render overrides — a mod can replace tank rendering with 3D meshes while leaving infantry as sprites.</p>
<p><strong>Security:</strong> Render host functions are gated by <code>ModCapabilities.render</code>. A gameplay mod (AI, scripting) cannot access <code>ic_render_*</code> functions. Render mods cannot access <code>ic_host_issue_order()</code> — they draw, they don’t command. These capabilities are declared in the mod manifest and verified at load time.</p>
<h3 id="wasm-pathfinding-api-surface"><a class="header" href="#wasm-pathfinding-api-surface">WASM Pathfinding API Surface</a></h3>
<p>Tier 3 WASM mods can provide custom <code>Pathfinder</code> trait implementations (D013, D045). This follows the same pattern as render mods — a well-defined host API surface, capability-gated, with the WASM module implementing the trait through exported functions that the engine calls.</p>
<p><strong>Why modders want this:</strong> Different games need different pathfinding. A Generals-style total conversion needs layered grid pathfinding with bridge and surface bitmask support. A naval mod needs flow-based routing. A tower defense mod needs waypoint pathfinding. The three built-in presets (Remastered, OpenRA, IC Default) cover the Red Alert family — community pathfinders cover everything else.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// === Pathfinding Host API (ic_pathfind_* namespace) ===
// Available only to mods with ModCapabilities.pathfinding = true

/// Register this WASM module as a Pathfinder implementation.
/// Called once at load time. The engine calls the exported trait methods below.
#[wasm_host_fn] fn ic_pathfind_register(pathfinder_id: &amp;str);

/// Query terrain passability at a position for a given locomotor.
/// Pathfinder mods need to read terrain but not modify it.
#[wasm_host_fn] fn ic_pathfind_get_terrain(pos: WorldPos) -&gt; TerrainType;

/// Query the terrain height at a position (for 3D-aware pathfinding).
#[wasm_host_fn] fn ic_pathfind_get_height(pos: WorldPos) -&gt; SimCoord;

/// Query entities in a radius (for dynamic obstacle avoidance).
/// Returns entity positions and radii — no gameplay data exposed.
#[wasm_host_fn] fn ic_pathfind_query_obstacles(
    center: WorldPos, radius: SimCoord
) -&gt; Vec&lt;(WorldPos, SimCoord)&gt;;

/// Read the current map dimensions.
#[wasm_host_fn] fn ic_pathfind_map_bounds() -&gt; (WorldPos, WorldPos);

/// Allocate scratch memory from the engine's pre-allocated pool.
/// Pathfinding is hot-path — no per-tick heap allocation allowed.
#[wasm_host_fn] fn ic_pathfind_scratch_alloc(bytes: u32) -&gt; *mut u8;

/// Return scratch memory to the pool.
#[wasm_host_fn] fn ic_pathfind_scratch_free(ptr: *mut u8, bytes: u32);
<span class="boring">}</span></code></pre>
<p><strong>WASM-exported trait functions</strong> (the engine <em>calls</em> these on the mod):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Exported by the WASM pathfinder mod — these map to the Pathfinder trait

/// Called by the engine when a unit requests a path.
#[wasm_export] fn pathfinder_request_path(
    origin: WorldPos, dest: WorldPos, locomotor: LocomotorType
) -&gt; PathId;

/// Called by the engine to retrieve computed waypoints.
#[wasm_export] fn pathfinder_get_path(id: PathId) -&gt; Option&lt;Vec&lt;WorldPos&gt;&gt;;

/// Called by the engine to check passability (e.g., building placement).
#[wasm_export] fn pathfinder_is_passable(
    pos: WorldPos, locomotor: LocomotorType
) -&gt; bool;

/// Called by the engine when terrain changes (building placed/destroyed).
#[wasm_export] fn pathfinder_invalidate_area(
    center: WorldPos, radius: SimCoord
);
<span class="boring">}</span></code></pre>
<p><strong>Example: Generals-style layered grid pathfinder as a WASM mod</strong></p>
<p>The C&amp;C Generals source code (GPL v3, <code>electronicarts/CnC_Generals_Zero_Hour</code>) uses a layered grid system with 10-unit cells, surface bitmasks, and bridge layers. A community mod can reimplement this as a WASM pathfinder — see <code>research/pathfinding-ic-default-design.md</code> § “C&amp;C Generals / Zero Hour” for the <code>LayeredGridPathfinder</code> design sketch.</p>
<pre><code class="language-yaml"># generals_pathfinder/mod.yaml
mod:
  name: "Generals Pathfinder"
  type: pathfinder
  pathfinder_id: layered-grid-generals
  display_name: "Generals (Layered Grid)"
  description: "Grid pathfinding with bridge layers and surface bitmasks, inspired by C&amp;C Generals"
  wasm_module: generals_pathfinder.wasm
  capabilities:
    pathfinding: true
  config:
    zone_block_size: 10
    bridge_clearance: 10.0
    surface_types: [ground, water, cliff, air, rubble]
</code></pre>
<p><strong>Security:</strong> Pathfinding host functions are gated by <code>ModCapabilities.pathfinding</code>. A pathfinder mod can read terrain and obstacle positions but cannot issue orders, read gameplay state (health, resources, fog), or access render functions. This is a narrower capability than gameplay mods — pathfinders compute routes, nothing else.</p>
<p><strong>Determinism:</strong> WASM pathfinder mods execute in the deterministic sim context. All clients run the same WASM binary (verified by SHA-256 hash in the lobby) with the same inputs, producing identical path results/deferred requests. Pathfinding uses a dedicated <code>pathfinder_fuel_per_tick</code> budget (see below) because its many-calls-per-tick workload differs from one-shot-per-tick WASM systems.</p>
<p><strong>Pathfinder fuel budget concern:</strong> Pathfinding has fundamentally different call patterns from other WASM mod types. An AI mod calls <code>ai_decide()</code> once per tick — one large computation. A pathfinder mod handles <code>pathfinder_request_path()</code> potentially hundreds of times per tick (once per moving unit). The flat <code>WasmExecutionLimits.fuel_per_tick</code> budget doesn’t distinguish between these patterns: a pathfinder that spends 5,000 fuel per path request × 200 moving units = 1,000,000 fuel, consuming the entire default budget on pathfinding alone.</p>
<p><strong>Mitigation — scaled fuel allocation for pathfinder mods:</strong></p>
<ul>
<li>Pathfinder WASM modules receive a <strong>separate, larger fuel allocation</strong> (<code>pathfinder_fuel_per_tick</code>) that defaults to 5× the standard budget (5,000,000 fuel). This reflects the many-calls-per-tick reality of pathfinding workloads.</li>
<li>The per-request fuel is not individually capped — the total fuel across all path requests in a tick is bounded. This allows some paths to be expensive (complex terrain) as long as the aggregate stays within budget.</li>
<li>If the pathfinder exhausts its fuel mid-tick, remaining path requests for that tick return <code>PathResult::Deferred</code> — the engine queues them for the next tick(s). This is deterministic (all clients defer the same requests) and gracefully degrades under load rather than truncating individual paths.</li>
<li>The pathfinder fuel budget is separate from the mod’s general <code>fuel_per_tick</code> (used for initialization, event handlers, etc.). A pathfinder mod that also handles events gets two budgets.</li>
<li>Mod manifests can request a custom <code>pathfinder_fuel_per_tick</code> value. The lobby displays this alongside other requested limits.</li>
</ul>
<p><strong>Multiplayer sync:</strong> Because pathfinding is sim-affecting, all players must use the same pathfinder. The lobby validates that all clients have the same pathfinder WASM module (hash + version + config). A modded pathfinder is treated identically to a built-in preset for sync purposes.</p>
<p><strong>Ranked policy (D045):</strong> Community pathfinders are allowed in single-player/skirmish/custom lobbies by default, but ranked/community competitive queues reject them unless the exact module hash/version/config profile has been certified and whitelisted (conformance + performance checks).</p>
<p><strong>Phase:</strong> WASM pathfinding API ships in Phase 6a alongside the mod testing framework and Workshop. Built-in pathfinder presets (D045) ship in Phase 2 as native Rust implementations.</p>
<h3 id="wasm-ai-strategy-api-surface"><a class="header" href="#wasm-ai-strategy-api-surface">WASM AI Strategy API Surface</a></h3>
<p>Tier 3 WASM mods can provide custom <code>AiStrategy</code> trait implementations (D041, D043). This follows the same pattern as render and pathfinder mods — a well-defined host API surface, capability-gated, with the WASM module implementing the trait through exported functions that the engine calls.</p>
<p><strong>Why modders want this:</strong> Different games call for different AI approaches. A competitive mod wants a GOAP planner that reads influence maps. An academic project wants a Monte Carlo tree search AI. A Generals-clone needs AI that understands bridge layers and surface types. A novelty mod wants a neural-net AI that learns from replays. The three built-in behavior presets (Classic RA, OpenRA, IC Default) use <code>PersonalityDrivenAi</code> — community AIs can use fundamentally different algorithms.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// === AI Host API (ic_ai_* namespace) ===
// Available only to mods with ModCapabilities.read_visible_state = true
// AND ModCapabilities.issue_orders = true

/// Query own units visible to this AI player.
/// Returns (entity_id, unit_type, position, health, max_health) tuples.
#[wasm_host_fn] fn ic_ai_get_own_units() -&gt; Vec&lt;AiUnitInfo&gt;;

/// Query enemy units visible to this AI player (fog-filtered).
/// Only returns units in line of sight — no maphack.
#[wasm_host_fn] fn ic_ai_get_visible_enemies() -&gt; Vec&lt;AiUnitInfo&gt;;

/// Query neutral/capturable entities visible to this AI player.
#[wasm_host_fn] fn ic_ai_get_visible_neutrals() -&gt; Vec&lt;AiUnitInfo&gt;;

/// Get current resource state for this AI player.
#[wasm_host_fn] fn ic_ai_get_resources() -&gt; AiResourceInfo;

/// Get current power state (production, drain, surplus).
#[wasm_host_fn] fn ic_ai_get_power() -&gt; AiPowerInfo;

/// Get current production queue state.
#[wasm_host_fn] fn ic_ai_get_production_queues() -&gt; Vec&lt;AiProductionQueue&gt;;

/// Check if a unit type can be built (prerequisites, cost, factory available).
#[wasm_host_fn] fn ic_ai_can_build(unit_type: &amp;str) -&gt; bool;

/// Check if a building can be placed at a position.
#[wasm_host_fn] fn ic_ai_can_place_building(
    building_type: &amp;str, pos: WorldPos
) -&gt; bool;

/// Get terrain type at a position (for strategic planning).
#[wasm_host_fn] fn ic_ai_get_terrain(pos: WorldPos) -&gt; TerrainType;

/// Get map dimensions.
#[wasm_host_fn] fn ic_ai_map_bounds() -&gt; (WorldPos, WorldPos);

/// Get current tick number.
#[wasm_host_fn] fn ic_ai_current_tick() -&gt; u64;

/// Get fog-filtered event narrative since a given tick (D041 AiEventLog).
/// Returns a natural-language chronological account of game events.
/// This is the "inner game event log / action story / context" that LLM-based
/// AI (D044) and any WASM AI can use for temporal awareness.
#[wasm_host_fn] fn ic_ai_get_event_narrative(since_tick: u64) -&gt; String;

/// Get structured event log since a given tick (D041 AiEventLog).
/// Returns fog-filtered events as typed entries for programmatic consumption.
#[wasm_host_fn] fn ic_ai_get_events(since_tick: u64) -&gt; Vec&lt;AiEventEntry&gt;;

/// Issue an order for an owned unit. Returns false if order is invalid.
/// Orders go through the same OrderValidator (D012/D041) as human orders.
#[wasm_host_fn] fn ic_ai_issue_order(order: &amp;PlayerOrder) -&gt; bool;

/// Allocate scratch memory from the engine's pre-allocated pool.
#[wasm_host_fn] fn ic_ai_scratch_alloc(bytes: u32) -&gt; *mut u8;
#[wasm_host_fn] fn ic_ai_scratch_free(ptr: *mut u8, bytes: u32);

/// String table lookups — resolve u32 type IDs to human-readable names.
/// Called once at game start or on-demand; results cached WASM-side.
/// This avoids per-tick String allocation across the WASM boundary.
#[wasm_host_fn] fn ic_ai_get_type_name(type_id: u32) -&gt; String;
#[wasm_host_fn] fn ic_ai_get_event_description(event_code: u32) -&gt; String;
#[wasm_host_fn] fn ic_ai_get_type_count() -&gt; u32;  // total registered unit types

pub struct AiUnitInfo {
    pub entity_id: u32,
    pub unit_type_id: u32,    // interned type ID (see ic_ai_get_type_name() for string lookup)
    pub position: WorldPos,
    pub health: i32,
    pub max_health: i32,
    pub is_idle: bool,
    pub is_moving: bool,
}

pub struct AiEventEntry {
    pub tick: u64,
    pub event_type: u32,      // mapped from AiEventType enum
    pub event_code: u32,      // interned event description ID (see ic_ai_get_event_description())
    pub entity_id: Option&lt;u32&gt;,
    pub related_entity_id: Option&lt;u32&gt;,
}
<span class="boring">}</span></code></pre>
<p><strong>WASM-exported trait functions</strong> (the engine <em>calls</em> these on the mod):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Exported by the WASM AI mod — these map to the AiStrategy trait

/// Called once per tick. Returns serialized Vec&lt;PlayerOrder&gt;.
#[wasm_export] fn ai_decide(player_id: u32, tick: u64) -&gt; Vec&lt;PlayerOrder&gt;;

/// Event callbacks — called before ai_decide() in the same tick.
#[wasm_export] fn ai_on_unit_created(unit_id: u32, unit_type: &amp;str);
#[wasm_export] fn ai_on_unit_destroyed(unit_id: u32, attacker_id: Option&lt;u32&gt;);
#[wasm_export] fn ai_on_unit_idle(unit_id: u32);
#[wasm_export] fn ai_on_enemy_spotted(unit_id: u32, unit_type: &amp;str);
#[wasm_export] fn ai_on_enemy_destroyed(unit_id: u32);
#[wasm_export] fn ai_on_under_attack(unit_id: u32, attacker_id: u32);
#[wasm_export] fn ai_on_building_complete(building_id: u32);
#[wasm_export] fn ai_on_research_complete(tech: &amp;str);

/// Parameter introspection — called by lobby UI for "Advanced AI Settings."
#[wasm_export] fn ai_get_parameters() -&gt; Vec&lt;ParameterSpec&gt;;
#[wasm_export] fn ai_set_parameter(name: &amp;str, value: i32);

/// Engine scaling opt-out.
#[wasm_export] fn ai_uses_engine_difficulty_scaling() -&gt; bool;
<span class="boring">}</span></code></pre>
<p><strong>Security:</strong> AI mods can read visible game state (<code>ic_ai_get_own_units</code>, <code>ic_ai_get_visible_enemies</code>) and issue orders (<code>ic_ai_issue_order</code>). They CANNOT read fogged state — <code>ic_ai_get_visible_enemies()</code> returns only units in the AI player’s line of sight. They cannot access render functions, pathfinder internals, or other players’ private data. Orders go through the same <code>OrderValidator</code> as human orders — an AI mod cannot issue impossible commands.</p>
<p><strong>Determinism:</strong> WASM AI mods execute in the deterministic sim context. Events fire in a fixed order (same order on all clients). <code>decide()</code> is called at the same pipeline point on all clients with the same <code>FogFilteredView</code>. All clients run the same WASM binary (verified by SHA-256 hash per AI player slot) with the same inputs, producing identical orders.</p>
<p><strong>Performance:</strong> AI mods share the <code>WasmExecutionLimits</code> fuel budget. The <code>tick_budget_hint()</code> return value is advisory — the engine uses it for scheduling but enforces the fuel limit regardless. A community AI that exceeds its budget mid-tick gets truncated deterministically.</p>
<p><strong>Phase:</strong> WASM AI API ships in Phase 6a. Built-in AI (<code>PersonalityDrivenAi</code> + behavior presets from D043) ships in Phase 4 as native Rust.</p>
<h3 id="wasm-format-loader-api-surface"><a class="header" href="#wasm-format-loader-api-surface">WASM Format Loader API Surface</a></h3>
<p>Tier 3 WASM mods can register custom asset format loaders via the <code>FormatRegistry</code>. This is critical for total conversions that use non-C&amp;C asset formats — analysis of OpenRA mods (see <code>research/openra-mod-architecture-analysis.md</code>) shows that non-C&amp;C games on the engine require extensive custom format support:</p>
<ul>
<li><strong>OpenKrush (KKnD):</strong> 15+ custom binary format decoders — <code>.blit</code> (sprites), <code>.mobd</code> (animations), <code>.mapd</code> (terrain), <code>.lvl</code> (levels), <code>.son</code>/<code>.soun</code> (audio), <code>.vbc</code> (video). None of these resemble C&amp;C formats.</li>
<li><strong>d2 (Dune II):</strong> 6 distinct sprite formats (<code>.icn</code>, <code>.cps</code>, <code>.wsa</code>, <code>.shp</code> variant), custom map format, <code>.adl</code> music.</li>
<li><strong>OpenHV:</strong> Uses standard PNG/WAV/OGG — no proprietary binary formats at all.</li>
</ul>
<p>The engine provides a <code>FormatLoader</code> WASM API surface that lets mods register custom decoders:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// === Format Loader Host API (ic_format_* namespace) ===
// Available only to mods with ModCapabilities.format_loading = true

/// Register a custom format loader for a file extension.
/// When the engine encounters a file with this extension, it calls
/// the mod's exported decode function instead of the built-in loader.
#[wasm_host_fn] fn ic_format_register_loader(
    extension: &amp;str, loader_id: &amp;str
);

/// Report decoded sprite data back to the engine.
#[wasm_host_fn] fn ic_format_emit_sprite(
    sprite_id: u32, width: u32, height: u32,
    pixel_data: &amp;[u8], palette: Option&lt;&amp;[u8]&gt;
);

/// Report decoded audio data back to the engine.
#[wasm_host_fn] fn ic_format_emit_audio(
    audio_id: u32, sample_rate: u32, channels: u8,
    pcm_data: &amp;[u8]
);

/// Read raw bytes from an archive or file (engine handles archive mounting).
#[wasm_host_fn] fn ic_format_read_bytes(
    path: &amp;str, offset: u32, length: u32
) -&gt; Option&lt;Vec&lt;u8&gt;&gt;;
<span class="boring">}</span></code></pre>
<p><strong>Security:</strong> Format loading occurs at asset load time, not during simulation ticks. Format loader mods have file read access (through the engine’s archive abstraction) but cannot issue orders, access game state, or call render functions. They decode bytes into engine-standard pixel/audio/mesh data — nothing else.</p>
<p><strong>Phase:</strong> WASM format loader API ships in Phase 6a alongside the broader mod testing framework. Built-in C&amp;C format loaders (<code>ra-formats</code>) ship in Phase 0.</p>
<h3 id="mod-testing-framework"><a class="header" href="#mod-testing-framework">Mod Testing Framework</a></h3>
<p><code>ic mod test</code> is referenced throughout this document but needs a concrete assertion API and test runner design.</p>
<h4 id="test-file-structure"><a class="header" href="#test-file-structure">Test File Structure</a></h4>
<pre><code class="language-yaml"># tests/my_mod_tests.yaml
tests:
  - name: "Tank costs 800 credits"
    setup:
      map: test_maps/flat_8x8.oramap
      players: [{ faction: allies, credits: 10000 }]
    actions:
      - build: { actor: medium_tank, player: 0 }
      - wait_ticks: 500
    assertions:
      - entity_exists: { type: medium_tank, owner: 0 }
      - player_credits: { player: 0, less_than: 9300 }

  - name: "Tesla coil requires power"
    setup:
      map: test_maps/flat_8x8.oramap
      players: [{ faction: soviet, credits: 10000 }]
      buildings: [{ type: tesla_coil, player: 0, pos: [4, 4] }]
    actions:
      - destroy: { type: power_plant, player: 0 }
      - wait_ticks: 30
    assertions:
      - condition_active: { entity_type: tesla_coil, condition: "disabled" }
</code></pre>
<h4 id="lua-test-api"><a class="header" href="#lua-test-api">Lua Test API</a></h4>
<p>For more complex test scenarios, Lua scripts can use test assertion functions:</p>
<pre><code class="language-lua">-- tests/combat_test.lua
function TestTankDamage()
    local tank = Actor.Create("medium_tank", { Owner = Player.GetPlayer(0), Location = CellPos(4, 4) })
    local target = Actor.Create("light_tank", { Owner = Player.GetPlayer(1), Location = CellPos(5, 4) })

    -- Force attack
    tank.Attack(target)
    Trigger.AfterDelay(100, function()
        Test.Assert(target.Health &lt; target.MaxHealth, "Target should take damage")
        Test.AssertRange(target.Health, 100, 350, "Damage should be in expected range")
        Test.Pass("Tank combat works correctly")
    end)
end

-- Test API globals (available only in test mode)
-- Test.Assert(condition, message)
-- Test.AssertEqual(actual, expected, message)
-- Test.AssertRange(value, min, max, message)
-- Test.AssertNear(actual, expected, tolerance, message)
-- Test.Pass(message)
-- Test.Fail(message)
-- Test.Log(message)
</code></pre>
<h4 id="test-runner-ic-mod-test"><a class="header" href="#test-runner-ic-mod-test">Test Runner (<code>ic mod test</code>)</a></h4>
<pre><code>$ ic mod test
Running 12 tests from tests/*.yaml and tests/*.lua...
  ✓ Tank costs 800 credits (0.3s)
  ✓ Tesla coil requires power (0.2s)
  ✓ Tank combat works correctly (0.8s)
  ✗ Harvester delivery rate (expected 100, got 0) (1.2s)
  ...
Results: 11 passed, 1 failed (2.5s total)
</code></pre>
<p><strong>Features:</strong></p>
<ul>
<li><code>ic mod test</code> — run all tests in <code>tests/</code> directory</li>
<li><code>ic mod test --filter "combat"</code> — run matching tests</li>
<li><code>ic mod test --headless</code> — no rendering (CI/CD mode, used by modpack validation)</li>
<li><code>ic mod test --verbose</code> — show per-tick sim state for failing tests</li>
<li><code>ic mod test --coverage</code> — report which YAML rules are exercised by tests</li>
</ul>
<p><strong>Headless mode:</strong> The engine initializes <code>ic-sim</code> without <code>ic-render</code> or <code>ic-audio</code>. Orders are injected programmatically. This is the same <code>LocalNetwork</code> model used for automated testing of the engine itself. Tests run at maximum speed (no frame rate limit).</p>
<h4 id="deterministic-conformance-suites-pathfinder--spatialindex"><a class="header" href="#deterministic-conformance-suites-pathfinder--spatialindex">Deterministic Conformance Suites (Pathfinder / SpatialIndex)</a></h4>
<p>Community pathfinders are one of the highest-risk Tier 3 extension points: they are <strong>sim-affecting</strong>, performance-sensitive, and easy to get subtly wrong (nondeterministic ordering, stale invalidation, cache bugs, path output drift across runs). D013/D045 therefore require a built-in conformance layer on top of ordinary scenario tests.</p>
<p><code>ic mod test</code> includes two engine-provided conformance suites: <strong><code>PathfinderConformanceTest</code></strong> and <strong><code>SpatialIndexConformanceTest</code></strong>. These are contract tests for “does your implementation satisfy the engine seam safely and deterministically?” — not gameplay-balance tests. They verify deterministic repeatability, output validity, invalidation correctness, snapshot/restore equivalence, and (for spatial) ordering and coherence contracts. Specific test vectors are defined at implementation time.</p>
<pre><code class="language-bash">ic mod test --conformance pathfinder
ic mod test --conformance spatial-index
ic mod test --conformance all
</code></pre>
<p><strong>Ranked / certification linkage (D045):</strong> Passing conformance is the minimum requirement for community pathfinder certification. Ranked queues may additionally require <code>ic mod perf-test --conformance pathfinder</code> on the baseline hardware tier. Uncertified pathfinders remain available in single-player/skirmish/custom by default.</p>
<p>This makes D013’s open <code>Pathfinder</code> seam practical: experimentation stays easy while deterministic multiplayer and ranked integrity remain protected.</p>
<p><strong>Phase:</strong> Conformance suites ship in Phase 6a (with WASM pathfinder support); performance conformance hooks integrate with <code>ic mod perf-test</code> in Phase 6b.</p>
<h3 id="3d-rendering-mods-tier-3-showcase"><a class="header" href="#3d-rendering-mods-tier-3-showcase">3D Rendering Mods (Tier 3 Showcase)</a></h3>
<p>The most powerful example of Tier 3 modding: replacing the entire visual presentation with 3D rendering. A “3D Red Alert” mod swaps sprites for GLTF meshes and the isometric camera for a free-rotating 3D camera — while the simulation, networking, pathfinding, and rules are completely unchanged.</p>
<p>This works because Bevy already ships a full 3D pipeline. The mod doesn’t build a 3D engine — it uses Bevy’s existing 3D renderer through the WASM mod API.</p>
<p><strong>A 3D render mod implements:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WASM mod: replaces the default sprite renderer
impl Renderable for MeshRenderer {
    fn render(&amp;self, entity: EntityId, state: &amp;RenderState, ctx: &amp;mut RenderContext) {
        let model = self.models.get(entity.unit_type);
        let animation = match state.activity {
            Activity::Idle =&gt; &amp;model.idle,
            Activity::Moving =&gt; &amp;model.walk,
            Activity::Attacking =&gt; &amp;model.attack,
        };
        ctx.draw_mesh(model.mesh, state.world_pos, state.facing, animation);
    }
}

impl ScreenToWorld for FreeCam3D {
    fn screen_to_world(&amp;self, screen_pos: Vec2, terrain: &amp;TerrainData) -&gt; WorldPos {
        // 3D raycast against terrain mesh → world position
        let ray = self.camera.screen_to_ray(screen_pos);
        terrain.raycast(ray).to_world_pos()
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Assets are mapped in YAML (mod overrides unit render definitions):</strong></p>
<pre><code class="language-yaml"># 3d_mod/render_overrides.yaml
rifle_infantry:
  render:
    type: mesh
    model: models/infantry/rifle.glb
    animations:
      idle: Idle
      move: Run
      attack: Shoot
      death: Death

medium_tank:
  render:
    type: mesh
    model: models/vehicles/medium_tank.glb
    turret: models/vehicles/medium_tank_turret.glb
    animations:
      idle: Idle
      move: Drive
</code></pre>
<p><strong>Cross-view multiplayer is a natural consequence.</strong> Since the mod only changes rendering, a player using the 3D mod can play against a player using classic isometric sprites. The sim produces identical state; each client just draws it differently. Replays are viewable in either mode.</p>
<p>See <code>02-ARCHITECTURE.md</code> § “3D Rendering as a Mod” for the full architectural rationale.</p>
<h3 id="custom-pathfinding-mods-tier-3-showcase"><a class="header" href="#custom-pathfinding-mods-tier-3-showcase">Custom Pathfinding Mods (Tier 3 Showcase)</a></h3>
<p>The second major Tier 3 showcase: replacing how units navigate the battlefield. Just as 3D render mods replace the visual presentation, pathfinder mods replace the movement algorithm — while combat, building, harvesting, and everything else remain unchanged.</p>
<p><strong>Why this matters:</strong> The original C&amp;C Generals uses a layered grid pathfinder with surface bitmasks and bridge layers — fundamentally different from Red Alert’s approach. A Generals-clone mod needs Generals-style pathfinding. A naval mod needs flow routing. A tower defense mod needs waypoint constraint pathfinding. No single algorithm fits every RTS — the <code>Pathfinder</code> trait (D013) lets modders bring their own.</p>
<p><strong>A pathfinder mod implements:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WASM mod: Generals-style layered grid pathfinder
// (See research/pathfinding-ic-default-design.md § "C&amp;C Generals / Zero Hour")
struct LayeredGridPathfinder {
    grid: Vec&lt;CellLayer&gt;,          // 10-unit cells with bridge layers
    zones: ZoneMap,                // flood-fill reachability zones
    surface_bitmask: SurfaceMask,  // ground | water | cliff | air | rubble
}

impl Pathfinder for LayeredGridPathfinder {
    fn request_path(&amp;mut self, origin: WorldPos, dest: WorldPos, locomotor: LocomotorType) -&gt; PathId {
        // 1. Check zone connectivity (instant reject if unreachable)
        // 2. Surface bitmask check for locomotor compatibility
        // 3. A* over layered grid (bridges are separate layers)
        // 4. Path smoothing pass
        // ...
    }
    fn get_path(&amp;self, id: PathId) -&gt; Option&lt;&amp;[WorldPos]&gt; { /* ... */ }
    fn is_passable(&amp;self, pos: WorldPos, locomotor: LocomotorType) -&gt; bool {
        let cell = self.grid.cell_at(pos);
        cell.surface_bitmask.allows(locomotor)
    }
    fn invalidate_area(&amp;mut self, center: WorldPos, radius: SimCoord) {
        // Rebuild affected zones, recalculate bridge connectivity
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Mod manifest and config:</strong></p>
<pre><code class="language-yaml"># generals_pathfinder/mod.yaml
mod:
  name: "Generals Pathfinder"
  type: pathfinder
  pathfinder_id: layered-grid-generals
  display_name: "Generals (Layered Grid)"
  version: "1.0.0"
  capabilities:
    pathfinding: true
  config:
    zone_block_size: 10
    bridge_clearance: 10.0
    surface_types: [ground, water, cliff, air, rubble]
</code></pre>
<p><strong>How other mods use it:</strong></p>
<pre><code class="language-yaml"># desert_strike_mod/mod.yaml — a total conversion using the Generals pathfinder
mod:
  name: "Desert Strike"
  pathfinder: layered-grid-generals
  depends:
    - community/generals-pathfinder@^1.0
</code></pre>
<p><strong>Multiplayer sync:</strong> All players must use the same pathfinder — the WASM binary hash/version/config profile is validated in the lobby, same as any sim-affecting mod. If a player is missing the pathfinder mod, the engine auto-downloads it from the Workshop (CS:GO-style, per D030).</p>
<p><strong>Performance contract:</strong> Pathfinder mods use a dedicated <code>pathfinder_fuel_per_tick</code> budget (separate from general WASM fuel). The engine monitors per-tick pathfinding time and deferred-request rates. The engine never falls back silently to a different pathfinder — determinism means all clients must agree on every path. If a WASM pathfinder exhausts its pathfinding fuel for the tick, remaining requests return <code>PathResult::Deferred</code> and are re-queued deterministically for subsequent ticks. Community pathfinders targeting ranked certification are expected to pass <code>PathfinderConformanceTest</code> and <code>ic mod perf-test --conformance pathfinder</code> on the baseline hardware tier (D045 policy).</p>
<p><strong>Ranked policy:</strong> Community pathfinders are available by default in single-player/skirmish/custom lobbies, but ranked/community competitive queues reject them unless the exact hash/version/config profile has been certified and explicitly whitelisted.</p>
<p><strong>Phase:</strong> WASM pathfinder mods in Phase 6a. The three built-in pathfinder presets (D045) ship as native Rust in Phase 2.</p>
<h3 id="custom-ai-mods-tier-3-showcase"><a class="header" href="#custom-ai-mods-tier-3-showcase">Custom AI Mods (Tier 3 Showcase)</a></h3>
<p>The third major Tier 3 showcase: replacing how AI opponents think. Just as render mods replace visual presentation and pathfinder mods replace navigation algorithms, AI mods replace the decision-making engine — while the simulation rules, damage pipeline, and everything else remain unchanged.</p>
<p><strong>Why this matters:</strong> The built-in <code>PersonalityDrivenAi</code> uses behavior trees tuned by YAML personality parameters. This works well for most players. But the RTS AI community spans decades of research — GOAP planners, Monte Carlo tree search, influence map systems, neural networks, evolutionary strategies (see <code>research/rts-ai-extensibility-survey.md</code>). The <code>AiStrategy</code> trait (D041) lets modders bring any algorithm to Iron Curtain, and the two-axis difficulty system (D043) lets any AI scale from Sandbox to Nightmare.</p>
<p><strong>A custom AI mod implements:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WASM mod: GOAP (Goal-Oriented Action Planning) AI
struct GoapPlannerAi {
    goals: Vec&lt;Goal&gt;,         // Expand, Attack, Defend, Tech, Harass
    plan: Option&lt;ActionPlan&gt;, // Current multi-step plan
    world_model: WorldModel,  // Internal state tracking
}

impl AiStrategy for GoapPlannerAi {
    fn decide(&amp;mut self, player: PlayerId, view: &amp;FogFilteredView, tick: u64) -&gt; Vec&lt;PlayerOrder&gt; {
        // 1. Update world model from visible state
        self.world_model.update(view);
        // 2. Re-evaluate goal priorities
        self.goals.sort_by_key(|g| -g.priority(&amp;self.world_model));
        // 3. If plan invalidated or expired, re-plan
        if self.plan.is_none() || tick % self.replan_interval == 0 {
            self.plan = self.planner.search(
                &amp;self.world_model, &amp;self.goals[0], self.search_depth
            );
        }
        // 4. Execute next action in plan
        self.plan.as_mut().map(|p| p.next_orders()).unwrap_or_default()
    }

    fn on_enemy_spotted(&amp;mut self, unit: EntityId, unit_type: &amp;str) {
        // Scouting intel → update world model → may trigger re-plan
        self.world_model.add_sighting(unit, unit_type);
        if self.world_model.threat_level() &gt; self.defend_threshold {
            self.plan = None; // force re-plan next tick
        }
    }

    fn on_under_attack(&amp;mut self, _unit: EntityId, _attacker: EntityId) {
        self.goals.iter_mut().find(|g| g.name == "Defend")
            .map(|g| g.urgency += 30); // boost defense priority
    }

    fn get_parameters(&amp;self) -&gt; Vec&lt;ParameterSpec&gt; {
        vec![
            ParameterSpec { name: "search_depth".into(), min: 1, max: 10, default: 5, .. },
            ParameterSpec { name: "replan_interval".into(), min: 10, max: 120, default: 30, .. },
            ParameterSpec { name: "defend_threshold".into(), min: 0, max: 100, default: 40, .. },
        ]
    }

    fn uses_engine_difficulty_scaling(&amp;self) -&gt; bool { false }
    // This AI handles difficulty via search_depth and replan_interval
}
<span class="boring">}</span></code></pre>
<p><strong>Mod manifest:</strong></p>
<pre><code class="language-yaml"># goap_ai/mod.yaml
mod:
  name: "GOAP Planner AI"
  type: ai_strategy
  ai_strategy_id: goap-planner
  display_name: "GOAP Planner"
  description: "Goal-oriented action planning — multi-step strategic reasoning"
  version: "2.1.0"
  wasm_module: goap_planner.wasm
  capabilities:
    read_visible_state: true
    issue_orders: true
    ai_strategy: true
  config:
    search_depth: 5
    replan_interval: 30
</code></pre>
<p><strong>How other mods use it:</strong></p>
<pre><code class="language-yaml"># zero_hour_mod/mod.yaml — a total conversion using the GOAP AI
mod:
  name: "Zero Hour Remake"
  default_ai: goap-planner
  depends:
    - community/goap-planner-ai@^2.0
</code></pre>
<p><strong>AI tournament community:</strong> Workshop can host AI tournament leaderboards — automated matches between community AI submissions, ranked by Elo/TrueSkill. This is directly inspired by BWAPI’s SSCAIT tournament (15+ years of StarCraft AI competition) and AoE2’s AI ladder (20+ years of community AI development). The <code>ic mod test</code> framework (above) provides headless match execution; the Workshop provides distribution and ranking.</p>
<p><strong>Phase:</strong> WASM AI mods in Phase 6a. Built-in <code>PersonalityDrivenAi</code> + behavior presets (D043) ship as native Rust in Phase 4.</p>
<h2 id="tera-templating-phase-6a"><a class="header" href="#tera-templating-phase-6a">Tera Templating (Phase 6a)</a></h2>
<h3 id="tera-as-the-template-engine"><a class="header" href="#tera-as-the-template-engine">Tera as the Template Engine</a></h3>
<p>Tera is a Rust-native Jinja2-compatible template engine. <strong>All first-party IC content uses it</strong> — the default Red Alert campaign, built-in resource packs, and balance presets are all Tera-templated. This means the system is proven by the content that ships with the engine, not just an abstract capability.</p>
<p>For <strong>third-party content creators, Tera is entirely optional.</strong> Plain YAML is always valid and is the recommended starting point. Most community mods, resource packs, and maps work fine without any templating at all. Tera is there when you need it — not forced on you.</p>
<p>What Tera handles:</p>
<ol>
<li><strong>YAML/Lua generation</strong> — eliminates copy-paste when defining dozens of faction variants or bulk unit definitions</li>
<li><strong>Mission templates</strong> — parameterized, reusable mission blueprints</li>
<li><strong>Resource packs</strong> — switchable asset layers with configurable parameters (quality, language, platform)</li>
</ol>
<p>Inspired by Helm’s approach to parameterized configuration, but adapted to game content: parameters are defined in a <code>schema.yaml</code>, defaults are inline in the template, and user preferences are set through the in-game settings UI — not a separate values file workflow. The pattern stays practical to our use case rather than importing Helm’s full complexity.</p>
<p>Load-time only (zero runtime cost). Tera is the right fit because:</p>
<ul>
<li>Rust-native (<code>tera</code> crate), no external dependencies</li>
<li>Jinja2 syntax — widely known, documented, tooling exists</li>
<li>Supports loops, conditionals, includes, macros, filters, inheritance</li>
<li>Deterministic output (no randomness unless explicitly seeded via context)</li>
</ul>
<h3 id="unitrule-templating-original-use-case"><a class="header" href="#unitrule-templating-original-use-case">Unit/Rule Templating (Original Use Case)</a></h3>
<pre><code class="language-jinja">{% for faction in ["allies", "soviet"] %}
{% for tier in [1, 2, 3] %}
{{ faction }}_tank_t{{ tier }}:
  inherits: _base_tank
  health:
    max: {{ 200 + tier * 100 }}
  buildable:
    cost: {{ 500 + tier * 300 }}
{% endfor %}
{% endfor %}
</code></pre>
<h3 id="mission-templates-parameterized-missions"><a class="header" href="#mission-templates-parameterized-missions">Mission Templates (Parameterized Missions)</a></h3>
<p>A mission template is a reusable mission blueprint with parameterized values. The template defines the structure (map layout, objectives, triggers, enemy composition); the user (or LLM) supplies values to produce a concrete, playable mission.</p>
<p><strong>Template structure:</strong></p>
<pre><code>templates/
  bridge_defense/
    template.yaml        # Tera template for map + rules
    triggers.lua.tera    # Tera template for Lua trigger scripts
    schema.yaml          # Parameter definitions with inline defaults
    preview.png          # Thumbnail for workshop browser
    README.md            # Description, author, usage notes
</code></pre>
<p><strong>Schema (what parameters the template accepts):</strong></p>
<pre><code class="language-yaml"># schema.yaml — defines the knobs for this template
parameters:
  map_size:
    type: enum
    options: [small, medium, large]
    default: medium
    description: "Overall map dimensions"
  
  player_faction:
    type: enum
    options: [allies, soviet]
    default: allies
    description: "Player's faction"
  
  enemy_waves:
    type: integer
    min: 3
    max: 20
    default: 8
    description: "Number of enemy attack waves"
  
  difficulty:
    type: enum
    options: [easy, normal, hard, brutal]
    default: normal
    description: "Controls enemy unit count and AI aggression"
  
  reinforcement_type:
    type: enum
    options: [infantry, armor, air, mixed]
    default: mixed
    description: "What reinforcements the player receives"
  
  enable_naval:
    type: boolean
    default: false
    description: "Include river crossings and naval units"
</code></pre>
<p><strong>Template (references parameters):</strong></p>
<pre><code class="language-jinja">{# template.yaml — bridge defense mission #}
mission:
  name: "Bridge Defense — {{ difficulty | title }}"
  briefing: &gt;
    Commander, hold the {{ map_size }} bridge crossing against
    {{ enemy_waves }} waves of {{ "Soviet" if player_faction == "allies" else "Allied" }} forces.
    {% if enable_naval %}Enemy naval units will approach from the river.{% endif %}

map:
  size: {{ {"small": [64, 64], "medium": [96, 96], "large": [128, 128]}[map_size] }}

actors:
  player_base:
    faction: {{ player_faction }}
    units:
      {% for i in range(end={"easy": 8, "normal": 5, "hard": 3, "brutal": 2}[difficulty]) %}
      - type: {{ reinforcement_type }}_defender_{{ i }}
      {% endfor %}

waves:
  count: {{ enemy_waves }}
  escalation: {{ {"easy": 1.1, "normal": 1.3, "hard": 1.5, "brutal": 2.0}[difficulty] }}
</code></pre>
<p><strong>Rendering a template into a playable mission:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tera::{Tera, Context};

pub fn render_mission_template(
    template_dir: &amp;Path,
    values: &amp;HashMap&lt;String, Value&gt;,
) -&gt; Result&lt;RenderedMission&gt; {
    let schema = load_schema(template_dir.join("schema.yaml"))?;
    let merged = merge_with_defaults(values, &amp;schema)?;  // fill in defaults
    validate_values(&amp;merged, &amp;schema)?;                   // check types, ranges, enums

    let mut tera = Tera::new(template_dir.join("*.tera").to_str().unwrap())?;
    let mut ctx = Context::new();
    for (k, v) in &amp;merged {
        ctx.insert(k, v);
    }

    Ok(RenderedMission {
        map_yaml: tera.render("template.yaml", &amp;ctx)?,
        triggers_lua: tera.render("triggers.lua.tera", &amp;ctx)?,
        // Standard mission format — indistinguishable from hand-crafted
    })
}
<span class="boring">}</span></code></pre>
<h3 id="llm--templates"><a class="header" href="#llm--templates">LLM + Templates</a></h3>
<p>The LLM doesn’t need to generate everything from scratch. It can:</p>
<ol>
<li><strong>Select a template</strong> from the workshop based on the user’s description</li>
<li><strong>Fill in parameters</strong> — the LLM generates parameter values against the <code>schema.yaml</code>, not an entire mission</li>
<li><strong>Validate</strong> — schema constraints catch hallucinated values before rendering</li>
<li><strong>Compose</strong> — chain multiple scene and mission templates for campaigns (e.g., “3 missions: base building → bridge defense → final assault”)</li>
</ol>
<p>This is dramatically more reliable than raw generation. The template constrains the LLM’s output to valid parameter space, and the schema validates it. The LLM becomes a smart form-filler, not an unconstrained code generator.</p>
<blockquote>
<p><strong>Lifelong learning (D057):</strong> Proven template parameter combinations — which <code>ambush</code> location choices, <code>defend_position</code> wave compositions, and multi-scene sequences produce missions that players rate highly — are stored in the <strong>skill library</strong> (<code>decisions/09f/D057-llm-skill-library.md</code>) and retrieved as few-shot examples for future generation. The template library provides the valid output space; the skill library provides accumulated knowledge about what works within that space.</p>
</blockquote>
<h3 id="scene-templates-composable-building-blocks"><a class="header" href="#scene-templates-composable-building-blocks">Scene Templates (Composable Building Blocks)</a></h3>
<p>Inspired by Operation Flashpoint / ArmA’s mission editor: scene templates are <strong>sub-mission components</strong> — reusable, pre-scripted building blocks that snap together inside a mission. Each scene template has its own trigger logic, AI behavior, and Lua scripts already written and tested. The user or LLM only fills in parameters.</p>
<blockquote>
<p><strong>Visual editor equivalent:</strong> The IC SDK’s scenario editor (D038) exposes these same building blocks as <strong>modules</strong> — drag-and-drop logic nodes with a properties panel. Scene templates are the YAML/Lua format; modules are the visual editor face. Same underlying data — a composition saved in the editor can be loaded as a scene template by Lua/LLM, and vice versa. See <code>decisions/09f/D038-scenario-editor.md</code>.</p>
</blockquote>
<p><strong>Template hierarchy:</strong></p>
<pre><code>Scene Template    — a single scripted encounter or event
  ↓ composed into
Mission Template  — a full mission assembled from scenes + overall structure
  ↓ sequenced into
Campaign Graph    — branching mission graph with persistent state (not a linear sequence)
</code></pre>
<p><strong>Built-in scene template library (examples):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scene Template</th><th>Parameters</th><th>Pre-built Logic</th></tr>
</thead>
<tbody>
<tr><td><code>ambush</code></td><td>location, attacker_units, trigger_zone, delay</td><td>Units hide until player enters zone, then attack from cover</td></tr>
<tr><td><code>patrol</code></td><td>waypoints, unit_composition, alert_radius</td><td>Units cycle waypoints, engage if player detected within radius</td></tr>
<tr><td><code>convoy_escort</code></td><td>route, convoy_units, ambush_points[], escort_units</td><td>Convoy follows route, ambushes trigger at defined points</td></tr>
<tr><td><code>defend_position</code></td><td>position, waves[], interval, reinforcement_schedule</td><td>Enemies attack in waves with escalating strength</td></tr>
<tr><td><code>base_building</code></td><td>start_resources, available_structures, tech_tree_limit</td><td>Player builds base, unlocked structures based on tech level</td></tr>
<tr><td><code>timed_objective</code></td><td>target, time_limit, failure_trigger</td><td>Player must complete objective before timer expires</td></tr>
<tr><td><code>reinforcements</code></td><td>trigger, units, entry_point, delay</td><td>Units arrive from map edge when trigger fires</td></tr>
<tr><td><code>scripted_scene</code></td><td>actors[], dialogue[], camera_positions[]</td><td>Non-interactive cutscene or briefing with camera movement</td></tr>
<tr><td><code>video_playback</code></td><td>video_ref, trigger, display_mode, skippable</td><td>Play a video on trigger — see display modes below</td></tr>
<tr><td><code>weather</code></td><td>type, intensity, trigger, duration, sim_effects</td><td>Weather system — see weather effects below</td></tr>
<tr><td><code>extraction</code></td><td>pickup_zone, transport_type, signal_trigger</td><td>Player moves units to extraction zone, transport arrives</td></tr>
<tr><td><code>map_expansion</code></td><td>trigger, layer_name, transition, reinforcements[], briefing</td><td>Activates a map layer — reveals shroud, extends bounds, wakes entities. See § Dynamic Mission Flow.</td></tr>
<tr><td><code>sub_map_transition</code></td><td>portal_region, sub_map, allowed_units[], transition, outcomes{}</td><td>Unit enters building → loads interior sub-map → outcomes affect parent map. See § Dynamic Mission Flow.</td></tr>
<tr><td><code>phase_briefing</code></td><td>briefing_ref, video_ref, display_mode, layer_name, reinforcements[]</td><td>Combines briefing/video with layer activation and reinforcements — the “next phase” one-stop module.</td></tr>
</tbody>
</table>
</div>
<p><strong><code>video_playback</code> display modes:</strong></p>
<p>The <code>display_mode</code> parameter controls <em>where</em> the video renders:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Behavior</th><th>Inspiration</th></tr>
</thead>
<tbody>
<tr><td><code>fullscreen</code></td><td>Pauses gameplay, fills screen. Classic FMV briefing between missions.</td><td>RA1 mission briefings</td></tr>
<tr><td><code>radar_comm</code></td><td>Video replaces the radar/minimap panel during gameplay. Game continues. RA2-style comm.</td><td>RA2 EVA / commander video calls</td></tr>
<tr><td><code>picture_in_picture</code></td><td>Small floating video overlay in a corner. Game continues. Dismissible.</td><td>Modern RTS cinematics</td></tr>
</tbody>
</table>
</div>
<p><code>radar_comm</code> is how RA2 handles in-mission conversations — the radar panel temporarily switches to a video feed of a character addressing the player, then returns to the minimap when the clip ends. The sidebar stays functional (build queues, power bar still visible). This creates narrative immersion without interrupting gameplay.</p>
<p>The LLM can use this in generated missions: a briefing video at mission start (<code>fullscreen</code>), a commander calling in mid-mission when a trigger fires (<code>radar_comm</code>), and a small notification video when reinforcements arrive (<code>picture_in_picture</code>).</p>
<p><strong><code>weather</code> scene template:</strong></p>
<p>Weather effects are GPU particle systems rendered by <code>ic-render</code>, with optional gameplay modifiers applied by <code>ic-sim</code>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Visual Effect</th><th>Optional Sim Effect (if <code>sim_effects: true</code>)</th></tr>
</thead>
<tbody>
<tr><td><code>rain</code></td><td>GPU particle rain, puddle reflections, darkened ambient lighting</td><td>Reduced visibility range (−20%), slower wheeled vehicles</td></tr>
<tr><td><code>snow</code></td><td>GPU particle snowfall, accumulation on terrain, white fog</td><td>Reduced movement speed (−15%), reduced visibility (−30%)</td></tr>
<tr><td><code>sandstorm</code></td><td>Dense particle wall, orange tint, reduced draw distance</td><td>Heavy visibility reduction (−50%), damage to exposed infantry</td></tr>
<tr><td><code>blizzard</code></td><td>Heavy snow + wind particles, near-zero visibility</td><td>Severe speed/visibility penalty, periodic cold damage</td></tr>
<tr><td><code>fog</code></td><td>Volumetric fog shader, reduced contrast at distance</td><td>Reduced visibility range (−40%), no other penalties</td></tr>
<tr><td><code>storm</code></td><td>Rain + lightning flashes + screen shake + thunder audio</td><td>Same as rain + random lightning strikes (cosmetic or damaging)</td></tr>
</tbody>
</table>
</div>
<p><strong>Key design principle:</strong> Weather is split into two layers:</p>
<ul>
<li><strong>Render layer</strong> (<code>ic-render</code>): Always active. GPU particles, shaders, post-FX, ambient audio changes. Pure cosmetic, zero sim impact. Particle density scales with <code>RenderSettings</code> for lower-end devices.</li>
<li><strong>Sim layer</strong> (<code>ic-sim</code>): Optional, controlled by <code>sim_effects</code> parameter. When enabled, weather modifies visibility ranges, movement speeds, and damage — deterministically, so multiplayer stays in sync. When disabled, weather is purely cosmetic eye candy.</li>
</ul>
<p>Weather can be set per-map (in map YAML), triggered mid-mission by Lua scripts, or composed via the <code>weather</code> scene template. An LLM generating a “blizzard defense” mission sets <code>type: blizzard, sim_effects: true</code> and gets both the visual atmosphere and the gameplay tension.</p>
<h3 id="dynamic-weather-system-d022"><a class="header" href="#dynamic-weather-system-d022">Dynamic Weather System (D022)</a></h3>
<p>The base weather system above covers static, per-mission weather. The <strong>dynamic weather system</strong> extends it with real-time weather transitions and terrain texture effects during gameplay — snow accumulates on the ground, rain darkens and wets surfaces, sunshine dries everything out.</p>
<h4 id="weather-state-machine"><a class="header" href="#weather-state-machine">Weather State Machine</a></h4>
<p>Weather transitions are modeled as a state machine running inside <code>ic-sim</code>. The machine is deterministic — same schedule + same tick = identical weather on every client.</p>
<pre><code>     ┌──────────┐      ┌───────────┐      ┌──────────┐
     │  Sunny   │─────▶│ Overcast  │─────▶│   Rain   │
     └──────────┘      └───────────┘      └──────────┘
          ▲                                     │
          │            ┌───────────┐            │
          └────────────│ Clearing  │◀───────────┘
                       └───────────┘            │
                            ▲           ┌──────────┐
                            └───────────│  Storm   │
                                        └──────────┘

     ┌──────────┐      ┌───────────┐      ┌──────────┐
     │  Clear   │─────▶│  Cloudy   │─────▶│   Snow   │
     └──────────┘      └───────────┘      └──────────┘
          ▲                  │                  │
          │                  ▼                  ▼
          │            ┌───────────┐      ┌──────────┐
          │            │    Fog    │      │ Blizzard │
          │            └───────────┘      └──────────┘
          │                  │                  │
          └──────────────────┴──────────────────┘
                    (melt / thaw / clear)

     Desert variant (temperature.base &gt; threshold):
     Rain → Sandstorm, Snow → (not reachable)
</code></pre>
<p>Each weather type has an <strong>intensity</strong> (fixed-point <code>0..1024</code>) that ramps up during transitions and down during clearing. The sim tracks this as a <code>WeatherState</code> resource:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ic-sim: deterministic weather state
pub struct WeatherState {
    pub current: WeatherType,
    pub intensity: FixedPoint,       // 0 = clear, 1024 = full
    pub transitioning_to: Option&lt;WeatherType&gt;,
    pub transition_progress: FixedPoint,  // 0..1024
    pub ticks_in_current: u32,
}
<span class="boring">}</span></code></pre>
<h4 id="weather-schedule-yaml"><a class="header" href="#weather-schedule-yaml">Weather Schedule (YAML)</a></h4>
<p>Maps define a weather schedule — the rules for how weather evolves. Three modes:</p>
<pre><code class="language-yaml"># maps/winter_assault/map.yaml
weather:
  schedule:
    mode: cycle           # cycle | random | scripted
    default: sunny
    seed_from_match: true # random mode uses match seed (deterministic)

    states:
      sunny:
        min_duration: 300   # minimum ticks before transition
        max_duration: 600
        transitions:
          - to: overcast
            weight: 60      # relative probability
          - to: cloudy
            weight: 40

      overcast:
        min_duration: 120
        max_duration: 240
        transitions:
          - to: rain
            weight: 70
          - to: sunny
            weight: 30
        transition_time: 30  # ticks to blend between states

      rain:
        min_duration: 200
        max_duration: 500
        transitions:
          - to: storm
            weight: 20
          - to: clearing
            weight: 80
        sim_effects: true    # enables gameplay modifiers

      snow:
        min_duration: 300
        max_duration: 800
        transitions:
          - to: clearing
            weight: 100
        sim_effects: true

      clearing:
        min_duration: 60
        max_duration: 120
        transitions:
          - to: sunny
            weight: 100
        transition_time: 60

    surface:
      snow:
        accumulation_rate: 2    # fixed-point units per tick while snowing
        max_depth: 1024
        melt_rate: 1            # per tick when not snowing
      rain:
        wet_rate: 4             # per tick while raining
        dry_rate: 2             # per tick when not raining
      temperature:
        base: 512              # 0 = freezing, 1024 = hot
        sunny_warming: 1       # per tick
        snow_cooling: 2        # per tick
</code></pre>
<ul>
<li><strong><code>cycle</code></strong> — deterministic round-robin through states per the transition weights and durations.</li>
<li><strong><code>random</code></strong> — weighted random using the match seed. Same seed = same weather progression on all clients.</li>
<li><strong><code>scripted</code></strong> — no automatic transitions; weather changes only when Lua calls <code>Weather.transition_to()</code>.</li>
</ul>
<p>Lua can override the schedule at any time:</p>
<pre><code class="language-lua">-- Force a blizzard for dramatic effect at mission climax
Weather.transition_to("blizzard", 45)  -- 45-tick transition
Weather.set_intensity(900)             -- near-maximum

-- Query current state
local w = Weather.get_state()
print(w.current)     -- "blizzard"
print(w.intensity)   -- 900
print(w.surface.snow_depth)  -- per-map average
</code></pre>
<h4 id="terrain-surface-state-sim-layer"><a class="header" href="#terrain-surface-state-sim-layer">Terrain Surface State (Sim Layer)</a></h4>
<p>When <code>sim_effects</code> is enabled, the sim maintains a per-cell <code>TerrainSurfaceGrid</code> — a compact grid tracking how weather has physically altered the terrain. This is <strong>deterministic</strong> and affects gameplay.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ic-sim: per-cell surface condition
pub struct SurfaceCondition {
    pub snow_depth: FixedPoint,   // 0 = bare ground, 1024 = deep snow
    pub wetness: FixedPoint,      // 0 = dry, 1024 = waterlogged
}

/// Grid resource, one entry per map cell
pub struct TerrainSurfaceGrid {
    pub cells: Vec&lt;SurfaceCondition&gt;,
    pub width: u32,
    pub height: u32,
}
<span class="boring">}</span></code></pre>
<p>The <code>weather_surface_system</code> runs every tick for visible cells and amortizes non-visible cells over 4 ticks (after weather state update, before movement — see D022 in <code>decisions/09c-modding.md</code> § “Performance”):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Condition</th><th>Effect on Surface</th></tr>
</thead>
<tbody>
<tr><td>Snowing</td><td><code>snow_depth += accumulation_rate × intensity / 1024</code></td></tr>
<tr><td>Not snowing, sunny</td><td><code>snow_depth -= melt_rate</code> (clamped at 0)</td></tr>
<tr><td>Raining</td><td><code>wetness += wet_rate × intensity / 1024</code></td></tr>
<tr><td>Not raining</td><td><code>wetness -= dry_rate</code> (clamped at 0)</td></tr>
<tr><td>Snow melting</td><td><code>wetness += melt_rate</code> (meltwater)</td></tr>
<tr><td>Temperature &lt; threshold</td><td>Puddles freeze → wet cells become icy</td></tr>
</tbody>
</table>
</div>
<p><strong>Sim effects from surface state (when <code>sim_effects: true</code>):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Surface State</th><th>Gameplay Effect</th></tr>
</thead>
<tbody>
<tr><td>Deep snow (&gt; 512)</td><td>Infantry −20% speed, wheeled −30%, tracked −10%</td></tr>
<tr><td>Ice (frozen wetness)</td><td>Water tiles become passable; all ground units slide (−15% turn rate)</td></tr>
<tr><td>Wet ground (&gt; 256)</td><td>Wheeled −15% speed; no effect on tracked/infantry</td></tr>
<tr><td>Muddy (wet + warm)</td><td>Wheeled −25% speed, tracked −10%; infantry unaffected</td></tr>
<tr><td>Dry / sunny</td><td>No penalties; baseline movement</td></tr>
</tbody>
</table>
</div>
<p>These modifiers stack with the weather-type modifiers from the base weather table. A blizzard over deep snow is brutal.</p>
<p><strong>Snapshot compatibility:</strong> <code>TerrainSurfaceGrid</code> derives <code>Serialize, Deserialize</code> — surface state is captured in save games and snapshots per D010 (snapshottable sim state).</p>
<h4 id="terrain-texture-effects-render-layer"><a class="header" href="#terrain-texture-effects-render-layer">Terrain Texture Effects (Render Layer)</a></h4>
<p><code>ic-render</code> reads the sim’s <code>TerrainSurfaceGrid</code> and blends terrain visuals accordingly. This is <strong>purely cosmetic</strong> — it has no effect on the sim and runs at whatever quality the device supports.</p>
<p>Three rendering strategies, selectable via <code>RenderSettings</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Strategy</th><th>Quality</th><th>Cost</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Palette tinting</strong></td><td>Low</td><td>Near-zero</td><td>Shift terrain palette toward white (snow) or darker (wet). Authentic to original RA palette tech. No extra assets needed.</td></tr>
<tr><td><strong>Overlay sprites</strong></td><td>Medium</td><td>One pass</td><td>Draw semi-transparent snow/puddle/ice overlays on top of base terrain tiles. Requires overlay sprite sheets (shipped with engine or mod-provided).</td></tr>
<tr><td><strong>Shader blending</strong></td><td>High</td><td>GPU blend</td><td>Fragment shader blends between base texture and weather-variant texture per tile. Smoothest transitions, gradual accumulation. Requires variant texture sets.</td></tr>
</tbody>
</table>
</div>
<p>Default: <strong>palette tinting</strong> (works everywhere, zero asset requirements). Mods that ship weather-variant sprites get overlay or shader blending automatically.</p>
<p><strong>Accumulation visuals</strong> (shader blending mode):</p>
<ul>
<li>Snow doesn’t appear uniformly — it starts on tile edges, elevated features, and rooftops, then fills inward as <code>snow_depth</code> increases</li>
<li>Rain creates puddle sprites in low-lying cells first, then spreads to flat ground</li>
<li>Drying happens as a gradual desaturation back to base palette</li>
<li>Blend factor = <code>surface_condition_value / 1024</code> — smooth interpolation</li>
</ul>
<p><strong>Performance considerations:</strong></p>
<ul>
<li>Palette tinting: no extra draw calls, no extra textures, negligible GPU cost</li>
<li>Overlay sprites: one additional sprite draw per affected cell — batched via Bevy’s sprite batching</li>
<li>Shader blending: texture array per terrain type (base + snow + wet variants), single draw call per terrain chunk with per-vertex blend weights</li>
<li>Particle density for weather effects already scales with <code>RenderSettings</code> (existing design)</li>
<li>Surface texture updates are amortized: only cells near weather transitions or visible cells update their blend factors each frame</li>
</ul>
<h4 id="daynight-and-seasonal-integration"><a class="header" href="#daynight-and-seasonal-integration">Day/Night and Seasonal Integration</a></h4>
<p>Dynamic weather composes naturally with other environmental systems:</p>
<ul>
<li><strong>Day/night cycle:</strong> Ambient lighting shifts interact with weather — overcast days are darker, rain at night is nearly black with lightning flashes, sunny midday is brightest</li>
<li><strong>Seasonal maps:</strong> A map can set <code>temperature.base</code> low (winter map) so any rain becomes snow, or high (desert) where <code>sandstorm</code> replaces <code>rain</code> in the state machine</li>
<li><strong>Map-specific overrides:</strong> Arctic maps default to snow schedule; desert maps disable snow transitions; tropical maps always rain</li>
</ul>
<h4 id="modding-weather"><a class="header" href="#modding-weather">Modding Weather</a></h4>
<p>Weather is fully moddable at every tier:</p>
<ul>
<li><strong>Tier 1 (YAML):</strong> Define custom weather schedules, tune surface rates, adjust sim effect values, choose blend strategy, create seasonal presets</li>
<li><strong>Tier 2 (Lua):</strong> Trigger weather transitions at story moments, query surface state for mission objectives (“defend until the blizzard clears”), create weather-dependent triggers</li>
<li><strong>Tier 3 (WASM):</strong> Implement custom weather types (acid rain, ion storms, radiation clouds) with new particles, new sim effects, and custom surface state logic</li>
</ul>
<pre><code class="language-yaml"># Example: Tiberian Sun ion storm (custom weather type via mod)
weather_types:
  ion_storm:
    particles: ion_storm_particles.shp
    palette_tint: [0.2, 0.8, 0.3]  # green tint
    sim_effects:
      aircraft_grounded: true
      radar_disabled: true
      lightning_damage: 50
      lightning_interval: 120  # ticks between strikes
    surface:
      contamination_rate: 1
      max_contamination: 512
    render:
      strategy: shader_blend
      variant_suffix: "_ion"
</code></pre>
<p><strong>Scene template structure:</strong></p>
<pre><code>scenes/
  ambush/
    scene.lua.tera       # Tera-templated Lua trigger logic
    schema.yaml          # Parameters + inline defaults: location, units, trigger_zone, etc.
    README.md            # Usage, preview, notes
</code></pre>
<p><strong>Composing scenes into a mission template:</strong></p>
<pre><code class="language-yaml"># mission_templates/commando_raid/template.yaml
mission:
  name: "Behind Enemy Lines — {{ difficulty | title }}"
  briefing: &gt;
    Infiltrate the Soviet base. Destroy the radar, 
    then extract before reinforcements arrive.

scenes:
  - template: scripted_scene
    values:
      actors: [tanya]
      dialogue: ["Let's do this quietly..."]
      camera_positions: [{{ insertion_point }}]

  - template: patrol
    values:
      waypoints: {{ outer_patrol_route }}
      unit_composition: [guard, guard, dog]
      alert_radius: 5

  - template: ambush
    values:
      location: {{ radar_approach }}
      attacker_units: [guard, guard, grenadier]
      trigger_zone: { center: {{ radar_position }}, radius: 4 }

  - template: timed_objective
    values:
      target: radar_building
      time_limit: {{ {"easy": 300, "normal": 180, "hard": 120}[difficulty] }}
      failure_trigger: soviet_reinforcements_arrive

  - template: extraction
    values:
      pickup_zone: {{ extraction_point }}
      transport_type: chinook
      signal_trigger: radar_destroyed
</code></pre>
<p><strong>How this works at runtime:</strong></p>
<ol>
<li>Mission template engine resolves scene references</li>
<li>Each scene’s <code>schema.yaml</code> validates its parameters</li>
<li>Each scene’s <code>scene.lua.tera</code> is rendered with its values</li>
<li>All rendered Lua scripts are merged into a single mission trigger file with namespaced functions (e.g., <code>scene_1_ambush_on_trigger()</code>)</li>
<li>Output is a standard mission — indistinguishable from hand-crafted</li>
</ol>
<p><strong>For the LLM, this is transformative.</strong> Instead of generating raw Lua trigger code (hallucination-prone, hard to validate), the LLM:</p>
<ul>
<li>Picks scene templates by name from a known catalog</li>
<li>Fills in parameters that the schema validates</li>
<li>Composes scenes in sequence — the wiring logic is already built into the templates</li>
</ul>
<p>A “convoy escort with two ambushes and a base-building finale” is 3 scene template references with ~15 parameters total, not 200 lines of handwritten Lua.</p>
<h3 id="dynamic-mission-flow-map-expansion-sub-maps-phase-transitions"><a class="header" href="#dynamic-mission-flow-map-expansion-sub-maps-phase-transitions">Dynamic Mission Flow (Map Expansion, Sub-Maps, Phase Transitions)</a></h3>
<p>Classic C&amp;C missions — and especially OFP/ArmA missions — aren’t static. The map <em>changes</em> as you play: new areas reveal when objectives are completed, units enter building interiors for infiltration sequences, briefings fire between phases. Iron Curtain makes all of this first-class, scriptable, and editor-friendly.</p>
<p>Three interconnected systems:</p>
<ol>
<li><strong>Map Layers</strong> — named groups of terrain, entities, and triggers that activate/deactivate at runtime. The map expansion primitive.</li>
<li><strong>Sub-Map Transitions</strong> — enter a building or structure, transition to an interior map, complete objectives, return to the parent map.</li>
<li><strong>Phase Briefings</strong> — mid-mission cutscenes and briefings that bridge expansion phases (builds on the existing <code>video_playback</code> and <code>scripted_scene</code> templates).</li>
</ol>
<h4 id="map-layers--dynamic-expansion"><a class="header" href="#map-layers--dynamic-expansion">Map Layers &amp; Dynamic Expansion</a></h4>
<p>The map is authored as one large map with <strong>named layers</strong>. Each layer groups a region of terrain, entities, triggers, and camera bounds into a named set that starts active or inactive. When a Lua script activates a layer, the engine reveals shroud over that area, wakes dormant entities, extends the playable camera bounds, and activates triggers assigned to that layer.</p>
<p><strong>Key invariant:</strong> The full map exists in the simulation from tick 0 — all cells, all terrain data. Layers control <em>visibility and activity</em>, not physical existence. This preserves determinism: every client has the same map data from the start; layer state is part of the sim state.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A named group of map content that can be activated/deactivated at runtime.
/// Entities assigned to an inactive layer are dormant: invisible, non-collidable,
/// non-targetable, and their Lua scripts don't fire. Activating the layer wakes them.
#[derive(Component)]
pub struct MapLayer {
    pub name: String,
    pub active: bool,
    pub bounds: Option&lt;CellRect&gt;,           // layer's spatial extent (for camera bounds expansion)
    pub activation_shroud: ShroudRevealMode,// how shroud lifts when activated
    pub activation_camera: CameraAction,    // what the camera does on activation
}

/// How shroud reveals when a layer activates.
pub enum ShroudRevealMode {
    Instant,                        // immediate full reveal (classic)
    Dissolve { duration_ticks: u32 }, // fade from black over N ticks (cinematic)
    Gradual { speed: i32 },         // shroud peels from activation edge outward
    None,                           // don't touch shroud (layer has no terrain, e.g. entity-only)
}

/// What the camera does when a layer activates.
pub enum CameraAction {
    Stay,                           // camera stays where it is
    PanTo { target: CellPos, duration_ticks: u32 }, // smooth pan to new area
    JumpTo { target: CellPos },     // instant jump (for hard cuts)
    FollowUnit { entity: Entity },  // lock camera to a specific unit
}

/// Bevy Resource tracking active layers and the current playable bounds.
#[derive(Resource)]
pub struct MapLayerState {
    pub layers: HashMap&lt;String, bool&gt;,  // name → active
    pub playable_bounds: CellRect,      // union of all active layer bounds
}

/// Marker component for entities assigned to a specific layer.
/// When the layer is inactive, the entity is dormant.
#[derive(Component)]
pub struct LayerMember {
    pub layer: String,
}
<span class="boring">}</span></code></pre>
<p><strong>YAML schema — layers defined in the mission file:</strong></p>
<pre><code class="language-yaml"># mission map definition (inside map.yaml or scenario.yaml)
layers:
  phase_1_coastal:
    bounds: { x: 0, y: 0, w: 96, h: 64 }
    active: true                    # starting layer — player sees this area
  phase_2_beach:
    bounds: { x: 0, y: 64, w: 96, h: 48 }
    active: false
    activation_shroud: dissolve
    activation_camera: { pan_to: { x: 48, y: 88 }, duration: 90 }  # 3 seconds at 30 tps
  phase_3_base:
    bounds: { x: 96, y: 0, w: 64, h: 112 }
    active: false
    activation_shroud: gradual
    activation_camera: stay

actors:
  # Entities can be assigned to layers. Inactive layer → entity dormant.
  - type: SovietBarracks
    position: { x: 120, y: 50 }
    owner: enemy
    layer: phase_3_base             # only appears when phase_3_base activates
  - type: Tanya
    position: { x: 10, y: 10 }
    owner: player
    # no layer → always active (part of the implicit "base" layer)
</code></pre>
<p><strong>Lua API — <code>Layer</code> global:</strong></p>
<pre><code class="language-lua">-- Activate a layer: reveal shroud, wake entities, extend camera bounds
Layer.Activate("phase_2_beach")

-- Activate with a cinematic transition (overrides YAML defaults)
Layer.ActivateWithTransition("phase_2_beach", {
    shroud = "dissolve",
    shroud_duration = 120,          -- 4 seconds
    camera = "pan",
    camera_target = { x = 48, y = 88 },
    camera_duration = 90,
})

-- Deactivate: re-shroud, deactivate entities, contract bounds
Layer.Deactivate("phase_2_beach")

-- Query state
local active = Layer.IsActive("phase_2_beach")  -- true/false
local entities = Layer.GetEntities("phase_2_beach")  -- list of actor references

-- Modify bounds at runtime (rare, but useful for dynamic scenarios)
Layer.SetBounds("phase_2_beach", { x = 0, y = 64, w = 128, h = 48 })
</code></pre>
<p><strong>Lua API — <code>Map</code> global extensions:</strong></p>
<pre><code class="language-lua">-- Directly manipulate playable camera bounds (independent of layers)
Map.SetPlayableBounds({ x = 0, y = 0, w = 192, h = 112 })
local bounds = Map.GetPlayableBounds()

-- Bulk shroud reveal (for custom reveal patterns, independent of layers)
Map.RevealShroud("named_region_from_editor")   -- reveal a D038 Named Region
Map.RevealShroud({ x = 10, y = 10, w = 30, h = 20 })  -- reveal a rectangle
Map.RevealShroudGradual("named_region", 90)     -- animated reveal over 3 seconds
</code></pre>
<p><strong>Worked example — “Operation Coastal Storm” (Tanya destroys AA → map expands):</strong></p>
<pre><code class="language-lua">-- mission_coastal_storm.lua

local aa_sites_remaining = 3

function OnMissionStart()
    Objectives.Add("primary", "destroy_aa", "Destroy the 3 anti-air batteries")
    -- Player starts in phase_1_coastal (64-cell-tall strip)
    -- phase_2_beach is invisible, its entities dormant
end

Trigger.OnKilled("aa_site_1", function() OnAASiteDestroyed() end)
Trigger.OnKilled("aa_site_2", function() OnAASiteDestroyed() end)
Trigger.OnKilled("aa_site_3", function() OnAASiteDestroyed() end)

function OnAASiteDestroyed()
    aa_sites_remaining = aa_sites_remaining - 1
    UserInterface.SetMissionText("AA sites remaining: " .. aa_sites_remaining)

    if aa_sites_remaining == 0 then
        Objectives.Complete("destroy_aa")

        -- Phase transition: expand the map
        Layer.ActivateWithTransition("phase_2_beach", {
            shroud = "dissolve",
            shroud_duration = 120,
            camera = "pan",
            camera_target = { x = 48, y = 88 },
            camera_duration = 90,
        })

        -- Mid-expansion briefing (radar_comm — game doesn't pause)
        Media.PlayVideo("videos/commander-clear-skies.webm", "radar_comm")

        -- Reinforcements arrive at the newly revealed beach
        Trigger.AfterDelay(150, function()
            Reinforcements.Arrive("allies", {"Tank", "Tank", "APC", "Rifle", "Rifle"},
                                  "south_beach_entry")
            PlayEVA("reinforcements_arrived")
        end)

        -- New objective in the expanded area
        Objectives.Add("primary", "capture_port", "Capture the enemy port facility")
    end
end
</code></pre>
<h4 id="sub-map-transitions-building-interiors"><a class="header" href="#sub-map-transitions-building-interiors">Sub-Map Transitions (Building Interiors)</a></h4>
<p>A <code>SubMapPortal</code> links a location on the main map to a secondary map file. When a qualifying unit enters the portal’s trigger region, the engine:</p>
<ol>
<li><strong>Snapshots</strong> the main map state (sim snapshot — D010)</li>
<li><strong>Transitions</strong> visually (fade, iris wipe, or cut)</li>
<li>Optionally plays a <strong>briefing</strong> during the transition</li>
<li><strong>Loads</strong> the sub-map and spawns the entering unit at the configured spawn point</li>
<li>Runs the sub-map as a <strong>self-contained mission</strong> with its own triggers, objectives, and Lua scripts</li>
<li>On sub-map completion (<code>SubMap.Exit(outcome)</code>), <strong>returns</strong> to the main map, restores the snapshot, applies outcome effects, and resumes simulation</li>
</ol>
<p><strong>Determinism:</strong> The main map snapshot is part of the sim state. Sub-map execution is fully deterministic. The sub-map’s Lua environment is isolated — it cannot access main map entities directly, only through <code>SubMap.GetParentContext()</code>.</p>
<p>Inspired by: Commandos: Behind Enemy Lines (building interiors), Fallout 1/2 (location transitions), Jagged Alliance 2 (sector movement), and the “Tanya infiltrates the base” C&amp;C mission archetype.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A portal linking the main map to a sub-map (building interior, underground, etc.)
#[derive(Component)]
pub struct SubMapPortal {
    pub name: String,
    pub sub_map: String,                    // path to sub-map file (e.g., "interiors/radar-station.yaml")
    pub entry_region: String,               // D038 Named Region on main map (trigger area)
    pub spawn_point: CellPos,               // where the unit appears in the sub-map
    pub exit_point: CellPos,                // where the unit appears on main map when exiting
    pub allowed_units: Vec&lt;String&gt;,         // unit type filter (empty = any unit)
    pub transition: SubMapTransitionEffect,
    pub on_enter_briefing: Option&lt;String&gt;,  // optional briefing during transition
    pub outcomes: HashMap&lt;String, SubMapOutcome&gt;, // named outcomes and their effects on parent
}

pub enum SubMapTransitionEffect {
    FadeBlack { duration_ticks: u32 },
    IrisWipe { duration_ticks: u32 },
    Cut,                                    // instant (no transition effect)
}

/// What happens on the parent map when the sub-map exits with a given outcome.
pub struct SubMapOutcome {
    pub set_flags: HashMap&lt;String, bool&gt;,   // campaign/mission flags to set
    pub activate_layers: Vec&lt;String&gt;,       // map layers to activate on return
    pub deactivate_layers: Vec&lt;String&gt;,     // map layers to deactivate
    pub spawn_units: Vec&lt;SpawnSpec&gt;,        // units to spawn on main map
    pub play_video: Option&lt;String&gt;,         // debrief video on return
}

/// Bevy Resource tracking the active sub-map state.
#[derive(Resource)]
pub struct SubMapState {
    pub active: bool,
    pub parent_snapshot: Option&lt;SimSnapshot&gt;,   // D010: frozen main map state
    pub entry_context: Option&lt;SubMapContext&gt;,    // which unit, which portal
    pub current_sub_map: Option&lt;String&gt;,         // active sub-map path
}

pub struct SubMapContext {
    pub entering_unit: Entity,
    pub portal_name: String,
    pub parent_map: String,
}
<span class="boring">}</span></code></pre>
<p><strong>YAML schema — portals defined in the mission file:</strong></p>
<pre><code class="language-yaml">portals:
  radar_dome_interior:
    sub_map: interiors/radar-station.yaml
    entry_region: radar_door_zone           # D038 Named Region
    spawn_point: { x: 5, y: 12 }
    exit_point: { x: 48, y: 30 }           # where unit reappears on main map
    allowed_units: [spy, tanya, commando]
    transition: { fade_black: { duration: 60 } }
    on_enter_briefing: briefings/infiltrate-radar.yaml
    outcomes:
      sabotaged:
        set_flags: { radar_destroyed: true }
        activate_layers: [phase_2_north]
        play_video: videos/radar-destroyed.webm
      detected:
        set_flags: { alarm_triggered: true }
        spawn_units:
          - type: SovietDog
            count: 4
            position: { x: 50, y: 32 }
          - type: Rifle
            count: 8
            position: { x: 55, y: 28 }
      captured:
        set_flags: { radar_captured: true, radar_destroyed: false }
        activate_layers: [allied_radar_overlay]
</code></pre>
<p><strong>Sub-map file (the interior):</strong></p>
<pre><code class="language-yaml"># interiors/radar-station.yaml — self-contained mini-mission
map:
  size: { w: 24, h: 16 }
  tileset: interior_concrete

actors:
  - type: SovietGuard
    position: { x: 10, y: 8 }
    owner: enemy
    stance: patrol
    patrol_route: [{ x: 10, y: 8 }, { x: 18, y: 8 }, { x: 18, y: 4 }]
  - type: RadarConsole
    position: { x: 20, y: 2 }
    owner: enemy
    # The objective target

triggers:
  - name: comm_array_destroyed
    condition: { killed: RadarConsole }
    action: { lua: "SubMap.Exit('sabotaged')" }
  - name: spy_detected
    condition: { any_enemy_sees: entering_unit, range: 3 }
    action: { lua: "SubMap.Exit('detected')" }
  - name: console_captured
    condition: { captured: RadarConsole }
    action: { lua: "SubMap.Exit('captured')" }
</code></pre>
<p><strong>Lua API — <code>SubMap</code> global:</strong></p>
<pre><code class="language-lua">-- Programmatically enter a portal (alternative to unit walking into trigger region)
SubMap.Enter("radar_dome_interior")

-- Exit back to parent map with a named outcome
SubMap.Exit("sabotaged")           -- triggers the outcome effects defined in YAML

-- Query state
local is_inside = SubMap.IsActive()                     -- true if inside a sub-map
local context = SubMap.GetParentContext()                -- { unit = ..., portal = "radar_dome_interior" }
local entering_unit = SubMap.GetParentContext().unit     -- the unit that entered

-- Transfer additional units into the sub-map (e.g., reinforcements arrive inside)
SubMap.TransferUnit(some_unit, { x = 5, y = 14 })

-- Read parent map flags from within the sub-map (read-only)
local has_power = SubMap.GetParentFlag("enemy_power_down")
</code></pre>
<p><strong>Worked example — spy infiltration with multiple outcomes:</strong></p>
<pre><code class="language-lua">-- interiors/radar-station.lua (runs inside the sub-map)

function OnMissionStart()
    local spy = SubMap.GetParentContext().unit
    Objectives.Add("primary", "disable_radar", "Reach the communications array")
    Objectives.Add("secondary", "capture_radar", "Capture the array instead of destroying it")

    -- Spy starts disguised — guards don't attack unless within detection range
    -- Detection range is smaller for spies (disguise mechanic from gameplay-systems.md)
end

-- Guard patrol detection
Trigger.OnEnteredProximity("soviet_guard_1", 3, function(detected_unit)
    if detected_unit == SubMap.GetParentContext().unit then
        UserInterface.SetMissionText("You've been detected!")
        PlayEVA("mission_compromised")
        Trigger.AfterDelay(30, function()
            SubMap.Exit("detected")  -- alarm on main map, enemy reinforcements
        end)
    end
end)

-- Destroy the console
Trigger.OnKilled("radar_console", function()
    Objectives.Complete("disable_radar")
    Camera.Shake(5)
    PlayEVA("objective_complete")
    Trigger.AfterDelay(60, function()
        SubMap.Exit("sabotaged")    -- radar goes offline, phase_2_north activates
    end)
end)

-- OR capture it (spy uses C4 vs. infiltration — player's choice)
Trigger.OnCaptured("radar_console", function()
    Objectives.Complete("capture_radar")
    PlayEVA("building_captured")
    Trigger.AfterDelay(60, function()
        SubMap.Exit("captured")     -- radar now works for allies
    end)
end)
</code></pre>
<h4 id="phase-briefings--cutscene-integration"><a class="header" href="#phase-briefings--cutscene-integration">Phase Briefings &amp; Cutscene Integration</a></h4>
<p>The existing <code>video_playback</code> scene template (fullscreen / radar_comm / picture_in_picture) and <code>scripted_scene</code> template already handle mid-mission cutscenes. The new <code>phase_briefing</code> scene template <strong>combines</strong> a briefing with layer activation and reinforcements into a single atomic “next phase” module:</p>
<pre><code class="language-lua">-- phase_briefing: the "glue" between mission phases
-- Equivalent to manually chaining: video → layer activation → reinforcements → new objectives
-- but packaged as one drag-and-drop module in the D038 editor

function TriggerPhaseTransition(config)
    -- 1. Play briefing (if provided)
    if config.video then
        Media.PlayVideo(config.video, config.display_mode or "radar_comm", function()
            -- 2. Activate layer (if provided) — callback fires when video ends
            if config.layer then
                Layer.ActivateWithTransition(config.layer, config.transition or {})
            end
            -- 3. Spawn reinforcements (if provided)
            if config.reinforcements then
                for _, r in ipairs(config.reinforcements) do
                    Reinforcements.Arrive(r.faction, r.units, r.entry_point)
                end
            end
            -- 4. Add new objectives (if provided)
            if config.objectives then
                for _, obj in ipairs(config.objectives) do
                    Objectives.Add(obj.priority, obj.id, obj.text)
                end
            end
        end)
    end
end
</code></pre>
<p><code>Media.PlayVideo</code> with a callback is the key addition — the existing video system plays the clip, and the callback fires when it ends (or when the player skips). This enables sequenced phase transitions: briefing → reveal → reinforcements → objectives, all timed correctly.</p>
<p>For <code>scripted_scene</code> (non-video cutscenes using in-engine camera movement and dialogue), the existing <code>Camera.Pan()</code> API chains naturally with <code>Layer.ActivateWithTransition()</code>:</p>
<pre><code class="language-lua">-- Dramatic reveal: camera pans to newly expanded area while shroud dissolves
Layer.ActivateWithTransition("phase_2_beach", {
    shroud = "dissolve", shroud_duration = 120,
    camera = "pan", camera_target = { x = 48, y = 88 }, camera_duration = 90,
})
-- Letterbox bars appear for cinematic framing
Camera.SetLetterbox(true)
Trigger.AfterDelay(120, function()
    Camera.SetLetterbox(false)
    -- Player regains control in the newly revealed area
end)
</code></pre>
<h4 id="multi-phase-mission-example-all-systems-combined"><a class="header" href="#multi-phase-mission-example-all-systems-combined">Multi-Phase Mission Example (All Systems Combined)</a></h4>
<p>This example shows how map expansion, sub-map transitions, and phase briefings compose into a sophisticated multi-phase mission — the kind of scenario the editor should make easy to build.</p>
<p><strong>“Operation Iron Veil” — 4-phase campaign mission:</strong></p>
<pre><code>Phase 1: Small map. Tanya + squad. Destroy 3 AA positions.
    ↓ AA destroyed
Phase 2: Map expands north (beach). Briefing: "Clear skies! Sending the fleet."
         Transports arrive. Beach assault with armor.
    ↓ Beach secured
Phase 3: Spy enters enemy radar dome (sub-map transition).
         Interior infiltration: avoid patrols, sabotage or capture radar.
    ↓ Radar outcome
Phase 4: Map expands east (enemy HQ). Final assault.
         If radar sabotaged: enemy has no radar, reduced AI vision.
         If radar captured: player gets full map reveal.
         If spy detected: enemy is reinforced, harder fight.
</code></pre>
<p>Each phase transition uses the systems described above. The campaign state (D021) tracks outcomes: <code>Campaign.set_flag("radar_outcome", outcome)</code> persists into subsequent missions. A follow-up mission might reference whether the player captured vs. destroyed the radar.</p>
<h4 id="editor-support-d038"><a class="header" href="#editor-support-d038">Editor Support (D038)</a></h4>
<p>The scenario editor exposes all three systems through its visual interface. These are <strong>Advanced mode</strong> features (hidden in Simple mode to keep it approachable).</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Editor Feature</th><th>Mode</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Layer Panel</strong></td><td>Advanced</td><td>Side panel listing all map layers. Create, rename, delete, toggle visibility. Click a layer to highlight its bounds and member entities. Drag entities into layers.</td></tr>
<tr><td><strong>Layer Bounds Tool</strong></td><td>Advanced</td><td>Draw/resize rectangles on the map to define layer spatial extents. Color-coded overlay per layer (semi-transparent tinting).</td></tr>
<tr><td><strong>Preview Layer</strong></td><td>Advanced</td><td>Toggle button per layer — shows what the map looks like with that layer active/inactive. Useful for testing expansion flow without running the mission.</td></tr>
<tr><td><strong>Expansion Zone Module</strong></td><td>Advanced</td><td>Drag-and-drop module in the Connections panel: wire a trigger condition → layer activation. Properties: shroud reveal mode, camera action, delay.</td></tr>
<tr><td><strong>Portal Placement</strong></td><td>Advanced</td><td>Place a portal entity on a building footprint. Properties panel: linked sub-map file, spawn point, exit point, allowed unit types, transition effect, outcomes.</td></tr>
<tr><td><strong>Sub-Map Tab</strong></td><td>Advanced</td><td>Open a linked sub-map in a new editor tab. Edit the interior with all standard tools. Portal entry/exit markers shown as special gizmos.</td></tr>
<tr><td><strong>Portal Connections View</strong></td><td>Advanced</td><td>Overlay showing lines from portal entities to their sub-map files. Click to open. Visual indication of which outcomes are wired to which parent map effects.</td></tr>
<tr><td><strong>Phase Briefing Module</strong></td><td>Advanced</td><td>Drag-and-drop module: combines video/briefing reference + layer activation + reinforcement list + new objectives. The “next phase” button in module form.</td></tr>
<tr><td><strong>Test Phase Flow</strong></td><td>Advanced</td><td>Play button that runs through phase transitions in sequence — activates layers, plays briefings, spawns reinforcements — without running full AI/combat simulation. Quick iteration on mission pacing.</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Simple mode</strong> users can still create multi-phase missions — they just use the pre-built <code>map_expansion</code>, <code>sub_map_transition</code>, and <code>phase_briefing</code> modules from the module library, filling in parameters via the properties panel. Advanced mode gives direct layer/portal manipulation for power users.</p>
</blockquote>
<h3 id="templates-as-workshop-resources"><a class="header" href="#templates-as-workshop-resources">Templates as Workshop Resources</a></h3>
<p>Scene templates and mission templates are both first-class workshop resource types — shared, rated, versioned, and downloadable like any other content. See the full resource category taxonomy in the <a href="#workshop-resource-registry--dependency-system-d030">Workshop Resource Registry</a> section below.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Contents</th><th>Examples</th></tr>
</thead>
<tbody>
<tr><td>Mods</td><td>YAML rules + Lua scripts + WASM modules</td><td>Total conversions, balance patches, new factions</td></tr>
<tr><td>Maps</td><td><code>.oramap</code> or native IC YAML map format</td><td>Skirmish maps, campaign maps, tournament pools</td></tr>
<tr><td>Missions</td><td>YAML map + Lua triggers + briefing</td><td>Hand-crafted or LLM-generated scenarios</td></tr>
<tr><td><strong>Scene Templates</strong></td><td><strong>Tera-templated Lua + schema</strong></td><td><strong>Reusable sub-mission building blocks</strong></td></tr>
<tr><td><strong>Mission Templates</strong></td><td><strong>Tera templates + scene refs + schema</strong></td><td><strong>Full parameterized mission blueprints</strong></td></tr>
<tr><td>Campaigns</td><td>Ordered mission sets + narrative</td><td>Multi-mission storylines</td></tr>
<tr><td>Music</td><td>OGG Vorbis recommended (<code>.ogg</code>); also <code>.mp3</code>, <code>.flac</code></td><td>Custom soundtracks, faction themes, menu music</td></tr>
<tr><td>Sound Effects</td><td>WAV or OGG (<code>.wav</code>, <code>.ogg</code>); legacy <code>.aud</code> accepted</td><td>Weapon sounds, ambient loops, UI feedback</td></tr>
<tr><td>Voice Lines</td><td>OGG Vorbis + trigger metadata; legacy <code>.aud</code> accepted</td><td>EVA packs, unit responses, faction voice sets</td></tr>
<tr><td>Sprites</td><td>PNG recommended (<code>.png</code>); legacy <code>.shp</code>+<code>.pal</code> accepted</td><td>HD unit packs, building sprites, effects packs</td></tr>
<tr><td>Textures</td><td>PNG or KTX2 (GPU-compressed); legacy <code>.tmp</code> accepted</td><td>Theater tilesets, seasonal terrain variants</td></tr>
<tr><td>Palettes</td><td><code>.pal</code> files (unchanged — 768 bytes, universal)</td><td>Theater palettes, faction colors, seasonal</td></tr>
<tr><td>Cutscenes / Video</td><td>WebM recommended (<code>.webm</code>); also <code>.mp4</code>; legacy <code>.vqa</code> accepted</td><td>Custom briefings, cinematics, narrative videos</td></tr>
<tr><td>UI Themes</td><td>Chrome layouts, fonts, cursors</td><td>Alternative sidebars, HD cursor packs</td></tr>
<tr><td>Balance Presets</td><td>YAML rule overrides</td><td>Competitive tuning, historical accuracy presets</td></tr>
<tr><td>QoL Presets</td><td>Gameplay behavior toggle sets (D033)</td><td>Custom QoL configurations, community favorites</td></tr>
<tr><td>Experience Profiles</td><td>Combined balance + theme + QoL (D019+D032+D033)</td><td>One-click full experience configurations</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Format guidance (D049):</strong> New Workshop content should use Bevy-native modern formats (OGG, PNG, WAV, WebM, KTX2, GLTF) for best compatibility, security, and tooling support. C&amp;C legacy formats (.aud, .shp, .vqa, .tmp) are fully supported for backward compatibility but not recommended for new content. See <code>05-FORMATS.md</code> § Canonical Asset Format Recommendations and <code>decisions/09e/D049-workshop-assets.md</code> for full rationale.</p>
</blockquote>
<h2 id="resource-packs-switchable-asset-layers"><a class="header" href="#resource-packs-switchable-asset-layers">Resource Packs (Switchable Asset Layers)</a></h2>
<p>Resource packs are <strong>switchable asset override layers</strong> — the player selects which version of a resource category to use (cutscenes, sprites, music, voice lines, etc.), and the engine swaps to those assets without touching gameplay. Same concept as Minecraft’s resource packs or the Remastered Collection’s SD/HD toggle, but generalized to any asset type.</p>
<p>This falls naturally out of the architecture. Every asset is referenced by <strong>logical ID</strong> in YAML (e.g., <code>video: videos/allied-01-briefing.vqa</code>). A resource pack overrides those references — mapping the same IDs to different files. No code, no mods, no gameplay changes. Pure presentation layer.</p>
<h3 id="tera-templated-resource-packs-optional-for-complex-packs"><a class="header" href="#tera-templated-resource-packs-optional-for-complex-packs">Tera-Templated Resource Packs (Optional, for Complex Packs)</a></h3>
<p>Most community resource packs are plain YAML (see “Most Packs Are Plain YAML” below). But <strong>all first-party IC packs use Tera</strong> — the built-in cutscene, sprite, and music packs are templated with configurable quality, language, and content selection. This dogfoods the system and provides working examples for pack authors who want to go beyond flat mappings.</p>
<p>For packs that need <strong>configurable parameters</strong> — quality tiers, language selection, platform-aware defaults — Tera templates use a <code>schema.yaml</code> that defines the available knobs. Defaults are inline in the template; users configure through the in-game settings UI.</p>
<p><strong>Pack structure:</strong></p>
<pre><code>resource-packs/hd-cutscenes/
  pack.yaml.tera      # Tera template — generates the override map
  schema.yaml          # Parameter definitions with inline defaults
  assets/              # The actual replacement files
    videos/
      allied-01-briefing-720p.mp4
      allied-01-briefing-1080p.mp4
      allied-01-briefing-4k.mp4
      ...
</code></pre>
<p><strong>Schema (configurable knobs):</strong></p>
<pre><code class="language-yaml"># schema.yaml
parameters:
  quality:
    type: enum
    options: [720p, 1080p, 4k]
    default: 1080p
    description: "Video resolution — higher needs more disk space"

  language:
    type: enum
    options: [en, de, fr, ru, es, ja]
    default: en
    description: "Subtitle/dub language"

  include_victory_sequences:
    type: boolean
    default: true
    description: "Also replace victory/defeat cinematics"

  style:
    type: enum
    options: [upscaled, redrawn, ai_generated]
    default: upscaled
    description: "Visual style of replacement cutscenes"
</code></pre>
<p><strong>Tera template (generates the override map from parameters):</strong></p>
<pre><code class="language-jinja">{# pack.yaml.tera #}
resource_pack:
  name: "HD Cutscenes ({{ quality }}, {{ language }})"
  description: "{{ style | title }} briefing videos in {{ quality }}"
  category: cutscenes
  version: "2.0.0"

  assets:
    {% for mission in ["allied-01", "allied-02", "allied-03", "soviet-01", "soviet-02", "soviet-03"] %}
    videos/{{ mission }}-briefing.vqa: assets/videos/{{ mission }}-briefing-{{ quality }}.mp4
    {% endfor %}

    {% if include_victory_sequences %}
    {% for seq in ["allied-victory", "allied-defeat", "soviet-victory", "soviet-defeat"] %}
    videos/{{ seq }}.vqa: assets/videos/{{ seq }}-{{ quality }}.mp4
    {% endfor %}
    {% endif %}

    {# Language-specific subtitle tracks #}
    {% if language != "en" %}
    {% for mission in ["allied-01", "allied-02", "allied-03", "soviet-01", "soviet-02", "soviet-03"] %}
    subtitles/{{ mission }}.srt: assets/subtitles/{{ language }}/{{ mission }}.srt
    {% endfor %}
    {% endif %}
</code></pre>
<p><strong>User configuration (in-game settings, not CLI overrides):</strong></p>
<p>Players configure pack parameters through the Settings → Resource Packs UI. When a pack has a <code>schema.yaml</code>, the UI renders the appropriate controls (dropdowns for enums, checkboxes for booleans). The engine re-renders the Tera template whenever settings change, producing an updated override map. This is load-time only — zero runtime cost.</p>
<p>For CLI users, <code>ic resource-pack install hd-cutscenes</code> installs the pack with its defaults. Parameters are then adjusted in settings.</p>
<h3 id="why-tera-not-just-flat-mappings"><a class="header" href="#why-tera-not-just-flat-mappings">Why Tera (Not Just Flat Mappings)</a></h3>
<p>Flat override maps (<code>asset_a → asset_b</code>) work for simple cases, but fall apart when packs need to:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Need</th><th>Flat Mapping</th><th>Tera Template</th></tr>
</thead>
<tbody>
<tr><td>Quality tiers (720p/1080p/4k)</td><td>3 separate packs with 90% duplicated YAML</td><td>One pack, <code>quality</code> parameter</td></tr>
<tr><td>Language variants</td><td>One pack per language × quality = combinatorial explosion</td><td><code>{% if language != "en" %}</code> conditional</td></tr>
<tr><td>Faction-specific overrides</td><td>Manual enumeration of every faction’s assets</td><td><code>{% for faction in factions %}</code> loop</td></tr>
<tr><td>Optional components (victory sequences, tutorial videos)</td><td>Separate packs or monolithic everything-pack</td><td>Boolean parameters with <code>{% if %}</code></td></tr>
<tr><td>Platform-aware (mobile gets 720p, desktop gets 1080p)</td><td>Separate mobile/desktop packs</td><td><code>quality</code> defaults per <code>ScreenClass</code></td></tr>
<tr><td>Mod-aware (pack adapts to which game module is active)</td><td>One pack per game module</td><td><code>{% if game_module == "ra2" %}</code> conditional</td></tr>
</tbody>
</table>
</div>
<p>This is the same reason Helm uses Go templates instead of static YAML — real-world configuration has conditionals, loops, and user-specific values. Our approach is inspired by Helm’s parameterized templating, but the configuration surface is the in-game settings UI, not a CLI + values file workflow.</p>
<h3 id="most-packs-are-plain-yaml-no-templating"><a class="header" href="#most-packs-are-plain-yaml-no-templating">Most Packs Are Plain YAML (No Templating)</a></h3>
<p>The <strong>default and recommended</strong> way to create a resource pack is plain YAML — just list the files you’re replacing. No template syntax, no schema, no values file. This is what <code>ic mod init resource-pack</code> generates:</p>
<pre><code class="language-yaml"># resource-packs/retro-sounds/pack.yaml — plain YAML, no Tera
resource_pack:
  name: "Retro 8-bit Sound Effects"
  category: sound_effects
  version: "1.0.0"
  assets:
    sounds/explosion_large.wav: assets/explosion_large_8bit.wav
    sounds/rifle_fire.wav: assets/rifle_fire_8bit.wav
    sounds/tank_move.wav: assets/tank_move_8bit.wav
</code></pre>
<p>This covers the majority of resource packs. Someone replacing cutscenes, swapping in HD sprites, or providing an alternative soundtrack just lists the overrides — done.</p>
<p><strong>Tera templates are opt-in for complex packs</strong> that need parameters (quality tiers, language selection, conditional content). Rename <code>pack.yaml</code> to <code>pack.yaml.tera</code>, add a <code>schema.yaml</code>, and the engine renders the template at install time. But this is a power-user feature — most content creators never need it.</p>
<p>The engine detects <code>.tera</code> extension → renders template; plain <code>.yaml</code> → loads directly.</p>
<h3 id="resource-pack-categories"><a class="header" href="#resource-pack-categories">Resource Pack Categories</a></h3>
<p>Players can mix and match one pack per category:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>What It Overrides</th><th>Example Packs</th></tr>
</thead>
<tbody>
<tr><td>Cutscenes</td><td>Briefing videos, victory/defeat sequences, in-mission cinematics</td><td>Original <code>.vqa</code>, AI-upscaled HD, community remakes, humorous parodies</td></tr>
<tr><td>Sprites</td><td>Unit art, building art, effects, projectiles</td><td>Classic <code>.shp</code>, HD sprite pack, hand-drawn style</td></tr>
<tr><td>Music</td><td>Soundtrack, menu music, faction themes</td><td>Original, Frank Klepacki remastered, community compositions</td></tr>
<tr><td>Voice Lines</td><td>EVA announcements, unit responses</td><td>Original, alternative EVA voices, localized voice packs</td></tr>
<tr><td>Sound Effects</td><td>Weapon sounds, explosions, ambient</td><td>Original, enhanced audio, retro 8-bit</td></tr>
<tr><td>Terrain</td><td>Theater tilesets, terrain textures</td><td>Classic, HD, seasonal (winter/desert variants)</td></tr>
</tbody>
</table>
</div>
<h3 id="settings-ui"><a class="header" href="#settings-ui">Settings UI</a></h3>
<pre><code>Settings → Resource Packs
┌───────────────────────────────────────────────┐
│ Cutscenes:     [HD Upscaled ▾]     [⚙ Configure]
│                 Quality: [1080p ▾]            │
│                 Language: [English ▾]         │
│                 Victory sequences: [✓]        │
│                                               │
│ Music:         [Remastered ▾]                 │
│ Voice Lines:   [Original ▾]                   │
│ Sprites:       [HD Pack ▾]          [⚙ Configure]
│ Sound Effects: [Original ▾]                   │
│ Terrain:       [HD Pack ▾]                    │
└───────────────────────────────────────────────┘
</code></pre>
<p>The ⚙ Configure button appears when a pack has a <code>schema.yaml</code> with user-configurable parameters. Simple packs (no schema) just show the dropdown.</p>
<h3 id="relationship-to-existing-decisions"><a class="header" href="#relationship-to-existing-decisions">Relationship to Existing Decisions</a></h3>
<p>Resource packs generalize a pattern that already appears in several places:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Decision</th><th>What It Switches</th><th>Resource Pack Equivalent</th></tr>
</thead>
<tbody>
<tr><td>D019</td><td>Balance rule sets (Classic/OpenRA/Remastered)</td><td>Balance presets already work this way</td></tr>
<tr><td>D029</td><td>Classic/HD sprite rendering (dual asset)</td><td>Sprite resource packs supersede this; D029’s <code>classic:</code>/<code>hd:</code> YAML keys become the first two sprite packs</td></tr>
<tr><td>D032</td><td>UI chrome, menus, lobby (themes)</td><td>UI themes are resource packs for the chrome category</td></tr>
<tr><td>Tera templating</td><td>Mission/scene templates</td><td>Resource packs use the same <code>template.tera</code> + <code>schema.yaml</code> pattern — one templating system for everything</td></tr>
</tbody>
</table>
</div>
<p>The underlying mechanism is the same: <strong>YAML-level asset indirection with Tera rendering</strong>. The <code>template.tera</code> + <code>schema.yaml</code> pattern appears in three places:</p>
<pre><code>Mission Templates  → template.yaml.tera + schema.yaml = playable mission
Scene Templates    → triggers.lua.tera  + schema.yaml = scripted encounter
Resource Packs     → pack.yaml.tera     + schema.yaml = asset override layer
</code></pre>
<p>One templating engine (Tera), one pattern, three use cases. Defaults live inline in the schema. User preferences come from settings UI (resource packs) or from the LLM/user filling in parameters (mission templates). No separate values file needed in the common case.</p>
<h3 id="workshop-distribution-d030"><a class="header" href="#workshop-distribution-d030">Workshop Distribution (D030)</a></h3>
<p>Resource packs are publishable to the workshop like any other resource:</p>
<ul>
<li><code>ic mod init resource-pack</code> → scaffolds a pack with asset manifest</li>
<li><code>ic mod publish</code> → uploads to workshop</li>
<li>Players subscribe in-game or via CLI</li>
<li>Packs from multiple authors can coexist — one per category, player’s choice</li>
<li>Dependencies work: a mission pack can require a specific cutscene pack (<code>depends: alice/hd-cutscenes@^1.0</code>)</li>
</ul>
<h3 id="cutscenes-specifically"><a class="header" href="#cutscenes-specifically">Cutscenes Specifically</a></h3>
<p>Since cutscenes are what prompted this — the system is particularly powerful here:</p>
<ol>
<li><strong>Original <code>.vqa</code> files</strong> — ship with the game (from original RA install). Low-res but authentic.</li>
<li><strong>AI-upscaled HD</strong> — community or first-party pack running the originals through video upscaling. Same content, better resolution.</li>
<li><strong>Community remakes</strong> — fans re-creating briefings with modern tools, voice acting, or different artistic styles.</li>
<li><strong>AI-generated replacements</strong> — using video generation AI to create entirely new briefing sequences. Same narrative beats (referenced from campaign YAML), different visuals.</li>
<li><strong>Humorous/parody versions</strong> — because the community will absolutely do this, and we should make it easy.</li>
<li><strong>Localized versions</strong> — same briefings with translated subtitles or dubbed audio.</li>
</ol>
<p>The campaign system (D021) references cutscenes by logical ID in the <code>video:</code> field. Changing which pack is active changes which video plays — no campaign YAML edits needed.</p>
<h2 id="campaign-system-branching-persistent-continuous"><a class="header" href="#campaign-system-branching-persistent-continuous">Campaign System (Branching, Persistent, Continuous)</a></h2>
<blockquote>
<p><strong>Moved to <a href="modding/campaigns.html">modding/campaigns.md</a></strong> for RAG/context efficiency.</p>
<p>Full design for branching mission graphs with persistent state, unit roster carryover, optional hero progression/toolkit (XP/levels/skills), and continuous mission flow. OFP/ArmA-inspired (D021). Includes: campaign graph schema, mission node types, branch conditions, outcome variables, unit persistence, Lua campaign API, adaptive difficulty, tutorial campaigns (D065), and LLM campaign generation.</p>
</blockquote>
<h2 id="workshop-federated-resource-registry-p2p-distribution-moderation"><a class="header" href="#workshop-federated-resource-registry-p2p-distribution-moderation">Workshop (Federated Resource Registry, P2P Distribution, Moderation)</a></h2>
<blockquote>
<p><strong>Moved to <a href="modding/workshop.html">modding/workshop.md</a></strong> for RAG/context efficiency.</p>
<p>Full design for the Workshop content distribution platform: federated repository architecture, P2P delivery (D049), resource registry with semver dependencies (D030), licensing, moderation, LLM-driven discovery, Steam integration, modpacks, creator reputation (D035), achievement system (D036), and Workshop API.</p>
</blockquote>
<h2 id="mod-sdk--developer-experience"><a class="header" href="#mod-sdk--developer-experience">Mod SDK &amp; Developer Experience</a></h2>
<p><em>Inspired by studying the <a href="https://github.com/OpenRA/OpenRAModSDK">OpenRA Mod SDK</a> — see D020.</em></p>
<h3 id="lessons-from-the-openra-mod-sdk"><a class="header" href="#lessons-from-the-openra-mod-sdk">Lessons from the OpenRA Mod SDK</a></h3>
<p>The OpenRA Mod SDK is a template repository that modders fork. It includes:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>OpenRA SDK Feature</th><th>What’s Good</th><th>Our Improvement</th></tr>
</thead>
<tbody>
<tr><td>Fork-the-repo template</td><td>Zero-config starting point</td><td><code>cargo-generate</code> template — same UX, better tooling</td></tr>
<tr><td><code>mod.config</code> (engine version pin)</td><td>Reproducible builds</td><td><code>mod.yaml</code> manifest with typed schema + semver</td></tr>
<tr><td><code>fetch-engine.sh</code> (auto-download engine)</td><td>Modders never touch engine source</td><td>Engine ships as a binary crate, not compiled from source</td></tr>
<tr><td><code>Makefile</code> / <code>make.cmd</code></td><td>Cross-platform build</td><td><code>ic</code> CLI tool — Rust binary, works everywhere</td></tr>
<tr><td><code>packaging/</code> (Win/Mac/Linux installers)</td><td>Full distribution pipeline</td><td>Workshop publish + <code>cargo-dist</code> for standalone</td></tr>
<tr><td><code>utility.sh --check-yaml</code></td><td>Catches YAML errors</td><td><code>ic mod check</code> — validates YAML, Lua syntax, WASM integrity</td></tr>
<tr><td><code>launch-dedicated.sh</code></td><td>Dedicated server for mods</td><td><code>ic mod server</code> — first-class CLI command</td></tr>
<tr><td><code>mod.yaml</code> manifest</td><td>Single entry point for mod composition</td><td>Real YAML manifest with typed <code>serde</code> deserialization</td></tr>
<tr><td>Standardized directory layout</td><td>Convention-based — chrome/, rules/, maps/</td><td>Adapted for our three-tier model</td></tr>
<tr><td><code>.vscode/</code> included</td><td>IDE support out of the box</td><td>Full VS Code extension with YAML schema + Lua LSP</td></tr>
<tr><td>C# DLL for custom traits</td><td><strong>Pain point:</strong> requires .NET toolchain, IDE, compilation</td><td>Our YAML/Lua/WASM tiers eliminate this entirely</td></tr>
<tr><td>GPL license on mod code</td><td><strong>Pain point:</strong> all mod code must be GPL-compatible</td><td>WASM sandbox + permissive engine license = modder’s choice</td></tr>
<tr><td>MiniYAML format</td><td><strong>Pain point:</strong> no tooling, no validation</td><td>Real YAML with JSON Schema, serde, linting</td></tr>
<tr><td>No workshop/distribution</td><td><strong>Pain point:</strong> manual file sharing, forum posts</td><td>Built-in workshop with <code>ic mod publish</code></td></tr>
<tr><td>No hot-reload</td><td><strong>Pain point:</strong> recompile engine+mod for every change</td><td>Lua + YAML hot-reload during development</td></tr>
</tbody>
</table>
</div>
<h3 id="the-ic-cli-tool"><a class="header" href="#the-ic-cli-tool">The <code>ic</code> CLI Tool</a></h3>
<p>A single Rust binary that replaces OpenRA’s grab-bag of shell scripts:</p>
<pre><code>ic mod init [template]     # scaffold a new mod from a template
ic mod check               # validate YAML rules, Lua syntax, WASM module integrity
ic mod test                # run mod in headless test harness (smoke test)
ic mod run                 # launch game with this mod loaded
ic mod server              # launch dedicated server for this mod
ic mod package             # build distributable packages (workshop or standalone)
ic mod publish             # publish to workshop
ic mod update-engine       # update engine version in mod.yaml
ic mod lint                # style/convention checks + llm: metadata completeness
ic mod watch               # hot-reload mode: watches files, reloads YAML/Lua on change
ic git setup               # install repo-local .gitattributes and IC diff/merge helper hints (Git-first workflow)
ic content diff &lt;file&gt;     # semantic diff for IC editor-authored content (human review / CI summaries)
ic content merge           # semantic merge helper for Git merge-driver integration (Phase 6b)
ic mod perf-test           # headless playtest profiling summary for CI/perf budgets (Phase 6b)
ic auth token create       # create scoped API token for CI/CD (publish, promote, admin)
ic auth token revoke       # revoke a leaked or expired token
</code></pre>
<p><strong>Why a CLI, not just scripts:</strong></p>
<ul>
<li>Single binary — no Python, .NET, or shell dependencies</li>
<li>Cross-platform (Windows, macOS, Linux) from one codebase</li>
<li>Rich error messages with fix suggestions</li>
<li>Integrates with the workshop API</li>
<li>Designed for CI/CD — all commands work headless (no interactive prompts)</li>
</ul>
<p><strong>Command/reference documentation requirement (D020 + D037 knowledge base):</strong></p>
<ul>
<li>The <code>ic</code> CLI command tree is a canonical source for a generated <strong>CLI reference</strong> (commands, subcommands, flags, examples, environment variables).</li>
<li>This reference should be published into the shared authoring knowledge base (D037) and bundled into the SDK’s embedded docs snapshot (D038).</li>
<li>Help output (<code>--help</code>) remains the fast local surface; the manual provides fuller examples, workflows, and cross-links (e.g., <code>ic mod check</code> ↔ SDK <code>Validate</code>, <code>ic mod migrate</code> ↔ Migration Workbench).</li>
<li>For script commands/APIs (Lua/WASM host functions), the modding docs and generated API reference must follow the same metadata model (<code>summary</code>, params, return values, examples, deprecations) so creators can reliably discover what is possible.</li>
</ul>
<p><strong>Git-first workflow support (no custom VCS):</strong></p>
<ul>
<li>Git remains the only version-control system (history/branches/remotes/merges)</li>
<li><code>ic git setup</code> configures repo-local integration helpers only (no global Git config mutation)</li>
<li><code>ic content diff</code> / <code>ic content merge</code> improve review and mergeability for editor-authored IC files without changing the canonical “files in Git” workflow</li>
</ul>
<p><strong>SDK “Validate” maps to CLI-grade checks, not a separate implementation:</strong></p>
<ul>
<li><strong>Quick Validate</strong> wraps fast subsets of <code>ic mod check</code> + content graph/reference checks</li>
<li><strong>Publish Validate</strong> layers in <code>ic mod audit</code>, export verification (<code>ic export --dry-run</code> / <code>ic export --verify</code>), and optional smoke tests (<code>ic mod test</code>)</li>
<li>The SDK is a UX layer over the same validation core used in CI/CD</li>
</ul>
<p><strong>Local content overlay / dev-profile workflow (fast iteration, real game path):</strong></p>
<ul>
<li>The CLI should support a <strong>local development overlay</strong> mode so creators can run local content through the <strong>real game flow</strong> (menus, loading, runtime systems) without packaging/publishing first.</li>
<li>This is a workflow/DX feature, not a second runtime: the game still runs <code>ic-game</code>; the difference is content resolution priority and clear “local dev” labeling.</li>
<li>Typical loop:
<ul>
<li>edit YAML/Lua/assets locally</li>
<li>run <code>ic mod run</code> (or SDK “Play in Game”) with a <strong>local dev profile</strong></li>
<li>optional <code>ic mod watch</code> hot-reloads YAML/Lua where supported</li>
<li>validate/publish only when ready</li>
</ul>
</li>
<li><strong>No packaging required for local iteration</strong> (packaging remains for Workshop/CI/distribution).</li>
<li>The local dev overlay must be <strong>explicitly visible</strong> in the UI/logs (“Local Content Overlay Active”) to avoid confusion with installed Workshop versions.</li>
<li>Local overlay precedence applies only to the active development profile/session and must not silently mutate installed packages or profile fingerprints used for multiplayer compatibility.</li>
<li>This workflow is the IC-native equivalent of the “test local content through the normal game UX” pattern seen in mature RTS mod ecosystems (adapted to IC’s D020/D069/D062 model, not copied verbatim).</li>
</ul>
<h3 id="player-first-installation-wizard-reuse-d069-shared-components"><a class="header" href="#player-first-installation-wizard-reuse-d069-shared-components">Player-First Installation Wizard Reuse (D069 Shared Components)</a></h3>
<p>The <strong>D069 installation / first-run setup wizard</strong> is designed player-first, but the SDK should reuse its shared setup components rather than inventing a parallel installer UX.</p>
<p><strong>What the SDK reuses:</strong></p>
<ul>
<li>install/setup mode framing (<code>Quick</code> / <code>Advanced</code> / <code>Maintenance</code>) where it fits creator workflows</li>
<li>data directory selection/health checks and repair/reclaim patterns</li>
<li>content source detection UI (useful for asset imports/reference game files)</li>
<li>transfer/progress/verify/error presentation patterns</li>
<li>maintenance entry points (<code>Modify Installation</code>, <code>Repair &amp; Verify</code>, re-scan sources)</li>
</ul>
<p><strong>SDK-specific additions (creator-focused):</strong></p>
<ul>
<li>Git availability check and guidance (informational, not a hard gate)</li>
<li>optional creator components/toolchains/templates/sample projects</li>
<li>optional export helper dependencies (downloaded on demand)</li>
<li>no forced installation of heavy creator packs on first launch</li>
</ul>
<p><strong>Boundary remains unchanged:</strong> <code>ic-editor</code> is still a separate application/binary (D020/D040). D069 contributes shared setup UX components and semantics, not a merged player+SDK binary or a single monolithic installer.</p>
<h3 id="continuous-deployment-for-workshop-authors"><a class="header" href="#continuous-deployment-for-workshop-authors">Continuous Deployment for Workshop Authors</a></h3>
<p>The <code>ic</code> CLI is designed to run unattended in CI pipelines. Every command that touches the Workshop API accepts a <code>--token</code> flag (or reads <code>IC_WORKSHOP_TOKEN</code> from the environment) for headless authentication. No interactive login required.</p>
<p><strong>API tokens:</strong></p>
<pre><code>ic auth token create --name "github-actions" --scope publish,promote --expires 90d
</code></pre>
<p>Tokens are scoped — a token can be limited to <code>publish</code> (upload only), <code>promote</code> (change channels), or <code>admin</code> (full access). Tokens expire. Leaked tokens can be revoked instantly via <code>ic auth token revoke</code> or the Workshop web UI.</p>
<p><strong>Example: GitHub Actions workflow</strong></p>
<pre><code class="language-yaml"># .github/workflows/publish.yml
name: Publish to Workshop
on:
  push:
    tags: ["v*"]        # trigger on version tags

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install IC CLI
        run: curl -sSf https://install.ironcurtain.gg | sh

      - name: Validate mod
        run: ic mod check

      - name: Run smoke tests
        run: ic mod test --headless

      - name: Publish to beta channel
        run: ic mod publish --channel beta
        env:
          IC_WORKSHOP_TOKEN: ${{ secrets.IC_WORKSHOP_TOKEN }}

      # Optional: auto-promote to release after beta soak period
      - name: Promote to release
        if: github.ref_type == 'tag' &amp;&amp; !contains(github.ref_name, '-beta')
        run: ic mod promote ${{ github.ref_name }} release
        env:
          IC_WORKSHOP_TOKEN: ${{ secrets.IC_WORKSHOP_TOKEN }}
</code></pre>
<p><strong>What this enables:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Workflow</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Tag-triggered publish</strong></td><td>Push a <code>v1.2.0</code> tag → CI validates, tests headless, publishes to Workshop automatically</td></tr>
<tr><td><strong>Beta channel CI</strong></td><td>Every merge to <code>main</code> publishes to <code>beta</code> channel; explicit tag promotes to <code>release</code></td></tr>
<tr><td><strong>Multi-resource monorepo</strong></td><td>A single repo with multiple resource packs, each published independently via matrix builds</td></tr>
<tr><td><strong>Automated quality gates</strong></td><td><code>ic mod check</code> + <code>ic mod test</code> + <code>ic mod audit</code> run before every publish — catch broken YAML, missing licenses, incompatible deps</td></tr>
<tr><td><strong>Scheduled rebuilds</strong></td><td>Cron-triggered CI re-publishes against latest engine version to catch compatibility regressions early</td></tr>
</tbody>
</table>
</div>
<p><strong>GitLab CI, Gitea Actions, and any other CI system</strong> work identically — the <code>ic</code> CLI is a single static binary with no runtime dependencies. Download it, set <code>IC_WORKSHOP_TOKEN</code>, run <code>ic mod publish</code>.</p>
<p><strong>Self-hosted Workshop servers</strong> accept the same tokens and API — authors publishing to a community Workshop server use the same CI workflow, just pointed at a different <code>--server</code> URL:</p>
<pre><code>ic mod publish --server https://mods.myclan.com/workshop --channel release
</code></pre>
<h3 id="mod-manifest-modyaml"><a class="header" href="#mod-manifest-modyaml">Mod Manifest (<code>mod.yaml</code>)</a></h3>
<p>Every mod has a <code>mod.yaml</code> at its root — the single source of truth for mod identity and composition. Inspired by OpenRA’s <code>mod.yaml</code> but using real YAML with typed deserialization:</p>
<pre><code class="language-yaml"># mod.yaml
mod:
  id: my-total-conversion
  title: "Red Apocalypse"
  version: "1.2.0"
  authors: ["ModderName"]
  description: "A total conversion set in an alternate timeline"
  website: "https://example.com/red-apocalypse"
  license: "CC-BY-SA-4.0"            # modder's choice — no GPL requirement

engine:
  version: "^0.3.0"                  # semver — compatible with 0.3.x
  game_module: "ra1"                 # which GameModule this mod targets

assets:
  rules: ["rules/**/*.yaml"]
  maps: ["maps/"]
  missions: ["missions/"]
  scripts: ["scripts/**/*.lua"]
  wasm_modules: ["wasm/*.wasm"]
  media: ["media/"]
  chrome: ["chrome/**/*.yaml"]
  sequences: ["sequences/**/*.yaml"]

dependencies:                        # other mods/workshop items required
  - id: "community-hd-sprites"
    version: "^2.0"
    source: workshop

balance_preset: classic              # default balance preset for this mod

llm:
  summary: "Alternate-timeline total conversion with new factions and units"
  gameplay_tags: [total_conversion, alternate_history, new_factions]
</code></pre>
<h3 id="standardized-mod-directory-layout"><a class="header" href="#standardized-mod-directory-layout">Standardized Mod Directory Layout</a></h3>
<pre><code>my-mod/
├── mod.yaml                  # manifest (required)
├── rules/                    # Tier 1: YAML data
│   ├── units/
│   │   ├── infantry.yaml
│   │   └── vehicles.yaml
│   ├── structures/
│   ├── weapons/
│   ├── terrain/
│   └── presets/              # balance preset overrides
├── maps/                     # map files (.oramap or native)
├── missions/                 # campaign missions
│   ├── allied-01.yaml
│   └── allied-01.lua
├── campaigns/                # campaign definitions (D021)
│   └── tutorial/
│       └── campaign.yaml
├── hints/                    # contextual hint definitions (D065)
│   └── mod-hints.yaml
├── tips/                     # post-game tip definitions (D065)
│   └── mod-tips.yaml
├── scripts/                  # Tier 2: Lua scripts
│   ├── abilities/
│   └── triggers/
├── wasm/                     # Tier 3: WASM modules
│   └── custom_mechanics.wasm
├── media/                    # videos, cutscenes
├── chrome/                   # UI layout definitions
├── sequences/                # sprite sequence definitions
├── cursors/                  # custom cursor definitions
├── audio/                    # music, SFX, voice lines
├── templates/                # Tera mission/scene templates
└── README.md                 # human-readable mod description
</code></pre>
<p><strong>Contextual hints (<code>hints/</code>):</strong> Modders define YAML-driven gameplay hints that appear at point-of-need during any game mode. Hints are merged with the base game’s hints at load time. The full schema — trigger types, suppression rules, experience profile targeting, and SQLite tracking — is documented in <code>decisions/09g/D065-tutorial.md</code> Layer 2.</p>
<p><strong>Post-game tips (<code>tips/</code>):</strong> YAML-driven rule-based tips shown on the post-game stats screen, matching gameplay event patterns. See <code>decisions/09g/D065-tutorial.md</code> Layer 5.</p>
<h3 id="mod-templates-via-cargo-generate"><a class="header" href="#mod-templates-via-cargo-generate">Mod Templates (via <code>cargo-generate</code>)</a></h3>
<p><code>ic mod init</code> uses <code>cargo-generate</code>-style templates. Built-in templates:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Template</th><th>Creates</th><th>For</th></tr>
</thead>
<tbody>
<tr><td><code>data-mod</code></td><td>mod.yaml + rules/ + empty maps/</td><td>Simple balance/cosmetic mods (Tier 1 only)</td></tr>
<tr><td><code>scripted-mod</code></td><td>Above + scripts/ + missions/</td><td>Mission packs, custom game modes (Tier 1+2)</td></tr>
<tr><td><code>total-conversion</code></td><td>Full directory layout including wasm/</td><td>Total conversions (all tiers)</td></tr>
<tr><td><code>map-pack</code></td><td>mod.yaml + maps/</td><td>Map collections</td></tr>
<tr><td><code>asset-pack</code></td><td>mod.yaml + media/ + sequences/</td><td>Sprite/sound/video packs</td></tr>
</tbody>
</table>
</div>
<p>Community can publish custom templates to the workshop.</p>
<h3 id="development-workflow"><a class="header" href="#development-workflow">Development Workflow</a></h3>
<pre><code>1. ic mod init scripted-mod          # scaffold
2. Edit YAML rules, write Lua scripts
3. ic mod watch                      # hot-reload mode
4. ic mod check                      # validate everything
5. ic mod test                       # headless smoke test
6. ic mod publish                    # push to workshop
</code></pre>
<p>Compare to OpenRA’s workflow: install .NET SDK → fork SDK repo → edit MiniYAML → write C# DLL → <code>make</code> → <code>launch-game.sh</code> → manually package → upload to forum.</p>
<h2 id="llm-readable-resource-metadata"><a class="header" href="#llm-readable-resource-metadata">LLM-Readable Resource Metadata</a></h2>
<p>Every game resource — units, weapons, structures, maps, mods, templates — carries structured metadata designed for consumption by LLMs and AI systems. This is not documentation for humans (that’s <code>display.name</code> and README files). This is <strong>machine-readable semantic context</strong> that enables AI to reason about game content.</p>
<h3 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h3>
<p>Traditional game data is structured for the engine: cost, health, speed, damage. An LLM reading <code>cost: 100, health: 50, speed: 56, weapon: m1_carbine</code> can parse the numbers but cannot infer <em>purpose</em>. It doesn’t know that rifle infantry is a cheap scout, that it’s useless against tanks, or that it should be built in groups of 5+.</p>
<p>The <code>llm:</code> metadata block bridges this gap. It gives LLMs the strategic and tactical context that experienced players carry in their heads.</p>
<h3 id="what-consumes-it"><a class="header" href="#what-consumes-it">What Consumes It</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Consumer</th><th>How It Uses <code>llm:</code> Metadata</th></tr>
</thead>
<tbody>
<tr><td><strong><code>ic-llm</code> (mission generation)</strong></td><td>Selects appropriate units for scenarios. “A hard mission” → picks units with <code>role: siege</code> and high counters. “A stealth mission” → picks units with <code>role: scout, infiltrator</code>.</td></tr>
<tr><td><strong><code>ic-ai</code> (skirmish AI)</strong></td><td>Reads <code>counters</code>/<code>countered_by</code> for build decisions. Knows to build anti-air when enemy has <code>role: air</code>. Reads <code>tactical_notes</code> for positioning hints.</td></tr>
<tr><td><strong>Workshop search</strong></td><td>Semantic search: “a map for beginners” matches <code>difficulty: beginner-friendly</code>. “Something for a tank rush” matches <code>gameplay_tags: ["open_terrain", "abundant_resources"]</code>.</td></tr>
<tr><td><strong>Future in-game AI advisor</strong></td><td>“What should I build?” → reads enemy composition’s <code>countered_by</code>, suggests units with matching <code>role</code>.</td></tr>
<tr><td><strong>Mod compatibility analysis</strong></td><td>Detects when a mod changes a unit’s <code>role</code> or <code>counters</code> in ways that affect balance.</td></tr>
</tbody>
</table>
</div>
<h3 id="metadata-format-on-game-resources"><a class="header" href="#metadata-format-on-game-resources">Metadata Format (on game resources)</a></h3>
<p>The <code>llm:</code> block is optional on every resource type. It follows a consistent schema:</p>
<pre><code class="language-yaml"># On units / weapons / structures:
llm:
  summary: "One-line natural language description"
  role: [semantic, tags, for, classification]
  strengths: [what, this, excels, at]
  weaknesses: [what, this, is, bad, at]
  tactical_notes: "Free-text tactical guidance for LLM reasoning"
  counters: [unit_types, this, beats]
  countered_by: [unit_types, that, beat, this]

# On maps:
llm:
  summary: "4-player island map with contested center bridge"
  gameplay_tags: [islands, naval, chokepoint, 4player]
  tactical_notes: "Control the center bridge for resource access. Naval early game is critical."

# On weapons:
llm:
  summary: "Long-range anti-structure artillery"
  role: [siege, anti_structure]
  strengths: [long_range, high_structure_damage, area_of_effect]
  weaknesses: [slow_fire_rate, inaccurate_vs_moving, minimum_range]
</code></pre>
<h3 id="metadata-format-on-workshop-resources"><a class="header" href="#metadata-format-on-workshop-resources">Metadata Format (on workshop resources)</a></h3>
<p>Workshop resources carry <code>LlmResourceMeta</code> in their package manifest:</p>
<pre><code class="language-yaml"># workshop manifest for a mission template
llm_meta:
  summary: "Defend a bridge against 5 waves of Soviet armor"
  purpose: "Good for practicing defensive tactics with limited resources"
  gameplay_tags: [defense, bridge, waves, armor, intermediate]
  difficulty: "intermediate"
  composition_hints: "Pairs well with the 'reinforcements' scene template for a harder variant"
</code></pre>
<p>This metadata is indexed by the workshop server for semantic search. When an LLM needs to find “a scene template for an ambush in a forest,” it searches <code>gameplay_tags</code> and <code>summary</code>, not filenames.</p>
<h3 id="design-rules"><a class="header" href="#design-rules">Design Rules</a></h3>
<ol>
<li><strong><code>llm:</code> is always optional.</strong> Resources work without it. Legacy content and OpenRA imports won’t have it initially — it can be added incrementally, by humans or by LLMs.</li>
<li><strong>Human-written is preferred, LLM-generated is acceptable.</strong> When a modder publishes to the workshop without <code>llm_meta</code>, the system can offer to auto-generate it from the resource’s data (unit stats, map layout, etc.). The modder reviews and approves.</li>
<li><strong>Tags use a controlled vocabulary.</strong> <code>role</code>, <code>strengths</code>, <code>weaknesses</code>, <code>counters</code>, and <code>gameplay_tags</code> draw from a published tag dictionary (extensible by mods). This prevents tag drift where the same concept has five spellings.</li>
<li><strong><code>tactical_notes</code> is free-text.</strong> This is the field where nuance lives. “Build 5+ to be cost-effective” or “Position behind walls for maximum effectiveness” — advice that can’t be captured in tags.</li>
<li><strong>Metadata is part of the YAML spec, not a sidecar.</strong> It lives in the same file as the resource definition. No separate metadata files to lose or desync.</li>
<li><strong><code>ai_usage</code> is required on publish, defaults to <code>metadata_only</code>.</strong> Authors must make an explicit choice about AI access. <code>ic mod publish</code> prompts for ai_usage on first publish and remembers the choice as a user-level default. Authors can change ai_usage on any existing resource at any time via <code>ic mod update --ai-usage allow|metadata_only|deny</code>.</li>
</ol>
<h3 id="author-consent-for-llm-usage-ai_usage"><a class="header" href="#author-consent-for-llm-usage-ai_usage">Author Consent for LLM Usage (ai_usage)</a></h3>
<p>The Workshop’s AI consent model is deliberately <strong>separate from the license system</strong>. A resource’s SPDX license governs what humans may legally do (redistribute, modify, sell). The <code>ai_usage</code> field governs what <strong>automated AI agents</strong> may do — and these are genuinely different questions.</p>
<p><strong>Why this separation is necessary:</strong></p>
<p>A composer publishes a Soviet march track under CC-BY-4.0. They’re fine with other modders using it in their mods (with credit). But they don’t want an LLM to automatically select their track when generating missions — they’d prefer a human to choose it deliberately. Under a license-only model, CC-BY permits both uses identically. The <code>ai_usage</code> field lets the author distinguish.</p>
<p>Conversely, a modder publishes cutscene briefings with all rights reserved (no redistribution). But they <em>do</em> want LLMs to know these cutscenes exist and recommend them — because more visibility means more downloads. <code>ai_usage: allow</code> with a restrictive license means the LLM can auto-add it as a dependency reference (the mission says “requires bob/soviet-briefings@1.0”), but the end user’s <code>ic mod install</code> still respects the license when downloading.</p>
<p><strong>The three tiers:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th><code>ai_usage</code> Value</th><th>LLM Can Search</th><th>LLM Can Read Metadata</th><th>LLM Can Auto-Add as Dependency</th><th>Human Approval Required</th></tr>
</thead>
<tbody>
<tr><td><code>allow</code></td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td><code>metadata_only</code> (default)</td><td>Yes</td><td>Yes</td><td>No — LLM recommends only</td><td>Yes — human confirms</td></tr>
<tr><td><code>deny</code></td><td>No</td><td>No</td><td>No</td><td>N/A — invisible to LLMs</td></tr>
</tbody>
</table>
</div>
<p><strong>YAML manifest example:</strong></p>
<pre><code class="language-yaml"># A cutscene pack published with full LLM access
mod:
  id: alice/soviet-briefing-pack
  title: "Soviet Campaign Briefings"
  version: "1.0.0"
  license: "CC-BY-4.0"
  ai_usage: allow                      # LLMs can auto-pull this

  llm_meta:
    summary: "5 live-action Soviet briefing videos with English subtitles"
    purpose: "Campaign briefings for Soviet missions — general briefs troops before battle"
    gameplay_tags: [soviet, briefing, cutscene, campaign, live_action]
    difficulty: null
    composition_hints: "Use before Soviet campaign missions. Pairs with soviet-march-music for atmosphere."
    content_description:
      contents:
        - "briefing_01.webm — General introduces the war (2:30)"
        - "briefing_02.webm — Orders to capture Allied base (1:45)"
        - "briefing_03.webm — Retreat and regroup speech (2:10)"
        - "briefing_04.webm — Final assault planning (3:00)"
        - "briefing_05.webm — Victory celebration (1:20)"
      themes: [military, soviet_propaganda, dramatic, patriotic]
      style: "Retro FMV with live actors, 4:3 aspect ratio, film grain"
      duration: "10:45 total"
      resolution: "640x480"
    related_resources:
      - "alice/soviet-march-music"
      - "community/ra1-soviet-voice-lines"
</code></pre>
<pre><code class="language-yaml"># A music track with metadata-only access (default)
mod:
  id: bob/ambient-war-music
  title: "Ambient Battlefield Soundscapes"
  version: "2.0.0"
  license: "CC-BY-NC-4.0"
  ai_usage: metadata_only              # LLMs can recommend but not auto-add

  llm_meta:
    summary: "6 ambient war soundscape loops, 3-5 minutes each"
    purpose: "Background audio for tense defensive scenarios"
    gameplay_tags: [ambient, tension, defense, loop, atmospheric]
    composition_hints: "Works best layered under game audio, not as primary music track"
</code></pre>
<p><strong>Workshop UI integration:</strong></p>
<ul>
<li>The Workshop browser shows an “AI Discoverable” badge on resources with <code>ai_usage: allow</code></li>
<li>Resource settings page includes a clear toggle: “Allow AI agents to use this resource automatically”</li>
<li>Creator profile shows aggregate AI stats: “42 of your resources are AI-discoverable” with a bulk-edit option</li>
<li><code>ic mod lint</code> warns if <code>ai_usage</code> is set to <code>allow</code> but <code>llm_meta</code> is empty (the resource is auto-pullable but provides no context for LLMs to evaluate it)</li>
</ul>
<h3 id="workshop-organization-for-llm-discovery"><a class="header" href="#workshop-organization-for-llm-discovery">Workshop Organization for LLM Discovery</a></h3>
<p>Beyond individual resource metadata, the Workshop itself is organized to support LLM navigation and composition:</p>
<p><strong>Semantic resource relationships:</strong></p>
<p>Resources can declare relationships to other resources beyond simple dependencies:</p>
<pre><code class="language-yaml"># In mod.yaml
relationships:
  variant_of: "community/standard-soviet-sprites"  # this is an HD variant
  works_with:                                         # bidirectional composition hints
    - "alice/soviet-march-music"
    - "community/snow-terrain-textures"
  supersedes: "bob/old-soviet-sprites@1.x"            # migration path from older resource
</code></pre>
<p>These relationships are indexed by the Workshop server and exposed to LLM queries. An LLM searching for “Soviet sprites” finds the standard version and is told “alice/hd-soviet-sprites is an HD variant.” An LLM building a winter mission finds snow terrain and is told “works well with alice/soviet-march-music.” This is structured composition knowledge that tags alone can’t express.</p>
<p><strong>Category hierarchies for LLM navigation:</strong></p>
<p>Resource categories (Music, Sprites, Maps, etc.) have sub-categories that LLMs can traverse:</p>
<pre><code>Music/
├── Soundtrack/          # full game soundtracks
├── Ambient/             # background loops
├── Faction/             # faction-themed tracks
│   ├── Soviet/
│   ├── Allied/
│   └── Custom/
└── Event/               # victory, defeat, mission start
Cutscenes/
├── Briefing/            # pre-mission briefings  
├── InGame/              # triggered during gameplay
└── Cinematic/           # standalone story videos
</code></pre>
<p>LLMs query hierarchically: “find a Soviet faction music track” → navigate Music → Faction → Soviet, rather than relying solely on tag matching. The hierarchy provides structure; tags provide precision within that structure.</p>
<p><strong>Curated LLM composition sets (Phase 7+):</strong></p>
<p>Workshop curators (human or LLM-assisted) can publish <strong>composition sets</strong> — pre-vetted bundles of resources that work together for a specific creative goal:</p>
<pre><code class="language-yaml"># A composition set (published as a Workshop resource with category: CompositionSet)
mod:
  id: curators/soviet-campaign-starter-kit
  category: CompositionSet
  ai_usage: allow
  llm_meta:
    summary: "Pre-vetted resource bundle for creating Soviet campaign missions"
    purpose: "Starting point for LLM mission generation — all resources are ai_usage:allow and license-compatible"
    gameplay_tags: [soviet, campaign, starter_kit, curated]
    composition_hints: "Use as a base, then search for mission-specific assets"
  
composition:
  resources:
    - id: "alice/soviet-briefing-pack"
      role: "briefings"
    - id: "alice/soviet-march-music"
      role: "soundtrack"
    - id: "community/ra1-soviet-voice-lines"
      role: "unit_voices"
    - id: "community/snow-terrain-textures"
      role: "terrain"
    - id: "community/standard-soviet-sprites"
      role: "unit_sprites"
  verified_compatible: true            # curator has tested these together
  all_ai_accessible: true              # all resources in set are ai_usage: allow
</code></pre>
<p>An LLM asked to “generate a Soviet campaign mission” can start by pulling a relevant composition set, then search for additional mission-specific assets. This saves the LLM from evaluating hundreds of individual resources and avoids license/ai_usage conflicts — the curator has already verified compatibility.</p>
<h2 id="mod-api-stability--compatibility"><a class="header" href="#mod-api-stability--compatibility">Mod API Stability &amp; Compatibility</a></h2>
<p>The mod-facing API — YAML schema, Lua globals, WASM host functions — is a <strong>stability surface</strong> distinct from engine internals. Engine crates can refactor freely between releases; the mod API changes only with explicit versioning and migration support. This section documents how IC avoids the Minecraft anti-pattern (community fragmenting across incompatible versions) and follows the Factorio model (stable API, deprecation warnings, migration scripts).</p>
<p><strong>Lesson from Minecraft:</strong> Forge and Fabric have no stable API contract. Every Minecraft update breaks most mods, fragmenting the community into version silos. Popular mods take months to update. Players are forced to choose between new game content and their mod setup. This is the single biggest friction in Minecraft modding.</p>
<p><strong>Lesson from Factorio:</strong> Wube publishes a versioned mod API with explicit stability guarantees. Breaking changes are announced releases in advance, include migration scripts, and come with deprecation warnings that fire during <code>mod check</code>. Result: 5,000+ mods on the portal, most updated within days of a new game version.</p>
<p><strong>Lesson from Stardew Valley:</strong> SMAPI (Stardew Modding API) acts as an adapter layer between the game and mods. When the game updates, SMAPI absorbs the breaking changes — mods written against SMAPI’s stable surface continue to work even when Stardew’s internals change. A single community-maintained compatibility layer protects thousands of mods.</p>
<p><strong>Lesson from ArmA/OFP:</strong> Bohemia Interactive’s SQF scripting language has remained backwards-compatible across 25+ years of releases (OFP → ArmA → ArmA 2 → ArmA 3). Scripts written for Operation Flashpoint in 2001 still execute in ArmA 3 (2013+). This extraordinary stability is a primary reason the ArmA modding community survived multiple engine generations — modders invest in learning an API only when they trust it won’t be discarded. Conversely, ArmA’s lack of a formal deprecation process meant obsolete commands accumulated indefinitely. IC applies both lessons: backwards compatibility within major versions (the ArmA principle) combined with explicit deprecation cycles (the Factorio principle) so the API stays clean without breaking existing work.</p>
<h3 id="stability-tiers"><a class="header" href="#stability-tiers">Stability Tiers</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Surface</th><th>Stability Guarantee</th><th>Breaking Change Policy</th></tr>
</thead>
<tbody>
<tr><td><strong>YAML schema</strong> (unit fields, weapon fields, structure fields)</td><td>Stable within major version</td><td>Fields can be added (non-breaking). Renaming or removing a field requires a deprecation cycle: old name works for 2 minor versions with a warning, then errors.</td></tr>
<tr><td><strong>Lua API globals</strong> (D024, 16 OpenRA-compatible globals + IC extensions)</td><td>Stable within major version</td><td>New globals can be added. Existing globals never change signature. Deprecated globals emit warnings for 2 minor versions.</td></tr>
<tr><td><strong>WASM host functions</strong> (host function namespaces: <code>ic_render_*</code>, <code>ic_pathfind_*</code>, <code>ic_ai_*</code>, <code>ic_format_*</code>, etc.)</td><td>Stable within major version</td><td>New host functions can be added. Existing function signatures never change. Deprecated functions continue to work with warnings.</td></tr>
<tr><td><strong>OpenRA aliases</strong> (D023 vocabulary layer)</td><td>Permanent</td><td>Aliases are never removed — they can only accumulate. An alias that worked in IC 0.3 works in IC 5.0.</td></tr>
<tr><td><strong>Engine internals</strong> (Bevy systems, component layouts, crate APIs)</td><td>No guarantee</td><td>Can change freely between any versions. Mods never depend on these directly.</td></tr>
</tbody>
</table>
</div>
<h3 id="migration-support"><a class="header" href="#migration-support">Migration Support</a></h3>
<p>When a breaking change is unavoidable (major version bump):</p>
<ul>
<li><strong><code>ic mod migrate</code></strong> — CLI command that auto-updates mod YAML/Lua to the new schema. Handles field renames, deprecated API replacements, and schema restructuring. Inspired by <code>rustfix</code> and Factorio’s migration scripts.</li>
<li><strong>Deprecation warnings in <code>ic mod check</code></strong> — flag usage of deprecated fields, globals, or host functions before they become errors. Shows the replacement.</li>
<li><strong>Changelog with migration guide</strong> — every release that touches the mod API surface includes a “For Modders” section with before/after examples.</li>
<li><strong>SDK Migration Workbench (D038 UI wrapper)</strong> — the SDK exposes the same migration backend as a read-only preview/report flow in Phase 6a (“Upgrade Project”), then an apply mode with rollback snapshots in Phase 6b. The SDK does not fork migration logic; it shells into the same engine that powers <code>ic mod migrate</code>.</li>
</ul>
<h3 id="versioned-mod-api-independent-of-engine-version"><a class="header" href="#versioned-mod-api-independent-of-engine-version">Versioned Mod API (Independent of Engine Version)</a></h3>
<p>The mod API version is declared separately from the engine version:</p>
<pre><code class="language-yaml"># mod.yaml
engine:
  version: "^0.5.0"          # engine version (can change rapidly)
  mod_api: "^1.0"            # mod API version (changes slowly)
</code></pre>
<p>A mod targeting <code>mod_api: "^1.0"</code> works on any engine version that supports mod API 1.x. The engine can ship 0.5.0 through 0.9.0 without breaking mod API 1.0 compatibility. This decoupling means engine development velocity doesn’t fragment the mod ecosystem.</p>
<h3 id="compatibility-adapter-layer"><a class="header" href="#compatibility-adapter-layer">Compatibility Adapter Layer</a></h3>
<p>Internally, the engine maintains an adapter between the mod API surface and engine internals — structurally similar to Stardew’s SMAPI:</p>
<pre><code>  Mod code (YAML / Lua / WASM)
        │
        ▼
  ┌─────────────────────────┐
  │  Mod API Surface        │  ← versioned, stable
  │  (schema, globals, host │
  │   functions)            │
  ├─────────────────────────┤
  │  Compatibility Adapter  │  ← translates stable API → current internals
  │  (ic-script crate)      │
  ├─────────────────────────┤
  │  Engine Internals       │  ← free to change
  │  (Bevy ECS, systems)    │
  └─────────────────────────┘
</code></pre>
<p>When engine internals change, the adapter is updated — mods don’t notice. This is the same pattern that makes OpenRA’s trait aliases (D023) work: the public YAML surface is stable, the internal component routing can change.</p>
<p><strong>Phase:</strong> Mod API versioning and <code>ic mod migrate</code> in Phase 4 (alongside Lua/WASM runtime). Compatibility adapter formalized in Phase 6a (when mod ecosystem is large enough to matter). Deprecation warnings from Phase 2 onward (YAML schema stability starts early). The SDK’s Migration Workbench UI ships in Phase 6a as a preview/report wrapper and gains apply/rollback mode in Phase 6b.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="netcode/match-lifecycle.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="modding/campaigns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="netcode/match-lifecycle.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="modding/campaigns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
