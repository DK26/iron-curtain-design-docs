<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Security &amp; Threat Model - Iron Curtain — Design Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Design docs for a Rust-native Red Alert RTS engine">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-04ba01c6.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-a85074c4.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Iron Curtain — Design Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/DK26/iron-curtain-design-docs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>
                        <a href="https://github.com/DK26/iron-curtain-design-docs/edit/main/src/06-SECURITY.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <span class=fa-svg id="git-edit-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M421.7 220.3l-11.3 11.3-22.6 22.6-205 205c-6.6 6.6-14.8 11.5-23.8 14.1L30.8 511c-8.4 2.5-17.5 .2-23.7-6.1S-1.5 489.7 1 481.2L38.7 353.1c2.6-9 7.5-17.2 14.1-23.8l205-205 22.6-22.6 11.3-11.3 33.9 33.9 62.1 62.1 33.9 33.9zM96 353.9l-9.3 9.3c-.9 .9-1.6 2.1-2 3.4l-25.3 86 86-25.3c1.3-.4 2.5-1.1 3.4-2l9.3-9.3H112c-8.8 0-16-7.2-16-16V353.9zM453.3 19.3l39.4 39.4c25 25 25 65.5 0 90.5l-14.5 14.5-22.6 22.6-11.3 11.3-33.9-33.9-62.1-62.1L314.3 67.7l11.3-11.3 22.6-22.6 14.5-14.5c25-25 65.5-25 90.5 0z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="06--security--threat-model"><a class="header" href="#06--security--threat-model">06 — Security &amp; Threat Model</a></h1>
<h2 id="fundamental-constraint"><a class="header" href="#fundamental-constraint">Fundamental Constraint</a></h2>
<p>In deterministic lockstep, every client runs the full simulation. Every player has <strong>complete game state in memory</strong> at all times. This shapes every vulnerability and mitigation.</p>
<h2 id="threat-matrix-by-network-model"><a class="header" href="#threat-matrix-by-network-model">Threat Matrix by Network Model</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>Pure P2P Lockstep</th><th>Relay Server Lockstep</th><th>Authoritative Fog Server</th></tr>
</thead>
<tbody>
<tr><td>Maphack</td><td><strong>OPEN</strong></td><td><strong>OPEN</strong></td><td><strong>BLOCKED</strong> ✓</td></tr>
<tr><td>Order injection</td><td>Sim rejects</td><td>Server rejects</td><td>Server rejects</td></tr>
<tr><td>Order forgery</td><td>Ed25519 per-order sigs</td><td>Server stamps + sigs</td><td>Server stamps + sigs</td></tr>
<tr><td>Lag switch</td><td><strong>OPEN</strong></td><td><strong>BLOCKED</strong> ✓</td><td><strong>BLOCKED</strong> ✓</td></tr>
<tr><td>Eavesdropping</td><td>DTLS encrypted</td><td>TLS encrypted</td><td>TLS encrypted</td></tr>
<tr><td>Packet forgery</td><td>AEAD rejects</td><td>TLS rejects</td><td>TLS rejects</td></tr>
<tr><td>Protocol DoS</td><td>Rate limit + size caps</td><td>Relay absorbs + limits</td><td>Server absorbs + limits</td></tr>
<tr><td>State saturation</td><td><strong>OPEN</strong></td><td>Rate caps ✓</td><td>Rate caps ✓</td></tr>
<tr><td>Desync exploit</td><td>Possible</td><td>Server-only analysis</td><td>N/A</td></tr>
<tr><td>Replay tampering</td><td><strong>OPEN</strong></td><td>Signed ✓</td><td>Signed ✓</td></tr>
<tr><td>WASM mod cheating</td><td>Sandbox</td><td>Sandbox</td><td>Sandbox</td></tr>
<tr><td>Reconciler abuse</td><td>N/A</td><td>N/A</td><td>Bounded + signed ✓</td></tr>
<tr><td>Join code brute-force</td><td>Rate limit + expiry</td><td>Rate limit + expiry</td><td>Rate limit + expiry</td></tr>
<tr><td>Tracking server abuse</td><td>Rate limit + validation</td><td>Rate limit + validation</td><td>Rate limit + validation</td></tr>
<tr><td>Version mismatch</td><td>Handshake ✓</td><td>Handshake ✓</td><td>Handshake ✓</td></tr>
</tbody>
</table>
</div>
<p><strong>Recommendation:</strong> Relay server is the minimum for ranked/competitive play. Fog-authoritative server for high-stakes tournaments.</p>
<p><strong>A note on lockstep and DoS resilience:</strong> Bryant &amp; Saiedian (2021) observe that deterministic lockstep is surprisingly the <em>best</em> architecture for resisting volumetric denial-of-service attacks. Because the simulation halts and awaits input from all clients before progressing, an attacker attempting to exhaust a victim’s bandwidth unintentionally introduces lag into their own experience as well. The relay server model adds further resilience — the relay absorbs attack traffic without forwarding it to clients.</p>
<h2 id="vulnerability-1-maphack-architectural-limit"><a class="header" href="#vulnerability-1-maphack-architectural-limit">Vulnerability 1: Maphack (Architectural Limit)</a></h2>
<h3 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h3>
<p>Both clients must simulate everything (enemy movement, production, harvesting), so all game state exists in process memory. Fog of war is a rendering filter — the data is always there.</p>
<p>Every lockstep RTS has this problem: OpenRA, StarCraft, Age of Empires.</p>
<h3 id="mitigations-partial-not-solutions"><a class="header" href="#mitigations-partial-not-solutions">Mitigations (partial, not solutions)</a></h3>
<p><strong>Memory obfuscation</strong> (raises bar for casual cheats):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ObfuscatedWorld {
    inner: World,
    xor_key: u64,  // rotated every N ticks
}
<span class="boring">}</span></code></pre>
<p><strong>Partitioned memory</strong> (harder to scan):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PartitionedWorld {
    visible: World,              // Normal memory
    hidden: ObfuscatedStore,     // Encrypted, scattered, decoy entries
}
<span class="boring">}</span></code></pre>
<p><strong>Actual solution: Fog-Authoritative Server</strong>
Server runs full sim, sends each client only entities they can see. Breaks pure lockstep. Requires server compute per game.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FogAuthoritativeNetwork {
    known_entities: HashSet&lt;EntityId&gt;,
}
impl NetworkModel for FogAuthoritativeNetwork {
    fn poll_tick(&amp;mut self) -&gt; Option&lt;TickOrders&gt; {
        // Returns orders AND visibility deltas:
        // "Entity 47 entered your vision at (30, 8)"
        // "Entity 23 left your vision"
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Trade-off:</strong> Relay server (just forwards orders) = cheap VPS handles thousands of games. Authoritative sim server = real CPU per game.</p>
<p><strong>Entity prioritization (Fiedler’s priority accumulator):</strong> When the fog-authoritative server sends partial state to each client, it must decide <em>what</em> to send within the bandwidth budget. Fiedler (2015) devised a priority accumulator that tracks object priority persistently between frames — objects accrue additional priority based on staleness (time since last update). High-priority objects (units in combat, projectiles) are sent every frame; low-priority objects (distant static structures) are deferred but eventually sent. This ensures a strict bandwidth upper bound while guaranteeing no object is permanently starved. Iron Curtain’s <code>FogAuthoritativeNetwork</code> should implement this pattern: player-owned units and nearby enemies at highest priority, distant visible terrain objects at lowest, with staleness-based promotion ensuring eventual consistency.</p>
<p><strong>Traffic class segregation:</strong> In FogAuth mode, player <em>input</em> (orders) and server <em>state</em> (entity updates) have different reliability requirements. Orders are small, latency-critical, and loss-intolerant — best suited for a reliable ordered channel. State updates are larger, frequent, and can tolerate occasional loss (the next update supersedes) — suited for an unreliable channel with delta compression. Bryant &amp; Saiedian (2021) recommend this segregation. A dual-channel approach (reliable for orders, unreliable for state) optimizes both latency and bandwidth.</p>
<h2 id="vulnerability-2-order-injection--spoofing"><a class="header" href="#vulnerability-2-order-injection--spoofing">Vulnerability 2: Order Injection / Spoofing</a></h2>
<h3 id="the-problem-1"><a class="header" href="#the-problem-1">The Problem</a></h3>
<p>Malicious client sends impossible orders (build without resources, control enemy units).</p>
<h3 id="mitigation-deterministic-validation-in-sim"><a class="header" href="#mitigation-deterministic-validation-in-sim">Mitigation: Deterministic Validation in Sim</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn validate_order(&amp;self, player: PlayerId, order: &amp;PlayerOrder) -&gt; OrderValidity {
    match order {
        PlayerOrder::Build { structure, position } =&gt; {
            let house = self.player_state(player);
            if house.credits &lt; structure.cost() { return Rejected(InsufficientFunds); }
            if !house.has_prerequisite(structure) { return Rejected(MissingPrerequisite); }
            if !self.can_place_building(player, structure, position) { return Rejected(InvalidPlacement); }
            Valid
        }
        PlayerOrder::Move { unit_ids, .. } =&gt; {
            for id in unit_ids {
                if self.unit_owner(*id) != Some(player) { return Rejected(NotOwner); }
            }
            Valid
        }
        // Every order type validated
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Key:</strong> Validation is deterministic and inside the sim. All clients run the same validation → all agree on rejections → no desync. Relay server also validates before broadcasting (defense in depth).</p>
<h2 id="vulnerability-3-lag-switch-timing-manipulation"><a class="header" href="#vulnerability-3-lag-switch-timing-manipulation">Vulnerability 3: Lag Switch (Timing Manipulation)</a></h2>
<h3 id="the-problem-2"><a class="header" href="#the-problem-2">The Problem</a></h3>
<p>Player deliberately delays packets → opponent’s game stalls → attacker gets extra thinking time.</p>
<h3 id="mitigation-relay-server-with-time-authority"><a class="header" href="#mitigation-relay-server-with-time-authority">Mitigation: Relay Server with Time Authority</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl RelayServer {
    fn process_tick(&amp;mut self, tick: u64) {
        let deadline = Instant::now() + self.tick_deadline;
        for player in &amp;self.players {
            match self.receive_orders_from(player, deadline) {
                Ok(orders) =&gt; self.tick_orders.add(player, orders),
                Err(Timeout) =&gt; {
                    // Missed deadline → always Idle (never RepeatLast —
                    // repeating the last order benefits the attacker)
                    self.tick_orders.add(player, PlayerOrder::Idle);
                    self.player_strikes[player] += 1;
                    // Enough strikes → disconnect
                }
            }
        }
        // Game never stalls for honest players
        self.broadcast_tick_orders(tick);
    }
}
<span class="boring">}</span></code></pre>
<p>Server owns the clock. Miss the window → your orders are replaced with Idle. Lag switch only punishes the attacker. Repeated late deliveries accumulate strikes; enough strikes trigger disconnection. See <code>03-NETCODE.md</code> § Order Rate Control for the full three-layer rate limiting system (time-budget pool + bandwidth throttle + hard ceiling).</p>
<h2 id="vulnerability-4-desync-exploit-for-information-gathering"><a class="header" href="#vulnerability-4-desync-exploit-for-information-gathering">Vulnerability 4: Desync Exploit for Information Gathering</a></h2>
<h3 id="the-problem-3"><a class="header" href="#the-problem-3">The Problem</a></h3>
<p>Cheating client intentionally causes desync, then analyzes desync report to extract hidden state.</p>
<h3 id="mitigation-server-side-only-desync-analysis"><a class="header" href="#mitigation-server-side-only-desync-analysis">Mitigation: Server-Side Only Desync Analysis</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DesyncReport {
    pub tick: u64,
    pub player_hashes: HashMap&lt;PlayerId, u64&gt;,
    // Full state diffs are SERVER-SIDE ONLY
    // Never transmitted to clients
}
<span class="boring">}</span></code></pre>
<p>Never send full state dumps to clients. Clients only learn “desync detected at tick N.” Admins can review server-side diffs.</p>
<h2 id="vulnerability-5-wasm-mod-as-attack-vector"><a class="header" href="#vulnerability-5-wasm-mod-as-attack-vector">Vulnerability 5: WASM Mod as Attack Vector</a></h2>
<h3 id="the-problem-4"><a class="header" href="#the-problem-4">The Problem</a></h3>
<p>Malicious mod reads entity positions, sends data to external overlay, or subtly modifies local sim.</p>
<h3 id="mitigation-capability-based-api-design"><a class="header" href="#mitigation-capability-based-api-design">Mitigation: Capability-Based API Design</a></h3>
<p>The WASM host API surface IS the security boundary:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ModCapabilities {
    pub read_own_state: bool,
    pub read_visible_state: bool,
    // read_fogged_state doesn't exist as a capability — the API function doesn't exist
    pub issue_orders: bool,
    pub filesystem: FileAccess,    // Usually None
    pub network: NetworkAccess,    // Usually None
}

pub enum NetworkAccess {
    None,
    AllowList(Vec&lt;String&gt;),
    // Never unrestricted
}
<span class="boring">}</span></code></pre>
<p><strong>Key principle:</strong> Don’t expose <code>get_all_units()</code> or <code>get_enemy_state()</code>. Only expose <code>get_visible_units()</code> which checks fog. Mods literally cannot request hidden data because the function doesn’t exist.</p>
<h2 id="vulnerability-6-replay-tampering"><a class="header" href="#vulnerability-6-replay-tampering">Vulnerability 6: Replay Tampering</a></h2>
<h3 id="the-problem-5"><a class="header" href="#the-problem-5">The Problem</a></h3>
<p>Modified replay files to fake tournament results.</p>
<h3 id="mitigation-signed-hash-chain"><a class="header" href="#mitigation-signed-hash-chain">Mitigation: Signed Hash Chain</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SignedReplay {
    pub data: ReplayData,
    pub server_signature: Ed25519Signature,
    pub hash_chain: Vec&lt;(u64, u64)&gt;,  // tick, cumulative_hash
}

impl SignedReplay {
    pub fn verify(&amp;self, server_public_key: &amp;PublicKey) -&gt; bool {
        // 1. Verify server signature
        // 2. Verify hash chain integrity (tampering any tick invalidates all subsequent)
    }
}
<span class="boring">}</span></code></pre>
<h2 id="vulnerability-7-reconciler-as-attack-surface"><a class="header" href="#vulnerability-7-reconciler-as-attack-surface">Vulnerability 7: Reconciler as Attack Surface</a></h2>
<h3 id="the-problem-6"><a class="header" href="#the-problem-6">The Problem</a></h3>
<p>If the client accepts “corrections” from an external authority (cross-engine reconciler), a fake server could send malicious corrections.</p>
<h3 id="mitigation-bounded-and-authenticated-corrections"><a class="header" href="#mitigation-bounded-and-authenticated-corrections">Mitigation: Bounded and Authenticated Corrections</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_sane_correction(&amp;self, c: &amp;EntityCorrection) -&gt; bool {
    match &amp;c.field {
        CorrectionField::Position(new_pos) =&gt; {
            let current = self.sim.entity_position(c.entity);
            let max_drift = MAX_UNIT_SPEED * self.ticks_since_sync;
            current.distance_to(new_pos) &lt;= max_drift
        }
        CorrectionField::Credits(amount) =&gt; {
            *amount &gt;= 0 &amp;&amp; 
            (*amount - self.last_known_credits).abs() &lt;= MAX_CREDIT_DELTA
        }
    }
}
<span class="boring">}</span></code></pre>
<p>All corrections must be: signed by the authority, bounded to physically possible values, and rejectable if suspicious.</p>
<h2 id="vulnerability-8-join-code-brute-forcing"><a class="header" href="#vulnerability-8-join-code-brute-forcing">Vulnerability 8: Join Code Brute-Forcing</a></h2>
<h3 id="the-problem-7"><a class="header" href="#the-problem-7">The Problem</a></h3>
<p>Join codes (e.g., <code>IRON-7K3M</code>) enable NAT-friendly P2P connections via a rendezvous server. If codes are short, an attacker can brute-force codes to join games uninvited — griefing lobbies or extracting connection info.</p>
<p>A 4-character alphanumeric code has ~1.7 million combinations. At 1000 requests/second, exhausted in ~28 minutes. Shorter codes are worse.</p>
<h3 id="mitigation-length--rate-limiting--expiry"><a class="header" href="#mitigation-length--rate-limiting--expiry">Mitigation: Length + Rate Limiting + Expiry</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct JoinCode {
    pub code: String,          // 6-8 chars, alphanumeric, no ambiguous chars (0/O, 1/I/l)
    pub created_at: Instant,
    pub expires_at: Instant,   // TTL: 5 minutes (enough to share, too short to brute-force)
    pub uses_remaining: u32,   // 1 for private, N for party invites
}

impl RendezvousServer {
    fn resolve_code(&amp;mut self, code: &amp;str, requester_ip: IpAddr) -&gt; Result&lt;ConnectionInfo&gt; {
        // Rate limit: max 5 resolve attempts per IP per minute
        if self.rate_limiter.check(requester_ip).is_err() {
            return Err(RateLimited);
        }
        // Lookup and consume
        match self.codes.get(code) {
            Some(entry) if entry.expires_at &gt; Instant::now() =&gt; Ok(entry.connection_info()),
            _ =&gt; Err(InvalidCode),  // Don't distinguish "expired" from "nonexistent"
        }
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Key choices:</strong></p>
<ul>
<li>6+ characters from a 32-char alphabet (no ambiguous chars) = ~1 billion combinations</li>
<li>Rate limit resolves per IP (5/minute blocks brute-force, legitimate users never hit it)</li>
<li>Codes expire after 5 minutes (limits attack window)</li>
<li>Invalid vs expired returns the same error (no information leakage)</li>
</ul>
<h2 id="vulnerability-9-tracking-server-abuse"><a class="header" href="#vulnerability-9-tracking-server-abuse">Vulnerability 9: Tracking Server Abuse</a></h2>
<h3 id="the-problem-8"><a class="header" href="#the-problem-8">The Problem</a></h3>
<p>The tracking server is a public API. Abuse vectors:</p>
<ul>
<li><strong>Spam listings</strong> — flood with fake games, burying real ones</li>
<li><strong>Phishing redirects</strong> — listing points to a malicious IP that mimics a game server but captures client info</li>
<li><strong>DDoS</strong> — overwhelm the server to deny game discovery for everyone</li>
</ul>
<p>OpenRA’s master server has been DDoSed before. Any public game directory faces this.</p>
<h3 id="mitigation-standard-api-hardening"><a class="header" href="#mitigation-standard-api-hardening">Mitigation: Standard API Hardening</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TrackingServerConfig {
    pub max_listings_per_ip: u32,        // 3 — one IP rarely needs more
    pub heartbeat_interval: Duration,    // 30s — listing expires if missed
    pub listing_ttl: Duration,           // 2 minutes without heartbeat → removed
    pub browse_rate_limit: u32,          // 30 requests/minute per IP
    pub publish_rate_limit: u32,         // 5 requests/minute per IP
    pub require_valid_game_port: bool,   // Server verifies the listed port is reachable
}
<span class="boring">}</span></code></pre>
<p><strong>Spam prevention:</strong> Limit listings per IP. Require heartbeats (real games send them, spam bots must sustain effort). Optionally verify the listed port actually responds to a game protocol handshake.</p>
<p><strong>Phishing prevention:</strong> Client validates the game protocol handshake before showing the lobby. A non-game server at the listed IP fails handshake and is silently dropped from the browser.</p>
<p><strong>DDoS:</strong> Standard infrastructure — CDN/reverse proxy for the browse API, rate limiting, geographic distribution. The tracking server is stateless and trivially horizontally scalable (it’s just a filtered list in memory).</p>
<h2 id="vulnerability-10-client-version-mismatch"><a class="header" href="#vulnerability-10-client-version-mismatch">Vulnerability 10: Client Version Mismatch</a></h2>
<h3 id="the-problem-9"><a class="header" href="#the-problem-9">The Problem</a></h3>
<p>Players with different client versions join the same game. Even minor differences in sim code (bug fix, balance patch) cause immediate desyncs. This looks like a bug to users, destroys trust, and wastes time. Age of Empires 2 DE had years of desync issues partly caused by version mismatches.</p>
<h3 id="mitigation-version-handshake-at-connection"><a class="header" href="#mitigation-version-handshake-at-connection">Mitigation: Version Handshake at Connection</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct VersionInfo {
    pub engine_version: SemVer,        // e.g., 0.3.1
    pub sim_hash: u64,                 // hash of compiled sim logic (catches patched binaries)
    pub mod_manifest_hash: u64,        // hash of loaded mod rules (catches different mod versions)
    pub protocol_version: u32,         // wire protocol version
}

impl GameLobby {
    fn accept_player(&amp;self, remote: &amp;VersionInfo) -&gt; Result&lt;()&gt; {
        if remote.protocol_version != self.host.protocol_version {
            return Err(IncompatibleProtocol);
        }
        if remote.sim_hash != self.host.sim_hash {
            return Err(SimVersionMismatch);
        }
        if remote.mod_manifest_hash != self.host.mod_manifest_hash {
            return Err(ModMismatch);
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Key:</strong> Check version during lobby join, not after game starts. The relay server and tracking server listings both include <code>VersionInfo</code> so incompatible games are filtered from the browser entirely.</p>
<h2 id="vulnerability-11-speed-hack--clock-manipulation"><a class="header" href="#vulnerability-11-speed-hack--clock-manipulation">Vulnerability 11: Speed Hack / Clock Manipulation</a></h2>
<h3 id="the-problem-10"><a class="header" href="#the-problem-10">The Problem</a></h3>
<p>A cheating client runs the local simulation faster than real time—either by manipulating the system clock or by feeding artificial timing into the game loop. In a pure P2P lockstep model, every client agrees on a tick cadence, so a faster client could potentially submit orders slightly sooner, giving a micro-advantage in reaction time.</p>
<h3 id="mitigation-relay-server-owns-the-clock"><a class="header" href="#mitigation-relay-server-owns-the-clock">Mitigation: Relay Server Owns the Clock</a></h3>
<p>In <code>RelayLockstepNetwork</code>, the relay server is the sole time authority. It advances the game by broadcasting canonical tick boundaries. The client’s local clock is irrelevant—a client that “runs faster” just finishes processing sooner and waits for the next server tick. Orders submitted before the tick window opens are discarded.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl RelayServer {
    fn tick_loop(&amp;mut self) {
        loop {
            let tick_start = Instant::now();
            let tick_end = tick_start + self.tick_interval;

            // Collect orders only within the valid window
            let orders = self.collect_orders_until(tick_end);

            // Orders with timestamps outside the current tick window are rejected
            for order in &amp;orders {
                if order.timestamp &lt; self.current_tick_start
                    || order.timestamp &gt; tick_end
                {
                    self.flag_suspicious(order.player, "out-of-window order");
                    continue;
                }
            }

            self.broadcast_tick_orders(self.current_tick, &amp;orders);
            self.current_tick += 1;
            self.current_tick_start = tick_end;
        }
    }
}
<span class="boring">}</span></code></pre>
<p><strong>For pure P2P (no relay):</strong> Speed hacks are harder to exploit because all clients must synchronize at each tick barrier — a client that runs faster simply idles. However, a desynced clock can cause subtle timing issues. This is another reason relay server is the recommended default for competitive play.</p>
<h2 id="vulnerability-12-automation--scripting-botting"><a class="header" href="#vulnerability-12-automation--scripting-botting">Vulnerability 12: Automation / Scripting (Botting)</a></h2>
<h3 id="the-problem-11"><a class="header" href="#the-problem-11">The Problem</a></h3>
<p>External tools (macros, overlays, input injectors) automate micro-management with superhuman precision: perfect unit splitting, instant reaction to enemy attacks, pixel-perfect targeting at 10,000+ APM. This is indistinguishable from a skilled player at a protocol level — the client sends valid orders at valid times.</p>
<h3 id="mitigation-behavioral-analysis-relay-side"><a class="header" href="#mitigation-behavioral-analysis-relay-side">Mitigation: Behavioral Analysis (Relay-Side)</a></h3>
<p>The relay server observes order patterns without needing access to game state:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PlayerBehaviorProfile {
    pub orders_per_tick: RingBuffer&lt;u32&gt;,          // rolling APM
    pub reaction_times: RingBuffer&lt;Duration&gt;,       // time from event to order
    pub order_precision: f64,                       // how tightly clustered targeting is
    pub sustained_apm_peak: Duration,               // how long max APM sustained
    pub pattern_entropy: f64,                        // randomness of input timing
}

impl RelayServer {
    fn analyze_behavior(&amp;self, player: PlayerId) -&gt; SuspicionScore {
        let profile = &amp;self.profiles[player];
        let mut score = 0.0;

        // Sustained inhuman APM (&gt;600 for extended periods)
        if profile.sustained_apm_above(600, Duration::from_secs(30)) {
            score += 0.4;
        }

        // Perfectly periodic input (bots often have metronomic timing)
        if profile.pattern_entropy &lt; HUMAN_ENTROPY_FLOOR {
            score += 0.3;
        }

        // Reaction times consistently under human minimum (~150ms)
        if profile.avg_reaction_time() &lt; Duration::from_millis(100) {
            score += 0.3;
        }

        SuspicionScore(score)
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Key design choices:</strong></p>
<ul>
<li><strong>Detection, not prevention.</strong> We can’t conclusively prove automation from order patterns alone. The system flags suspicion for review, not automatic bans.</li>
<li><strong>Relay-side only.</strong> Analysis happens on the server — cheating clients can’t detect or adapt to the analysis.</li>
<li><strong>Replay-based post-hoc analysis.</strong> Tournament replays can be analyzed after the fact with more sophisticated models (timing distribution analysis, reaction-to-fog-reveal correlation).</li>
<li><strong>Community reporting.</strong> Player reports feed into suspicion scoring — a player flagged by both the system and opponents warrants review.</li>
</ul>
<p><strong>What we deliberately DON’T do:</strong></p>
<ul>
<li>No kernel-level anti-cheat (Vanguard, EAC-style). We’re an open-source game — intrusive anti-cheat contradicts our values and doesn’t work on Linux/WASM anyway.</li>
<li>No input rate limiting. Capping APM punishes legitimate high-skill players. Detection, not restriction.</li>
</ul>
<h2 id="vulnerability-13-match-result-fraud"><a class="header" href="#vulnerability-13-match-result-fraud">Vulnerability 13: Match Result Fraud</a></h2>
<h3 id="the-problem-12"><a class="header" href="#the-problem-12">The Problem</a></h3>
<p>In competitive/ranked play, match results determine ratings. A dishonest client could claim a false result, or colluding players could submit fake results to manipulate rankings.</p>
<h3 id="mitigation-relay-certified-match-results"><a class="header" href="#mitigation-relay-certified-match-results">Mitigation: Relay-Certified Match Results</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CertifiedMatchResult {
    pub match_id: MatchId,
    pub players: Vec&lt;PlayerId&gt;,
    pub result: MatchOutcome,          // winner(s), losers, draw, disconnect
    pub final_tick: u64,
    pub duration: Duration,
    pub final_state_hash: u64,         // hash of sim state at game end
    pub replay_hash: [u8; 32],         // SHA-256 of the full replay data
    pub server_signature: Ed25519Signature, // relay server signs the result
}

impl RankingService {
    fn submit_result(&amp;mut self, result: &amp;CertifiedMatchResult) -&gt; Result&lt;()&gt; {
        // Only accept results signed by a trusted relay server
        if !self.verify_relay_signature(result) {
            return Err(UntrustedSource);
        }
        // Cross-check: if any player also submitted a replay, verify hashes match
        self.update_ratings(result);
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Key:</strong> Only relay-server-signed results update rankings. Direct P2P games can be played for fun but don’t affect ranked standings.</p>
<h2 id="vulnerability-14-transport-layer-attacks-eavesdropping--packet-forgery"><a class="header" href="#vulnerability-14-transport-layer-attacks-eavesdropping--packet-forgery">Vulnerability 14: Transport Layer Attacks (Eavesdropping &amp; Packet Forgery)</a></h2>
<h3 id="the-problem-13"><a class="header" href="#the-problem-13">The Problem</a></h3>
<p>If game traffic is unencrypted or weakly encrypted, any on-path observer (same WiFi, ISP, VPN provider) can read all game data and forge packets. C&amp;C Generals used XOR with a fixed starting key <code>0xFade</code> — this is not encryption. The key is hardcoded, the increment (<code>0x00000321</code>) is constant, and a comment in the source reads “just for fun” (see <code>Transport.cpp</code> lines 42-56). Any packet could be decrypted instantly even before the GPL source release. Combined with no packet authentication (the “validation” is a simple non-cryptographic CRC), an attacker had full read/write access to all game traffic.</p>
<p>This is not a theoretical concern. Game traffic on public WiFi, tournament LANs, or shared networks is trivially interceptable.</p>
<h3 id="mitigation-dtls-13--noise-protocol"><a class="header" href="#mitigation-dtls-13--noise-protocol">Mitigation: DTLS 1.3 / Noise Protocol</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TransportSecurity {
    /// Relay mode: clients connect via TLS 1.3 to the relay server.
    /// The relay terminates TLS and re-encrypts for each recipient.
    /// Simplest model — clients authenticate to the relay, relay handles forwarding.
    RelayTls {
        server_cert: Certificate,
        client_session_token: SessionToken,
    },

    /// Direct P2P: DTLS 1.3 over UDP for encrypted datagrams.
    /// Key exchange during connection establishment (noise protocol handshake).
    DirectDtls {
        peer_public_key: Ed25519PublicKey,
        session_keys: ChaCha20Poly1305Keys,
    },
}
<span class="boring">}</span></code></pre>
<p><strong>Key design choices:</strong></p>
<ul>
<li><strong>Never roll custom crypto.</strong> Generals’ XOR is the cautionary example. Use established libraries (<code>rustls</code>, <code>snow</code> for noise protocol, <code>ring</code> for primitives).</li>
<li><strong>Relay mode makes this simple.</strong> Clients open a TLS connection to the relay — standard web-grade encryption. The relay is the trust anchor.</li>
<li><strong>Direct P2P uses DTLS.</strong> UDP-compatible TLS. The connection establishment phase (join code / direct IP) exchanges public keys. The noise protocol (<code>snow</code> crate) is an alternative with lower overhead for game traffic.</li>
<li><strong>Authenticated encryption.</strong> Every packet is both encrypted AND authenticated (ChaCha20-Poly1305 or AES-256-GCM). Tampering is detected and the packet is dropped. This eliminates the entire class of packet-modification attacks that Generals’ XOR+CRC allowed.</li>
<li><strong>No encrypted passwords on the wire.</strong> Lobby authentication uses session tokens issued during TLS handshake. Generals transmitted “encrypted” passwords using trivially reversible bit manipulation (see <code>encrypt.cpp</code> — passwords truncated to 8 characters, then XOR’d). We use SRP or OAuth2 — passwords never leave the client.</li>
</ul>
<h3 id="what-this-prevents"><a class="header" href="#what-this-prevents">What This Prevents</a></h3>
<ul>
<li>Eavesdropping on game state (reading opponent’s orders in transit)</li>
<li>Packet injection (forging orders that appear to come from another player)</li>
<li>Replay attacks (re-sending captured packets from a previous game)</li>
<li>Credential theft (capturing lobby passwords from network traffic)</li>
</ul>
<h2 id="vulnerability-15-protocol-parsing-exploitation-malformed-input"><a class="header" href="#vulnerability-15-protocol-parsing-exploitation-malformed-input">Vulnerability 15: Protocol Parsing Exploitation (Malformed Input)</a></h2>
<h3 id="the-problem-14"><a class="header" href="#the-problem-14">The Problem</a></h3>
<p>Even with memory-safe code, a malicious peer can craft protocol messages designed to exploit the parser: oversized fields that exhaust memory, deeply nested structures that blow the stack, or invalid enum variants that cause panics. The goal is denial of service — crashing or freezing the target.</p>
<p>C&amp;C Generals’ receive-side code is the canonical cautionary tale. The send-side is careful — every <code>FillBufferWith*</code> function checks <code>isRoomFor*</code> against <code>MAX_PACKET_SIZE</code>. But the receive-side parsers (<code>readGameMessage</code>, <code>readChatMessage</code>, <code>readFileMessage</code>, etc.) operate on raw <code>(UnsignedByte *data, Int &amp;i)</code> with <strong>no size parameter</strong>. They trust every length field, blindly advance the read cursor, and never check if they’ve run past the buffer end. Specific examples verified in Generals GPL source:</p>
<ul>
<li><strong><code>readFileMessage</code></strong>: reads a filename with <code>while (data[i] != 0)</code> — no length limit. A packet without a null terminator overflows a stack buffer. Then <code>dataLength</code> from the packet controls both <code>new UnsignedByte[dataLength]</code> (unbounded allocation) and <code>memcpy(buf, data + i, dataLength)</code> (out-of-bounds read).</li>
<li><strong><code>readChatMessage</code></strong>: <code>length</code> byte controls <code>memcpy(text, data + i, length * sizeof(UnsignedShort))</code>. No check that the packet actually contains that many bytes.</li>
<li><strong><code>readWrapperMessage</code></strong>: reassembles chunked commands with network-supplied <code>totalDataLength</code>. An attacker claiming billions of bytes forces unbounded allocation.</li>
<li><strong><code>ConstructNetCommandMsgFromRawData</code></strong>: dispatches to type-specific readers, but an unknown command type leaves <code>msg</code> as NULL, then dereferences it — instant crash.</li>
</ul>
<p>Rust eliminates the buffer overflows (slices enforce bounds), but not the denial-of-service vectors.</p>
<h3 id="mitigation-defense-in-depth-protocol-parsing"><a class="header" href="#mitigation-defense-in-depth-protocol-parsing">Mitigation: Defense-in-Depth Protocol Parsing</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// All protocol parsing goes through a BoundedReader that tracks remaining bytes.
/// Every read operation checks available length first. Underflow returns Err, never panics.
pub struct BoundedReader&lt;'a&gt; {
    data: &amp;'a [u8],
    pos: usize,
}

impl&lt;'a&gt; BoundedReader&lt;'a&gt; {
    pub fn read_u8(&amp;mut self) -&gt; Result&lt;u8, ProtocolError&gt; {
        if self.pos &gt;= self.data.len() { return Err(ProtocolError::Truncated); }
        let val = self.data[self.pos];
        self.pos += 1;
        Ok(val)
    }

    pub fn read_bytes(&amp;mut self, len: usize) -&gt; Result&lt;&amp;'a [u8], ProtocolError&gt; {
        if self.pos + len &gt; self.data.len() { return Err(ProtocolError::Truncated); }
        let slice = &amp;self.data[self.pos..self.pos + len];
        self.pos += len;
        Ok(slice)
    }

    pub fn remaining(&amp;self) -&gt; usize { self.data.len() - self.pos }
}

/// Hard limits on all protocol fields — reject before allocating.
/// These are the absolute ceilings. The primary rate control is the
/// time-budget pool (OrderBudget) — see `03-NETCODE.md` § Order Rate Control.
pub struct ProtocolLimits {
    pub max_order_size: usize,               // 4 KB — single order
    pub max_orders_per_tick: usize,           // 256 — per player (hard ceiling)
    pub max_chat_message_length: usize,       // 512 chars
    pub max_file_transfer_size: usize,        // 64 KB — map files
    pub max_pending_data_per_peer: usize,     // 256 KB — total buffered per connection
    pub max_reassembled_command_size: usize,  // 64 KB — chunked/wrapper commands
}

/// Command type dispatch uses exhaustive matching — unknown types return Err.
fn parse_command(reader: &amp;mut BoundedReader, cmd_type: u8) -&gt; Result&lt;NetCommand, ProtocolError&gt; {
    match cmd_type {
        CMD_FRAME =&gt; parse_frame_command(reader),
        CMD_ORDER =&gt; parse_order_command(reader),
        CMD_CHAT  =&gt; parse_chat_command(reader),
        CMD_ACK   =&gt; parse_ack_command(reader),
        CMD_FILE  =&gt; parse_file_command(reader),
        _         =&gt; Err(ProtocolError::UnknownCommandType(cmd_type)),
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Design principles (each addresses a specific Generals vulnerability):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Principle</th><th>Addresses</th><th>Implementation</th></tr>
</thead>
<tbody>
<tr><td>Length-delimited reads</td><td>All read*Message functions lacking bounds checks</td><td><code>BoundedReader</code> with remaining-bytes tracking</td></tr>
<tr><td>Hard size caps</td><td>Unbounded allocation via network-supplied lengths</td><td><code>ProtocolLimits</code> checked before any allocation</td></tr>
<tr><td>Exhaustive command dispatch</td><td>NULL dereference on unknown command type</td><td>Rust <code>match</code> with <code>_ =&gt; Err(...)</code></td></tr>
<tr><td>Per-connection memory budget</td><td>Wrapper/chunking memory exhaustion</td><td>Track per-peer buffered bytes, disconnect on exceeded</td></tr>
<tr><td>Rate limiting at transport layer</td><td>Packet flood consuming parse CPU</td><td>Max packets/second per source IP, connection cookies</td></tr>
<tr><td>Separate parse and execute</td><td>Malformed input affecting game state</td><td>Parse into validated types first, then execute. Parse failures never touch sim.</td></tr>
</tbody>
</table>
</div>
<p><strong>The core insight from Generals:</strong> Send-side code is careful (validates sizes before building packets). Receive-side code trusts everything. This asymmetry is the root cause of most vulnerabilities. Our protocol layer must apply the same rigor to <strong>parsing</strong> as to <strong>serialization</strong> — which Rust’s type system naturally encourages via <code>serde::Deserialize</code> with explicit error handling.</p>
<blockquote>
<p>For the full vulnerability catalog from Generals source code analysis, see <code>research/rts-netcode-security-vulnerabilities.md</code>.</p>
</blockquote>
<h2 id="vulnerability-16-order-source-authentication-p2p-forgery"><a class="header" href="#vulnerability-16-order-source-authentication-p2p-forgery">Vulnerability 16: Order Source Authentication (P2P Forgery)</a></h2>
<h3 id="the-problem-15"><a class="header" href="#the-problem-15">The Problem</a></h3>
<p>In relay mode, the relay server stamps each order with the authenticated sender’s player slot — forgery is prevented by the trusted relay. But in direct P2P modes (<code>LockstepNetwork</code>), orders contain a self-declared <code>playerID</code>. A malicious client can forge orders with another player’s ID, sending commands for units they don’t own.</p>
<p>Generals’ <code>ConstructNetCommandMsgFromRawData</code> reads the player ID from the ‘P’ tag in the packet data with no validation against the source address. Any peer can claim to be any player.</p>
<p>Order <em>validation</em> (D012) catches ownership violations — commanding units you don’t own is rejected deterministically. But without authentication, a malicious client can still forge valid orders <em>as</em> the victim player (e.g., ordering the victim’s units to walk into danger). Validation checks whether the <em>order</em> is legal for that player — it doesn’t check whether the <em>sender</em> is that player.</p>
<h3 id="mitigation-ed25519-per-order-signing"><a class="header" href="#mitigation-ed25519-per-order-signing">Mitigation: Ed25519 Per-Order Signing</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AuthenticatedOrder {
    pub order: TimestampedOrder,
    pub signature: Ed25519Signature,  // Signed by sender's session keypair
}

/// Each player generates an ephemeral Ed25519 keypair at game start.
/// Public keys are exchanged during lobby setup (over TLS — see Vulnerability 14).
/// The relay server also holds all public keys and validates signatures before forwarding.
pub struct SessionAuth {
    pub player_id: PlayerId,
    pub signing_key: Ed25519SigningKey,   // Private — never leaves client
    pub peer_keys: HashMap&lt;PlayerId, Ed25519VerifyingKey&gt;,  // All players' public keys
}

impl SessionAuth {
    /// Sign an outgoing order
    pub fn sign_order(&amp;self, order: &amp;TimestampedOrder) -&gt; AuthenticatedOrder {
        let bytes = order.to_canonical_bytes();
        let signature = self.signing_key.sign(&amp;bytes);
        AuthenticatedOrder { order: order.clone(), signature }
    }

    /// Verify an incoming order came from the claimed player
    pub fn verify_order(&amp;self, auth_order: &amp;AuthenticatedOrder) -&gt; Result&lt;(), AuthError&gt; {
        let expected_key = self.peer_keys.get(&amp;auth_order.order.player)
            .ok_or(AuthError::UnknownPlayer)?;
        let bytes = auth_order.order.to_canonical_bytes();
        expected_key.verify(&amp;bytes, &amp;auth_order.signature)
            .map_err(|_| AuthError::InvalidSignature)
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Key design choices:</strong></p>
<ul>
<li><strong>Ephemeral session keys.</strong> Generated fresh for each game. No long-lived keys to steal. Key exchange happens during lobby setup over the encrypted channel (Vulnerability 14).</li>
<li><strong>Defense in depth.</strong> Relay mode: relay validates signatures AND stamps orders. P2P mode: each client validates all peers’ signatures. Both: sim validates order legality (D012).</li>
<li><strong>Overhead is minimal.</strong> Ed25519 signing is ~15,000 ops/second on a single core. At peak RTS APM (~300 orders/minute = 5/second), signature overhead is negligible.</li>
<li><strong>Replays include signatures.</strong> The signed order chain in replays allows post-hoc verification that no orders were tampered with — useful for tournament dispute resolution.</li>
</ul>
<h2 id="vulnerability-17-state-saturation-order-flooding"><a class="header" href="#vulnerability-17-state-saturation-order-flooding">Vulnerability 17: State Saturation (Order Flooding)</a></h2>
<h3 id="the-problem-16"><a class="header" href="#the-problem-16">The Problem</a></h3>
<p>Bryant &amp; Saiedian (2021) introduced the term “state saturation” to describe a class of lag-based attack where a player generates disproportionate network traffic through rapid game actions — starving other players’ command messages and gaining a competitive edge. Their companion paper (<em>A State Saturation Attack against Massively Multiplayer Online Videogames</em>, ICISSP 2021) demonstrated this via animation canceling: rapidly interrupting actions generates far more state updates than normal play, consuming bandwidth that would otherwise carry opponents’ orders.</p>
<p>The companion ICISSP paper (2021) demonstrated this empirically via Elder Scrolls Online: when players exploited animation canceling (rapidly alternating offensive and defensive inputs to bypass client-side throttling), network traffic increased by <strong>+175% packets sent</strong> and <strong>+163% packets received</strong> compared to the intended baseline. A prominent community figure demonstrated a <strong>50% DPS increase</strong> (70K → 107K) through this technique — proving the competitive advantage is real and measurable.</p>
<p>In an RTS context, this could manifest as:</p>
<ul>
<li><strong>Order flooding:</strong> Spamming hundreds of move/stop/move/stop commands per tick to consume relay server processing capacity and delay other players’ orders</li>
<li><strong>Chain-reactive mod effects:</strong> A mod creates ability chains that spawn hundreds of entities or effects per tick, overwhelming the sim and network (the paper’s Risk of Rain 2 case study found “procedurally generated effects combined to produce unintended chain-reactive behavior which may ultimately overwhelm the ability for game clients to render objects or handle sending/receiving of game update messages”)</li>
<li><strong>Build order spam:</strong> Rapidly queuing and canceling production to generate maximum order traffic</li>
</ul>
<h3 id="mitigation-already-addressed-by-design"><a class="header" href="#mitigation-already-addressed-by-design">Mitigation: Already Addressed by Design</a></h3>
<p>Our architecture prevents state saturation at three independent layers — see <code>03-NETCODE.md</code> § Order Rate Control for the full design:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Layer 1: Time-budget pool (primary). Each player has an OrderBudget that
/// refills per tick and caps at a burst limit. Handles burst legitimately,
/// catches sustained abuse. Inspired by Minetest's LagPool.

/// Layer 2: Bandwidth throttle. Token bucket on raw bytes per client.
/// Catches oversized orders that pass the order-count budget.

/// Layer 3: Hard ceiling (ProtocolLimits). Absolute maximum regardless
/// of budget/bandwidth — the last resort.
pub struct ProtocolLimits {
    pub max_orders_per_tick: usize,     // 256 — no player can flood the pipeline
    pub max_order_size: usize,          // 4 KB — no single oversized order
    pub max_pending_data_per_peer: usize, // 256 KB — total buffered per connection
}

/// The relay server enforces all three layers.
impl RelayServer {
    fn process_player_orders(&amp;mut self, player: PlayerId, orders: Vec&lt;PlayerOrder&gt;) {
        // Layer 1: Consume from time-budget pool
        let budget_accepted = self.budgets[player].try_consume(orders.len() as u32);
        let orders = &amp;orders[..budget_accepted as usize];

        // Layer 3: Hard cap as absolute ceiling
        let accepted = &amp;orders[..orders.len().min(self.limits.max_orders_per_tick)];

        // Behavioral flag: sustained max-rate ordering is suspicious
        self.profiles[player].record_order_rate(accepted.len());

        self.tick_orders.add(player, accepted);
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Why this works for Iron Curtain specifically:</strong></p>
<ul>
<li><strong>Relay server (D007) is the bandwidth arbiter.</strong> Each player gets equal processing. One player’s flood cannot starve another’s inputs — the relay processes all players’ orders independently within the tick window.</li>
<li><strong>Order rate caps (ProtocolLimits)</strong> prevent any single player from exceeding 256 orders per tick. Normal RTS play peaks around 5-10 orders/tick even at professional APM levels.</li>
<li><strong>WASM mod sandbox</strong> limits entity creation and instruction count per tick, preventing chain-reactive state explosions from mod code.</li>
<li><strong>Sub-tick timestamps (D008)</strong> ensure that even within a tick, order priority is based on actual submission time — not on who flooded more orders.</li>
</ul>
<p><strong>Lesson from the ESO case study:</strong> The Elder Scrolls Online relied on client-side “soft throttling” (animations that gate input) alongside server-side “hard throttling” (cooldown timers). Players bypassed the soft throttle by using different input types to interrupt animations — the priority/interrupt system intended for reactive defense became an exploit. The lesson: <strong>client-side throttling that can be circumvented by input type-switching is ineffective.</strong> Server-side validation is the real throttle — which is exactly what our relay does. Zenimax eventually moved block validation server-side, adding an RTT penalty — the same trade-off our relay architecture accepts by design.</p>
<blockquote>
<p><strong>Academic reference:</strong> Bryant, B.D. &amp; Saiedian, H. (2021). <em>An evaluation of videogame network architecture performance and security.</em> Computer Networks, 192, 108128. DOI: <a href="https://doi.org/10.1016/j.comnet.2021.108128">10.1016/j.comnet.2021.108128</a>. Companion: Bryant, B.D. &amp; Saiedian, H. (2021). <em>A State Saturation Attack against Massively Multiplayer Online Videogames.</em> ICISSP 2021.</p>
</blockquote>
<h2 id="competitive-integrity-summary"><a class="header" href="#competitive-integrity-summary">Competitive Integrity Summary</a></h2>
<p>Iron Curtain’s anti-cheat is <strong>architectural, not bolted on.</strong> Every defense emerges from design decisions made for other reasons:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>Defense</th><th>Source</th></tr>
</thead>
<tbody>
<tr><td>Maphack</td><td>Fog-authoritative server</td><td>Network model architecture</td></tr>
<tr><td>Order injection</td><td>Deterministic validation in sim</td><td>Sim purity (invariant #1)</td></tr>
<tr><td>Order forgery (P2P)</td><td>Ed25519 per-order signing</td><td>Session auth design</td></tr>
<tr><td>Lag switch</td><td>Relay server owns the clock</td><td>Relay architecture (D007)</td></tr>
<tr><td>Speed hack</td><td>Relay tick authority</td><td>Same as above</td></tr>
<tr><td>State saturation</td><td>Time-budget pool + bandwidth throttle + hard caps</td><td>OrderBudget + ProtocolLimits + relay (D007)</td></tr>
<tr><td>Eavesdropping</td><td>DTLS / TLS transport encryption</td><td>Transport security design</td></tr>
<tr><td>Packet forgery</td><td>Authenticated encryption (AEAD)</td><td>Transport security design</td></tr>
<tr><td>Protocol DoS</td><td>BoundedReader + size caps + rate limits</td><td>Protocol hardening</td></tr>
<tr><td>Replay tampering</td><td>Ed25519 signed hash chain</td><td>Replay system design</td></tr>
<tr><td>Automation</td><td>Behavioral analysis + community reports</td><td>Relay-side observability</td></tr>
<tr><td>Result fraud</td><td>Relay-certified match results</td><td>Relay architecture</td></tr>
<tr><td>Version mismatch</td><td>Protocol handshake</td><td>Lobby system</td></tr>
<tr><td>WASM mod abuse</td><td>Capability-based sandbox</td><td>Modding architecture (D005)</td></tr>
<tr><td>Desync exploit</td><td>Server-side only analysis</td><td>Security by design</td></tr>
</tbody>
</table>
</div>
<p><strong>No kernel-level anti-cheat.</strong> Open-source, cross-platform, no ring-0 drivers. We accept that lockstep RTS will always have a maphack risk in P2P/relay modes — the fog-authoritative server is the real answer for high-stakes play.</p>
<p><strong>Performance as anti-cheat.</strong> Our tick-time targets (&lt; 10ms on 8-core desktop) mean the relay server can run games at full speed with headroom for behavioral analysis. Stuttery servers with 40ms ticks can’t afford real-time order analysis — we can.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="05-FORMATS.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="07-CROSS-ENGINE.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="05-FORMATS.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="07-CROSS-ENGINE.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
