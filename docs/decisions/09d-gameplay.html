<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Gameplay &amp; AI - Iron Curtain — Design Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Design docs for a Rust-native Red Alert RTS engine">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-1e683dcc.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-a0d63c9c.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Iron Curtain — Design Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/DK26/iron-curtain-design-docs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>
                        <a href="https://github.com/DK26/iron-curtain-design-docs/edit/main/src/decisions/09d-gameplay.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <span class=fa-svg id="git-edit-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M421.7 220.3l-11.3 11.3-22.6 22.6-205 205c-6.6 6.6-14.8 11.5-23.8 14.1L30.8 511c-8.4 2.5-17.5 .2-23.7-6.1S-1.5 489.7 1 481.2L38.7 353.1c2.6-9 7.5-17.2 14.1-23.8l205-205 22.6-22.6 11.3-11.3 33.9 33.9 62.1 62.1 33.9 33.9zM96 353.9l-9.3 9.3c-.9 .9-1.6 2.1-2 3.4l-25.3 86 86-25.3c1.3-.4 2.5-1.1 3.4-2l9.3-9.3H112c-8.8 0-16-7.2-16-16V353.9zM453.3 19.3l39.4 39.4c25 25 25 65.5 0 90.5l-14.5 14.5-22.6 22.6-11.3 11.3-33.9-33.9-62.1-62.1L314.3 67.7l11.3-11.3 22.6-22.6 14.5-14.5c25-25 65.5-25 90.5 0z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="decision-log--gameplay--ai"><a class="header" href="#decision-log--gameplay--ai">Decision Log — Gameplay &amp; AI</a></h1>
<p>Pathfinding, balance presets, QoL toggles, AI systems, render modes, and trait-abstracted subsystems.</p>
<hr>
<h2 id="d013-pathfinding--trait-abstracted-multi-layer-hybrid-first"><a class="header" href="#d013-pathfinding--trait-abstracted-multi-layer-hybrid-first">D013: Pathfinding — Trait-Abstracted, Multi-Layer Hybrid First</a></h2>
<p><strong>Decision:</strong> Pathfinding and spatial queries are abstracted behind traits (<code>Pathfinder</code>, <code>SpatialIndex</code>) in the engine core. The RA1 game module implements them with a multi-layer hybrid pathfinder and spatial hash. The engine core never calls algorithm-specific functions directly.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>OpenRA uses hierarchical A* which struggles with large unit groups and lacks local avoidance</li>
<li>A multi-layer approach (hierarchical sectors + JPS/flowfield tiles + local avoidance) handles both small and mass movement well</li>
<li>Grid-based implementations are the right choice for the isometric C&amp;C family</li>
<li>But pathfinding is a <em>game module concern</em>, not an engine-core assumption</li>
<li>Abstracting behind a trait costs near-zero now (one trait, one impl) and prevents a rewrite if a future game module needs navmesh or any other spatial model</li>
<li>Same philosophy as <code>NetworkModel</code> (build <code>LocalNetwork</code> first, but the seam exists), <code>WorldPos.z</code> (costs one <code>i32</code>, saves RA2 rewrite), and <code>InputSource</code> (build mouse/keyboard first, touch slots in later)</li>
</ul>
<p><strong>Concrete design:</strong></p>
<ul>
<li><code>Pathfinder</code> trait: <code>request_path()</code>, <code>get_path()</code>, <code>is_passable()</code>, <code>invalidate_area()</code>, <code>path_distance()</code>, <code>batch_distances_into()</code> (+ convenience <code>batch_distances()</code> wrapper for non-hot paths)</li>
<li><code>SpatialIndex</code> trait: <code>query_range_into()</code>, <code>update_position()</code>, <code>remove()</code></li>
<li>RA1 module registers <code>IcPathfinder</code> (primary) + <code>GridSpatialHash</code>; D045 adds <code>RemastersPathfinder</code> and <code>OpenRaPathfinder</code> as additional <code>Pathfinder</code> implementations for movement feel presets</li>
<li>All sim systems call the traits, never grid-specific data structures</li>
<li>See <code>02-ARCHITECTURE.md</code> § “Pathfinding &amp; Spatial Queries” for trait definitions</li>
</ul>
<p><strong>Modder-selectable and modder-provided:</strong> The <code>Pathfinder</code> trait is open — not locked to first-party implementations. Modders can:</p>
<ol>
<li><strong>Select</strong> any registered <code>Pathfinder</code> for their mod (e.g., a total conversion picks <code>IcPathfinder</code> for its smooth movement, or <code>RemastersPathfinder</code> for its retro feel)</li>
<li><strong>Provide</strong> their own <code>Pathfinder</code> implementation via a Tier 3 WASM module and distribute it through the Workshop (D030)</li>
<li><strong>Use someone else’s</strong> community-created pathfinder — just declare it as a dependency in the mod manifest</li>
</ol>
<p>This follows the same pattern as render modes (D048): the engine ships built-in implementations, mods can add more, and players/modders pick what they want. A Generals-clone mod ships a <code>LayeredGridPathfinder</code>; a tower defense mod ships a waypoint pathfinder; a naval mod ships something flow-based. The trait doesn’t care — <code>request_path()</code> returns waypoints regardless of how they were computed.</p>
<p><strong>Performance:</strong> the architectural seam is <strong>near-zero cost</strong>. Pathfinding/spatial cost is dominated by algorithm choice, cache behavior, and allocations — not dispatch overhead. Hot-path APIs use caller-owned scratch buffers (<code>*_into</code> pattern). Dispatch strategy (static vs dynamic) is chosen per-subsystem by profiling, not by dogma.</p>
<p><strong>What we build first:</strong> <code>IcPathfinder</code> and <code>GridSpatialHash</code>. The traits exist from day one. <code>RemastersPathfinder</code> and <code>OpenRaPathfinder</code> are Phase 2 deliverables (D045) — ported from their respective GPL codebases. Community pathfinders can be published to the Workshop from Phase 6a.</p>
<hr>
<hr>
<h2 id="d019-switchable-balance-presets-classic-ra-vs-openra"><a class="header" href="#d019-switchable-balance-presets-classic-ra-vs-openra">D019: Switchable Balance Presets (Classic RA vs OpenRA)</a></h2>
<p><strong>Decision:</strong> Ship multiple balance presets as first-class YAML rule sets. Default to classic Red Alert values from the EA source code. OpenRA balance available as an alternative preset. Selectable per-game in lobby.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Original Red Alert’s balance makes units feel <strong>powerful and iconic</strong> — Tanya, MiGs, Tesla Coils, V2 rockets are devastating. This is what made the game memorable.</li>
<li>OpenRA rebalances toward competitive fairness, which can dilute the personality of iconic units. Valid for tournaments, wrong as a default.</li>
<li>The community is split on this. Rather than picking a side, expose it as a choice.</li>
<li>Presets are just alternate YAML files loaded at game start — zero engine complexity. The modding system already supports this via inheritance and overrides.</li>
<li>The Remastered Collection made its own subtle balance tweaks — worth capturing as a third preset.</li>
</ul>
<p><strong>Implementation:</strong></p>
<ul>
<li><code>rules/presets/classic/</code> — unit/weapon/structure values from EA source code (default)</li>
<li><code>rules/presets/openra/</code> — values matching OpenRA’s current balance</li>
<li><code>rules/presets/remastered/</code> — values matching the Remastered Collection</li>
<li>Preset selection exposed in lobby UI and stored in game settings</li>
<li>Presets use YAML inheritance: only override fields that differ from <code>classic</code></li>
<li>Multiplayer: all players must use the same preset (enforced by lobby, validated by sim)</li>
<li>Custom presets: modders can create new presets as additional YAML directories</li>
</ul>
<p><strong>What this is NOT:</strong></p>
<ul>
<li>Not a “difficulty setting” — both presets play at normal difficulty</li>
<li>Not a mod — it’s a first-class game option, no workshop download required</li>
<li>Not just multiplayer — applies to skirmish and campaign too</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Only ship classic values (rejected — alienates OpenRA competitive community)</li>
<li>Only ship OpenRA values (rejected — loses the original game’s personality)</li>
<li>Let mods handle it (rejected — too important to bury in the modding system; should be one click in settings)</li>
</ul>
<p><strong>Phase:</strong> Phase 2 (balance values extracted during simulation implementation).</p>
<h3 id="balance-philosophy--lessons-from-the-most-balanced-and-fun-rts-games"><a class="header" href="#balance-philosophy--lessons-from-the-most-balanced-and-fun-rts-games">Balance Philosophy — Lessons from the Most Balanced and Fun RTS Games</a></h3>
<p>D019 defines the <em>mechanism</em> (switchable YAML presets). This section defines the <em>philosophy</em> — what makes faction balance good, drawn from studying the games that got it right over decades of competitive play. These principles guide the creation of the “IC Default” balance preset and inform modders creating their own.</p>
<p><strong>Source games studied:</strong> StarCraft: Brood War (25+ years competitive, 3 radically asymmetric races), StarCraft II (Blizzard’s most systematically balanced RTS), Age of Empires II (40+ civilizations remarkably balanced over 25 years), Warcraft III (4 factions with hero mechanics), Company of Heroes (asymmetric doctrines), original Red Alert, and the Red Alert Remastered Collection. Where claims are specific, they reflect publicly documented game design decisions, developer commentary, or decade-scale competitive data.</p>
<h4 id="principle-1-asymmetry-creates-identity"><a class="header" href="#principle-1-asymmetry-creates-identity">Principle 1: Asymmetry Creates Identity</a></h4>
<p>The most beloved RTS factions — SC:BW’s Zerg/Protoss/Terran, AoE2’s diverse civilizations, RA’s Allies/Soviet — are memorable because they <em>feel different to play</em>, not because they have slightly different stat numbers. Asymmetry is the source of faction identity. Homogenizing factions for balance kills the reason factions exist.</p>
<p><strong>Red Alert’s original asymmetry:</strong> Allies favor technology, range, precision, and flexibility (GPS, Cruisers, longbow helicopters, Tanya as surgical strike). Soviets favor mass, raw power, armor, and area destruction (Mammoth tanks, V2 rockets, Tesla coils, Iron Curtain). Both factions can win — but they win differently. An Allied player who tries to play like a Soviet player (massing heavy armor) will lose. The asymmetry forces different strategies and creates varied, interesting matches.</p>
<p><strong>The lesson IC applies:</strong> Balance presets may adjust unit costs, health, and damage — but they must never collapse faction asymmetry. A “balanced” Tanya is still a fragile commando who kills infantry instantly and demolishes buildings, not a generic elite unit. A “balanced” Mammoth Tank is still the most expensive, slowest, toughest unit on the field, not a slightly upgunned medium tank. If a balance change makes a unit feel generic, the change is wrong.</p>
<h4 id="principle-2-counter-triangles-not-raw-power"><a class="header" href="#principle-2-counter-triangles-not-raw-power">Principle 2: Counter Triangles, Not Raw Power</a></h4>
<p>Good balance comes from every unit having a purpose and a vulnerability — not from every unit being equally strong. SC:BW’s Zergling → Marine → Lurker → Zealot chains, AoE2’s cavalry → archers → spearmen → cavalry triangle, and RA’s own infantry → tank → rocket soldier → infantry loops create dynamic gameplay where army composition matters more than total resource investment.</p>
<p><strong>The lesson IC applies:</strong> When defining units for any balance preset, maintain clear counter relationships. Every unit must have:</p>
<ul>
<li>At least one unit type it is <strong>strong against</strong> (justifies building it)</li>
<li>At least one unit type it is <strong>weak against</strong> (prevents it from being the only answer)</li>
<li>A <strong>role</strong> that can’t be fully replaced by another unit of the same faction</li>
</ul>
<p>The <code>llm:</code> metadata block in YAML unit definitions (see <code>04-MODDING.md</code>) already enforces this: <code>counters</code>, <code>countered_by</code>, and <code>role</code> fields are required for every unit. Balance presets adjust <em>how strong</em> these relationships are, not <em>whether they exist</em>.</p>
<h4 id="principle-3-spectacle-over-spreadsheet"><a class="header" href="#principle-3-spectacle-over-spreadsheet">Principle 3: Spectacle Over Spreadsheet</a></h4>
<p>Red Alert’s original balance is “unfair” by competitive standards — Tesla Coils delete infantry, Tanya solo-kills buildings, a pack of MiGs erases a Mammoth Tank. But this is what makes the game <em>fun</em>. Units feel powerful and dramatic. SC:BW has the same quality — a full Reaver drop annihilates a mineral line, Storm kills an entire Zergling army, a Nuke ends a stalemate. These moments create stories.</p>
<p><strong>The lesson IC applies:</strong> The “Classic” preset preserves these high-damage, high-spectacle interactions — units feel as powerful as players remember. The “OpenRA” preset tones them down for competitive fairness. The “IC Default” preset aims for a middle ground: powerful enough to create memorable moments, constrained enough that counter-play is viable. Whether the Cruiser’s shells one-shot a barracks or two-shot it is a balance value; whether the Cruiser <em>feels devastating to deploy</em> is a design requirement that no preset should violate.</p>
<h4 id="principle-4-maps-are-part-of-balance"><a class="header" href="#principle-4-maps-are-part-of-balance">Principle 4: Maps Are Part of Balance</a></h4>
<p>SC:BW’s competitive scene discovered this over 25 years: faction balance is inseparable from map design. A map with wide open spaces favors ranged factions; a map with tight choke points favors splash damage; a map with multiple expansions favors economic factions. AoE2’s tournament map pool is curated as carefully as the balance patches.</p>
<p><strong>The lesson IC applies:</strong> Balance presets should be designed and tested against a representative map pool, not a single map. The competitive committee (D037) curates both the balance preset and the ranked map pool together — because changing one without considering the other produces false conclusions about faction strength. Replay data (faction win rates per map) informs both map rotation and balance adjustments.</p>
<h4 id="principle-5-balance-through-addition-not-subtraction"><a class="header" href="#principle-5-balance-through-addition-not-subtraction">Principle 5: Balance Through Addition, Not Subtraction</a></h4>
<p>AoE2’s approach to 40+ civilizations is instructive: every civilization has the same shared tech tree, with specific technologies <em>removed</em> and one unique unit <em>added</em>. The Britons lose key cavalry upgrades but get Longbowmen with exceptional range. The Goths lose stone wall technology but get cheap, fast-training infantry. Identity comes from what you’re missing and what you uniquely possess — not from having a completely different tech tree.</p>
<p><strong>The lesson IC applies for modders:</strong> When creating new factions or subfactions (RA2’s country bonuses, community mods), the recommended pattern is:</p>
<ol>
<li>Start from the base faction tech tree (Allied or Soviet)</li>
<li>Remove a small number of specific capabilities (units, upgrades, or technologies)</li>
<li>Add one or two unique capabilities that create a distinctive playstyle</li>
<li>The unique capabilities should address a gap created by the removals, but not perfectly — the faction should have a real weakness</li>
</ol>
<p>This pattern is achievable purely in YAML (Tier 1 modding) through inheritance: the subfaction definition inherits the faction base and overrides <code>prerequisites</code> to gate or remove units, then defines new units.</p>
<h4 id="principle-6-patch-sparingly-observe-patiently"><a class="header" href="#principle-6-patch-sparingly-observe-patiently">Principle 6: Patch Sparingly, Observe Patiently</a></h4>
<p>SC:BW received minimal balance patches after 1999 — and it’s the most balanced RTS ever made. The meta evolved through player innovation, not developer intervention. AoE2: Definitive Edition patches more frequently but exercises restraint — small numerical changes (±5%), never removing or redesigning units. In contrast, games that patch aggressively based on short-term win rate data (the “nerf/buff treadmill”) chase balance without ever achieving it, and players never develop deep mastery because the ground keeps shifting.</p>
<p><strong>The lesson IC applies:</strong> The “Classic” preset is conservative — values come from the EA source code and don’t change. The “OpenRA” preset tracks OpenRA’s competitive balance decisions. The “IC Default” preset follows its own balance philosophy:</p>
<ul>
<li><strong>Observe before acting.</strong> Collect ranked replay data for a full season (D055, 3 months) before making balance changes. Short-term spikes in a faction’s win rate may self-correct as players adapt.</li>
<li><strong>Adjust values, not mechanics.</strong> A balance pass changes numbers (cost, health, damage, build time, range) — never adds or removes units, never changes core mechanics. Mechanical changes are saved for major version releases.</li>
<li><strong>Absolute changes, small increments.</strong> ±5-10% per pass, never doubling or halving a value. Multiple small passes converge on balance better than dramatic swings.</li>
<li><strong>Separate pools by rating.</strong> A faction that dominates at beginner level may be fine at expert level (and vice versa). Faction win rates should be analyzed per rating bracket before making changes.</li>
</ul>
<h4 id="principle-7-fun-is-not-win-rate"><a class="header" href="#principle-7-fun-is-not-win-rate">Principle 7: Fun Is Not Win Rate</a></h4>
<p>A 50% win rate doesn’t mean a faction is fun. A faction can have a perfect statistical balance while being miserable to play — if its optimal strategy is boring, if its units don’t feel impactful, or if its matchups produce repetitive games. Conversely, a faction can have a slight statistical disadvantage and still be the community’s favorite (SC:BW Zerg for years; AoE2 Celts; RA2 Korea).</p>
<p><strong>The lesson IC applies:</strong> Balance telemetry (D031) tracks not just win rates but also:</p>
<ul>
<li><strong>Pick rates</strong> — are players choosing to play this faction? Low pick rate with high win rate suggests the faction is strong but unpleasant.</li>
<li><strong>Game length distribution</strong> — factions that consistently produce very short or very long games may indicate degenerate strategies.</li>
<li><strong>Unit production diversity</strong> — if a faction’s optimal strategy only uses 3 of its 15 units, the other 12 are effectively dead content.</li>
<li><strong>Comeback frequency</strong> — healthy balance allows comebacks; if a faction that falls behind never recovers, the matchup may need attention.</li>
</ul>
<p>These metrics feed into balance discussions (D037 competitive committee) alongside pure win rate data.</p>
<h4 id="summary-ics-balance-stance"><a class="header" href="#summary-ics-balance-stance">Summary: IC’s Balance Stance</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Preset</th><th>Philosophy</th><th>Stability</th></tr>
</thead>
<tbody>
<tr><td><strong>Classic</strong></td><td>Faithful RA values from EA source code. Spectacle over fairness. The game as Westwood made it.</td><td>Frozen — never changes.</td></tr>
<tr><td><strong>OpenRA</strong></td><td>Community-driven competitive balance. Tracks OpenRA’s active balance decisions.</td><td>Updated when OpenRA ships balance patches.</td></tr>
<tr><td><strong>Remastered</strong></td><td>Petroglyph’s subtle tweaks for the 2020 release.</td><td>Frozen — captures the Remastered Collection as shipped.</td></tr>
<tr><td><strong>IC Default</strong></td><td>Spectacle + competitive viability. Asymmetry preserved. Counter triangles enforced. Patched sparingly based on seasonal data.</td><td>Updated once per season (D055), small increments only.</td></tr>
<tr><td><strong>Custom</strong></td><td>Modder-created presets via Workshop. Community experiments, tournament rules, “what if” scenarios.</td><td>Modder-controlled.</td></tr>
</tbody>
</table>
</div>
<hr>
<h3 id="d020--mod-sdk--creative-toolchain"><a class="header" href="#d020--mod-sdk--creative-toolchain">D020 — Mod SDK &amp; Creative Toolchain</a></h3>
<p><strong>Decision:</strong> Ship a Mod SDK comprising two components: (1) the <code>ic</code> CLI tool for headless mod workflow (init, check, test, build, publish), and (2) the <strong>IC SDK application</strong> — a visual creative toolchain with the scenario editor (D038), asset studio (D040), campaign editor, and Game Master mode. The SDK is a separate application from the game — players never see it (see D040 § SDK Architecture).</p>
<p><strong>Context:</strong> The OpenRA Mod SDK is a template repository modders fork. It bundles shell scripts (<code>fetch-engine.sh</code>, <code>launch-game.sh</code>, <code>utility.sh</code>), a <code>Makefile</code>/<code>make.cmd</code> build system, and a <code>packaging/</code> directory with per-platform installer scripts. The approach works — it’s the standard way to create OpenRA mods. But it has significant friction: requires .NET SDK, custom C# DLLs for anything beyond data changes, MiniYAML with no validation tooling, GPL contamination on mod code, and no distribution system beyond manual file sharing.</p>
<p><strong>What we adapt:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concept</th><th>OpenRA SDK</th><th>Iron Curtain</th></tr>
</thead>
<tbody>
<tr><td>Starting point</td><td>Fork a template repo</td><td><code>ic mod init [template]</code> via <code>cargo-generate</code></td></tr>
<tr><td>Engine version pin</td><td><code>ENGINE_VERSION</code> in <code>mod.config</code></td><td><code>engine.version</code> in <code>mod.yaml</code> with semver</td></tr>
<tr><td>Engine management</td><td><code>fetch-engine.sh</code> downloads + compiles from source</td><td>Engine ships as binary crate, auto-resolved</td></tr>
<tr><td>Build/run</td><td><code>Makefile</code> + shell scripts (requires Python, .NET)</td><td><code>ic</code> CLI — single Rust binary, zero dependencies</td></tr>
<tr><td>Mod manifest</td><td><code>mod.yaml</code> in MiniYAML</td><td><code>mod.yaml</code> in real YAML with typed serde schema</td></tr>
<tr><td>Validation</td><td><code>utility.sh --check-yaml</code></td><td><code>ic mod check</code> — YAML + Lua + WASM validation</td></tr>
<tr><td>Packaging</td><td><code>packaging/</code> shell scripts → .exe/.app/.AppImage</td><td><code>ic mod package</code> + workshop publish</td></tr>
<tr><td>Dedicated server</td><td><code>launch-dedicated.sh</code></td><td><code>ic mod server</code></td></tr>
<tr><td>Directory layout</td><td>Convention-based (chrome/, rules/, maps/, etc.)</td><td>Adapted for three-tier model</td></tr>
<tr><td>IDE support</td><td><code>.vscode/</code> in repo</td><td>VS Code extension with YAML schema + Lua LSP</td></tr>
</tbody>
</table>
</div>
<p><strong>What we don’t adapt (pain points we solve differently):</strong></p>
<ul>
<li>C# DLLs for custom traits → our Lua + WASM tiers are strictly better (no compilation, sandboxed, polyglot)</li>
<li>GPL license contamination → WASM sandbox means mod code is isolated; engine license doesn’t infect mods</li>
<li>MiniYAML → real YAML with <code>serde_yaml</code>, JSON Schema, standard linters</li>
<li>No hot-reload → Lua and YAML hot-reload during <code>ic mod watch</code></li>
<li>No workshop → built-in workshop with <code>ic mod publish</code></li>
</ul>
<p><strong>The <code>ic</code> CLI tool:</strong>
A single Rust binary replacing OpenRA’s shell scripts + Makefile + Python dependencies:</p>
<pre><code>ic mod init [template]     # scaffold from template
ic mod check               # validate all mod content
ic mod test                # headless smoke test
ic mod run                 # launch game with mod
ic mod server              # dedicated server
ic mod package             # build distributables
ic mod publish             # workshop upload
ic mod watch               # hot-reload dev mode
ic mod lint                # convention + llm: metadata checks
ic mod update-engine       # bump engine version
ic sdk                     # launch the visual SDK application (scenario editor, asset studio, campaign editor)
ic sdk open [project]      # launch SDK with a specific mod/scenario
ic replay parse [file]     # extract replay data to structured output (JSON/CSV) — enables community stats sites,
                           #   tournament analysis, anti-cheat review (inspired by Valve's csgo-demoinfo)
ic replay inspect [file]   # summary view: players, map, duration, outcome, desync status
ic replay verify [file]    # verify relay signature chain + integrity (see 06-SECURITY.md)
</code></pre>
<blockquote>
<p><strong>CLI design principle (from Fossilize):</strong> Each subcommand does one focused thing well — validate, convert, inspect, verify. Valve’s Fossilize toolchain (<code>fossilize-replay</code>, <code>fossilize-merge</code>, <code>fossilize-convert</code>, <code>fossilize-list</code>) demonstrates that a family of small, composable CLI tools is more useful than a monolithic Swiss Army knife. The <code>ic</code> CLI follows this pattern: <code>ic mod check</code> validates, <code>ic mod convert</code> converts formats, <code>ic replay parse</code> extracts data, <code>ic replay inspect</code> summarizes. Each subcommand is independently useful and composable via shell pipelines. See <code>research/valve-github-analysis.md</code> § 3.3 and § 6.2.</p>
</blockquote>
<p><strong>Mod templates (built-in):</strong></p>
<ul>
<li><code>data-mod</code> — YAML-only balance/cosmetic mods</li>
<li><code>scripted-mod</code> — missions and custom game modes (YAML + Lua)</li>
<li><code>total-conversion</code> — full layout with WASM scaffolding</li>
<li><code>map-pack</code> — map collections</li>
<li><code>asset-pack</code> — sprites, sounds, video packs</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li>OpenRA’s SDK validates the template-project approach — modders want a turnkey starting point</li>
<li>Engine version pinning is essential — mods break when engine updates; semver solves this cleanly</li>
<li>A CLI tool is more portable, discoverable, and maintainable than shell scripts + Makefiles</li>
<li>Workshop integration from the CLI closes the “last mile” — OpenRA modders must manually distribute their work</li>
<li>The three-tier modding system means most modders never compile anything — <code>ic mod init data-mod</code> gives you a working mod instantly</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Shell scripts like OpenRA (rejected — cross-platform pain, Python/shell dependencies, fragile)</li>
<li>Cargo workspace (rejected — mods aren’t Rust crates; YAML/Lua mods have nothing to compile)</li>
<li>In-engine mod editor only (rejected — power users want filesystem access and version control)</li>
<li>No SDK, just documentation (rejected — OpenRA proves that a template project dramatically lowers the barrier)</li>
</ul>
<p><strong>Phase:</strong> Phase 6a (Core Modding + Scenario Editor). CLI prototype in Phase 4 (for Lua scripting development).</p>
<hr>
<h3 id="d021--branching-campaign-system-with-persistent-state"><a class="header" href="#d021--branching-campaign-system-with-persistent-state">D021 — Branching Campaign System with Persistent State</a></h3>
<p><strong>Decision:</strong> Campaigns are directed graphs of missions with named outcomes, branching paths, persistent unit rosters, and continuous flow — not linear sequences with binary win/lose. Failure doesn’t end the campaign; it branches to a different path. Unit state, equipment, and story flags persist across missions.</p>
<p><strong>Context:</strong> OpenRA’s campaigns are disconnected — each mission is standalone, you exit to menu after completion, there’s no sense of flow or consequence. The original Red Alert had linear progression with FMV briefings but no branching or state persistence. Games like Operation Flashpoint: Cold War Crisis showed that branching outcomes create dramatically more engaging campaigns, and OFP: Resistance proved that persistent unit rosters (surviving soldiers, captured equipment, accumulated experience) create deep emotional investment.</p>
<p><strong>Key design points:</strong></p>
<ol>
<li>
<p><strong>Campaign graph:</strong> Missions are nodes in a directed graph. Each mission has named outcomes (not just win/lose). Each outcome maps to a next-mission node, forming branches and convergences. The graph is defined in YAML and validated at load time.</p>
</li>
<li>
<p><strong>Named outcomes:</strong> Lua scripts signal completion with a named key: <code>Campaign.complete("victory_bridge_intact")</code>. The campaign YAML maps each outcome to the next mission. This enables rich branching: “Won cleanly” → easy path, “Won with heavy losses” → harder path, “Failed” → fallback mission.</p>
</li>
<li>
<p><strong>Failure continues the game:</strong> A <code>defeat</code> outcome is just another edge in the graph. The campaign designer decides what happens: retry with fewer resources, branch to a retreating mission, skip ahead with consequences, or even “no game over” campaigns where the story always continues.</p>
</li>
<li>
<p><strong>Persistent unit roster (OFP: Resistance model):</strong></p>
<ul>
<li>Surviving units carry forward between missions (configurable per transition)</li>
<li>Units accumulate veterancy across missions — a veteran tank from mission 1 stays veteran in mission 5</li>
<li>Dead units are gone permanently — losing veterans hurts</li>
<li>Captured enemy equipment joins a persistent equipment pool</li>
<li>Five carryover modes: <code>none</code>, <code>surviving</code>, <code>extracted</code> (only units in evac zone), <code>selected</code> (Lua picks), <code>custom</code> (full Lua control)</li>
</ul>
</li>
<li>
<p><strong>Story flags:</strong> Arbitrary key-value state writable from Lua, readable in subsequent missions. Enables conditional content: “If the radar was captured in mission 2, it provides intel in mission 4.”</p>
</li>
<li>
<p><strong>Campaign state is serializable:</strong> Fits D010 (snapshottable sim state). Save games capture full campaign progress including roster, flags, and path taken. Replays can replay entire campaign runs.</p>
</li>
<li>
<p><strong>Continuous flow:</strong> Briefing → mission → debrief → next mission. No exit to menu between levels unless the player explicitly quits.</p>
</li>
<li>
<p><strong>Campaign mission transitions:</strong> When the sim ends and the next mission’s assets need to load, the player never sees a blank screen or a generic loading bar. The transition sequence is: sim ends → debrief intermission displays (already loaded, zero wait) → background asset loading begins for the next mission → briefing intermission displays (runs concurrently with loading) → when loading completes and the player clicks “Begin Mission,” gameplay starts instantly. If the player clicks before loading finishes, a non-intrusive progress indicator appears at the bottom of the briefing screen (“Preparing battlefield… 87%”) — the briefing remains interactive, the player can re-read text or review the roster while waiting. For missions with cinematic intros (Video Playback module), the video plays while assets load in the background — by the time the cutscene ends, the mission is ready. This means campaign transitions feel like <em>narrative beats</em>, not technical interruptions. The only time a traditional loading screen appears is on first mission launch (cold start) or when asset size vastly exceeds available memory — and even then, the loading screen is themed to the campaign (campaign-defined background image, faction logo, loading tip text from <code>loading_tips.yaml</code>).</p>
</li>
<li>
<p><strong>Credits sequence:</strong> The final campaign node can chain to a Credits intermission (see D038 § Intermission Screens). A credits sequence is defined per campaign — the RA1 game module ships with credits matching the original game’s style (scrolling text over a background, Hell March playing). Modders define their own credits via the Credits intermission template or a <code>credits.yaml</code> file. Credits are skippable (press Escape or click) but play by default — respecting the work of everyone who contributed to the campaign.</p>
</li>
<li>
<p><strong>Narrative identity (Principle #20).</strong> Briefings, debriefs, character dialogue, and mission framing follow the C&amp;C narrative pillars: earnest commitment to the world, larger-than-life characters, quotable lines, and escalating stakes. Even procedurally generated campaigns (D016) are governed by the “C&amp;C Classic” narrative DNA rules. See <a href="13-PHILOSOPHY.html">13-PHILOSOPHY.md</a> § Principle 20 and D016 § “C&amp;C Classic — Narrative DNA.”</p>
</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>OpenRA’s disconnected missions are its single biggest single-player UX failure — universally cited in community feedback</li>
<li>OFP proved persistent rosters create investment: players restart missions to save a veteran soldier</li>
<li>Branching eliminates the frustration of replaying the same mission on failure — the campaign adapts</li>
<li>YAML graph definition is accessible to modders (Tier 1) and LLM-generable</li>
<li>Lua campaign API enables complex state logic while staying sandboxed</li>
<li>The same system works for hand-crafted campaigns, modded campaigns, and LLM-generated campaigns</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Linear mission sequence like RA1 (rejected — primitive, no replayability, failure is frustrating)</li>
<li>Disconnected missions like OpenRA (rejected — the specific problem we’re solving)</li>
<li>Full open-world (rejected — scope too large, not appropriate for RTS)</li>
<li>Only branching on win/lose (rejected — named outcomes are trivially more expressive with no added complexity)</li>
<li>No unit persistence (rejected — OFP: Resistance proves this is the feature that creates campaign investment)</li>
</ul>
<p><strong>Phase:</strong> Phase 4 (AI &amp; Single Player). Campaign graph engine and Lua Campaign API are core Phase 4 deliverables. The visual Campaign Editor in D038 (Phase 6b) builds on this system — D021 provides the sim-side engine, D038 provides the visual authoring tools.</p>
<hr>
<h3 id="d022--dynamic-weather-with-terrain-surface-effects"><a class="header" href="#d022--dynamic-weather-with-terrain-surface-effects">D022 — Dynamic Weather with Terrain Surface Effects</a></h3>
<p><strong>Decision:</strong> Weather transitions dynamically during gameplay via a deterministic state machine, and terrain textures visually respond to weather — snow accumulates on the ground, rain darkens/wets surfaces, sunshine dries them out. Terrain surface state optionally affects gameplay (movement penalties on snow/ice/mud).</p>
<p><strong>Context:</strong> The base weather system (static per-mission, GPU particles + sim modifiers) provides atmosphere but doesn’t evolve. Real-world weather changes. A mission that starts sunny and ends in a blizzard is vastly more dramatic — and strategically different — than one where weather is set-and-forget.</p>
<p><strong>Key design points:</strong></p>
<ol>
<li>
<p><strong>Weather state machine (sim-side):</strong> <code>WeatherState</code> resource tracks current type, intensity (fixed-point <code>0..1024</code>), and transition progress. Three schedule modes: <code>cycle</code> (deterministic round-robin), <code>random</code> (seeded from match, deterministic), <code>scripted</code> (Lua-driven only). State machine graph and transition weights defined in map YAML.</p>
</li>
<li>
<p><strong>Terrain surface state (sim-side):</strong> <code>TerrainSurfaceGrid</code> — a per-cell grid of <code>SurfaceCondition { snow_depth, wetness }</code>. Updated every tick by <code>weather_surface_system</code>. Fully deterministic, derives <code>Serialize, Deserialize</code> for snapshots. When <code>sim_effects: true</code>, surface state modifies movement: deep snow slows infantry/vehicles, ice makes water passable, mud bogs wheeled units.</p>
</li>
<li>
<p><strong>Terrain texture effects (render-side):</strong> Three quality tiers — palette tinting (free, no assets needed), overlay sprites (moderate, one extra pass), shader blending (GPU blend between base + weather variant textures). Selectable via <code>RenderSettings</code>. Accumulation is gradual and spatially non-uniform (snow appears on edges/roofs first, puddles in low cells first).</p>
</li>
<li>
<p><strong>Composes with day/night and seasons:</strong> Overcast days are darker, rain at night is near-black with lightning flashes. Map <code>temperature.base</code> controls whether precipitation is rain or snow. Arctic/desert/tropical maps set different defaults.</p>
</li>
<li>
<p><strong>Fully moddable:</strong> YAML defines schedules and surface rates (Tier 1). Lua triggers transitions and queries surface state (Tier 2). WASM adds custom weather types like ion storms (Tier 3).</p>
</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>No other C&amp;C engine has dynamic weather that affects terrain visuals — unique differentiator</li>
<li>Deterministic state machine preserves lockstep (same seed = same weather progression on all clients)</li>
<li>Sim/render split respected: surface state is sim (deterministic), visual blending is render (cosmetic)</li>
<li>Palette tinting tier ensures even low-end devices and WASM can show weather effects</li>
<li>Gameplay effects are optional per-map — purely cosmetic weather is valid</li>
<li>Surface state fits the snapshot system (D010) for save games and replays</li>
<li>Weather schedules are LLM-generable — “generate a mission where weather gets progressively worse”</li>
</ul>
<p><strong>Performance:</strong></p>
<ul>
<li>Palette tinting: zero extra draw calls, negligible GPU cost</li>
<li>Surface state grid: ~2 bytes per cell (compact fixed-point) — a 128×128 map is 32KB</li>
<li><code>weather_surface_system</code> is O(cells) but amortized via spatial quadrant rotation: the map is partitioned into 4 quadrants and one quadrant is updated per tick, achieving 4× throughput with constant 1-tick latency. This is a sim-only strategy — it does not depend on camera position (the sim has no camera awareness).</li>
<li>Follows efficiency pyramid: algorithmic (grid lookup) → cache-friendly (contiguous array) → amortized</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Static weather only (rejected — misses dramatic potential, no terrain response)</li>
<li>Client-side random weather (rejected — breaks deterministic sim, desync risk)</li>
<li>Full volumetric weather simulation (rejected — overkill, performance cost, not needed for isometric RTS)</li>
<li>Always-on sim effects (rejected — weather-as-decoration is valid for casual/modded games)</li>
</ul>
<p><strong>Phase:</strong> Phase 3 (visual effects) for render-side; Phase 2 (sim implementation) for weather state machine and surface grid.</p>
<hr>
<h3 id="d023--openra-vocabulary-compatibility-layer"><a class="header" href="#d023--openra-vocabulary-compatibility-layer">D023 — OpenRA Vocabulary Compatibility Layer</a></h3>
<p><strong>Decision:</strong> Accept OpenRA trait names and YAML keys as aliases in our YAML parser. Both OpenRA-style names (e.g., <code>Armament</code>, <code>Valued</code>, <code>Buildable</code>) and IC-native names (e.g., <code>combat</code>, <code>buildable.cost</code>) resolve to the same ECS components. Unconverted OpenRA YAML loads with a deprecation warning.</p>
<p><strong>Context:</strong> The biggest migration barrier for the 80% YAML tier isn’t missing features — it’s naming divergence. Every renamed concept multiplies across thousands of mod files. OpenRA modders have years of muscle memory with trait names and YAML keys. Forcing renames creates friction that discourages adoption.</p>
<p><strong>Key design points:</strong></p>
<ol>
<li><strong>Alias registry:</strong> <code>ra-formats</code> maintains a compile-time map of OpenRA trait names to IC component names. <code>Armament</code> → <code>combat</code>, <code>Valued</code> → <code>buildable.cost</code>, <code>AttackOmni</code> → <code>combat.mode: omni</code>, etc.</li>
<li><strong>Bi-directional:</strong> The alias registry is used during YAML parsing (OpenRA names accepted) and by the <code>miniyaml2yaml</code> converter (produces IC-native names). Both representations are valid.</li>
<li><strong>Deprecation warnings:</strong> When an OpenRA alias is used, the parser emits a warning: <code>"Armament" is accepted but deprecated; prefer "combat"</code>. Warnings can be suppressed per-mod via <code>mod.yaml</code> setting.</li>
<li><strong>No runtime cost:</strong> Aliases resolve during YAML deserialization (load time only). The ECS never sees alias names — only canonical IC component types.</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>Reduces the YAML migration from “convert everything” to “drop in and play, clean up later”</li>
<li>Respects invariant #8 (“the community’s existing work is sacred”) at the data vocabulary layer, not just binary formats</li>
<li>Zero runtime cost — purely a deserialization convenience</li>
<li>Makes <code>miniyaml2yaml</code> output immediately usable even without manual cleanup</li>
<li>Modders can learn IC-native names gradually as they edit files</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>IC-native names only (rejected — unnecessary migration barrier for thousands of existing mod files)</li>
<li>Adopt OpenRA’s names wholesale (rejected — some OpenRA names are poorly chosen or C#-specific; IC benefits from cleaner naming)</li>
<li>Converter handles everything (rejected — modders still need to re-learn names for new content; aliases let them use familiar names forever)</li>
</ul>
<p><strong>Phase:</strong> Phase 0 (alias registry built alongside <code>ra-formats</code> YAML parser). Phase 6a (deprecation warnings configurable in <code>mod.yaml</code>).</p>
<hr>
<h3 id="d024--lua-api-superset-of-openra"><a class="header" href="#d024--lua-api-superset-of-openra">D024 — Lua API Superset of OpenRA</a></h3>
<p><strong>Decision:</strong> Iron Curtain’s Lua scripting API is a strict superset of OpenRA’s 16 global objects. Same function names, same parameter signatures, same return types. OpenRA Lua missions run unmodified. IC then extends with additional functionality.</p>
<p><strong>Context:</strong> OpenRA has a mature Lua API used in hundreds of campaign missions across all C&amp;C game mods. Combined Arms alone has 34 Lua-scripted missions. The mod migration doc (12-MOD-MIGRATION.md) identified “API compatibility shim” as a migration requirement — this decision elevates it from “nice to have” to “hard requirement.”</p>
<p><strong>OpenRA’s 16 globals (all must work identically in IC):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Global</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Actor</code></td><td>Create, query, manipulate actors</td></tr>
<tr><td><code>Map</code></td><td>Terrain, bounds, spatial queries</td></tr>
<tr><td><code>Trigger</code></td><td>Event hooks (OnKilled, AfterDelay)</td></tr>
<tr><td><code>Media</code></td><td>Audio, video, text display</td></tr>
<tr><td><code>Player</code></td><td>Player state, resources, diplomacy</td></tr>
<tr><td><code>Reinforcements</code></td><td>Spawn units at edges/drops</td></tr>
<tr><td><code>Camera</code></td><td>Pan, position, shake</td></tr>
<tr><td><code>DateTime</code></td><td>Game time queries</td></tr>
<tr><td><code>Objectives</code></td><td>Mission objective management</td></tr>
<tr><td><code>Lighting</code></td><td>Global lighting control</td></tr>
<tr><td><code>UserInterface</code></td><td>UI text, notifications</td></tr>
<tr><td><code>Utils</code></td><td>Math, random, table utilities</td></tr>
<tr><td><code>Beacon</code></td><td>Map beacon management</td></tr>
<tr><td><code>Radar</code></td><td>Radar ping control</td></tr>
<tr><td><code>HSLColor</code></td><td>Color construction</td></tr>
<tr><td><code>WDist</code></td><td>Distance unit conversion</td></tr>
</tbody>
</table>
</div>
<p><strong>IC extensions (additions, not replacements):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Global</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Campaign</code></td><td>Branching campaign state (D021)</td></tr>
<tr><td><code>Weather</code></td><td>Dynamic weather control (D022)</td></tr>
<tr><td><code>Layer</code></td><td>Runtime layer activation/deaction</td></tr>
<tr><td><code>Region</code></td><td>Named region queries</td></tr>
<tr><td><code>Var</code></td><td>Mission/campaign variable access</td></tr>
<tr><td><code>Workshop</code></td><td>Mod metadata queries</td></tr>
<tr><td><code>LLM</code></td><td>LLM integration hooks (Phase 7)</td></tr>
<tr><td><code>Commands</code></td><td>Command registration for mods (D058)</td></tr>
<tr><td><code>Ping</code></td><td>Typed tactical pings (D059)</td></tr>
<tr><td><code>ChatWheel</code></td><td>Auto-translated phrase system (D059)</td></tr>
<tr><td><code>Marker</code></td><td>Persistent tactical markers (D059)</td></tr>
<tr><td><code>Chat</code></td><td>Programmatic chat messages (D059)</td></tr>
</tbody>
</table>
</div>
<p><strong>Actor properties also match:</strong> Each actor reference exposes properties matching OpenRA’s property groups (<code>.Health</code>, <code>.Location</code>, <code>.Owner</code>, <code>.Move()</code>, <code>.Attack()</code>, <code>.Stop()</code>, <code>.Guard()</code>, <code>.Deploy()</code>, etc.) with identical semantics.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>CA’s 34 missions + hundreds of community missions work on day one — no porting effort</li>
<li>Reduces Lua migration from “moderate effort” to “zero effort” for standard missions</li>
<li>IC’s extensions are additive — no conflicts, no breaking changes</li>
<li>Modders who know OpenRA Lua immediately know IC Lua</li>
<li>Future OpenRA missions created by the community are automatically IC-compatible</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Design our own API, provide shim (rejected — shim is always leaky, creates two mental models)</li>
<li>Partial compatibility (rejected — partial breaks are worse than full breaks; either missions work or they don’t)</li>
<li>No Lua compatibility (rejected — throws away hundreds of community missions for no gain)</li>
</ul>
<p><strong>Phase:</strong> Phase 4 (Lua scripting implementation). API surface documented during Phase 2 planning.</p>
<hr>
<h3 id="d025--runtime-miniyaml-loading"><a class="header" href="#d025--runtime-miniyaml-loading">D025 — Runtime MiniYAML Loading</a></h3>
<p><strong>Decision:</strong> Support loading MiniYAML directly at runtime as a fallback format in <code>ra-formats</code>. When the engine encounters tab-indented files with <code>^</code> inheritance or <code>@</code> suffixes, it auto-converts in memory. The <code>miniyaml2yaml</code> CLI converter still exists for permanent migration, but is no longer a prerequisite for loading mods.</p>
<p><strong>Revision of D003:</strong> D003 (“Real YAML, not MiniYAML”) remains the canonical format. All IC-native content uses standard YAML. D025 adds a compatibility loader — it does not change what IC produces, only what it accepts.</p>
<p><strong>Key design points:</strong></p>
<ol>
<li><strong>Format detection:</strong> <code>ra-formats</code> checks the first few lines of each file. Tab-indented content with no YAML indicators triggers the MiniYAML parser path.</li>
<li><strong>In-memory conversion:</strong> MiniYAML is parsed to an intermediate tree, then resolved to standard YAML structs. The result is identical to what <code>miniyaml2yaml</code> would produce.</li>
<li><strong>Combined with D023:</strong> OpenRA trait name aliases (D023) apply after MiniYAML parsing — so the full chain is: MiniYAML → intermediate tree → alias resolution → typed Rust structs.</li>
<li><strong>Performance:</strong> Conversion adds ~10-50ms per mod at load time (one-time cost). Cached after first load.</li>
<li><strong>Warning output:</strong> Console logs <code>"Loaded MiniYAML file rules.yaml — consider converting to standard YAML with 'ic mod convert'"</code>.</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>Turns “migrate then play” into “play immediately, migrate when ready”</li>
<li>Existing OpenRA mods become testable on IC within minutes, not hours</li>
<li>Respects invariant #8 — the community’s existing work is sacred, including their file formats</li>
<li>The converter CLI still exists for modders who want clean IC-native files</li>
<li>No performance impact after initial load (conversion result is cached)</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Require pre-conversion (original plan — rejected as unnecessary friction; the converter runs in memory just as well as on disk)</li>
<li>Support MiniYAML as a first-class format permanently (rejected — standard YAML is strictly better for tooling, validation, and editor support)</li>
<li>Only support converted files (rejected — blocks quick experimentation and casual mod testing)</li>
</ul>
<p><strong>Phase:</strong> Phase 0 (MiniYAML parser already needed for <code>miniyaml2yaml</code>; making it a runtime loader is minimal additional work).</p>
<hr>
<h3 id="d026--openra-mod-manifest-compatibility"><a class="header" href="#d026--openra-mod-manifest-compatibility">D026 — OpenRA Mod Manifest Compatibility</a></h3>
<p><strong>Decision:</strong> <code>ra-formats</code> can parse OpenRA’s <code>mod.yaml</code> manifest format and auto-map it to IC’s mod structure at load time. Combined with D023 (aliases), D024 (Lua API), and D025 (MiniYAML loading), this means a modder can point IC at an existing OpenRA mod directory and it loads — no restructuring needed.</p>
<p><strong>Key design points:</strong></p>
<ol>
<li><strong>Manifest parsing:</strong> OpenRA’s <code>mod.yaml</code> declares <code>Packages</code>, <code>Rules</code>, <code>Sequences</code>, <code>Cursors</code>, <code>Chrome</code>, <code>Assemblies</code>, <code>ChromeLayout</code>, <code>Weapons</code>, <code>Voices</code>, <code>Notifications</code>, <code>Music</code>, <code>Translations</code>, <code>MapFolders</code>, <code>SoundFormats</code>, <code>SpriteFormats</code>. IC maps each section to its equivalent concept.</li>
<li><strong>Directory convention mapping:</strong> OpenRA mods use <code>rules/</code>, <code>maps/</code>, <code>sequences/</code> etc. IC maps these to its own layout at load time without copying files.</li>
<li><strong>Unsupported sections flagged:</strong> <code>Assemblies</code> (C# DLLs) cannot load — these are flagged as warnings listing which custom traits are unavailable and what WASM alternatives exist.</li>
<li><strong>Partial loading:</strong> A mod with unsupported C# traits still loads — units using those traits get a visual placeholder and a “missing trait” debug overlay. The mod is playable with reduced functionality.</li>
<li><strong><code>ic mod import</code>:</strong> CLI command that reads an OpenRA mod directory and generates an IC-native <code>mod.yaml</code> with proper structure, converting files to standard YAML and flagging C# dependencies for WASM migration.</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>Combined with D023/D024/D025, this completes the “zero-friction import” pipeline</li>
<li>Modders can evaluate IC as a target without committing to migration</li>
<li>Partial loading means even mods with C# dependencies are partially testable</li>
<li>The <code>ic mod import</code> command provides a clean migration path when the modder is ready</li>
<li>Validates our claim that “the community’s existing work is sacred”</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Require manual mod restructuring (rejected — unnecessary friction, blocks adoption)</li>
<li>Only support IC mod format (rejected — makes evaluation impossible without migration effort)</li>
<li>Full C# trait loading via .NET interop (rejected — violates D001/D002, reintroduces the problems Rust solves)</li>
</ul>
<p><strong>Phase:</strong> Phase 0 (manifest parsing) + Phase 6a (full <code>ic mod import</code> workflow).</p>
<hr>
<h3 id="d027--canonical-enum-compatibility-with-openra"><a class="header" href="#d027--canonical-enum-compatibility-with-openra">D027 — Canonical Enum Compatibility with OpenRA</a></h3>
<p><strong>Decision:</strong> Use OpenRA’s canonical enum names for locomotor types, armor types, target types, damage states, and other enumerated values — or accept both OpenRA and IC-native names via the alias system (D023).</p>
<p><strong>Specific enums aligned:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Enum Type</th><th>OpenRA Names</th><th>IC Accepts</th></tr>
</thead>
<tbody>
<tr><td>Locomotor</td><td><code>Foot</code>, <code>Wheeled</code>, <code>Tracked</code>, <code>Float</code>, <code>Fly</code></td><td>Same (canonical)</td></tr>
<tr><td>Armor</td><td><code>None</code>, <code>Light</code>, <code>Medium</code>, <code>Heavy</code>, <code>Wood</code>, <code>Concrete</code></td><td>Same (canonical)</td></tr>
<tr><td>Target Type</td><td><code>Ground</code>, <code>Air</code>, <code>Water</code>, <code>Underground</code></td><td>Same (canonical)</td></tr>
<tr><td>Damage State</td><td><code>Undamaged</code>, <code>Light</code>, <code>Medium</code>, <code>Heavy</code>, <code>Critical</code>, <code>Dead</code></td><td>Same (canonical)</td></tr>
<tr><td>Stance</td><td><code>AttackAnything</code>, <code>Defend</code>, <code>ReturnFire</code>, <code>HoldFire</code></td><td>Same (canonical)</td></tr>
<tr><td>UnitType</td><td><code>Building</code>, <code>Infantry</code>, <code>Vehicle</code>, <code>Aircraft</code>, <code>Ship</code></td><td>Same (canonical)</td></tr>
</tbody>
</table>
</div>
<p><strong>Why this matters:</strong> The <code>Versus</code> damage table — which modders spend 80% of their balance time tuning — uses armor type names as keys. Locomotor types determine pathfinding behavior. Target types control weapon targeting. If these don’t match, every single weapon definition, armor table, and locomotor reference needs translation. By matching names, these definitions copy-paste directly.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Eliminates an entire category of conversion mapping</li>
<li>Versus tables, weapon definitions, locomotor configs — all transfer without renaming</li>
<li>OpenRA’s names are reasonable and well-known in the community</li>
<li>No technical reason to rename these — they describe the same concepts</li>
<li>Where IC needs additional values (e.g., <code>Hover</code>, <code>Amphibious</code>), they extend the enum without conflicting</li>
</ul>
<p><strong>Phase:</strong> Phase 2 (when enum types are formally defined in <code>ic-sim</code>).</p>
<hr>
<h3 id="d028--condition-and-multiplier-systems-as-phase-2-requirements"><a class="header" href="#d028--condition-and-multiplier-systems-as-phase-2-requirements">D028 — Condition and Multiplier Systems as Phase 2 Requirements</a></h3>
<p><strong>Decision:</strong> The condition system and multiplier system identified as P0 critical gaps in <code>11-OPENRA-FEATURES.md</code> are promoted to hard Phase 2 exit criteria. Phase 2 cannot ship without both systems implemented and tested.</p>
<p><strong>What this adds to Phase 2:</strong></p>
<ol>
<li>
<p><strong>Condition system:</strong></p>
<ul>
<li><code>Conditions</code> component: <code>HashMap&lt;ConditionId, u32&gt;</code> (ref-counted named conditions per entity)</li>
<li>Condition sources: <code>GrantConditionOnMovement</code>, <code>GrantConditionOnDamageState</code>, <code>GrantConditionOnDeploy</code>, <code>GrantConditionOnAttack</code>, <code>GrantConditionOnTerrain</code>, <code>GrantConditionOnVeterancy</code> — exposed in YAML</li>
<li>Condition consumers: any component field can declare <code>requires:</code> or <code>disabled_by:</code> conditions</li>
<li>Runtime: systems check <code>conditions.is_active("deployed")</code> via fast bitset or hash lookup</li>
</ul>
</li>
<li>
<p><strong>Multiplier system:</strong></p>
<ul>
<li><code>StatModifiers</code> component: per-entity stack of <code>(source, stat, modifier_value, condition)</code></li>
<li>Every numeric stat (speed, damage, range, reload, build time, build cost, sight range, etc.) resolves through the modifier stack</li>
<li>Modifiers from: veterancy, terrain, crates, conditions, player handicaps</li>
<li>Fixed-point multiplication (no floats)</li>
<li>YAML-configurable: modders add multipliers without code</li>
</ul>
</li>
<li>
<p><strong>Full damage pipeline:</strong></p>
<ul>
<li>Armament → Projectile entity → travel → impact → Warhead(s) → armor-versus-weapon table → DamageMultiplier resolution → Health reduction</li>
<li>Composable warheads: each weapon can trigger multiple warheads (damage + condition + terrain effect)</li>
</ul>
</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>Without conditions, 80% of OpenRA YAML mods cannot express their behavior at all — conditions are the fundamental modding primitive</li>
<li>Without multipliers, veterancy/crates/terrain bonuses don’t work — critical gameplay systems are broken</li>
<li>Without the full damage pipeline, weapons are simplistic and balance modding is impossible</li>
<li>These three systems are the foundation that P1–P3 features build on (stealth, veterancy, transport, support powers all use conditions and multipliers)</li>
<li>Promoting from “identified gap” to “exit criteria” ensures they’re not deferred</li>
</ul>
<p><strong>Phase:</strong> Phase 2 (hard exit criteria — no Phase 3 starts without these).</p>
<hr>
<h3 id="d029--cross-game-component-library-phase-2-targets"><a class="header" href="#d029--cross-game-component-library-phase-2-targets">D029 — Cross-Game Component Library (Phase 2 Targets)</a></h3>
<p><strong>Decision:</strong> The seven first-party component systems identified in <code>12-MOD-MIGRATION.md</code> (from Combined Arms and Remastered case studies) are Phase 2 targets. They are high priority and independently scoped — any that don’t land by Phase 2 exit are early Phase 3 work, not deferred indefinitely. (The D028 systems — conditions, multipliers, damage pipeline — are the hard Phase 2 gate; see <code>08-ROADMAP.md</code> § Phase 2 exit criteria.)</p>
<p><strong>The seven systems:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>System</th><th>Needed For</th><th>Phase 2 Scope</th></tr>
</thead>
<tbody>
<tr><td><strong>Mind Control</strong></td><td>CA (Yuri), RA2 game module, Scrin</td><td>Controller/controllable components, capacity limits, override</td></tr>
<tr><td><strong>Carrier/Spawner</strong></td><td>CA, RA2 (Aircraft Carrier, Kirov drones)</td><td>Master/slave with respawn, recall, autonomous attack</td></tr>
<tr><td><strong>Teleport Networks</strong></td><td>CA, Nod tunnels (TD/TS), Chronosphere</td><td>Multi-node network with primary exit designation</td></tr>
<tr><td><strong>Shield System</strong></td><td>CA, RA2 force shields, Scrin</td><td>Absorb-before-health, recharge timer, depletion</td></tr>
<tr><td><strong>Upgrade System</strong></td><td>CA, C&amp;C3 game module</td><td>Per-unit tech research via building, condition grants</td></tr>
<tr><td><strong>Delayed Weapons</strong></td><td>CA (radiation, poison), RA2 (terror drones)</td><td>Timer-attached effects on targets</td></tr>
<tr><td><strong>Dual Asset Rendering</strong></td><td>Remastered recreation, HD mod packs</td><td>Superseded by the Resource Pack system (<code>04-MODDING.md</code> § “Resource Packs”) which generalizes this to N asset tiers, not just two. Phase 2 scope: <code>ic-render</code> supports runtime-switchable asset source per entity; Resource Pack manifests resolve at load time.</td></tr>
</tbody>
</table>
</div>
<p><strong>Evidence from OpenRA mod ecosystem:</strong> Analysis of six major OpenRA community mods (see <code>research/openra-mod-architecture-analysis.md</code> and <code>research/openra-ra2-mod-architecture.md</code>) validates and extends this list. Cross-game component reuse is the most consistent pattern across mods — the same mechanics appear independently in 3–5 mods each:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Mods Using It</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Mind Control</td><td>RA2, Romanovs-Vengeance</td><td>MindController/MindControllable with capacity limits, DiscardOldest policy, ArcLaserZap visual</td></tr>
<tr><td>Carrier/Spawner</td><td>RA2, OpenHV, OpenSA</td><td>BaseSpawnerParent→CarrierParent hierarchy; OpenHV uses for drone carriers; OpenSA for colony spawning</td></tr>
<tr><td>Infection</td><td>RA2, Romanovs-Vengeance</td><td>InfectableInfo with damage/kill triggers</td></tr>
<tr><td>Disguise/Mirage</td><td>RA2, Romanovs-Vengeance</td><td>MirageInfo with configurable reveal triggers (attack, damage, deploy, unload, infiltrate, heal)</td></tr>
<tr><td>Temporal Weapons</td><td>RA2, Romanovs-Vengeance</td><td>ChronoVortexInfo with return-to-start mechanics</td></tr>
<tr><td>Radiation</td><td>RA2</td><td>World-level TintedCellsLayer with sparse storage and logarithmic decay</td></tr>
<tr><td>Hacking</td><td>OpenHV</td><td>HackerInfo with delay, condition grant on target</td></tr>
<tr><td>Periodic Discharge</td><td>OpenHV</td><td>PeriodicDischargeInfo with damage/effects on timer</td></tr>
<tr><td>Colony Capture</td><td>OpenSA</td><td>ColonyBit with conversion mechanics</td></tr>
</tbody>
</table>
</div>
<p>This validates that IC’s seven systems are necessary but reveals two additional patterns that appear cross-game: <strong>infection</strong> (delayed damage/conversion — distinct from “delayed weapons” in that the infected unit carries the effect) and <strong>disguise/mirage</strong> (appearance substitution with configurable reveal triggers). These are candidates for promotion from WASM-only to first-party components.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>These aren’t CA-specific — they’re needed for RA2 (the likely second game module). Building them in Phase 2 means they’re available when RA2 development starts.</li>
<li>CA can migrate to IC the moment the engine is playable, rather than waiting for Phase 6a</li>
<li>Without these as built-in components, CA modders would need to write WASM for basic mechanics like mind control — unacceptable for adoption</li>
<li>The seven systems cover ~60% of CA’s custom C# code — collapsing the WASM tier from ~15% to ~5% of migration effort</li>
<li>Each system is independently useful and well-scoped (2-5 days engineering each)</li>
</ul>
<p><strong>Impact on migration estimates:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Migration Tier</th><th>Before D029</th><th>After D029</th></tr>
</thead>
<tbody>
<tr><td>Tier 1 (YAML)</td><td>~40%</td><td>~45%</td></tr>
<tr><td>Built-in</td><td>~30%</td><td>~40%</td></tr>
<tr><td>Tier 2 (Lua)</td><td>~15%</td><td>~10%</td></tr>
<tr><td>Tier 3 (WASM)</td><td>~15%</td><td>~5%</td></tr>
</tbody>
</table>
</div>
<p><strong>Phase:</strong> Phase 2 (sim-side components and dual asset rendering in <code>ic-render</code>).</p>
<hr>
<hr>
<h2 id="d033-toggleable-qol--gameplay-behavior-presets"><a class="header" href="#d033-toggleable-qol--gameplay-behavior-presets">D033: Toggleable QoL &amp; Gameplay Behavior Presets</a></h2>
<p><strong>Decision:</strong> Every UX and gameplay behavior improvement added by OpenRA or the Remastered Collection over vanilla Red Alert is individually toggleable. Built-in presets group these toggles into coherent experience profiles. Players can pick a preset and then customize any individual toggle. In multiplayer lobbies, sim-affecting toggles are shared settings; client-only toggles are per-player.</p>
<p><strong>The problem this solves:</strong></p>
<p>OpenRA and the Remastered Collection each introduced dozens of quality-of-life improvements over the original 1996 Red Alert. Many are genuinely excellent (attack-move, waypoint queuing, multi-queue production). But some players want the authentic vanilla experience. Others want the full OpenRA feature set. Others want the Remastered Collection’s specific subset. And some want to cherry-pick: “Give me OpenRA’s attack-move but not its build radius circles.”</p>
<p>Currently, no Red Alert implementation lets you do this. OpenRA’s QoL features are hardcoded. The Remastered Collection’s are hardcoded. Vanilla’s limitations are hardcoded. Every version forces you into one developer’s opinion of what the game “should” feel like.</p>
<p><strong>Our approach:</strong> Every QoL feature is a YAML-configurable toggle. Presets set all toggles at once. Individual toggles override the preset. The player owns their experience.</p>
<h3 id="qol-feature-catalog"><a class="header" href="#qol-feature-catalog">QoL Feature Catalog</a></h3>
<p>Every toggle is categorized as <strong>sim-affecting</strong> (changes game logic — must be identical for all players in multiplayer) or <strong>client-only</strong> (visual/UX — each player can set independently).</p>
<h4 id="production--economy-sim-affecting"><a class="header" href="#production--economy-sim-affecting">Production &amp; Economy (Sim-Affecting)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Toggle</th><th>Vanilla</th><th>OpenRA</th><th>Remastered</th><th>IC Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>multi_queue</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Queue multiple units of the same type</td></tr>
<tr><td><code>parallel_factories</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Multiple factories of same type produce simultaneously</td></tr>
<tr><td><code>build_radius_rule</code></td><td>None</td><td>ConYard+buildings</td><td>ConYard only</td><td>ConYard+buildings</td><td>Where you can place new buildings</td></tr>
<tr><td><code>sell_buildings</code></td><td>Partial</td><td>✅ Full</td><td>✅ Full</td><td>✅ Full</td><td>Sell any own building for partial refund</td></tr>
<tr><td><code>repair_buildings</code></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>Repair buildings for credits</td></tr>
</tbody>
</table>
</div>
<h4 id="unit-commands-sim-affecting"><a class="header" href="#unit-commands-sim-affecting">Unit Commands (Sim-Affecting)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Toggle</th><th>Vanilla</th><th>OpenRA</th><th>Remastered</th><th>IC Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>attack_move</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Move to location, engaging enemies en route</td></tr>
<tr><td><code>waypoint_queue</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Shift-click to queue movement waypoints</td></tr>
<tr><td><code>guard_command</code></td><td>❌</td><td>✅</td><td>❌</td><td>✅</td><td>Guard a unit or position, engage nearby threats</td></tr>
<tr><td><code>scatter_command</code></td><td>❌</td><td>✅</td><td>❌</td><td>✅</td><td>Units scatter from current position</td></tr>
<tr><td><code>force_fire_ground</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Force-fire on empty ground (area denial)</td></tr>
<tr><td><code>force_move</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Force move through crushable targets</td></tr>
<tr><td><code>rally_points</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Set rally point for production buildings</td></tr>
<tr><td><code>stance_system</code></td><td>None</td><td>Full</td><td>Basic</td><td>Full</td><td>Unit stance: aggressive / defensive / hold / return fire</td></tr>
</tbody>
</table>
</div>
<h4 id="ui--visual-feedback-client-only"><a class="header" href="#ui--visual-feedback-client-only">UI &amp; Visual Feedback (Client-Only)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Toggle</th><th>Vanilla</th><th>OpenRA</th><th>Remastered</th><th>IC Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>health_bars</code></td><td><code>never</code></td><td><code>always</code></td><td><code>on_selection</code></td><td><code>on_selection</code></td><td>Unit health bar visibility: <code>never</code> / <code>on_selection</code> / <code>always</code> / <code>damaged_or_selected</code></td></tr>
<tr><td><code>range_circles</code></td><td>❌</td><td>✅</td><td>❌</td><td>✅</td><td>Show weapon range circle when selecting defense buildings</td></tr>
<tr><td><code>build_radius_display</code></td><td>❌</td><td>✅</td><td>❌</td><td>✅</td><td>Show buildable area around construction yard / buildings</td></tr>
<tr><td><code>power_indicators</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Visual indicator on buildings affected by low power</td></tr>
<tr><td><code>support_power_timer</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Countdown timer bar for superweapons</td></tr>
<tr><td><code>production_progress</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Progress bar on sidebar build icons</td></tr>
<tr><td><code>target_lines</code></td><td>❌</td><td>✅</td><td>❌</td><td>✅</td><td>Lines showing order targets (move, attack)</td></tr>
<tr><td><code>rally_point_display</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Visual line from factory to rally point</td></tr>
</tbody>
</table>
</div>
<h4 id="selection--input-client-only"><a class="header" href="#selection--input-client-only">Selection &amp; Input (Client-Only)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Toggle</th><th>Vanilla</th><th>OpenRA</th><th>Remastered</th><th>IC Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>double_click_select_type</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Double-click a unit to select all of that type on screen</td></tr>
<tr><td><code>ctrl_click_select_type</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Ctrl+click to add all of type to selection</td></tr>
<tr><td><code>tab_cycle_types</code></td><td>❌</td><td>✅</td><td>❌</td><td>✅</td><td>Tab through unit types in multi-type selection</td></tr>
<tr><td><code>control_group_limit</code></td><td>10</td><td>Unlimited</td><td>Unlimited</td><td>Unlimited</td><td>Max units per control group (0 = unlimited)</td></tr>
<tr><td><code>smart_select_priority</code></td><td>❌</td><td>✅</td><td>❌</td><td>✅</td><td>Prefer combat units over harvesters in box select</td></tr>
</tbody>
</table>
</div>
<h4 id="gameplay-rules-sim-affecting-lobby-setting"><a class="header" href="#gameplay-rules-sim-affecting-lobby-setting">Gameplay Rules (Sim-Affecting, Lobby Setting)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Toggle</th><th>Vanilla</th><th>OpenRA</th><th>Remastered</th><th>IC Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>fog_of_war</code></td><td>❌</td><td>Optional</td><td>❌</td><td>Optional</td><td>Fog of war (explored but not visible = greyed out)</td></tr>
<tr><td><code>shroud_regrow</code></td><td>❌</td><td>Optional</td><td>❌</td><td>❌</td><td>Explored shroud grows back after units leave</td></tr>
<tr><td><code>short_game</code></td><td>❌</td><td>Optional</td><td>❌</td><td>Optional</td><td>Destroying all production buildings = defeat</td></tr>
<tr><td><code>crate_system</code></td><td>Basic</td><td>Enhanced</td><td>Basic</td><td>Enhanced</td><td>Bonus crates type and behavior</td></tr>
<tr><td><code>ore_regrowth</code></td><td>✅</td><td>✅ Configurable</td><td>✅</td><td>✅ Configurable</td><td>Ore regeneration rate</td></tr>
</tbody>
</table>
</div>
<h3 id="experience-presets"><a class="header" href="#experience-presets">Experience Presets</a></h3>
<p>Presets set all toggles at once. The player selects a preset, then overrides individual toggles if they want.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Preset</th><th>Balance (D019)</th><th>Theme (D032)</th><th>QoL (D033)</th><th>Feel</th></tr>
</thead>
<tbody>
<tr><td><strong>Vanilla RA</strong></td><td><code>classic</code></td><td><code>classic</code></td><td><code>vanilla</code></td><td>Authentic 1996 experience — warts and all</td></tr>
<tr><td><strong>OpenRA</strong></td><td><code>openra</code></td><td><code>modern</code></td><td><code>openra</code></td><td>Full OpenRA experience</td></tr>
<tr><td><strong>Remastered</strong></td><td><code>remastered</code></td><td><code>remastered</code></td><td><code>remastered</code></td><td>Remastered Collection feel</td></tr>
<tr><td><strong>Iron Curtain</strong> (default)</td><td><code>classic</code></td><td><code>modern</code></td><td><code>iron_curtain</code></td><td>Classic balance + best QoL from all eras</td></tr>
<tr><td><strong>Custom</strong></td><td>any</td><td>any</td><td>any</td><td>Player picks everything</td></tr>
</tbody>
</table>
</div>
<p>The “Iron Curtain” default cherry-picks: classic balance (units feel iconic), modern theme (polished UI), and the best QoL features from both OpenRA and Remastered (attack-move, multi-queue, health bars, range circles — everything that makes the game more playable without changing game feel).</p>
<h3 id="yaml-structure"><a class="header" href="#yaml-structure">YAML Structure</a></h3>
<pre><code class="language-yaml"># presets/qol/iron_curtain.yaml
qol:
  name: "Iron Curtain"
  description: "Best quality-of-life features from all eras"
  
  production:
    multi_queue: true
    parallel_factories: true
    build_radius_rule: conyard_and_buildings
    sell_buildings: full
    repair_buildings: true
  
  commands:
    attack_move: true
    waypoint_queue: true
    guard_command: true
    scatter_command: true
    force_fire_ground: true
    force_move: true
    rally_points: true
    stance_system: full    # none | basic | full
  
  ui_feedback:
    health_bars: on_selection  # never | on_selection | always | damaged_or_selected
    range_circles: true
    build_radius_display: true
    power_indicators: true
    support_power_timer: true
    production_progress: true
    target_lines: true
    rally_point_display: true
  
  selection:
    double_click_select_type: true
    ctrl_click_select_type: true
    tab_cycle_types: true
    control_group_limit: 0    # 0 = unlimited
    smart_select_priority: true
  
  gameplay:
    fog_of_war: optional      # on | off | optional (lobby choice)
    shroud_regrow: false
    short_game: optional
    crate_system: enhanced    # none | basic | enhanced
    ore_regrowth: true
</code></pre>
<pre><code class="language-yaml"># presets/qol/vanilla.yaml
qol:
  name: "Vanilla Red Alert"
  description: "Authentic 1996 experience"
  
  production:
    multi_queue: false
    parallel_factories: false
    build_radius_rule: none
    sell_buildings: partial
    repair_buildings: true
  
  commands:
    attack_move: false
    waypoint_queue: false
    guard_command: false
    scatter_command: false
    force_fire_ground: false
    force_move: false
    rally_points: false
    stance_system: none
  
  ui_feedback:
    health_bars: never
    range_circles: false
    build_radius_display: false
    power_indicators: false
    support_power_timer: false
    production_progress: false
    target_lines: false
    rally_point_display: false
  
  selection:
    double_click_select_type: false
    ctrl_click_select_type: false
    tab_cycle_types: false
    control_group_limit: 10
    smart_select_priority: false
  
  gameplay:
    fog_of_war: off
    shroud_regrow: false
    short_game: off
    crate_system: basic
    ore_regrowth: true
</code></pre>
<h3 id="sim-vs-client-split"><a class="header" href="#sim-vs-client-split">Sim vs Client Split</a></h3>
<p>Critical for multiplayer: some toggles change game rules, others are purely cosmetic.</p>
<p><strong>Sim-affecting toggles</strong> (lobby settings — all players must agree):</p>
<ul>
<li>Everything in <code>production</code>, <code>commands</code>, and <code>gameplay</code> sections</li>
<li>These are validated deterministically by the sim (invariant #1)</li>
<li>Multiplayer lobby: host sets the QoL preset; displayed to all players before match start</li>
<li>Mismatch = connection refused (enforced by sim hash, same as balance presets)</li>
</ul>
<p><strong>Client-only toggles</strong> (per-player preferences — each player sets their own):</p>
<ul>
<li>Everything in <code>ui_feedback</code> and <code>selection</code> sections</li>
<li>One player can play with always-visible health bars while their opponent plays with none</li>
<li>Stored in player settings, not in the lobby configuration</li>
<li>No sim impact — purely visual/UX</li>
</ul>
<p><strong>Client-only onboarding/touch comfort settings (D065 integration):</strong></p>
<ul>
<li>Tutorial hint frequency and category toggles (already in D065)</li>
<li>First-run controls walkthrough prompts (show on first launch / replay walkthrough / suppress)</li>
<li>Mobile handedness and touch interaction affordance visibility (e.g., command rail hints, bookmark dock labels)</li>
<li>Mobile Tempo Advisor warnings and reminder suppression (“don’t show again for this profile”)</li>
</ul>
<p>These settings are client-only for the same reason as subtitles or UI scale: they shape presentation and teaching pace, not the simulation. They may reference lobby state (e.g., selected game speed) to display warnings, but they never alter the synced match configuration by themselves.</p>
<h3 id="interaction-with-other-systems"><a class="header" href="#interaction-with-other-systems">Interaction with Other Systems</a></h3>
<p><strong>D019 (Balance Presets):</strong> QoL presets and balance presets are independent axes. You can play with <code>classic</code> balance + <code>openra</code> QoL, or <code>openra</code> balance + <code>vanilla</code> QoL. The lobby UI shows both selections.</p>
<p><strong>D032 (UI Themes):</strong> QoL and themes are also independent. The “Classic” theme changes chrome appearance; the “Vanilla” QoL preset changes gameplay behavior. They’re separate settings that happen to compose well.</p>
<p><strong>D065 (Tutorial &amp; New Player Experience):</strong> The tutorial system uses D033 for per-player hint frequency, category toggles, controls walkthrough visibility, and touch comfort guidance. The same mission/tutorial content is shared across platforms; D033 preferences control how aggressively the UI teaches and warns, not what the simulation does.</p>
<p><strong>Experience Profiles:</strong> The meta-layer above all of these. Selecting “Vanilla RA” experience profile sets D019=classic, D032=classic, D033=vanilla, D043=classic-ra, D045=classic-ra, D048=classic in one click. Selecting “Iron Curtain” sets D019=classic, D032=modern, D033=iron_curtain, D043=ic-default, D045=ic-default, D048=hd. After selecting a profile, any individual setting can still be overridden.</p>
<p><strong>Modding (Tier 1):</strong> QoL presets are just YAML files in <code>presets/qol/</code>. Modders can create custom QoL presets — a total conversion mod ships its own preset tuned for its gameplay. The <code>mod.yaml</code> manifest can specify a default QoL preset.</p>
<h3 id="rationale"><a class="header" href="#rationale">Rationale</a></h3>
<ul>
<li><strong>Respect for all eras.</strong> Each version of Red Alert — original, OpenRA, Remastered — has a community that loves it. Forcing one set of behaviors on everyone loses part of the audience.</li>
<li><strong>Player agency.</strong> “Good defaults with full customization” is the guiding principle. The IC default enables the best QoL features; purists can turn them off; power users can cherry-pick.</li>
<li><strong>Zero engine complexity.</strong> QoL toggles are just config flags read by systems that already exist. Attack-move is either registered as a command or not. Health bars are either rendered or not. No complex runtime switching — the config is read once at game start.</li>
<li><strong>Multiplayer safety.</strong> The sim/client split ensures determinism. Sim-affecting toggles are lobby settings (like game speed or starting cash). Client-only toggles are personal preferences (like enabling subtitles in any other game).</li>
<li><strong>Natural extension of D019 + D032.</strong> Balance, theme, and behavior are three independent axes of experience customization. Together they let a player fully configure what “Red Alert” feels like to them.</li>
</ul>
<h3 id="ux-principle-no-dead-end-buttons"><a class="header" href="#ux-principle-no-dead-end-buttons">UX Principle: No Dead-End Buttons</a></h3>
<p><strong>Never grey out or disable a button without telling the player why and how to fix it.</strong> A greyed-out button is a dead end — the player sees a feature exists, knows they can’t use it, and has no idea what to do about it. This is a universal UX anti-pattern.</p>
<p>IC’s rule: <strong>every button is always clickable.</strong> If a feature requires something the player hasn’t configured, clicking the button opens an <strong>inline guidance panel</strong> that:</p>
<ol>
<li><strong>Explains what’s needed</strong> — a short, plain-language sentence (not a generic “feature unavailable”)</li>
<li><strong>Offers a direct link</strong> to the relevant settings/configuration screen</li>
<li><strong>Returns the player</strong> to where they were after configuration, so they can continue seamlessly</li>
</ol>
<p><strong>Examples across the engine:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Button Clicked</th><th>Missing Prerequisite</th><th>Guidance Panel Shows</th></tr>
</thead>
<tbody>
<tr><td>“New Generative Campaign”</td><td>No LLM provider configured</td><td>“Generative campaigns need an LLM provider to create missions. [Configure LLM Provider →] You can also browse pre-generated campaigns on the Workshop. [Browse Workshop →]”</td></tr>
<tr><td>“3D View” render mode</td><td>3D mod not installed</td><td>“3D rendering requires a render mod that provides 3D models. [Browse Workshop for 3D mods →]”</td></tr>
<tr><td>“HD” render mode</td><td>HD sprite pack not installed</td><td>“HD mode requires an HD sprite resource pack. [Browse Workshop →] [Learn more about resource packs →]”</td></tr>
<tr><td>“Generate Assets” in Asset Studio</td><td>No LLM provider configured</td><td>“Asset generation uses an LLM to create sprites, palettes, and other resources. [Configure LLM Provider →]”</td></tr>
<tr><td>“Publish to Workshop”</td><td>No community server configured</td><td>“Publishing requires a community server account. [Set up community server →] [What is a community server? →]”</td></tr>
</tbody>
</table>
</div>
<p>This principle applies to <strong>every UI surface</strong> — game menus, SDK tools, lobby, settings, Workshop browser. No exceptions. The guidance panel is a lightweight overlay (not a modal dialog that blocks interaction), styled to match the active UI theme (D032), and dismissible with Escape or clicking outside.</p>
<p><strong>Why this matters:</strong></p>
<ul>
<li>Players discover features by clicking things. A greyed-out button teaches them “this doesn’t work” and they may never try again. A guidance panel teaches them “this works if you do X” and gets them there in one click.</li>
<li>Reduces support questions. Instead of “why is this button grey,” the UI answers the question before it’s asked.</li>
<li>Respects player intelligence. The player clicked the button because they wanted the feature — help them get it, don’t just say no.</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Hardcode one set of behaviors (rejected — this is what every other implementation does; we can do better)</li>
<li>Make QoL features mod-only (rejected — too important to bury behind modding; should be one click in settings, same as D019)</li>
<li>Only offer presets without individual toggles (rejected — power users need granular control; presets are starting points, not cages)</li>
<li>Bundle QoL into balance presets (rejected — “I want OpenRA’s attack-move but classic unit values” is a legitimate preference; conflating balance with UX is a design mistake)</li>
</ul>
<p><strong>Phase:</strong> Phase 3 (alongside D032 UI themes and sidebar work). QoL toggles are implemented as system-level config flags — each system checks its toggle on initialization. Preset YAML files are authored during Phase 2 (simulation) as features are built.</p>
<hr>
<hr>
<hr>
<h2 id="d041-trait-abstracted-subsystem-strategy--beyond-networking-and-pathfinding"><a class="header" href="#d041-trait-abstracted-subsystem-strategy--beyond-networking-and-pathfinding">D041: Trait-Abstracted Subsystem Strategy — Beyond Networking and Pathfinding</a></h2>
<p><strong>Decision:</strong> Extend the <code>NetworkModel</code>/<code>Pathfinder</code>/<code>SpatialIndex</code> trait-abstraction pattern to five additional engine subsystems that carry meaningful risk of regret if hardcoded: <strong>AI strategy, fog of war, damage resolution, ranking/matchmaking, and order validation</strong>. Each gets a formal trait in the engine, a default implementation in the RA1 game module, and the same “costs near-zero now, prevents rewrites later” guarantee.</p>
<p><strong>Context:</strong> The engine already trait-abstracts 14 subsystems (see inventory below, including Transport added by D054). These were designed individually — some as architectural invariants (D006 networking, D013 pathfinding), others as consequences of multi-game extensibility (D018 <code>GameModule</code>, <code>Renderable</code>, <code>FormatRegistry</code>). But several critical <em>algorithm-level</em> concerns remain hardcoded in RA1’s system implementations. For data-driven concerns (weather, campaigns, achievements, themes), YAML+Lua modding provides sufficient flexibility — no trait needed. For <em>algorithmic</em> concerns, the resolution logic itself is what varies between game types and modding ambitions.</p>
<p><strong>The principle:</strong> Abstract the <em>algorithm</em>, not the <em>data</em>. If a modder can change behavior through YAML values or Lua scripts, a trait is unnecessary overhead. If changing behavior requires replacing the <em>logic</em> — the decision-making process, the computation pipeline, the scoring formula — that’s where a trait prevents a future rewrite.</p>
<h3 id="inventory-already-trait-abstracted-14"><a class="header" href="#inventory-already-trait-abstracted-14">Inventory: Already Trait-Abstracted (14)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Crate</th><th>Decision</th><th>Phase</th></tr>
</thead>
<tbody>
<tr><td><code>NetworkModel</code></td><td>ic-net</td><td>D006</td><td>2</td></tr>
<tr><td><code>Pathfinder</code></td><td>ic-sim (trait), game module (impl)</td><td>D013</td><td>2</td></tr>
<tr><td><code>SpatialIndex</code></td><td>ic-sim (trait), game module (impl)</td><td>D013</td><td>2</td></tr>
<tr><td><code>InputSource</code></td><td>ic-game</td><td>D018</td><td>2</td></tr>
<tr><td><code>ScreenToWorld</code></td><td>ic-render</td><td>D018</td><td>1</td></tr>
<tr><td><code>Renderable</code> / <code>RenderPlugin</code></td><td>ic-render</td><td>D017/D018</td><td>1</td></tr>
<tr><td><code>GameModule</code></td><td>ic-game</td><td>D018</td><td>2</td></tr>
<tr><td><code>OrderCodec</code></td><td>ic-protocol</td><td>D007</td><td>5</td></tr>
<tr><td><code>TrackingServer</code></td><td>ic-net</td><td>D007</td><td>5</td></tr>
<tr><td><code>LlmProvider</code></td><td>ic-llm</td><td>D016</td><td>7</td></tr>
<tr><td><code>FormatRegistry</code> / <code>FormatLoader</code></td><td>ra-formats</td><td>D018</td><td>0</td></tr>
<tr><td><code>SimReconciler</code></td><td>ic-net</td><td>D011</td><td>Future</td></tr>
<tr><td><code>CommunityBridge</code></td><td>ic-net</td><td>D011</td><td>Future</td></tr>
<tr><td><code>Transport</code></td><td>ic-net</td><td>D054</td><td>5</td></tr>
</tbody>
</table>
</div>
<h3 id="new-trait-abstractions-5"><a class="header" href="#new-trait-abstractions-5">New Trait Abstractions (5)</a></h3>
<h4 id="1-aistrategy--pluggable-ai-decision-making"><a class="header" href="#1-aistrategy--pluggable-ai-decision-making">1. <code>AiStrategy</code> — Pluggable AI Decision-Making</a></h4>
<p><strong>Problem:</strong> <code>ic-ai</code> defines <code>AiPersonality</code> as a YAML-configurable parameter struct (aggression, tech preference, micro level) that tunes behavior within a fixed decision algorithm. This is great for balance knobs — but a modder who wants a fundamentally different AI approach (GOAP planner, Monte Carlo tree search, neural network, scripted state machine, or a tournament-specific meta-counter AI) cannot plug one in. They’d have to fork <code>ic-ai</code> or write a WASM mod that reimplements the entire AI from scratch.</p>
<p><strong>Solution:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Game modules and mods implement this to provide AI opponents.
/// The default RA1 implementation uses AiPersonality-driven behavior trees.
/// Mods can provide alternatives: planning-based, neural, procedural, etc.
pub trait AiStrategy: Send + Sync {
    /// Called once per AI player per tick. Reads visible game state, emits orders.
    fn decide(
        &amp;mut self,
        player: PlayerId,
        view: &amp;FogFilteredView,  // only what this player can see
        tick: u64,
    ) -&gt; Vec&lt;PlayerOrder&gt;;

    /// Human-readable name for lobby display.
    fn name(&amp;self) -&gt; &amp;str;

    /// Difficulty tier for matchmaking/UI categorization.
    fn difficulty(&amp;self) -&gt; AiDifficulty;

    /// Optional: per-tick compute budget hint (microseconds).
    fn tick_budget_hint(&amp;self) -&gt; Option&lt;u64&gt;;

    // --- Event callbacks (inspired by Spring Engine + BWAPI research) ---
    // Default implementations are no-ops. AIs override what they care about.
    // Events are pushed by the engine at the same pipeline point as decide(),
    // before the decide() call — so the AI can react within the same tick.

    /// Own unit finished construction/training.
    fn on_unit_created(&amp;mut self, _unit: EntityId, _unit_type: &amp;str) {}
    /// Own unit destroyed.
    fn on_unit_destroyed(&amp;mut self, _unit: EntityId, _attacker: Option&lt;EntityId&gt;) {}
    /// Own unit has no orders (idle).
    fn on_unit_idle(&amp;mut self, _unit: EntityId) {}
    /// Enemy unit enters line of sight.
    fn on_enemy_spotted(&amp;mut self, _unit: EntityId, _unit_type: &amp;str) {}
    /// Known enemy unit destroyed.
    fn on_enemy_destroyed(&amp;mut self, _unit: EntityId) {}
    /// Own unit taking damage.
    fn on_under_attack(&amp;mut self, _unit: EntityId, _attacker: EntityId) {}
    /// Own building completed.
    fn on_building_complete(&amp;mut self, _building: EntityId) {}
    /// Research/upgrade completed.
    fn on_research_complete(&amp;mut self, _tech: &amp;str) {}

    // --- Parameter introspection (inspired by MicroRTS research) ---
    // Enables: automated parameter tuning, UI-driven difficulty sliders,
    // tournament parameter search, AI vs AI evaluation.

    /// Expose tunable parameters for external configuration.
    fn get_parameters(&amp;self) -&gt; Vec&lt;ParameterSpec&gt; { vec![] }
    /// Set a parameter value (called by engine from YAML config or UI).
    fn set_parameter(&amp;mut self, _name: &amp;str, _value: i32) {}

    // --- Engine difficulty scaling (inspired by 0 A.D. + AoE2 research) ---

    /// Whether this AI uses engine-level difficulty scaling (resource bonuses,
    /// reaction delays, etc.). Default: true. Sophisticated AIs that handle
    /// difficulty internally can return false to opt out.
    fn uses_engine_difficulty_scaling(&amp;self) -&gt; bool { true }
}

pub enum AiDifficulty { Sandbox, Easy, Normal, Hard, Brutal, Custom(String) }

pub struct ParameterSpec {
    pub name: String,
    pub description: String,
    pub min_value: i32,
    pub max_value: i32,
    pub default_value: i32,
    pub current_value: i32,
}
<span class="boring">}</span></code></pre>
<p><strong>Key design points:</strong></p>
<ul>
<li><code>FogFilteredView</code> ensures AI honesty — no maphack by default. Campaign scripts can provide an omniscient view for specific AI players via conditions.</li>
<li><code>AiPersonality</code> becomes the configuration for the <em>default</em> <code>AiStrategy</code> implementation (<code>PersonalityDrivenAi</code>), not the only way to configure AI.</li>
<li><strong>Event callbacks</strong> (from Spring Engine/BWAPI research, see <code>research/rts-ai-extensibility-survey.md</code>) enable reactive AI without polling. Pure <code>decide()</code>-only AI works fine (events are optional), but event-aware AI can respond immediately to threats, idle units, and scouting information. Events fire before <code>decide()</code> in the same tick, so the AI can incorporate event data into its tick decision.</li>
<li><strong>Parameter introspection</strong> (from MicroRTS research) enables automated parameter tuning and UI-driven difficulty sliders. Every <code>AiStrategy</code> can expose its knobs — tournament systems use this for automated parameter search, the lobby UI uses it for “Advanced AI Settings” sliders.</li>
<li><strong>Engine difficulty scaling opt-out</strong> (from 0 A.D. + AoE2 research) lets sophisticated AIs handle difficulty internally. Simple AIs get engine-provided resource bonuses and reaction time delays; advanced AIs that model difficulty as behavioral parameters can opt out.</li>
<li>AI strategies are selectable in the lobby: “IC Default (Normal)”, “IC Default (Brutal)”, “Workshop: Neural Net v2.1”, etc.</li>
<li>WASM Tier 3 mods can provide <code>AiStrategy</code> implementations — the trait is part of the stable mod API surface.</li>
<li>Lua Tier 2 mods can script lightweight AI via the existing Lua API (trigger-based). <code>AiStrategy</code> trait is for full-replacement AI, not scripted behaviors.</li>
<li>Adaptive difficulty (D034 integration) is implemented inside the default strategy, not in the trait — it’s an implementation detail of <code>PersonalityDrivenAi</code>.</li>
<li>Determinism: <code>decide()</code> and all event callbacks are called at a fixed point in the system pipeline. All clients run the same AI with the same state → same orders. Mod-provided AI is subject to the same determinism requirements as any sim code.</li>
</ul>
<p><strong>Event accumulation — <code>AiEventLog</code>:</strong></p>
<p>The engine provides an <code>AiEventLog</code> utility struct to every <code>AiStrategy</code> instance. It accumulates fog-filtered events from the callbacks above into a structured, queryable log — the “inner game event log” that D044 (LLM-enhanced AI) consumes as its primary context source. Non-LLM AI can ignore the log entirely (zero cost if <code>to_narrative()</code> is never called); LLM-based AI uses it as the bridge between simulation events and natural-language prompts.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Accumulates fog-filtered game events into a structured log.
/// Provided by the engine to every AiStrategy instance. Events are pushed
/// into the log when callbacks fire — the AI gets both the callback
/// AND a persistent log entry.
pub struct AiEventLog {
    entries: CircularBuffer&lt;AiEventEntry&gt;,  // bounded, oldest entries evicted
    capacity: usize,                        // default: 1000 entries
}

pub struct AiEventEntry {
    pub tick: u64,
    pub event_type: AiEventType,
    pub description: String,  // human/LLM-readable summary
    pub entity: Option&lt;EntityId&gt;,
    pub related_entity: Option&lt;EntityId&gt;,
}

pub enum AiEventType {
    UnitCreated, UnitDestroyed, UnitIdle,
    EnemySpotted, EnemyDestroyed,
    UnderAttack, BuildingComplete, ResearchComplete,
    StrategicUpdate,  // injected by orchestrator AI when plan changes (D044)
}

impl AiEventLog {
    /// All events since a given tick (for periodic LLM consultations).
    pub fn since(&amp;self, tick: u64) -&gt; &amp;[AiEventEntry] { /* ... */ }

    /// Natural-language narrative summary — suitable for LLM prompts.
    /// Produces chronological text: "Tick 450: Enemy tank spotted near our
    /// expansion. Tick 460: Our refinery under attack by 3 enemy units."
    pub fn to_narrative(&amp;self, since_tick: u64) -&gt; String { /* ... */ }

    /// Structured summary — counts by event type, key entities, threat level.
    pub fn summary(&amp;self) -&gt; EventSummary { /* ... */ }
}
<span class="boring">}</span></code></pre>
<p>Key properties of the event log:</p>
<ul>
<li><strong>Fog-filtered by construction.</strong> All entries originate from the same callback pipeline that respects <code>FogFilteredView</code> — no event reveals information the AI shouldn’t have. This is the architectural guarantee the user asked for: the “action story / context” the LLM reads is honest.</li>
<li><strong>Bounded.</strong> Circular buffer with configurable capacity (default 1000 entries). Oldest entries are evicted. No unbounded memory growth.</li>
<li><strong><code>to_narrative(since_tick)</code></strong> generates a chronological natural-language account of events since a given tick — this is the “inner game event log / action story / context” that D044’s <code>LlmOrchestratorAi</code> sends to the LLM for strategic guidance.</li>
<li><strong><code>StrategicUpdate</code> event type.</strong> D044’s LLM orchestrator records its own plan changes into the log, creating a complete narrative that includes both game events and AI strategic decisions.</li>
<li><strong>Useful beyond LLM.</strong> Debug/spectator overlays for any AI (“what does this AI know?”), D042’s behavioral profile building, and replay analysis all benefit from a structured event log.</li>
<li><strong>Zero cost if unused.</strong> The engine pushes entries regardless (they’re cheap structs), but <code>to_narrative()</code> — the expensive serialization — is only called by consumers that need it.</li>
</ul>
<p><strong>Modder-selectable and modder-provided:</strong> The <code>AiStrategy</code> trait is open — not locked to first-party implementations. This follows the same pattern as <code>Pathfinder</code> (D013/D045) and render modes (D048):</p>
<ol>
<li><strong>Select</strong> any registered <code>AiStrategy</code> for a mod (e.g., a Generals total conversion uses a GOAP planner instead of behavior trees)</li>
<li><strong>Provide</strong> a custom <code>AiStrategy</code> via a Tier 3 WASM module and distribute it through the Workshop (D030)</li>
<li><strong>Use someone else’s</strong> community-created AI — declare it as a dependency in the mod manifest</li>
</ol>
<p>Unlike pathfinders (one axis: algorithm), AI has <strong>two orthogonal axes</strong>: which algorithm (<code>AiStrategy</code> impl) and how hard it plays (difficulty level). See D043 for the full two-axis difficulty system.</p>
<p><strong>What we build now:</strong> Only <code>PersonalityDrivenAi</code> (the existing YAML-configurable behavior). The trait exists from Phase 4 (when AI ships); alternative implementations are future work by us or the community.</p>
<p><strong>Phase:</strong> Phase 4 (AI &amp; Single Player).</p>
<h4 id="2-fogprovider--pluggable-fog-of-war-computation"><a class="header" href="#2-fogprovider--pluggable-fog-of-war-computation">2. <code>FogProvider</code> — Pluggable Fog of War Computation</a></h4>
<p><strong>Problem:</strong> <code>fog_system()</code> is system #21 in the RA1 pipeline. It computes visibility based on unit sight ranges — but the computation algorithm is baked into the system implementation. Different game modules need different fog models: radius-based (RA1), line-of-sight with elevation raycast (RA2/TS), hex-grid fog (non-C&amp;C mods), or even no fog at all (sandbox modes). The future fog-authoritative <code>NetworkModel</code> needs server-side fog computation that fundamentally differs from client-side — the same <code>FogProvider</code> trait would serve both.</p>
<p><strong>Solution:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Game modules implement this to define how visibility is computed.
/// The engine calls this from fog_system() — the system schedules the work,
/// the provider computes the result.
pub trait FogProvider: Send + Sync {
    /// Recompute visibility for a player. Called by fog_system() each tick
    /// (or staggered per 10-PERFORMANCE.md amortization rules).
    fn update_visibility(
        &amp;mut self,
        player: PlayerId,
        sight_sources: &amp;[(WorldPos, SimCoord)],  // (position, sight_range) pairs
        terrain: &amp;TerrainData,
    );

    /// Is this position visible to this player right now?
    fn is_visible(&amp;self, player: PlayerId, pos: WorldPos) -&gt; bool;

    /// Is this position explored (ever seen) by this player?
    fn is_explored(&amp;self, player: PlayerId, pos: WorldPos) -&gt; bool;

    /// Bulk query: all entity IDs visible to this player (for AI, render culling).
    fn visible_entities(&amp;self, player: PlayerId) -&gt; &amp;[EntityId];
}
<span class="boring">}</span></code></pre>
<p><strong>Key design points:</strong></p>
<ul>
<li>RA1 module registers <code>RadiusFogProvider</code> — simple circle-based visibility. Fast, cache-friendly, matches original RA behavior.</li>
<li>RA2/TS module would register <code>ElevationFogProvider</code> — raycasts against terrain heightmap for line-of-sight.</li>
<li>Non-C&amp;C mods could implement hex fog, cone-of-vision, or always-visible. Sandbox/debug modes: <code>NoFogProvider</code> (everything visible).</li>
<li>Fog-authoritative server (<code>FogAuthoritativeNetwork</code> from D006 future architectures) reuses the same <code>FogProvider</code> on the server side to determine which entities to send to each client.</li>
<li>Performance: <code>fog_system()</code> drives the amortization schedule (stagger updates per <code>10-PERFORMANCE.md</code>). The provider does the math; the system decides when to call it.</li>
<li>Shroud (unexplored terrain) vs. fog (explored but not currently visible) distinction is preserved in the trait via <code>is_visible()</code> vs. <code>is_explored()</code>.</li>
</ul>
<p><strong>What we build now:</strong> Only <code>RadiusFogProvider</code>. The trait exists from Phase 2; <code>ElevationFogProvider</code> ships when RA2/TS module development begins.</p>
<p><strong>Phase:</strong> Phase 2 (built alongside <code>fog_system()</code> in the sim).</p>
<h4 id="3-damageresolver--pluggable-damage-pipeline-resolution"><a class="header" href="#3-damageresolver--pluggable-damage-pipeline-resolution">3. <code>DamageResolver</code> — Pluggable Damage Pipeline Resolution</a></h4>
<p><strong>Problem:</strong> D028 defines the full damage pipeline: Armament → Projectile → Warhead → Versus table → multiplier stack → Health reduction. The <em>data</em> flowing through this pipeline is deeply moddable — warheads, versus tables, modifier stacks are all YAML-configurable. But the <em>resolution algorithm</em> — the order in which shields, armor, conditions, and multipliers are applied — is hardcoded in <code>projectile_system()</code>. A game module where shields absorb before armor checks, or where sub-object targeting distributes damage across components (Generals-style), or where damage types bypass armor entirely (TS ion storms) needs a different resolution order. These aren’t data changes — they’re algorithmic.</p>
<p><strong>Solution:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Game modules implement this to define how damage is resolved after
/// a warhead makes contact. The default RA1 implementation applies the
/// standard Versus table + modifier stack pipeline.
pub trait DamageResolver: Send + Sync {
    /// Resolve final damage from a warhead impact on a target.
    /// Called by projectile_system() after hit detection.
    fn resolve_damage(
        &amp;self,
        warhead: &amp;WarheadDef,
        target: &amp;DamageTarget,
        modifiers: &amp;StatModifiers,
        distance_from_impact: SimCoord,
    ) -&gt; DamageResult;
}

pub struct DamageTarget {
    pub entity: EntityId,
    pub armor_type: ArmorType,
    pub current_health: i32,
    pub shield: Option&lt;ShieldState&gt;,  // D029 shield system
    pub conditions: Conditions,
}

pub struct DamageResult {
    pub health_damage: i32,
    pub shield_damage: i32,
    pub conditions_applied: Vec&lt;(ConditionId, u32)&gt;,  // condition grants from warhead
    pub overkill: i32,  // excess damage (for death effects)
}
<span class="boring">}</span></code></pre>
<p><strong>Key design points:</strong></p>
<ul>
<li>The default <code>StandardDamageResolver</code> implements the RA1 pipeline from D028: Versus table lookup → distance falloff → multiplier stack → health reduction. This handles 95% of C&amp;C damage scenarios.</li>
<li>RA2 registers <code>ShieldFirstDamageResolver</code>: absorb shield → then armor → then health. Same trait, different algorithm.</li>
<li>Generals-class modules could register <code>SubObjectDamageResolver</code>: distributes damage across multiple hit zones per unit.</li>
<li>The trait boundary is <em>after hit detection</em> and <em>before health reduction</em>. Projectile flight, homing, and area-of-effect detection are shared infrastructure. Only the final damage-number calculation varies.</li>
<li>Warhead-applied conditions (e.g., “irradiated” from D028’s composable warhead design) flow through <code>DamageResult.conditions_applied</code> — the resolver decides which conditions apply based on its game’s rules.</li>
<li>WASM Tier 3 mods can provide custom resolvers for total conversions.</li>
</ul>
<p><strong>What we build now:</strong> Only <code>StandardDamageResolver</code>. The trait exists from Phase 2 (ships with D028). Shield-aware resolver ships when the D029 shield system lands.</p>
<p><strong>Phase:</strong> Phase 2 (ships with D028 damage pipeline).</p>
<h4 id="4-rankingprovider--pluggable-rating-and-matchmaking"><a class="header" href="#4-rankingprovider--pluggable-rating-and-matchmaking">4. <code>RankingProvider</code> — Pluggable Rating and Matchmaking</a></h4>
<p><strong>Problem:</strong> The competitive infrastructure (AGENTS.md) specifies Glicko-2 ratings, but the ranking algorithm is implemented directly in the relay/tracking server with no abstraction boundary. Tournament organizers and community servers may want Elo (simpler, well-understood), TrueSkill (better for team games), or custom rating systems (handicap-adjusted, seasonal decay variants, faction-specific ratings). Since tracking servers are community-hostable and federated (D030/D037), locking the rating algorithm to Glicko-2 limits what community operators can offer.</p>
<p><strong>Solution:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Tracking servers implement this to provide rating calculations.
/// The default implementation uses Glicko-2.
pub trait RankingProvider: Send + Sync {
    /// Calculate updated ratings after a match result.
    fn update_ratings(
        &amp;mut self,
        result: &amp;CertifiedMatchResult,
        current_ratings: &amp;[PlayerRating],
    ) -&gt; Vec&lt;PlayerRating&gt;;

    /// Estimate match quality / fairness for proposed matchmaking.
    fn match_quality(&amp;self, team_a: &amp;[PlayerRating], team_b: &amp;[PlayerRating]) -&gt; MatchQuality;

    /// Rating display for UI (e.g., "1500 ± 200" for Glicko, "Silver II" for league).
    fn display_rating(&amp;self, rating: &amp;PlayerRating) -&gt; String;

    /// Algorithm identifier for interop (ratings from different algorithms aren't comparable).
    fn algorithm_id(&amp;self) -&gt; &amp;str;
}

pub struct PlayerRating {
    pub player_id: PlayerId,
    pub rating: i64,        // fixed-point, algorithm-specific
    pub deviation: i64,     // uncertainty (Glicko RD, TrueSkill σ)
    pub volatility: i64,    // Glicko-2 specific; other algorithms may ignore
    pub games_played: u32,
}

pub struct MatchQuality {
    pub fairness: i32,      // 0-1000 (fixed-point), higher = more balanced
    pub estimated_draw_probability: i32,  // 0-1000 (fixed-point)
}
<span class="boring">}</span></code></pre>
<p><strong>Key design points:</strong></p>
<ul>
<li>Default: <code>Glicko2Provider</code> — well-suited for 1v1 and small teams, proven in chess and competitive gaming. Validated by Valve’s CS Regional Standings (see <code>research/valve-github-analysis.md</code> § Part 4), which uses Glicko with RD fixed at 75 for team competitive play.</li>
<li>Community operators provide alternatives: <code>EloProvider</code> (simpler), <code>TrueSkillProvider</code> (better team rating), or custom implementations.</li>
<li><code>algorithm_id()</code> prevents mixing ratings from different algorithms — a Glicko-2 “1800” is not an Elo “1800”.</li>
<li><code>CertifiedMatchResult</code> (from relay server, D007) is the input — no self-reported results.</li>
<li>Ratings stored in SQLite (D034) on the tracking server.</li>
<li>The official tracking server uses Glicko-2. Community tracking servers choose their own.</li>
<li>Fixed-point ratings (matching sim math conventions) — no floating-point in the ranking pipeline.</li>
</ul>
<p><strong>Information content weighting (from Valve CS Regional Standings):</strong> The <code>match_quality()</code> method returns a <code>MatchQuality</code> struct that includes an <code>information_content</code> field (0–1000, fixed-point). This parameter scales how much a match affects rating changes — low-information matches (casual, heavily mismatched, very short duration) contribute less to rating updates, while high-information matches (ranked, well-matched, full-length) contribute more. This prevents rating inflation/deflation from low-quality matches. For IC, information content is derived from: (1) game mode (ranked vs. casual), (2) player count balance (1v1 is higher information than 3v1), (3) game duration (very short games may indicate disconnection, not skill), (4) map symmetry rating (if available). See <code>research/valve-github-analysis.md</code> § 4.2.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MatchQuality {
    pub fairness: i32,                // 0-1000 (fixed-point), higher = more balanced
    pub estimated_draw_probability: i32,  // 0-1000 (fixed-point)
    pub information_content: i32,     // 0-1000 (fixed-point), scales rating impact
}
<span class="boring">}</span></code></pre>
<p><strong>New player seeding (from Valve CS Regional Standings):</strong> New players entering ranked play are seeded using a weighted combination of calibration performance and opponent quality — not placed at a flat default rating:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Seeding formula for new players completing calibration.
/// Inspired by Valve's CS seeding (bounty, opponent network, LAN factor).
/// IC adapts: no prize money, but the weighted-combination approach is sound.
pub struct SeedingResult {
    pub initial_rating: i64,       // Fixed-point, mapped into rating range
    pub initial_deviation: i64,    // Higher than settled players (fast convergence)
}

/// Inputs to the seeding formula:
/// - calibration_performance: win rate across calibration matches (0-1000)
/// - opponent_quality: average rating of calibration opponents (fixed-point)
/// - match_count: number of calibration matches played
/// The seed is mapped into the rating range (e.g., 800–1800 for Glicko-2).
<span class="boring">}</span></code></pre>
<p>This prevents the cold-start problem where a skilled player placed at 1500 stomps their way through dozens of mismatched games before reaching their true rating. Valve’s system proved that even ~5–10 calibration matches with quality weighting produce a dramatically better initial placement.</p>
<p><strong>Ranking visibility thresholds (from Valve CS Regional Standings):</strong></p>
<ul>
<li><strong>Minimum 5 matches</strong> to appear on leaderboards — prevents noise from one-game players.</li>
<li><strong>Must have defeated at least 1 distinct opponent</strong> — prevents collusion (two friends repeatedly playing each other to inflate ratings).</li>
<li><strong>RD decay for inactivity:</strong> <code>sqrt(rd² + C²*t)</code> where C=34.6, t=rating periods since last match. Inactive players’ ratings become less certain, naturally widening their matchmaking range until they play again.</li>
</ul>
<p><strong>Ranking model validation (from Valve CS Regional Standings):</strong> The <code>Glicko2Provider</code> implementation logs <strong>expected win probabilities alongside match results</strong> from day one. This enables post-hoc model validation using the methodology Valve describes: (1) bin expected win rates into 5% buckets, (2) compare expected vs. observed win rates within each bucket, (3) compute Spearman’s rank correlation (ρ). Valve achieved ρ = 0.98 — excellent. IC targets ρ ≥ 0.95 as a health threshold; below that triggers investigation of the rating model parameters. This data feeds into the OTEL telemetry pipeline (D031) and is visible on the Grafana dashboard for community server operators. See <code>research/valve-github-analysis.md</code> § 4.5.</p>
<p><strong>What we build now:</strong> Only <code>Glicko2Provider</code>. The trait exists from Phase 5 (when competitive infrastructure ships). Alternative providers are community work.</p>
<p><strong>Phase:</strong> Phase 5 (Multiplayer &amp; Competitive).</p>
<h4 id="5-ordervalidator--explicit-per-module-order-validation"><a class="header" href="#5-ordervalidator--explicit-per-module-order-validation">5. <code>OrderValidator</code> — Explicit Per-Module Order Validation</a></h4>
<p><strong>Problem:</strong> D012 mandates that every order is validated inside the sim before execution, deterministically. Currently, validation is implicit — it happens inside <code>apply_orders()</code>, which is part of the game module’s system pipeline. This works because <code>GameModule::system_pipeline()</code> lets each module define its own <code>apply_orders()</code> implementation. But the validation contract is informal: nothing in the architecture <em>requires</em> a game module to validate orders, or specifies what validation means. A game module that forgets validation breaks the anti-cheat guarantee (D012) silently.</p>
<p><strong>Solution:</strong> Add <code>order_validator()</code> to the <code>GameModule</code> trait, making validation an explicit, required contract:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Added to GameModule trait (D018):
pub trait GameModule: Send + Sync + 'static {
    // ... existing methods ...

    /// Provide the module's order validation logic.
    /// Called by the engine before apply_orders() — not by the module's own systems.
    /// The engine enforces that ALL orders pass validation before execution.
    fn order_validator(&amp;self) -&gt; Box&lt;dyn OrderValidator&gt;;
}

/// Game modules implement this to define legal orders.
/// The engine calls this for EVERY order, EVERY tick — the game module
/// cannot accidentally skip validation.
pub trait OrderValidator: Send + Sync {
    /// Validate an order against current game state.
    /// Returns Valid or Rejected with a reason for logging/anti-cheat.
    fn validate(
        &amp;self,
        player: PlayerId,
        order: &amp;PlayerOrder,
        state: &amp;SimReadView,
    ) -&gt; OrderValidity;
}

pub enum OrderValidity {
    Valid,
    Rejected(RejectionReason),
}

pub enum RejectionReason {
    NotOwner,
    InsufficientFunds,
    MissingPrerequisite,
    InvalidPlacement,
    CooldownActive,
    InvalidTarget,
    RateLimited,       // OrderBudget exceeded (D006 security)
    Custom(String),    // game-module-specific reasons
}
<span class="boring">}</span></code></pre>
<p><strong>Key design points:</strong></p>
<ul>
<li>The engine (not the game module) calls <code>validate()</code> before <code>apply_orders()</code>. This means a game module <em>cannot</em> skip validation — the architecture enforces D012’s anti-cheat guarantee.</li>
<li><code>SimReadView</code> is a read-only view of sim state — the validator cannot mutate game state.</li>
<li><code>RejectionReason</code> includes standard reasons (shared across all game modules) plus <code>Custom</code> for game-specific rules.</li>
<li>Repeated rejections from the same player are logged for anti-cheat pattern detection (existing D012 design, now formalized).</li>
<li>The default RA1 implementation validates ownership, affordability, prerequisites, placement rules, and rate limits. RA2 would add superweapon authorization, garrison capacity checks, etc.</li>
<li>This is the lowest-risk trait in the set — it formalizes what <code>apply_orders()</code> already does informally. The cost is moving validation from “inside the first system” to “explicit engine-level contract.”</li>
</ul>
<p><strong>What we build now:</strong> RA1 <code>StandardOrderValidator</code>. The trait exists from Phase 2.</p>
<p><strong>Phase:</strong> Phase 2 (ships with <code>apply_orders()</code>).</p>
<h3 id="costbenefit-analysis"><a class="header" href="#costbenefit-analysis">Cost/Benefit Analysis</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Cost Now</th><th>Prevents Later</th></tr>
</thead>
<tbody>
<tr><td><code>AiStrategy</code></td><td>One trait + <code>PersonalityDrivenAi</code> wrapper</td><td>Community AI cannot plug in without forking ic-ai</td></tr>
<tr><td><code>FogProvider</code></td><td>One trait + <code>RadiusFogProvider</code></td><td>RA2 elevation fog requires rewriting fog_system(); fog-authoritative server requires separate fog codebase</td></tr>
<tr><td><code>DamageResolver</code></td><td>One trait + <code>StandardDamageResolver</code></td><td>Shield/sub-object games require rewriting projectile_system()</td></tr>
<tr><td><code>RankingProvider</code></td><td>One trait + <code>Glicko2Provider</code></td><td>Community tracking servers stuck with one rating algorithm</td></tr>
<tr><td><code>OrderValidator</code></td><td>One trait + explicit validate() call</td><td>Game modules can silently skip validation; anti-cheat guarantee is informal</td></tr>
</tbody>
</table>
</div>
<p>All five follow the established pattern: <strong>one trait definition + one default implementation with near-zero architectural cost</strong>. Dispatch strategy is subsystem-dependent (profiling decides, not dogma). The architectural cost is 5 trait definitions (~50 lines total) and 5 wrapper implementations (~200 lines total). The benefit is that none of these subsystems becomes a rewrite-required bottleneck when game modules, mods, or community servers need different behavior.</p>
<h3 id="what-does-not-need-a-trait"><a class="header" href="#what-does-not-need-a-trait">What Does NOT Need a Trait</a></h3>
<p>These subsystems are already sufficiently modular through data-driven design (YAML/Lua/WASM):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Subsystem</th><th>Why No Trait Needed</th></tr>
</thead>
<tbody>
<tr><td>Weather (D022)</td><td>State machine defined in YAML, transitions driven by Lua. Algorithm is trivial; data is everything.</td></tr>
<tr><td>Campaign (D021)</td><td>Graph structure in YAML, logic in Lua. The campaign engine runs any graph; no algorithmic variation needed.</td></tr>
<tr><td>Achievements (D036)</td><td>Definitions in YAML, triggers in Lua. Storage in SQLite. No algorithm to swap.</td></tr>
<tr><td>UI Themes (D032)</td><td>Pure YAML + sprite sheets. No computation to abstract.</td></tr>
<tr><td>QoL Toggles (D033)</td><td>YAML config flags. Each toggle is a sim-affecting or client-only boolean.</td></tr>
<tr><td>Audio (P003)</td><td>Bevy abstracts the audio backend. <code>ic-audio</code> is a Bevy plugin, not an algorithm.</td></tr>
<tr><td>Balance Presets (D019)</td><td>YAML rule sets. Switching preset = loading different YAML.</td></tr>
</tbody>
</table>
</div>
<p>The distinction: <strong>traits abstract algorithms; YAML/Lua abstracts data and behavior parameters.</strong> A damage <em>formula</em> is an algorithm (trait). A damage <em>value</em> is data (YAML). An AI <em>decision process</em> is an algorithm (trait). An AI <em>aggression level</em> is a parameter (YAML).</p>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Trait-abstract everything (rejected — unnecessary overhead for data-driven systems; violates D015’s “no speculative abstractions” principle from D018)</li>
<li>Trait-abstract nothing new (rejected — the 5 identified systems carry real risk of regret; the <code>NetworkModel</code> pattern has proven its value; the cost is near-zero)</li>
<li>Abstract only AI and fog (rejected — damage resolution and ranking carry comparable risk, and <code>OrderValidator</code> formalizes an existing implicit contract)</li>
</ul>
<p><strong>Relationship to existing decisions:</strong></p>
<ul>
<li>Extends D006’s philosophy (“pluggable via trait”) to 5 new subsystems</li>
<li>Extends D013’s pattern (“trait-abstracted, default impl first”) identically</li>
<li>Extends D018’s <code>GameModule</code> trait with <code>order_validator()</code></li>
<li>Supports D028 (damage pipeline) by abstracting the resolution step</li>
<li>Supports D029 (shield system) by allowing shield-first damage resolution</li>
<li>Supports future fog-authoritative server (D006 future architecture)</li>
<li>Extended by D054 (Transport trait, SignatureScheme enum, SnapshotCodec version dispatch) — one additional trait and two version-dispatched mechanisms identified by architecture switchability audit</li>
</ul>
<p><strong>Phase:</strong> Trait definitions exist from the phase each subsystem ships (Phase 2–5). Alternative implementations are future work.</p>
<hr>
<hr>
<h2 id="d042-player-behavioral-profiles--training-system--the-black-box"><a class="header" href="#d042-player-behavioral-profiles--training-system--the-black-box">D042: Player Behavioral Profiles &amp; Training System — The Black Box</a></h2>
<p><strong>Status:</strong> Accepted
<strong>Scope:</strong> <code>ic-ai</code>, <code>ic-ui</code>, <code>ic-llm</code> (optional), <code>ic-sim</code> (read-only), D034 SQLite extension
<strong>Phase:</strong> Core profiles + quick training: Phase 4–5. LLM coaching loop: Phase 7.</p>
<h3 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h3>
<p>Every gameplay session generates rich structured data (D031 <code>GameplayEvent</code> stream, D034 SQLite storage). Today this data feeds:</p>
<ul>
<li>Post-game stats and career analytics (<code>ic-ui</code>)</li>
<li>Adaptive AI difficulty and counter-strategy (<code>ic-ai</code>, between-game queries)</li>
<li>LLM personalization: coaching suggestions, post-match commentary, rivalry narratives (<code>ic-llm</code>, optional)</li>
<li>Replay-to-scenario pipeline: extract one replay’s behavior into AI modules (<code>ic-editor</code> + <code>ic-ai</code>, D038)</li>
</ul>
<p>But three capabilities are missing:</p>
<ol>
<li>
<p><strong>Aggregated player style profiles.</strong> The replay-to-scenario pipeline extracts behavior from <em>one</em> replay. The adaptive AI mentions “per-player gameplay patterns” but only for difficulty tuning, not for creating a reusable AI opponent. There’s no cross-game model that captures <em>how a specific player tends to play</em> — their preferred build orders, timing windows, unit composition habits, engagement style, faction tendencies — aggregated from all recorded games.</p>
</li>
<li>
<p><strong>Quick training mode.</strong> Training against a human’s style currently requires the full scenario editor pipeline (import replay → configure extraction → save → play). There’s no “pick an opponent from your match history and play against their style on any map right now” flow.</p>
</li>
<li>
<p><strong>Iterative training loop with progress tracking.</strong> Coaching suggestions exist as one-off readouts. There’s no structured system for: play → get coached → play again with targeted AI → measure improvement → repeat. No weakness tracking over time.</p>
</li>
</ol>
<h3 id="the-black-box-concept"><a class="header" href="#the-black-box-concept">The Black Box Concept</a></h3>
<p>Every match produces a <em>flight recorder</em> — a structured event log informative enough that an AI system (rule-based or LLM) can reconstruct:</p>
<ul>
<li><strong>What happened</strong> — build timelines, army compositions, engagement sequences, resource curves</li>
<li><strong>How the player plays</strong> — timing patterns, aggression level, unit preferences, micro tendencies, strategic habits</li>
<li><strong>Where the player struggles</strong> — loss patterns, weaknesses by faction/map/timing, unit types with poor survival rates</li>
</ul>
<p>The gameplay event stream (D031) already captures this data. D042 adds the systems that <em>interpret</em> it: profile building, profile-driven AI, and a training workflow that uses both.</p>
<h3 id="player-style-profiles"><a class="header" href="#player-style-profiles">Player Style Profiles</a></h3>
<p>A <code>PlayerStyleProfile</code> aggregates gameplay patterns across multiple games into a reusable behavioral model:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Aggregated behavioral model built from gameplay event history.
/// Drives StyleDrivenAi and training recommendations.
pub struct PlayerStyleProfile {
    pub player_id: HashedPlayerId,
    pub games_analyzed: u32,
    pub last_updated: Timestamp,

    // Strategic tendencies (averages across games)
    pub preferred_factions: Vec&lt;(String, f32)&gt;,         // faction → usage rate
    pub avg_expansion_timing: FixedPoint,               // ticks until first expansion
    pub avg_first_attack_timing: FixedPoint,            // ticks until first offensive
    pub build_order_templates: Vec&lt;BuildOrderTemplate&gt;, // most common opening sequences
    pub unit_composition_profile: UnitCompositionProfile, // preferred unit mix by game phase
    pub aggression_index: FixedPoint,                   // 0.0 = turtle, 1.0 = all-in rusher
    pub tech_priority: TechPriority,                    // rush / balanced / fast-tech
    pub resource_efficiency: FixedPoint,                // avg resource utilization rate
    pub micro_intensity: FixedPoint,                    // orders-per-unit-per-minute

    // Engagement patterns
    pub preferred_attack_directions: Vec&lt;MapQuadrant&gt;,  // where they tend to attack from
    pub retreat_threshold: FixedPoint,                  // health % at which units disengage
    pub multi_prong_frequency: FixedPoint,              // how often they split forces

    // Weakness indicators (for training)
    pub loss_patterns: Vec&lt;LossPattern&gt;,                // recurring causes of defeat
    pub weak_matchups: Vec&lt;(String, FixedPoint)&gt;,       // faction/strategy → loss rate
    pub underused_counters: Vec&lt;String&gt;,                // unit types available but rarely built
}
<span class="boring">}</span></code></pre>
<p><strong>How profiles are built:</strong></p>
<ul>
<li><code>ic-ai</code> runs aggregation queries against the SQLite <code>gameplay_events</code> and <code>match_players</code> tables at profile-build time (not during matches)</li>
<li>Profile building is triggered after each completed match and cached in a new <code>player_profiles</code> SQLite table</li>
<li>For the local player: full data from all local games</li>
<li>For opponents: data reconstructed from matches where you were a participant — you can only model players you’ve actually played against, using the events visible in those shared sessions</li>
</ul>
<p><strong>Privacy:</strong> Opponent profiles are built entirely from your local replay data. No data is fetched from other players’ machines. You see their behavior <em>from your games with them</em>, not from their solo play. No profile data is exported or shared unless the player explicitly opts in.</p>
<h4 id="sqlite-extension-d034"><a class="header" href="#sqlite-extension-d034">SQLite Extension (D034)</a></h4>
<pre><code class="language-sql">-- Player style profiles (D042 — cached aggregated behavior models)
CREATE TABLE player_profiles (
    id              INTEGER PRIMARY KEY,
    player_id_hash  TEXT NOT NULL UNIQUE,  -- hashed player identifier
    display_name    TEXT,                  -- last known display name
    games_analyzed  INTEGER NOT NULL,
    last_updated    TEXT NOT NULL,
    profile_json    TEXT NOT NULL,         -- serialized PlayerStyleProfile
    is_local        INTEGER NOT NULL DEFAULT 0  -- 1 for the local player's own profile
);

-- Training session tracking (D042 — iterative improvement measurement)
CREATE TABLE training_sessions (
    id              INTEGER PRIMARY KEY,
    started_at      TEXT NOT NULL,
    target_weakness TEXT NOT NULL,         -- what weakness this session targets
    opponent_profile TEXT,                 -- player_id_hash of the style being trained against
    map_name        TEXT NOT NULL,
    result          TEXT,                  -- 'victory', 'defeat', null if incomplete
    duration_ticks  INTEGER,
    weakness_score_before REAL,            -- measured weakness metric before session
    weakness_score_after  REAL,            -- measured weakness metric after session
    notes_json      TEXT                   -- LLM-generated or rule-based coaching notes
);
</code></pre>
<h3 id="style-driven-ai"><a class="header" href="#style-driven-ai">Style-Driven AI</a></h3>
<p>A new <code>AiStrategy</code> implementation (extends D041) that reads a <code>PlayerStyleProfile</code> and approximates that player’s behavior:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// AI strategy that mimics a specific player's style from their profile.
pub struct StyleDrivenAi {
    profile: PlayerStyleProfile,
    variance: FixedPoint,  // 0.0 = exact reproduction, 1.0 = loose approximation
    difficulty_scale: FixedPoint,  // adjusts execution speed/accuracy
}

impl AiStrategy for StyleDrivenAi {
    fn name(&amp;self) -&gt; &amp;str { "style_driven" }

    fn decide(&amp;self, world: &amp;World, player: PlayerId, budget: &amp;mut TickBudget) -&gt; Vec&lt;PlayerOrder&gt; {
        // 1. Check game phase (opening / mid / late) from tick count + base count
        // 2. Select build order template from profile.build_order_templates
        //    (with variance: slight timing jitter, occasional substitution)
        // 3. Match unit composition targets from profile.unit_composition_profile
        // 4. Engagement decisions use profile.aggression_index and retreat_threshold
        // 5. Attack timing follows profile.avg_first_attack_timing (± variance)
        // 6. Multi-prong attacks at profile.multi_prong_frequency rate
        todo!()
    }

    fn difficulty(&amp;self) -&gt; AiDifficulty { AiDifficulty::Custom }
    fn tick_budget_hint(&amp;self) -&gt; Duration { Duration::from_micros(200) }
}
<span class="boring">}</span></code></pre>
<p><strong>Relationship to existing <code>ReplayBehaviorExtractor</code> (D038):</strong> The extractor converts one replay into scripted AI waypoints/triggers (deterministic, frame-level). <code>StyleDrivenAi</code> is different — it reads an aggregated <em>profile</em> and makes real-time decisions based on tendencies, not a fixed script. The extractor says “at tick 300, build a Barracks at (120, 45).” <code>StyleDrivenAi</code> says “this player tends to build a Barracks within the first 250–350 ticks, usually near their War Factory” — then adapts to the actual game state. Both are useful:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>System</th><th>Input</th><th>Output</th><th>Fidelity</th><th>Replayability</th></tr>
</thead>
<tbody>
<tr><td><code>ReplayBehaviorExtractor</code> (D038)</td><td>One replay file</td><td>Scripted AI modules (waypoints, timed triggers)</td><td>High — frame-level reproduction of one game</td><td>Low — same script every time (mitigated by Probability of Presence)</td></tr>
<tr><td><code>StyleDrivenAi</code> (D042)</td><td>Aggregated <code>PlayerStyleProfile</code></td><td>Real-time AI decisions based on tendencies</td><td>Medium — captures style, not exact moves</td><td>High — different every game because it reacts to the actual situation</td></tr>
</tbody>
</table>
</div>
<h3 id="quick-training-mode"><a class="header" href="#quick-training-mode">Quick Training Mode</a></h3>
<p>A streamlined UI flow that bypasses the scenario editor entirely:</p>
<p><strong>“Train Against” flow:</strong></p>
<ol>
<li>Open match history or player profile screen</li>
<li>Click “Train Against [Player Name]” on any opponent you’ve encountered</li>
<li>Pick a map (or let the system choose one matching your weak matchups)</li>
<li>The engine generates a temporary scenario: your starting position + <code>StyleDrivenAi</code> loaded with that opponent’s profile</li>
<li>Play immediately — no editor, no saving, no publishing</li>
</ol>
<p><strong>“Challenge My Weakness” flow:</strong></p>
<ol>
<li>Open training menu (accessible from main menu)</li>
<li>System shows your weakness summary: “You lose 68% of games against Allied air rushes” / “Your expansion timing is slow (6:30 vs. 4:15 average)”</li>
<li>Click a weakness → system auto-generates a training scenario:
<ul>
<li>Selects a map that exposes the weakness (e.g., map with air-favorable terrain)</li>
<li>Configures AI to exploit that specific weakness (aggressive air build)</li>
<li>Sets appropriate difficulty (slightly above your current level)</li>
</ul>
</li>
<li>Play → post-match summary highlights whether the weakness improved</li>
</ol>
<p><strong>Implementation:</strong></p>
<ul>
<li><code>ic-ui</code> provides the training screens (match history integration, weakness display, map picker)</li>
<li><code>ic-ai</code> provides <code>StyleDrivenAi</code> + weakness analysis queries + temporary scenario generation</li>
<li>No <code>ic-editor</code> dependency — training scenarios are generated programmatically and never saved to disk (unless the player explicitly exports them)</li>
<li>The temporary scenario uses the same sim infrastructure as any skirmish — <code>LocalNetwork</code> (D006), standard map loading, standard game loop</li>
</ul>
<h3 id="iterative-training-loop"><a class="header" href="#iterative-training-loop">Iterative Training Loop</a></h3>
<p>Training isn’t one session — it’s a cycle with tracked progress:</p>
<pre><code>┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│  Analyze        │────▶│  Train           │────▶│  Review         │
│  (identify      │     │  (play targeted  │     │  (measure       │
│  weaknesses)    │     │  session)        │     │  improvement)   │
└─────────────────┘     └──────────────────┘     └─────────────────┘
        ▲                                                │
        └────────────────────────────────────────────────┘
                         next cycle
</code></pre>
<p><strong>Without LLM (always available):</strong></p>
<ul>
<li>Weakness identification: rule-based analysis of <code>gameplay_events</code> aggregates — loss rate by faction/map/timing window, unit survival rates, resource efficiency compared to wins</li>
<li>Training scenario generation: map + AI configuration targeting the weakness</li>
<li>Progress tracking: <code>training_sessions</code> table records before/after weakness scores per area</li>
<li>Post-session summary: structured stats comparison (“Your anti-air unit production increased from 2.1 to 4.3 per game. Survival rate against air improved 12%.”)</li>
</ul>
<p><strong>With LLM (optional, BYOLLM — D016):</strong></p>
<ul>
<li>Natural language training plans: “Week 1: Focus on expansion timing. Session 1: Practice fast expansion against passive AI. Session 2: Defend early rush while expanding. Session 3: Full game with aggressive opponent.”</li>
<li>Post-session coaching: “You expanded at 4:45 this time — 90 seconds faster than your average. But you over-invested in base defense, delaying your tank push by 2 minutes. Next session, try lighter defenses.”</li>
<li>Contextual tips during weakness review: “PlayerX always opens with two Barracks into Ranger rush. Build a Pillbox at your choke point before your second Refinery.”</li>
<li>LLM reads <code>training_sessions</code> history to track multi-session arcs: “Over 5 sessions, your anti-air response time improved from 45s to 18s. Let’s move on to defending naval harassment.”</li>
</ul>
<h3 id="what-this-is-not"><a class="header" href="#what-this-is-not">What This Is NOT</a></h3>
<ul>
<li><strong>Not machine learning during gameplay.</strong> All profile building and analysis happens between sessions, reading SQLite. The sim remains deterministic (invariant #1).</li>
<li><strong>Not a replay bot.</strong> <code>StyleDrivenAi</code> makes real-time strategic decisions informed by tendencies, not a frame-by-frame replay script. It adapts to the actual game state.</li>
<li><strong>Not surveillance.</strong> Opponent profiles are built from your local data only. You cannot fetch another player’s solo games, ranked history, or private matches. You model what you’ve seen firsthand.</li>
<li><strong>Not required.</strong> The training system is entirely optional. Players can ignore it and play skirmish/multiplayer normally. No game mode requires a profile to exist.</li>
</ul>
<h3 id="crate-boundaries"><a class="header" href="#crate-boundaries">Crate Boundaries</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Crate</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>PlayerStyleProfile</code> struct</td><td><code>ic-ai</code></td><td>Behavioral model — part of AI system</td></tr>
<tr><td><code>StyleDrivenAi</code> (AiStrategy impl)</td><td><code>ic-ai</code></td><td>AI decision-making logic</td></tr>
<tr><td>Profile aggregation queries</td><td><code>ic-ai</code></td><td>Reads SQLite <code>gameplay_events</code> + <code>match_players</code></td></tr>
<tr><td>Training UI (match history, weakness display, map picker)</td><td><code>ic-ui</code></td><td>Player-facing screens</td></tr>
<tr><td>Temporary scenario generation</td><td><code>ic-ai</code></td><td>Programmatic scenario setup without <code>ic-editor</code></td></tr>
<tr><td>Training session recording</td><td><code>ic-ui</code> + <code>ic-ai</code></td><td>Writes <code>training_sessions</code> to SQLite after each session</td></tr>
<tr><td>LLM coaching + training plans</td><td><code>ic-llm</code></td><td>Optional — reads <code>training_sessions</code> + <code>player_profiles</code></td></tr>
<tr><td>SQLite schema (<code>player_profiles</code>, <code>training_sessions</code>)</td><td><code>ic-game</code></td><td>Schema migration on startup, like all D034 tables</td></tr>
</tbody>
</table>
</div>
<p><code>ic-editor</code> is NOT involved in quick training mode. The scenario editor’s replay-to-scenario pipeline (D038) remains separate — it’s for creating publishable community content, not ephemeral training matches.</p>
<h3 id="consumers-of-player-data-d034-extension"><a class="header" href="#consumers-of-player-data-d034-extension">Consumers of Player Data (D034 Extension)</a></h3>
<p>Two new rows for the D034 consumer table:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Consumer</th><th>Crate</th><th>What it reads</th><th>What it produces</th><th>Required?</th></tr>
</thead>
<tbody>
<tr><td><strong>Player style profiles</strong></td><td><code>ic-ai</code></td><td><code>gameplay_events</code>, <code>match_players</code>, <code>matches</code></td><td><code>player_profiles</code> table — aggregated behavioral models for local player + opponents</td><td>Always on (profile building)</td></tr>
<tr><td><strong>Training system</strong></td><td><code>ic-ai</code> + <code>ic-ui</code></td><td><code>player_profiles</code>, <code>training_sessions</code>, <code>gameplay_events</code></td><td>Quick training scenarios, weakness analysis, progress tracking</td><td>Always on (training UI)</td></tr>
</tbody>
</table>
</div>
<h3 id="relationship-to-existing-decisions"><a class="header" href="#relationship-to-existing-decisions">Relationship to Existing Decisions</a></h3>
<ul>
<li><strong>D031 (telemetry):</strong> Gameplay events are the raw data. D042 adds interpretation — the <code>GameplayEvent</code> stream is the black box recorder; the profile builder is the flight data analyst.</li>
<li><strong>D034 (SQLite):</strong> Two new tables (<code>player_profiles</code>, <code>training_sessions</code>). Same patterns: schema migration, read-only consumers, local-first.</li>
<li><strong>D038 (replay-to-scenario):</strong> Complementary, not overlapping. D038 extracts one replay into a publishable scenario. D042 aggregates many games into a live AI personality. D038 produces scripts; D042 produces strategies.</li>
<li><strong>D041 (trait abstraction):</strong> <code>StyleDrivenAi</code> implements the <code>AiStrategy</code> trait. Same plug-in pattern — the engine doesn’t know it’s running a profile-driven AI vs. a scripted one.</li>
<li><strong>D016 (BYOLLM):</strong> LLM coaching is optional. Without it, the rule-based weakness identification and structured summary system works standalone.</li>
<li><strong>D010 (snapshots):</strong> Training sessions use standard sim snapshots for save/restore. No special infrastructure needed.</li>
</ul>
<h3 id="alternatives-considered"><a class="header" href="#alternatives-considered">Alternatives Considered</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Alternative</th><th>Why Not</th></tr>
</thead>
<tbody>
<tr><td>ML model trained on replays (neural-net opponent)</td><td>Too complex, non-deterministic, opaque behavior, requires GPU inference during gameplay. Profile-driven rule selection is transparent and runs in microseconds.</td></tr>
<tr><td>Server-side profile building</td><td>Conflicts with local-first principle. Opponent profiles come from your replays, not a central database. Server could aggregate opt-in community profiles in the future, but the base system is entirely local.</td></tr>
<tr><td>Manual profile creation (“custom AI personality editor”)</td><td>Useful but separate. D042 is about automated profile extraction. A manual personality editor is a future nice-to-have that reads/writes the same <code>PlayerStyleProfile</code> struct — the systems compose.</td></tr>
<tr><td>Integrate training into scenario editor only</td><td>Too much friction for casual training. The editor is for content creation; training is a play mode. Different UX goals.</td></tr>
</tbody>
</table>
</div>
<p><strong>Phase:</strong> Profile building infrastructure ships in <strong>Phase 4</strong> (available for single-player training against AI tendencies). Opponent profile building and “Train Against” flow ship in <strong>Phase 5</strong> (requires multiplayer match data). LLM coaching loop ships in <strong>Phase 7</strong> (optional BYOLLM). The <code>training_sessions</code> table and progress tracking ship alongside the training UI in Phase 4–5.</p>
<hr>
<hr>
<h2 id="d043-ai-behavior-presets--classic-openra-and-ic-default"><a class="header" href="#d043-ai-behavior-presets--classic-openra-and-ic-default">D043: AI Behavior Presets — Classic, OpenRA, and IC Default</a></h2>
<p><strong>Status:</strong> Accepted
<strong>Scope:</strong> <code>ic-ai</code>, <code>ic-sim</code> (read-only), game module configuration
<strong>Phase:</strong> Phase 4 (ships with AI &amp; Single Player)</p>
<h3 id="the-problem-1"><a class="header" href="#the-problem-1">The Problem</a></h3>
<p>D019 gives players switchable <em>balance</em> presets (Classic RA vs. OpenRA vs. Remastered values). D041 provides the <code>AiStrategy</code> trait for pluggable AI algorithms. But neither addresses a parallel concern: AI <em>behavioral</em> style. Original Red Alert AI, OpenRA AI, and a research-informed IC AI all make fundamentally different decisions given the same balance values. A player who selects “Classic RA” balance expects an AI that <em>plays like Classic RA</em> — predictable build orders, minimal micro, base-walk expansion, no focus-fire — not an advanced AI that happens to use 1996 damage tables.</p>
<h3 id="decision"><a class="header" href="#decision">Decision</a></h3>
<p>Ship <strong>AI behavior presets</strong> as first-class configurations alongside balance presets (D019). Each preset defines how the AI plays — its decision-making style, micro level, strategic patterns, and quirks — independent of which balance values or pathfinding behavior are active.</p>
<h3 id="built-in-presets"><a class="header" href="#built-in-presets">Built-In Presets</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Preset</th><th>Behavior Description</th><th>Source</th></tr>
</thead>
<tbody>
<tr><td><strong>Classic RA</strong></td><td>Mimics original RA AI quirks: predictable build queues, base-walk expansion, minimal unit micro, no focus-fire, doesn’t scout, doesn’t adapt to player strategy</td><td>EA Red Alert source code analysis</td></tr>
<tr><td><strong>OpenRA</strong></td><td>Matches OpenRA skirmish AI: better micro, uses attack-move, scouts, adapts build to counter player’s army composition, respects fog of war properly</td><td>OpenRA AI implementation analysis</td></tr>
<tr><td><strong>IC Default</strong></td><td>Research-informed enhanced AI: flowfield-aware group tactics, proper formation movement, multi-prong attacks, economic harassment, tech-switching, adaptive aggression</td><td>Open-source RTS AI research (see below)</td></tr>
</tbody>
</table>
</div>
<h3 id="ic-default-ai--research-foundation"><a class="header" href="#ic-default-ai--research-foundation">IC Default AI — Research Foundation</a></h3>
<p>The IC Default preset draws from published research and open-source implementations across the RTS genre:</p>
<ul>
<li><strong>0 A.D.</strong> — economic AI with resource balancing heuristics, expansion timing models</li>
<li><strong>Spring Engine (BAR/Zero-K)</strong> — group micro, terrain-aware positioning, retreat mechanics, formation movement</li>
<li><strong>Wargus (Stratagus)</strong> — Warcraft II AI with build-order scripting and adaptive counter-play</li>
<li><strong>OpenRA</strong> — the strongest open-source C&amp;C AI; baseline for improvement</li>
<li><strong>MicroRTS / AIIDE competitions</strong> — academic RTS AI research: MCTS-based planning, influence maps, potential fields for tactical positioning</li>
<li><strong>StarCraft: Brood War AI competitions (SSCAIT, AIIDE)</strong> — decades of research on build-order optimization, scouting, harassment timing</li>
</ul>
<p>The IC Default AI is not a simple difficulty bump — it’s a qualitatively different decision process. Where Classic RA groups all units and attack-moves to the enemy base, IC Default maintains map control, denies expansions, and probes for weaknesses before committing.</p>
<h3 id="ic-default-ai--implementation-architecture"><a class="header" href="#ic-default-ai--implementation-architecture">IC Default AI — Implementation Architecture</a></h3>
<p>Based on cross-project analysis of EA Red Alert, EA Generals/Zero Hour, OpenRA, 0 A.D. Petra, Spring Engine, MicroRTS, and Stratagus (see <code>research/rts-ai-implementation-survey.md</code> and <code>research/stratagus-stargus-opencraft-analysis.md</code>), <code>PersonalityDrivenAi</code> uses a <strong>priority-based manager hierarchy</strong> — the dominant pattern across all surveyed RTS AI implementations (independently confirmed in 7 codebases):</p>
<pre><code>PersonalityDrivenAi → AiStrategy trait impl
├── EconomyManager
│   ├── HarvesterController     (nearest-resource assignment, danger avoidance)
│   ├── PowerMonitor            (urgency-based power plant construction)
│   └── ExpansionPlanner        (economic triggers for new base timing)
├── ProductionManager
│   ├── UnitCompositionTarget   (share-based, self-correcting — from OpenRA)
│   ├── BuildOrderEvaluator     (priority queue with urgency — from Petra)
│   └── StructurePlanner        (influence-map placement — from 0 A.D.)
├── MilitaryManager
│   ├── AttackPlanner           (composition thresholds + timing — from Petra)
│   ├── DefenseResponder        (event-driven reactive defense — from OpenRA)
│   └── SquadManager            (unit grouping, assignment, retreat)
└── AiState (shared)
    ├── ThreatMap               (influence map: enemy unit positions + DPS)
    ├── ResourceMap             (known resource node locations and status)
    ├── ScoutingMemory          (last-seen timestamps for enemy buildings)
    └── StrategyClassification  (Phase 5+: opponent archetype tracking)
</code></pre>
<p>Each manager runs on its own tick-gated schedule (see Performance Budget below). Managers communicate through shared <code>AiState</code>, not direct calls — the same pattern used by 0 A.D. Petra and OpenRA’s modular bot architecture.</p>
<h4 id="key-techniques-phase-4"><a class="header" href="#key-techniques-phase-4">Key Techniques (Phase 4)</a></h4>
<p>These six techniques form the Phase 4 implementation. Each is proven across multiple surveyed projects:</p>
<ol>
<li>
<p><strong>Priority-based resource allocation</strong> (from Petra’s <code>QueueManager</code>) — single most impactful pattern. Build requests go into a priority queue ordered by urgency. Power plant at 90% capacity is urgent; third barracks is not. Prevents the “AI has 50k credits and no power” failure mode seen in EA Red Alert.</p>
</li>
<li>
<p><strong>Share-based unit composition</strong> (from OpenRA’s <code>UnitBuilderBotModule</code>) — production targets expressed as ratios (e.g., infantry 40%, vehicles 50%, air 10%). Each production cycle builds whatever unit type is furthest below its target share. Self-correcting: losing tanks naturally shifts production toward tanks. Personality parameters (D043 YAML config) tune the ratios per preset.</p>
</li>
<li>
<p><strong>Influence map for building placement</strong> (from 0 A.D. Petra) — a grid overlay scoring each cell by proximity to resources, distance from known threats, and connectivity to existing base. Dramatically better base layouts than EA RA’s random placement. The influence map is a fixed-size array in <code>AiScratch</code>, cleared and rebuilt on the building-placement schedule.</p>
</li>
<li>
<p><strong>Tick-gated evaluation</strong> (from Generals/Petra/MicroRTS) — expensive decisions run infrequently, cheap ones run often. Defense response is near-instant (every tick, event-driven). Strategic reassessment is every 60 ticks (~2 seconds). This pattern appears in <em>every</em> surveyed project that handles 200+ units. See Performance Budget table below.</p>
</li>
<li>
<p><strong>Fuzzy engagement logic</strong> (from OpenRA’s <code>AttackOrFleeFuzzy</code>) — combat decisions use fuzzy membership functions over health ratio, relative DPS, and nearby ally strength, producing a continuous attack↔retreat score rather than a binary threshold. This avoids the “oscillating dance” where units alternate between attacking and fleeing at a hard HP boundary.</p>
</li>
<li>
<p><strong>Computation budget cap</strong> (from MicroRTS) — <code>AiStrategy::tick_budget_hint()</code> (D041) returns a microsecond budget. The AI <em>must</em> return within this budget, even if evaluation is incomplete — partial results are better than frame stalls. The manager hierarchy makes this natural: if the budget is exhausted after <code>EconomyManager</code> and <code>ProductionManager</code>, <code>MilitaryManager</code> runs its cached plan from last evaluation.</p>
</li>
</ol>
<h4 id="evaluation-and-threat-assessment"><a class="header" href="#evaluation-and-threat-assessment">Evaluation and Threat Assessment</a></h4>
<p>The evaluation function is the foundation of all AI decision-making. A bad evaluation function makes every other component worse (MicroRTS research). Iron Curtain uses <strong>Lanchester-inspired threat scoring</strong>:</p>
<pre><code>threat(army) = Σ(unit_dps × unit_hp) × count^0.7
</code></pre>
<p>This captures Lanchester’s Square Law — military power scales superlinearly with unit count. Two tanks aren’t twice as effective as one; they’re ~1.6× as effective (at exponent 0.7, conservative vs. full Lanchester exponent of 2.0). The exponent is a YAML-tunable personality parameter, allowing presets to value army mass differently.</p>
<p>For evaluating damage taken against our own units:</p>
<pre><code>value(unit) = unit_cost × sqrt(hp / max_hp) × 40
</code></pre>
<p>The <code>sqrt(hp/maxHP)</code> gives diminishing returns for overkill — killing a 10% HP unit is worth less than the same cost in fresh units. This is the MicroRTS <code>SimpleSqrtEvaluationFunction</code> pattern, validated across years of AI competition.</p>
<p>Both formulas use fixed-point arithmetic (integer math only, consistent with sim determinism).</p>
<h4 id="phase-5-enhancements"><a class="header" href="#phase-5-enhancements">Phase 5+ Enhancements</a></h4>
<p>These techniques are explicitly deferred — the Phase 4 AI ships without them:</p>
<ul>
<li><strong>Strategy classification and adaptation:</strong> Track opponent behavior patterns (build timing, unit composition, attack frequency). Classify into archetypes: “rush”, “turtle”, “boom”, “all-in”. Select counter-strategy from personality parameters. This is the MicroRTS Stratified Strategy Selection (SCV) pattern applied at RTS scale.</li>
<li><strong>Active scouting system:</strong> No surveyed project scouts well — opportunity to lead. Periodically send cheap units to explore unknown areas. Maintain “last seen” timestamps for enemy building locations in <code>AiState::ScoutingMemory</code>. Higher urgency when opponent is quiet (they’re probably teching up).</li>
<li><strong>Multi-pronged attacks:</strong> Graduate from Petra/OpenRA’s single-army-blob pattern. Split forces based on attack plan (main force + flanking/harassment force). Coordinate timing via shared countdown in <code>AiState</code>. The <code>AiEventLog</code> (D041) enables coordination visibility between sub-plans.</li>
<li><strong>Advanced micro:</strong> Kiting, focus-fire priority targeting, ability usage. Kept out of Phase 4 to avoid the “chasing optimal AI” anti-pattern.</li>
</ul>
<h4 id="what-to-explicitly-not-do"><a class="header" href="#what-to-explicitly-not-do">What to Explicitly Not Do</a></h4>
<p>Five anti-patterns identified from surveyed implementations (full analysis in <code>research/rts-ai-implementation-survey.md</code> §9):</p>
<ol>
<li><strong>Don’t implement MCTS/minimax for strategic decisions.</strong> The search space is too large for 500+ unit games. MicroRTS research confirms: portfolio/script search beats raw MCTS at RTS scale. Reserve tree search for micro-scale decisions only (if at all).</li>
<li><strong>Don’t use behavior trees for the strategic AI.</strong> Every surveyed RTS uses priority cascades or manager hierarchies, not BTs. BTs add complexity without proven benefit at RTS strategic scale.</li>
<li><strong>Don’t chase “optimal” AI at launch.</strong> RA shipped with terrible AI and sold 10 million copies. The Remastered Collection shipped with the same terrible AI. Get a good-enough AI working, then iterate. Phase 4 target: “better than EA RA, comparable to OpenRA.”</li>
<li><strong>Don’t hardcode strategies.</strong> Use YAML configuration (the personality model above) so modders and the difficulty system can tune behavior without code changes.</li>
<li><strong>Don’t skip evaluation function design.</strong> A bad evaluation function makes every other AI component worse. Invest time in getting threat assessment right (Lanchester scoring above) — it’s the foundation everything else builds on.</li>
</ol>
<h4 id="ai-performance-budget"><a class="header" href="#ai-performance-budget">AI Performance Budget</a></h4>
<p>Based on the efficiency pyramid (D015) and surveyed projects’ performance characteristics (see also <code>10-PERFORMANCE.md</code>):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>AI Component</th><th>Frequency</th><th>Target Time</th><th>Approach</th></tr>
</thead>
<tbody>
<tr><td>Harvester assignment</td><td>Every 4 ticks</td><td>&lt; 0.1ms</td><td>Nearest-resource lookup</td></tr>
<tr><td>Defense response</td><td>Every tick (reactive)</td><td>&lt; 0.1ms</td><td>Event-driven, not polling</td></tr>
<tr><td>Unit production</td><td>Every 8 ticks</td><td>&lt; 0.2ms</td><td>Priority queue evaluation</td></tr>
<tr><td>Building placement</td><td>On demand</td><td>&lt; 1.0ms</td><td>Influence map lookup</td></tr>
<tr><td>Attack planning</td><td>Every 30 ticks</td><td>&lt; 2.0ms</td><td>Composition check + timing</td></tr>
<tr><td>Strategic reassessment</td><td>Every 60 ticks</td><td>&lt; 5.0ms</td><td>Full state evaluation</td></tr>
<tr><td><strong>Total per tick (amortized)</strong></td><td></td><td><strong>&lt; 0.5ms</strong></td><td><strong>Budget for 500 units</strong></td></tr>
</tbody>
</table>
</div>
<p>All AI working memory (influence maps, squad rosters, composition tallies, priority queues) is pre-allocated in <code>AiScratch</code> — analogous to <code>TickScratch</code> (Layer 5 of the efficiency pyramid). Zero per-tick heap allocation. Influence maps are fixed-size arrays, cleared and rebuilt on their evaluation schedule.</p>
<h3 id="configuration-model"><a class="header" href="#configuration-model">Configuration Model</a></h3>
<p>AI presets are YAML-driven, paralleling balance presets:</p>
<pre><code class="language-yaml"># ai/presets/classic-ra.yaml
ai_preset:
  name: "Classic Red Alert"
  description: "Faithful recreation of original RA AI behavior"
  strategy: personality-driven     # AiStrategy implementation to use
  personality:
    aggression: 0.6
    tech_priority: rush
    micro_level: none              # no individual unit control
    scout_frequency: never
    build_order: scripted          # fixed build queues per faction
    expansion_style: base_walk     # builds structures adjacent to existing base
    focus_fire: false
    retreat_behavior: never        # units fight to the death
    adaptation: none               # doesn't change strategy based on opponent
    group_tactics: blob            # all units in one control group

# ai/presets/ic-default.yaml
ai_preset:
  name: "IC Default"
  description: "Research-informed AI with modern RTS intelligence"
  strategy: personality-driven
  personality:
    aggression: 0.5
    tech_priority: balanced
    micro_level: moderate          # focus-fire, kiting ranged units, retreat wounded
    scout_frequency: periodic      # sends scouts every 60-90 seconds
    build_order: adaptive          # adjusts build based on scouting information
    expansion_style: strategic     # expands to control resource nodes
    focus_fire: true
    retreat_behavior: wounded      # retreats units below 30% HP
    adaptation: reactive           # counters observed army composition
    group_tactics: multi_prong     # splits forces for flanking/harassment
    influence_maps: true           # uses influence maps for threat assessment
    harassment: true               # sends small squads to attack economy
</code></pre>
<h3 id="relationship-to-existing-decisions-1"><a class="header" href="#relationship-to-existing-decisions-1">Relationship to Existing Decisions</a></h3>
<ul>
<li><strong>D019 (balance presets):</strong> Orthogonal. Balance defines <em>what units can do</em>; AI presets define <em>how the AI uses them</em>. A player can combine any balance preset with any AI preset. “Classic RA balance + IC Default AI” is valid and interesting.</li>
<li><strong>D041 (<code>AiStrategy</code> trait):</strong> AI presets are configurations for the default <code>PersonalityDrivenAi</code> strategy. The trait allows entirely different AI algorithms (neural net, GOAP planner); presets are parameter sets within one algorithm. Both coexist — presets for built-in AI, traits for custom AI.</li>
<li><strong>D042 (<code>StyleDrivenAi</code>):</strong> Player behavioral profiles are a fourth source of AI behavior (alongside Classic/OpenRA/IC Default presets). No conflict — <code>StyleDrivenAi</code> implements <code>AiStrategy</code> independently of presets.</li>
<li><strong>D033 (QoL toggles / experience profiles):</strong> AI preset selection integrates naturally into experience profiles. The “Classic Red Alert” experience profile bundles classic balance + classic AI + classic theme.</li>
</ul>
<h3 id="experience-profile-integration"><a class="header" href="#experience-profile-integration">Experience Profile Integration</a></h3>
<pre><code class="language-yaml">profiles:
  classic-ra:
    balance: classic
    ai_preset: classic-ra          # D043 — original RA AI behavior
    pathfinding: classic-ra        # D045 — original RA movement feel
    render_mode: classic           # D048 — original sprite rendering
    theme: classic
    qol: vanilla

  openra-ra:
    balance: openra
    ai_preset: openra
    pathfinding: openra            # D045 — OpenRA movement feel
    render_mode: classic           # D048
    theme: modern
    qol: openra

  iron-curtain-ra:
    balance: classic
    ai_preset: ic-default          # D043 — enhanced AI
    pathfinding: ic-default        # D045 — modern flowfield movement
    render_mode: hd                # D048 — high-definition sprites
    theme: modern
    qol: iron_curtain
</code></pre>
<h3 id="lobby-integration"><a class="header" href="#lobby-integration">Lobby Integration</a></h3>
<p>AI preset is selectable per AI player slot in the lobby, independent of game-wide balance preset:</p>
<pre><code>Player 1: [Human]           Faction: Soviet
Player 2: [AI] IC Default (Hard)    Faction: Allied
Player 3: [AI] Classic RA (Normal)  Faction: Allied
Player 4: [AI] OpenRA (Brutal)      Faction: Soviet

Balance Preset: Classic RA
</code></pre>
<p>This allows mixed AI playstyles in the same game – useful for testing, fun for variety, and educational for understanding how different AI approaches handle the same scenario.</p>
<h3 id="community-ai-presets"><a class="header" href="#community-ai-presets">Community AI Presets</a></h3>
<p>Modders can create custom AI presets as Workshop resources (D030):</p>
<ul>
<li>YAML preset files defining <code>personality</code> parameters for <code>PersonalityDrivenAi</code></li>
<li>Full <code>AiStrategy</code> implementations via WASM Tier 3 mods (D041)</li>
<li>AI tournament brackets: community members compete by submitting AI presets, tournament server runs automated matches</li>
</ul>
<h3 id="engine-level-difficulty-system"><a class="header" href="#engine-level-difficulty-system">Engine-Level Difficulty System</a></h3>
<p>Inspired by 0 A.D.’s two-axis difficulty (engine cheats + behavioral parameters) and AoE2’s strategic number scaling with opt-out (see <code>research/rts-ai-extensibility-survey.md</code>), Iron Curtain separates difficulty into two independent layers:</p>
<p><strong>Layer 1 — Engine scaling (applies to ALL AI players by default):</strong></p>
<p>The engine provides resource, build-time, and reaction-time multipliers that scale an AI’s raw capability independent of how smart its decisions are. This ensures that even a simple YAML-configured AI can be made harder or easier without touching its behavioral parameters.</p>
<pre><code class="language-yaml"># difficulties/built-in.yaml
difficulties:
  sandbox:
    name: "Sandbox"
    description: "AI barely acts — for learning the interface"
    engine_scaling:
      resource_gather_rate: 0.5     # AI gathers half speed (fixed-point: 512/1024)
      build_time_multiplier: 1.5    # AI builds 50% slower
      reaction_delay_ticks: 30      # AI waits 30 ticks (~1s) before acting on events
      vision_range_multiplier: 0.8  # AI sees 20% less
    personality_overrides:
      aggression: 0.1
      adaptation: none

  easy:
    name: "Easy"
    engine_scaling:
      resource_gather_rate: 0.8
      build_time_multiplier: 1.2
      reaction_delay_ticks: 8
      vision_range_multiplier: 1.0

  normal:
    name: "Normal"
    engine_scaling:
      resource_gather_rate: 1.0     # No modification
      build_time_multiplier: 1.0
      reaction_delay_ticks: 0
      vision_range_multiplier: 1.0

  hard:
    name: "Hard"
    engine_scaling:
      resource_gather_rate: 1.0     # No economic bonus
      build_time_multiplier: 1.0
      reaction_delay_ticks: 0
      vision_range_multiplier: 1.0
    # Hard is purely behavioral — the AI makes smarter decisions, not cheaper ones
    personality_overrides:
      micro_level: moderate
      adaptation: reactive

  brutal:
    name: "Brutal"
    engine_scaling:
      resource_gather_rate: 1.3     # AI gets 30% bonus
      build_time_multiplier: 0.8    # AI builds 20% faster
      reaction_delay_ticks: 0
      vision_range_multiplier: 1.2  # AI sees 20% further
    personality_overrides:
      aggression: 0.8
      micro_level: extreme
      adaptation: full
</code></pre>
<p><strong>Layer 2 — Implementation-level difficulty (per-<code>AiStrategy</code> impl):</strong></p>
<p>Each <code>AiStrategy</code> implementation interprets difficulty through its own behavioral parameters. <code>PersonalityDrivenAi</code> uses the <code>personality:</code> YAML config (aggression, micro level, adaptation). A neural-net AI might have a “skill cap” parameter. A GOAP planner might limit search depth. The <code>get_parameters()</code> method (from MicroRTS research) exposes these as introspectable knobs.</p>
<p><strong>Engine scaling opt-out</strong> (from AoE2’s <code>sn-do-not-scale-for-difficulty-level</code>): Sophisticated AI implementations that model difficulty internally can opt out of engine scaling by returning <code>false</code> from <code>uses_engine_difficulty_scaling()</code>. This prevents double-scaling — an advanced AI that already weakens its play at Easy difficulty shouldn’t also get the engine’s gather-rate penalty on top.</p>
<p><strong>Modder-addable difficulty levels:</strong> Difficulty levels are YAML files, not hardcoded enums. Community modders can define new difficulties via Workshop (D030) — no code required (Tier 1):</p>
<pre><code class="language-yaml"># workshop: community/nightmare-difficulty/difficulty.yaml
difficulty:
  name: "Nightmare"
  description: "Economy bonuses + perfect micro — for masochists"
  engine_scaling:
    resource_gather_rate: 2.0
    build_time_multiplier: 0.5
    reaction_delay_ticks: 0
    vision_range_multiplier: 1.5
  personality_overrides:
    aggression: 0.95
    micro_level: extreme
    adaptation: full
    harassment: true
    group_tactics: multi_prong
</code></pre>
<p>Once installed, “Nightmare” appears alongside built-in difficulties in the lobby dropdown. Any <code>AiStrategy</code> implementation (first-party or community) can be paired with any difficulty level — they compose independently.</p>
<h3 id="mod-selectable-and-mod-provided-ai"><a class="header" href="#mod-selectable-and-mod-provided-ai">Mod-Selectable and Mod-Provided AI</a></h3>
<p>The three built-in behavior presets (Classic RA, OpenRA, IC Default) are configurations for <code>PersonalityDrivenAi</code>. They are not the only <code>AiStrategy</code> implementations. The trait (D041) is explicitly open to community implementations — following the same pattern as <code>Pathfinder</code> (D013/D045) and render modes (D048).</p>
<p><strong>Two-axis lobby selection:</strong></p>
<p>In the lobby, each AI player slot has two independent selections:</p>
<ol>
<li><strong>AI implementation</strong> — which <code>AiStrategy</code> algorithm</li>
<li><strong>Difficulty level</strong> — which engine scaling + personality config</li>
</ol>
<pre><code>Player 2: [AI] IC Default / Hard        Faction: Allied
Player 3: [AI] Classic RA / Normal      Faction: Allied
Player 4: [AI] Workshop: GOAP Planner / Brutal   Faction: Soviet
Player 5: [AI] Workshop: Neural Net v2 / Nightmare   Faction: Soviet

Balance Preset: Classic RA
</code></pre>
<p>This is different from pathfinders (one axis: which algorithm). AI has two orthogonal axes because <em>how smart the AI plays</em> and <em>what advantages it gets</em> are independent concerns. A “Brutal Classic RA” AI should play with original 1996 patterns but get economic bonuses and instant reactions; an “Easy IC Default” AI should use modern tactics but gather slowly and react late.</p>
<p><strong>Modder as consumer — selecting an AI:</strong></p>
<p>A mod’s YAML manifest can declare which <code>AiStrategy</code> implementations it ships with or requires:</p>
<pre><code class="language-yaml"># mod.yaml — total conversion with custom AI
mod:
  name: "Zero Hour Remake"
  ai_strategies:
    - goap-planner              # Requires this community AI
    - personality-driven        # Also supports the built-in default
  default_ai: goap-planner
  depends:
    - community/goap-planner-ai@^2.0
</code></pre>
<p>If the mod doesn’t specify <code>ai_strategies</code>, all registered AI implementations are available.</p>
<p><strong>Modder as author — providing an AI:</strong></p>
<p>A Tier 3 WASM mod can implement the <code>AiStrategy</code> trait and register it:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WASM mod: GOAP (Goal-Oriented Action Planning) AI
impl AiStrategy for GoapPlannerAi {
    fn decide(&amp;mut self, player: PlayerId, view: &amp;FogFilteredView, tick: u64) -&gt; Vec&lt;PlayerOrder&gt; {
        // 1. Update world model from FogFilteredView
        // 2. Evaluate goal priorities (expand? attack? defend? tech?)
        // 3. GOAP search: find action sequence to achieve highest-priority goal
        // 4. Emit orders for first action in plan
        // ...
    }

    fn name(&amp;self) -&gt; &amp;str { "GOAP Planner" }
    fn difficulty(&amp;self) -&gt; AiDifficulty { AiDifficulty::Custom("adaptive".into()) }

    fn on_enemy_spotted(&amp;mut self, unit: EntityId, unit_type: &amp;str) {
        // Re-prioritize goals: if enemy spotted near base, defend goal priority increases
        self.goal_priorities.defend += self.threat_weight(unit_type);
    }

    fn on_under_attack(&amp;mut self, _unit: EntityId, _attacker: EntityId) {
        // Emergency re-plan: abort current plan, switch to defense
        self.force_replan = true;
    }

    fn get_parameters(&amp;self) -&gt; Vec&lt;ParameterSpec&gt; {
        vec![
            ParameterSpec { name: "plan_depth".into(), min_value: 1, max_value: 10, default_value: 5, .. },
            ParameterSpec { name: "replan_interval".into(), min_value: 10, max_value: 120, default_value: 30, .. },
            ParameterSpec { name: "aggression_weight".into(), min_value: 0, max_value: 100, default_value: 50, .. },
        ]
    }

    fn uses_engine_difficulty_scaling(&amp;self) -&gt; bool { false } // handles difficulty internally
}
<span class="boring">}</span></code></pre>
<p>The mod registers its AI in its manifest:</p>
<pre><code class="language-yaml"># goap_planner/mod.yaml
mod:
  name: "GOAP Planner AI"
  type: ai_strategy
  ai_strategy_id: goap-planner
  display_name: "GOAP Planner"
  description: "Goal-oriented action planning AI — plans multi-step strategies"
  wasm_module: goap_planner.wasm
  capabilities:
    read_visible_state: true
    issue_orders: true
  config:
    plan_depth: 5
    replan_interval_ticks: 30
</code></pre>
<p><strong>Workshop distribution:</strong> Community AI implementations are Workshop resources (D030). They can be rated, reviewed, and depended upon — same as pathfinder mods. The Workshop can host AI tournament leaderboards: automated matches between community AI submissions, ranked by Elo/TrueSkill (inspired by BWAPI’s SSCAIT and AoE2’s AI ladder communities, see <code>research/rts-ai-extensibility-survey.md</code>).</p>
<p><strong>Multiplayer implications:</strong> AI selection is NOT sim-affecting in the same way pathfinding is. In a human-vs-AI game, each AI player can run a different <code>AiStrategy</code> — they’re independent agents. In AI-vs-AI tournaments, all AI players can be different. The engine doesn’t need to validate that all clients have the same AI WASM module (unlike pathfinding). However, for determinism, the AI’s <code>decide()</code> output must be identical on all clients — so the WASM binary hash IS validated per AI player slot.</p>
<h3 id="relationship-to-existing-decisions-2"><a class="header" href="#relationship-to-existing-decisions-2">Relationship to Existing Decisions</a></h3>
<ul>
<li><strong>D019 (balance presets):</strong> Orthogonal. Balance defines <em>what units can do</em>; AI presets define <em>how the AI uses them</em>. A player can combine any balance preset with any AI preset. “Classic RA balance + IC Default AI” is valid and interesting.</li>
<li><strong>D041 (<code>AiStrategy</code> trait):</strong> AI behavior presets are configurations for the default <code>PersonalityDrivenAi</code> strategy. The trait allows entirely different AI algorithms (neural net, GOAP planner); presets are parameter sets within one algorithm. Both coexist — presets for built-in AI, traits for custom AI. The trait now includes event callbacks, parameter introspection, and engine scaling opt-out based on cross-project research.</li>
<li><strong>D042 (<code>StyleDrivenAi</code>):</strong> Player behavioral profiles are a fourth source of AI behavior (alongside Classic/OpenRA/IC Default presets). No conflict — <code>StyleDrivenAi</code> implements <code>AiStrategy</code> independently of presets.</li>
<li><strong>D033 (QoL toggles / experience profiles):</strong> AI preset selection integrates naturally into experience profiles. The “Classic Red Alert” experience profile bundles classic balance + classic AI + classic theme.</li>
<li><strong>D045 (pathfinding presets):</strong> Same modder-selectable pattern. Mods select or provide pathfinders; mods select or provide AI implementations. Both distribute via Workshop; both compose with experience profiles. Key difference: pathfinding is one axis (algorithm), AI is two axes (algorithm + difficulty).</li>
<li><strong>D048 (render modes):</strong> Same modder-selectable pattern. The trait-per-subsystem architecture means every pluggable system follows the same model: engine ships built-in implementations, mods can add more, players/modders pick what they want.</li>
</ul>
<h3 id="alternatives-considered-1"><a class="header" href="#alternatives-considered-1">Alternatives Considered</a></h3>
<ul>
<li>AI difficulty only, no style presets (rejected — difficulty is orthogonal to style; a “Hard Classic RA” AI should be hard but still play like original RA, not like a modern AI turned up)</li>
<li>One “best” AI only (rejected — the community is split like they are on balance; offer choice)</li>
<li>Lua-only AI scripting (rejected — too slow for tick-level decisions; Lua is for mission triggers, WASM for full AI replacement)</li>
<li>Difficulty as a fixed enum only (rejected — modders should be able to define new difficulty levels via YAML without code changes; AoE2’s 20+ years of community AI prove that a large parameter space outlasts a restrictive one)</li>
<li>No engine-level difficulty scaling (rejected — delegating difficulty entirely to AI implementations produces inconsistent experiences across different AIs; 0 A.D. and AoE2 both provide engine scaling with opt-out, proving this is the right separation of concerns)</li>
<li>No event callbacks on <code>AiStrategy</code> (rejected — polling-only AI misses reactive opportunities; Spring Engine and BWAPI both use event + tick hybrid, which is the proven model)</li>
</ul>
<hr>
<hr>
<h2 id="d044-llm-enhanced-ai--orchestrator-and-experimental-llm-player"><a class="header" href="#d044-llm-enhanced-ai--orchestrator-and-experimental-llm-player">D044: LLM-Enhanced AI — Orchestrator and Experimental LLM Player</a></h2>
<p><strong>Status:</strong> Accepted
<strong>Scope:</strong> <code>ic-llm</code>, <code>ic-ai</code>, <code>ic-sim</code> (read-only)
<strong>Phase:</strong> LLM Orchestrator: Phase 7. LLM Player: Experimental, no scheduled phase.</p>
<h3 id="the-problem-2"><a class="header" href="#the-problem-2">The Problem</a></h3>
<p>D016 provides LLM integration for mission generation. D042 provides LLM coaching between games. But neither addresses LLM involvement <em>during</em> gameplay — using an LLM to influence or directly control AI decisions in real-time. Two distinct use cases exist:</p>
<ol>
<li><strong>Enhancing existing AI</strong> — an LLM advisor that reads game state and nudges a conventional AI toward better strategic decisions, without replacing the tick-level execution</li>
<li><strong>Full LLM control</strong> — an experimental mode where an LLM makes every decision, exploring whether modern language models can play RTS games competently</li>
</ol>
<h3 id="decision-1"><a class="header" href="#decision-1">Decision</a></h3>
<p>Define two new <code>AiStrategy</code> implementations (D041) for LLM-integrated gameplay:</p>
<h3 id="1-llm-orchestrator-llmorchestratorai"><a class="header" href="#1-llm-orchestrator-llmorchestratorai">1. LLM Orchestrator (<code>LlmOrchestratorAi</code>)</a></h3>
<p>Wraps any existing <code>AiStrategy</code> implementation (D041) and periodically consults an LLM for high-level strategic guidance. The inner AI handles tick-level execution; the LLM provides strategic direction.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Wraps an existing AiStrategy with LLM strategic oversight.
/// The inner AI makes tick-level decisions; the LLM provides
/// periodic strategic guidance that the inner AI incorporates.
pub struct LlmOrchestratorAi {
    inner: Box&lt;dyn AiStrategy&gt;,         // the AI that actually issues orders
    provider: Box&lt;dyn LlmProvider&gt;,     // D016 BYOLLM
    consultation_interval: u64,         // ticks between LLM consultations
    last_consultation: u64,
    current_plan: Option&lt;StrategicPlan&gt;,
    event_log: AiEventLog,              // D041 — fog-filtered event accumulator
}
<span class="boring">}</span></code></pre>
<p><strong>How it works:</strong></p>
<pre><code>Every N ticks (configurable, default ~300 = ~10 seconds at 30 tick/s):
  1. Serialize visible game state into a structured prompt:
     - Own base layout, army composition, resource levels
     - Known enemy positions, army composition estimate
     - Current strategic plan (if any)
     - event_log.to_narrative(last_consultation) — fog-filtered event chronicle
  2. Send prompt to LlmProvider (D016)
  3. LLM returns a StrategicPlan:
     - Priority targets (e.g., "attack enemy expansion at north")
     - Build focus (e.g., "switch to anti-air production")
     - Economic guidance (e.g., "expand to second ore field")
     - Risk assessment (e.g., "enemy likely to push soon, fortify choke")
  4. Translate StrategicPlan into inner AI parameter adjustments via set_parameter()
     (e.g., "switch to anti-air" → set_parameter("tech_priority_aa", 80))
  5. Record plan change as StrategicUpdate event in event_log
  6. Inner AI incorporates guidance into its normal tick-level decisions

Between consultations:
  - Inner AI runs normally, using the last parameter adjustments as guidance
  - Tick-level micro, build queue management, unit control all handled by inner AI
  - No LLM latency in the hot path
  - Events continue accumulating in event_log for the next consultation
</code></pre>
<p><strong>Event log as LLM context (D041 integration):</strong></p>
<p>The <code>AiEventLog</code> (defined in D041) is the bridge between simulation events and LLM understanding. The orchestrator accumulates fog-filtered events from the D041 callback pipeline — <code>on_enemy_spotted</code>, <code>on_under_attack</code>, <code>on_unit_destroyed</code>, etc. — and serializes them into a natural-language narrative via <code>to_narrative(since_tick)</code>. This narrative is the “inner game event log / action story / context” the LLM reads to understand what happened since its last consultation.</p>
<p>The event log is <strong>fog-filtered by construction</strong> — all events originate from the same fog-filtered callback pipeline that respects <code>FogFilteredView</code>. The LLM never receives information about actions behind fog of war, only events the AI player is supposed to be aware of. This is an architectural guarantee, not a filtering step that could be bypassed.</p>
<p><strong>Event callback forwarding:</strong></p>
<p>The orchestrator implements all D041 event callbacks by forwarding to both the inner AI and the event log:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AiStrategy for LlmOrchestratorAi {
    fn decide(&amp;mut self, player: PlayerId, view: &amp;FogFilteredView, tick: u64) -&gt; Vec&lt;PlayerOrder&gt; {
        // Check if it's time for an LLM consultation
        if tick - self.last_consultation &gt;= self.consultation_interval {
            self.consult_llm(player, view, tick);
        }
        // Delegate tick-level decisions to the inner AI
        self.inner.decide(player, view, tick)
    }

    fn on_enemy_spotted(&amp;mut self, unit: EntityId, unit_type: &amp;str) {
        self.event_log.push(AiEventEntry {
            tick: self.current_tick,
            event_type: AiEventType::EnemySpotted,
            description: format!("Enemy {} spotted", unit_type),
            entity: Some(unit),
            related_entity: None,
        });
        self.inner.on_enemy_spotted(unit, unit_type);  // forward to inner AI
    }

    fn on_under_attack(&amp;mut self, unit: EntityId, attacker: EntityId) {
        self.event_log.push(/* ... */);
        self.inner.on_under_attack(unit, attacker);
    }

    // ... all other callbacks follow the same pattern:
    // 1. Record in event_log  2. Forward to inner AI

    fn name(&amp;self) -&gt; &amp;str { "LLM Orchestrator" }
    fn difficulty(&amp;self) -&gt; AiDifficulty { self.inner.difficulty() }
    fn tick_budget_hint(&amp;self) -&gt; Option&lt;u64&gt; { self.inner.tick_budget_hint() }

    // Delegate parameter introspection — expose orchestrator params + inner AI params
    fn get_parameters(&amp;self) -&gt; Vec&lt;ParameterSpec&gt; {
        let mut params = vec![
            ParameterSpec {
                name: "consultation_interval".into(),
                description: "Ticks between LLM consultations".into(),
                min_value: 30, max_value: 3000,
                default_value: 300, current_value: self.consultation_interval as i32,
            },
        ];
        // Include inner AI's parameters (prefixed for clarity)
        params.extend(self.inner.get_parameters());
        params
    }

    fn set_parameter(&amp;mut self, name: &amp;str, value: i32) {
        match name {
            "consultation_interval" =&gt; self.consultation_interval = value as u64,
            _ =&gt; self.inner.set_parameter(name, value),  // delegate to inner AI
        }
    }

    // Delegate engine scaling to inner AI — the orchestrator adds LLM guidance,
    // difficulty scaling applies to the underlying AI that executes orders
    fn uses_engine_difficulty_scaling(&amp;self) -&gt; bool {
        self.inner.uses_engine_difficulty_scaling()
    }
}
<span class="boring">}</span></code></pre>
<p><strong>How StrategicPlan reaches the inner AI:</strong></p>
<p>The orchestrator translates <code>StrategicPlan</code> fields into <code>set_parameter()</code> calls on the inner AI (D041). For example:</p>
<ul>
<li>“Switch to anti-air production” → <code>set_parameter("tech_priority_aa", 80)</code></li>
<li>“Be more aggressive” → <code>set_parameter("aggression", 75)</code></li>
<li>“Expand to second ore field” → <code>set_parameter("expansion_priority", 90)</code></li>
</ul>
<p>This uses D041’s existing parameter introspection infrastructure — no new trait methods needed. The inner AI’s <code>get_parameters()</code> exposes its tunable knobs; the LLM’s strategic output maps to those knobs. An inner AI that doesn’t expose relevant parameters simply ignores guidance it can’t act on — the orchestrator degrades gracefully.</p>
<p><strong>Key design points:</strong></p>
<ul>
<li><strong>No latency impact on gameplay.</strong> LLM consultation is async — fires off a request, continues with the previous plan until the response arrives. If the LLM is slow (or unavailable), the inner AI plays normally.</li>
<li><strong>BYOLLM (D016).</strong> Same provider system — users configure their own model. Local models (Ollama) give lowest latency; cloud APIs work but add ~1-3s round-trip per consultation.</li>
<li><strong>Determinism maintained.</strong> In multiplayer, the LLM runs on exactly one machine (the AI slot owner’s client). The resulting <code>StrategicPlan</code> is submitted as an order through the <code>NetworkModel</code> — the same path as human player orders. Other clients never run the LLM; they receive and apply the same plan at the same deterministic tick boundary. In singleplayer, determinism is trivially preserved (orders are recorded in the replay, not LLM calls).</li>
<li><strong>Inner AI is any <code>AiStrategy</code>.</strong> Orchestrator wraps IC Default, Classic RA, a community WASM AI (D043), or even a <code>StyleDrivenAi</code> (D042). The LLM adds strategic thinking on top of whatever execution style is underneath. Because the orchestrator communicates through the generic <code>AiStrategy</code> trait (event callbacks + <code>set_parameter()</code>), it works with any implementation — including community-provided WASM AI mods.</li>
<li><strong>Two-axis difficulty compatibility (D043).</strong> The orchestrator delegates <code>difficulty()</code> and <code>uses_engine_difficulty_scaling()</code> to the inner AI. Engine-level difficulty scaling (resource bonuses, reaction delays) applies to the inner AI’s execution; the LLM consultation frequency and depth are separate parameters exposed via <code>get_parameters()</code>. In the lobby, players select the inner AI + difficulty normally, then optionally enable LLM orchestration on top.</li>
<li><strong>Observable.</strong> The current <code>StrategicPlan</code> and the event log narrative are displayed in a debug overlay (developer/spectator mode), letting players see the LLM’s “thinking” and the events that informed it.</li>
<li><strong>Prompt engineering is in YAML.</strong> Prompt templates are mod-data, not hardcoded. Modders can customize LLM prompts for different game modules or scenarios.</li>
</ul>
<pre><code class="language-yaml"># llm/prompts/orchestrator.yaml
orchestrator:
  system_prompt: |
    You are a strategic advisor for a Red Alert AI player.
    Analyze the game state and provide high-level strategic guidance.
    Do NOT issue specific unit orders — your AI subordinate handles execution.
    Focus on: what to build, where to expand, when to attack, what threats to prepare for.
  response_format:
    type: structured
    schema: StrategicPlan
  consultation_interval_ticks: 300
  max_tokens: 500
</code></pre>
<h3 id="2-llm-player-llmplayerai--experimental"><a class="header" href="#2-llm-player-llmplayerai--experimental">2. LLM Player (<code>LlmPlayerAi</code>) — Experimental</a></h3>
<p>A fully LLM-driven player where the language model makes every decision. No inner AI — the LLM receives game state and emits player orders directly. This is the “LLM makes every small decision” path — the architecture supports it through the same <code>AiStrategy</code> trait and <code>AiEventLog</code> infrastructure as the orchestrator.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Experimental: LLM makes all decisions directly.
/// Every N ticks, the LLM receives game state and returns orders.
/// Performance and quality depend entirely on the LLM model and latency.
pub struct LlmPlayerAi {
    provider: Box&lt;dyn LlmProvider&gt;,
    decision_interval: u64,           // ticks between LLM decisions
    pending_orders: Vec&lt;PlayerOrder&gt;, // buffered orders from last LLM response
    order_cursor: usize,              // index into pending_orders for drip-feeding
    event_log: AiEventLog,            // D041 — fog-filtered event accumulator
}
<span class="boring">}</span></code></pre>
<p><strong>How it works:</strong></p>
<ul>
<li>Every N ticks, serialize <code>FogFilteredView</code> + <code>event_log.to_narrative(last_decision_tick)</code> → send to LLM → receive a batch of <code>PlayerOrder</code> values</li>
<li>The event log narrative gives the LLM a chronological understanding of what happened — “what has been going on in this game” — rather than just a snapshot of current state</li>
<li>Between decisions, drip-feed buffered orders to the sim (one or few per tick)</li>
<li>If the LLM response is slow, the player idles (no orders until response arrives)</li>
<li>Event callbacks continue accumulating into the event log between LLM decisions, building a richer narrative for the next consultation</li>
</ul>
<p><strong>Why the event log matters for full LLM control:</strong></p>
<p>The LLM Player receives <code>FogFilteredView</code> (current game state) AND <code>AiEventLog</code> (recent game history). Together these give the LLM:</p>
<ul>
<li><strong>Spatial awareness</strong> — what’s where right now (from <code>FogFilteredView</code>)</li>
<li><strong>Temporal awareness</strong> — what happened recently (from the event log narrative)</li>
<li><strong>Causal understanding</strong> — “I was attacked from the north, my refinery was destroyed, I spotted 3 enemy tanks” forms a coherent story the LLM can reason about</li>
</ul>
<p>Without the event log, the LLM would see only a static snapshot every N ticks, with no continuity between decisions. The log bridges decisions into a narrative that LLMs are natively good at processing.</p>
<p><strong>Why this is experimental:</strong></p>
<ul>
<li><strong>Latency.</strong> Even local LLMs take 100-500ms per response. A 30 tick/s sim expects decisions every 33ms. The LLM Player will always be slower than a conventional AI.</li>
<li><strong>Quality ceiling.</strong> Current LLMs struggle with spatial reasoning and precise micro. The LLM Player will likely lose to even Easy conventional AI in direct combat efficiency.</li>
<li><strong>Cost.</strong> Cloud LLMs charge per token. A full game might generate thousands of consultations. Local models are free but slower.</li>
<li><strong>The value is educational and entertaining</strong>, not competitive. Watching an LLM try to play Red Alert — making mistakes, forming unexpected strategies, explaining its reasoning — is intrinsically interesting. Community streaming of “GPT vs. Claude playing Red Alert” is a content opportunity.</li>
</ul>
<p><strong>Design constraints:</strong></p>
<ul>
<li><strong>Never the default.</strong> LLM Player is clearly labeled “Experimental” in the lobby.</li>
<li><strong>Not allowed in ranked.</strong> LLM AI modes are excluded from competitive matchmaking.</li>
<li><strong>Observable.</strong> The LLM’s reasoning text and event log narrative are capturable as a spectator overlay, enabling commentary-style viewing.</li>
<li><strong>Same BYOLLM infrastructure.</strong> Uses <code>LlmProvider</code> trait (D016), same configuration, same provider options.</li>
<li><strong>Two-axis difficulty compatibility (D043).</strong> Engine-level difficulty scaling (resource bonuses, reaction delays) applies normally — <code>uses_engine_difficulty_scaling()</code> returns <code>true</code>. The LLM’s “skill” is inherent in the model’s capability and prompt engineering, not in engine parameters. <code>get_parameters()</code> exposes LLM-specific knobs: decision interval, max tokens, model selection, prompt template — but the LLM’s quality is ultimately model-dependent, not engine-controlled. This is an honest design: we don’t pretend to make the LLM “harder” or “easier” through engine scaling, but we do let the engine give it economic advantages or handicaps.</li>
<li><strong>Determinism:</strong> The LLM runs on one machine (the AI slot owner’s client) and submits orders through the <code>NetworkModel</code>, just like human input. All clients apply the same orders at the same deterministic tick boundaries. The LLM itself is non-deterministic (different responses per run), but that non-determinism is resolved before orders enter the sim — the sim only sees deterministic order streams. Replays record orders (not LLM calls), so replay playback is fully deterministic.</li>
</ul>
<h3 id="relationship-to-d041d043--integration-summary"><a class="header" href="#relationship-to-d041d043--integration-summary">Relationship to D041/D043 — Integration Summary</a></h3>
<p>The LLM AI modes build entirely on the <code>AiStrategy</code> trait (D041) and the two-axis difficulty system (D043):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Orchestrator</th><th>LLM Player</th></tr>
</thead>
<tbody>
<tr><td>Implements <code>AiStrategy</code>?</td><td>Yes — wraps an inner <code>AiStrategy</code></td><td>Yes — direct implementation</td></tr>
<tr><td>Uses <code>AiEventLog</code>?</td><td>Yes — accumulates events for LLM prompts, forwards callbacks to inner AI</td><td>Yes — accumulates events for LLM self-context</td></tr>
<tr><td><code>FogFilteredView</code>?</td><td>Yes — serialized into LLM prompt alongside event narrative</td><td>Yes — serialized into LLM prompt</td></tr>
<tr><td>Event callbacks?</td><td>Forwards to inner AI + records in event log</td><td>Records in event log for next LLM consultation</td></tr>
<tr><td><code>set_parameter()</code>?</td><td>Exposes orchestrator params + delegates to inner AI; translates LLM plans to param adjustments</td><td>Exposes LLM-specific params (decision_interval, max_tokens)</td></tr>
<tr><td><code>get_parameters()</code>?</td><td>Returns orchestrator params + inner AI’s params</td><td>Returns LLM Player params</td></tr>
<tr><td><code>uses_engine_difficulty_scaling()</code>?</td><td>Delegates to inner AI</td><td>Returns <code>true</code> (engine bonuses/handicaps apply)</td></tr>
<tr><td><code>difficulty()</code>?</td><td>Delegates to inner AI</td><td>Returns selected difficulty (user picks in lobby)</td></tr>
<tr><td>Two-axis difficulty?</td><td>Inner AI axis applies to execution; orchestrator params are separate</td><td>Engine scaling applies; LLM quality is model-dependent</td></tr>
</tbody>
</table>
</div>
<p>The critical architectural property: <strong>neither LLM AI mode introduces any new trait methods, crate dependencies, or sim-layer concepts.</strong> They compose entirely from existing infrastructure — <code>AiStrategy</code>, <code>AiEventLog</code>, <code>FogFilteredView</code>, <code>set_parameter()</code>, <code>LlmProvider</code>. This means the LLM AI path doesn’t constrain or complicate the non-LLM AI path. A modder who never uses LLM features is completely unaffected.</p>
<h3 id="future-path-full-llm-control-at-scale"><a class="header" href="#future-path-full-llm-control-at-scale">Future Path: Full LLM Control at Scale</a></h3>
<p>The current <code>LlmPlayerAi</code> is limited by latency (LLM responses take 100-500ms vs. 33ms sim ticks) and spatial reasoning capability. As LLM inference speeds improve and models gain better spatial/numerical reasoning, the same architecture scales:</p>
<ul>
<li>Faster models → lower <code>decision_interval</code> → more responsive LLM play</li>
<li>Better spatial reasoning → LLM can handle micro, not just strategy</li>
<li>Multimodal models → render a minimap image as additional LLM context alongside the event narrative</li>
<li>The <code>AiStrategy</code> trait, <code>AiEventLog</code>, and <code>FogFilteredView</code> infrastructure are all model-agnostic — they serve whatever LLM capability exists at runtime</li>
</ul>
<p>The architecture is deliberately designed not to stand in the way of full LLM control becoming practical. Every piece needed for “LLM makes every small decision” already exists in the trait design — the only bottleneck is LLM speed and quality, which are external constraints that improve over time.</p>
<h3 id="crate-boundaries-1"><a class="header" href="#crate-boundaries-1">Crate Boundaries</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Crate</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>LlmOrchestratorAi</code> struct</td><td><code>ic-ai</code></td><td>AI strategy implementation</td></tr>
<tr><td><code>LlmPlayerAi</code> struct</td><td><code>ic-ai</code></td><td>AI strategy implementation</td></tr>
<tr><td><code>StrategicPlan</code> type</td><td><code>ic-ai</code></td><td>AI-internal data structure</td></tr>
<tr><td><code>AiEventLog</code> struct</td><td><code>ic-ai</code></td><td>Engine-provided event accumulator (D041 design, <code>ic-ai</code> impl)</td></tr>
<tr><td><code>LlmProvider</code> trait</td><td><code>ic-llm</code></td><td>Existing D016 infrastructure</td></tr>
<tr><td>Prompt templates (YAML)</td><td>mod data</td><td>Game-module-specific, moddable</td></tr>
<tr><td>Game state serializer for LLM</td><td><code>ic-ai</code></td><td>Reads sim state (read-only), formats for LLM prompts</td></tr>
<tr><td>Debug overlay (plan viewer)</td><td><code>ic-ui</code></td><td>Spectator/dev UI for observing LLM reasoning + event narrative</td></tr>
</tbody>
</table>
</div>
<h3 id="alternatives-considered-2"><a class="header" href="#alternatives-considered-2">Alternatives Considered</a></h3>
<ul>
<li>LLM replaces inner AI entirely in orchestrator mode (rejected — latency makes tick-level LLM control impractical; hybrid is better)</li>
<li>LLM operates between games only (rejected — D042 already covers between-game coaching; real-time guidance is the new capability)</li>
<li>No LLM Player mode (rejected — the experimental mode has minimal implementation cost and high community interest/entertainment value)</li>
<li>LLM in the sim crate (rejected — violates BYOLLM optionality; <code>ic-ai</code> imports <code>ic-llm</code> optionally, <code>ic-sim</code> never imports either)</li>
<li>New trait method <code>set_strategic_guidance()</code> for LLM → inner AI communication (rejected — <code>set_parameter()</code> already provides the mechanism; adding an LLM-specific method to the generic <code>AiStrategy</code> trait would couple the trait to an optional feature)</li>
<li>Custom event log per AI instead of engine-provided <code>AiEventLog</code> (rejected — the log benefits all AI implementations for debugging/observation, not just LLM; making it engine infrastructure avoids redundant implementations)</li>
</ul>
<h3 id="relationship-to-existing-decisions-3"><a class="header" href="#relationship-to-existing-decisions-3">Relationship to Existing Decisions</a></h3>
<ul>
<li><strong>D016 (BYOLLM):</strong> Same provider infrastructure. Both LLM AI modes use <code>LlmProvider</code> trait for model access.</li>
<li><strong>D041 (<code>AiStrategy</code> trait):</strong> Both modes implement <code>AiStrategy</code>. The orchestrator wraps any <code>AiStrategy</code> via the generic trait. Both use <code>AiEventLog</code> (D041) for fog-filtered event accumulation. The orchestrator communicates with the inner AI through <code>set_parameter()</code> and event callback forwarding — all D041 infrastructure.</li>
<li><strong>D042 (<code>StyleDrivenAi</code>):</strong> The orchestrator can wrap <code>StyleDrivenAi</code> — LLM strategic guidance on top of a mimicked player’s style. The <code>AiEventLog</code> serves both D042 (profile building reads events) and D044 (LLM reads events).</li>
<li><strong>D043 (AI presets + two-axis difficulty):</strong> LLM AI integrates with the two-axis difficulty system. Orchestrator delegates difficulty to inner AI; LLM Player accepts engine scaling. Users select inner AI + difficulty in the lobby, then optionally enable LLM orchestration.</li>
<li><strong>D031 (telemetry):</strong> The <code>GameplayEvent</code> stream (D031) feeds the fog-filtered callback pipeline that populates <code>AiEventLog</code>. D031 is the raw data source; D041 callbacks are the filtered AI-facing interface; <code>AiEventLog</code> is the accumulated narrative.</li>
<li><strong>D034 (SQLite):</strong> LLM consultation history (prompts sent, plans received, execution outcomes) stored in SQLite for debugging and quality analysis. No new tables required — uses the existing <code>gameplay_events</code> schema with LLM-specific event types.</li>
<li><strong>D057 (Skill Library):</strong> The orchestrator is the primary producer and consumer of AI strategy skills. Proven <code>StrategicPlan</code> outputs are stored in the skill library; future consultations retrieve relevant skills as few-shot prompt context. See D057 for the full verification→storage→retrieval loop.</li>
</ul>
<hr>
<hr>
<h2 id="d045-pathfinding-behavior-presets--movement-feel"><a class="header" href="#d045-pathfinding-behavior-presets--movement-feel">D045: Pathfinding Behavior Presets — Movement Feel</a></h2>
<p><strong>Status:</strong> Accepted
<strong>Scope:</strong> <code>ic-sim</code>, game module configuration
<strong>Phase:</strong> Phase 2 (ships with simulation)</p>
<h3 id="the-problem-3"><a class="header" href="#the-problem-3">The Problem</a></h3>
<p>D013 provides the <code>Pathfinder</code> trait for pluggable pathfinding <em>algorithms</em> (multi-layer hybrid vs. navmesh). D019 provides switchable <em>balance</em> values. But movement <em>feel</em> — how units navigate, group, avoid each other, and handle congestion — varies dramatically between Classic RA, OpenRA, and what modern pathfinding research enables. This is partially balance (unit speed values) but mostly <em>behavioral</em>: how the pathfinder handles collisions, how units merge into formations, how traffic jams resolve, and how responsive movement commands feel.</p>
<h3 id="decision-2"><a class="header" href="#decision-2">Decision</a></h3>
<p>Ship <strong>pathfinding behavior presets</strong> as separate <code>Pathfinder</code> trait implementations (D013), each sourced from the codebase it claims to reproduce. Presets are selectable alongside balance presets (D019) and AI presets (D043), bundled into experience profiles, and presented through progressive disclosure so casual players never see the word “pathfinding.”</p>
<h3 id="built-in-presets-1"><a class="header" href="#built-in-presets-1">Built-In Presets</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Preset</th><th>Movement Feel</th><th>Source</th><th><code>Pathfinder</code> Implementation</th></tr>
</thead>
<tbody>
<tr><td><strong>Classic RA</strong></td><td>Unit-level A*-like pathing, units block each other, congestion causes jams, no formation movement, units take wide detours around obstacles</td><td>EA Remastered Collection source code (GPL v3)</td><td><code>RemastersPathfinder</code></td></tr>
<tr><td><strong>OpenRA</strong></td><td>Improved cell-based pathing, basic crush/push logic, units attempt to flow around blockages, locomotor-based speed modifiers, no formal formations</td><td>OpenRA pathfinding implementation (GPL v3)</td><td><code>OpenRaPathfinder</code></td></tr>
<tr><td><strong>IC Default</strong></td><td>Multi-layer hybrid: hierarchical sectors for routing, JPS for small groups, flow field tiles for mass movement, ORCA-lite local avoidance, formation-aware group coordination</td><td>Open-source RTS research + IC original (see below)</td><td><code>IcPathfinder</code></td></tr>
</tbody>
</table>
</div>
<p>Each preset is a <strong>distinct <code>Pathfinder</code> trait implementation</strong>, not a parameterized variant of one algorithm. The Remastered pathfinder and OpenRA pathfinder use fundamentally different algorithms and produce fundamentally different movement behavior — parameterizing one to emulate the other would be an approximation at best and a lie at worst. The <code>Pathfinder</code> trait (D013) was designed for exactly this: slot in different implementations without touching sim code.</p>
<p><strong>Why “IcPathfinder,” not “IcFlowfieldPathfinder”?</strong> Research revealed that no shipped RTS engine uses pure flowfields (except SupCom2/PA by the same team). Spring Engine tried flow maps and abandoned them. Independent developers (jdxdev) documented the same “ant line” failure with 100+ units. IC’s default pathfinder is a multi-layer hybrid — flowfield tiles are one layer activated for large groups, not the system’s identity. See <code>research/pathfinding-ic-default-design.md</code> for full architecture.</p>
<p><strong>Why Remastered, not original RA source?</strong> The Remastered Collection engine DLLs (GPL v3) contain the same pathfinding logic as original RA but with bug fixes and modernized C++ that’s easier to port to Rust. The original RA source is also GPL and available for cross-reference. Both produce the same movement feel — the Remastered version is simply a cleaner starting point.</p>
<h3 id="ic-default-pathfinding--research-foundation"><a class="header" href="#ic-default-pathfinding--research-foundation">IC Default Pathfinding — Research Foundation</a></h3>
<p>The IC Default preset (<code>IcPathfinder</code>) is a five-layer hybrid architecture synthesizing pathfinding approaches from across the open-source RTS ecosystem and academic research. Full design: <code>research/pathfinding-ic-default-design.md</code>.</p>
<p><strong>Layer 1 — Cost Field &amp; Passability:</strong> Per-cell movement cost (u8, 1–255) per locomotor type, inspired by EA Remastered terrain cost tables and 0 A.D.’s passability classes.</p>
<p><strong>Layer 2 — Hierarchical Sector Graph:</strong> Map divided into 32×32-cell sectors with portal connections between them. Flood-fill domain IDs for O(1) reachability checks. Inspired by OpenRA’s hierarchical abstraction and HPA* research.</p>
<p><strong>Layer 3 — Adaptive Detailed Pathfinding:</strong> JPS (Jump Point Search) for small groups (&lt;8 units) — 10–100× faster than A* on uniform-cost grids. Flow field tiles for mass movement (≥8 units sharing a destination). Weighted A* fallback for non-uniform terrain. LRU flow field cache. Inspired by 0 A.D.’s JPS, SupCom2’s flow field tiles, Game AI Pro 2’s JPS+ precomputed tables.</p>
<p><strong>Layer 4 — ORCA-lite Local Avoidance:</strong> Fixed-point deterministic collision avoidance based on RVO2/ORCA (Reciprocal Velocity Obstacles). Commitment locking prevents hallway dance. Cooperative side selection (“mind reading”) from HowToRTS research.</p>
<p><strong>Layer 5 — Group Coordination:</strong> Formation offset assignment, synchronized arrival, chokepoint compression. Inspired by jdxdev’s boids-for-RTS formation offsets and Spring Engine’s group movement.</p>
<p><strong>Source engines studied:</strong></p>
<ul>
<li><strong>EA Remastered Collection</strong> (GPL v3) — obstacle-tracing, terrain cost tables, integer math</li>
<li><strong>OpenRA</strong> (GPL v3) — hierarchical A*, custom search graph with 10×10 abstraction</li>
<li><strong>Spring Engine</strong> (GPL v2) — QTPFS quadtree, flow-map attempt (abandoned), unit push/slide</li>
<li><strong>0 A.D.</strong> (GPL v2/MIT) — JPS long-range + vertex short-range, clearance-based sizing, fixed-point <code>CFixed_15_16</code></li>
<li><strong>Warzone 2100</strong> (GPL v2) — A* with LRU context caching, gateway optimization</li>
<li><strong>SupCom2/PA</strong> — flow field tiles (only shipped flowfield RTS)</li>
<li><strong>Academic</strong> — RVO2/ORCA (UNC), HPA*, continuum crowds (Treuille et al.), JPS+ (Game AI Pro 2)</li>
</ul>
<h3 id="configuration-model-1"><a class="header" href="#configuration-model-1">Configuration Model</a></h3>
<p>Each <code>Pathfinder</code> implementation exposes its own tunable parameters via YAML. Parameters differ between implementations because they control fundamentally different algorithms — there is no shared “pathfinding config” struct that applies to all three.</p>
<pre><code class="language-yaml"># pathfinding/remastered.yaml — RemastersPathfinder tunables
remastered_pathfinder:
  name: "Classic Red Alert"
  description: "Movement feel matching the original game"
  # These are behavioral overrides on the Remastered pathfinder.
  # Defaults reproduce original behavior exactly.
  harvester_stuck_fix: false         # true = apply minor QoL fix for harvesters stuck on each other
  bridge_queue_behavior: original    # original | relaxed (slightly wider queue threshold)
  infantry_scatter_pattern: original # original | smoothed (less jagged scatter on damage)

# pathfinding/openra.yaml — OpenRaPathfinder tunables
openra_pathfinder:
  name: "OpenRA"
  description: "Movement feel matching OpenRA's pathfinding"
  locomotor_speed_modifiers: true    # per-terrain speed multipliers (OpenRA feature)
  crush_logic: true                  # vehicles can crush infantry
  blockage_flow: true                # units attempt to flow around blocking units

# pathfinding/ic-default.yaml — IcPathfinder tunables
ic_pathfinder:
  name: "IC Default"
  description: "Multi-layer hybrid: JPS + flow field tiles + ORCA-lite avoidance"

  # Layer 2 — Hierarchical sectors
  sector_size: 32                    # cells per sector side
  portal_max_width: 8                # max portal opening (cells)

  # Layer 3 — Adaptive pathfinding
  flowfield_group_threshold: 8       # units sharing dest before flowfield activates
  flowfield_cache_size: 64           # LRU cache entries for flow field tiles
  jps_enabled: true                  # JPS for small groups on uniform terrain
  repath_frequency: adaptive         # low | medium | high | adaptive

  # Layer 4 — Local avoidance (ORCA-lite)
  avoidance_radius_multiplier: 1.2   # multiplier on unit collision radius
  commitment_frames: 4               # frames locked into avoidance direction
  cooperative_avoidance: true        # "mind reading" side selection

  # Layer 5 — Group coordination
  formation_movement: true           # groups move in formation
  synchronized_arrival: true         # units slow down to arrive together
  chokepoint_compression: true       # formation compresses at narrow passages

  # General
  path_smoothing: funnel             # none | funnel | spline
  influence_avoidance: true          # avoid areas with high enemy threat
</code></pre>
<p>Power users can override any parameter in the lobby’s advanced settings or in mod YAML. Casual players never see these — they pick an experience profile and the correct implementation + parameters are selected automatically.</p>
<h3 id="sim-affecting-nature"><a class="header" href="#sim-affecting-nature">Sim-Affecting Nature</a></h3>
<p>Pathfinding presets are <strong>sim-affecting</strong> — they change how the deterministic simulation resolves movement. Like balance presets (D019):</p>
<ul>
<li>All players in a multiplayer game must use the same pathfinding preset (enforced by lobby, validated by sim)</li>
<li>Preset selection is part of the game configuration hash for desync detection</li>
<li>Replays record the active pathfinding preset</li>
</ul>
<h3 id="experience-profile-integration-1"><a class="header" href="#experience-profile-integration-1">Experience Profile Integration</a></h3>
<pre><code class="language-yaml">profiles:
  classic-ra:
    balance: classic
    ai_preset: classic-ra
    pathfinding: classic-ra          # NEW — movement feel
    theme: classic
    qol: vanilla

  openra-ra:
    balance: openra
    ai_preset: openra
    pathfinding: openra              # NEW — OpenRA movement feel
    theme: modern
    qol: openra

  iron-curtain-ra:
    balance: classic
    ai_preset: ic-default
    pathfinding: ic-default          # NEW — modern movement
    theme: modern
    qol: iron_curtain
</code></pre>
<h3 id="user-facing-ux--progressive-disclosure"><a class="header" href="#user-facing-ux--progressive-disclosure">User-Facing UX — Progressive Disclosure</a></h3>
<p>Pathfinding selection follows the same progressive disclosure pyramid as the rest of the experience profile system. A casual player should never encounter the word “pathfinding.”</p>
<p><strong>Level 1 — One dropdown (casual player):</strong> The lobby’s experience profile selector offers “Classic RA,” “OpenRA,” or “Iron Curtain.” Picking one sets balance, theme, QoL, AI, movement feel, AND render mode. The pathfinder and render mode selections are invisible — they’re bundled. A player who picks “Classic RA” gets Remastered pathfinding and classic pixel art because that’s what Classic RA <em>is</em>.</p>
<p><strong>Level 2 — Per-axis override (intermediate player):</strong> An “Advanced” toggle in the lobby expands the experience profile into its 6 independent axes. The movement axis is labeled by feel, not algorithm: “Movement: Classic / OpenRA / Modern” — not “<code>RemastersPathfinder</code> / <code>OpenRaPathfinder</code> / <code>IcPathfinder</code>.” The render mode axis shows “Graphics: Classic / HD / 3D” (D048). The player can mix “OpenRA balance + Classic movement + HD graphics” if they want.</p>
<p><strong>Level 3 — Parameter tuning (power user / modder):</strong> A gear icon next to the movement axis opens implementation-specific parameters (see Configuration Model above). This is where harvester stuck fixes, pressure diffusion strength, and formation toggles live.</p>
<h3 id="scenario-required-pathfinding"><a class="header" href="#scenario-required-pathfinding">Scenario-Required Pathfinding</a></h3>
<p>Scenarios and campaign missions can specify a <strong>required</strong> or <strong>recommended</strong> pathfinding preset in their YAML metadata:</p>
<pre><code class="language-yaml">scenario:
  name: "Bridge Assault"
  pathfinding:
    required: classic-ra    # this mission depends on chokepoint blocking behavior
    reason: "Mission balance depends on single-file bridge queuing"
</code></pre>
<p>When the lobby loads this scenario, it auto-selects the required pathfinder and shows the player why: “This scenario requires Classic movement (mission balance depends on chokepoint behavior).” The player cannot override a <code>required</code> setting. A <code>recommended</code> setting auto-selects but allows override with a warning.</p>
<p>This preserves original campaign missions. A mission designed around units jamming at a bridge works correctly because it ships with <code>required: classic-ra</code>. A modern community scenario can ship with <code>required: ic-default</code> to ensure smooth flowfield behavior.</p>
<h3 id="mod-selectable-and-mod-provided-pathfinders"><a class="header" href="#mod-selectable-and-mod-provided-pathfinders">Mod-Selectable and Mod-Provided Pathfinders</a></h3>
<p>The three built-in presets are the <strong>first-party</strong> <code>Pathfinder</code> implementations. They are not the only ones. The <code>Pathfinder</code> trait (D013) is explicitly open to community implementations.</p>
<p><strong>Modder as consumer — selecting a pathfinder:</strong></p>
<p>A mod’s YAML manifest can declare which pathfinder it uses. The modder picks from any available implementation — first-party or community:</p>
<pre><code class="language-yaml"># mod.yaml — total conversion mod that uses IC's modern pathfinding
mod:
  name: "Desert Strike"
  pathfinder: ic-default            # Use IC's multi-layer hybrid
  # Or: remastered, openra, layered-grid-generals, community/navmesh-pro, etc.
</code></pre>
<p>If the mod doesn’t specify a pathfinder, it inherits whatever the player’s experience profile selects. When specified, it overrides the experience profile’s pathfinding axis — the same way <code>scenario.pathfinding.required</code> works (see “Scenario-Required Pathfinding” above), but at the mod level.</p>
<p><strong>Modder as author — providing a pathfinder:</strong></p>
<p>A Tier 3 WASM mod can implement the <code>Pathfinder</code> trait and register it as a new option:</p>
<p><strong>Host ABI note:</strong> The Rust trait-style example below is <strong>conceptual</strong>. A WASM pathfinder does not share a native Rust trait object directly with the engine. In implementation, the engine exposes a stable host ABI and adapts the WASM exports to the <code>Pathfinder</code> trait on the host side.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WASM mod: custom pathfinder (e.g., Generals-style layered grid)
impl Pathfinder for LayeredGridPathfinder {
    fn request_path(&amp;mut self, origin: WorldPos, dest: WorldPos, locomotor: LocomotorType) -&gt; PathId {
        // Surface bitmask check, zone reachability, A* with bridge layers
        // ...
    }
    fn get_path(&amp;self, id: PathId) -&gt; Option&lt;&amp;[WorldPos]&gt; { /* ... */ }
    fn is_passable(&amp;self, pos: WorldPos, locomotor: LocomotorType) -&gt; bool { /* ... */ }
    fn invalidate_area(&amp;mut self, center: WorldPos, radius: SimCoord) { /* ... */ }
}
<span class="boring">}</span></code></pre>
<p>The mod registers its pathfinder in its manifest with a YAML config block (like the built-in presets):</p>
<pre><code class="language-yaml"># mod.yaml — community pathfinder distributed via Workshop
mod:
  name: "Generals Pathfinder"
  type: pathfinder                   # declares this mod provides a Pathfinder impl
  pathfinder_id: layered-grid-generals
  display_name: "Generals (Layered Grid)"
  description: "Grid pathfinding with bridge layers and surface bitmasks, inspired by C&amp;C Generals"
  wasm_module: generals_pathfinder.wasm
  config:
    zone_block_size: 10
    bridge_clearance: 10.0
    surface_types: [ground, water, cliff, air, rubble]
</code></pre>
<p>Once installed, the community pathfinder appears alongside first-party presets in the lobby’s Level 2 per-axis override (“Movement: Classic / OpenRA / Modern / Generals”) and is selectable by other mods via <code>pathfinder: layered-grid-generals</code>.</p>
<p><strong>Workshop distribution:</strong> Community pathfinders are Workshop resources (D030) like any other mod. They can be rated, reviewed, and depended upon. A total conversion mod declares <code>depends: community/generals-pathfinder@^1.0</code> and the engine auto-downloads it on lobby join (same as CS:GO-style auto-download).</p>
<p><strong>Sim-affecting implications:</strong> Because pathfinding is deterministic and sim-affecting, all players in a multiplayer game must use the same pathfinder. A community pathfinder is synced like a first-party preset — the lobby validates that all clients have the same pathfinder WASM module (by SHA-256 hash), same config, same version.</p>
<h3 id="wasm-pathfinder-policy-determinism-performance-ranked"><a class="header" href="#wasm-pathfinder-policy-determinism-performance-ranked">WASM Pathfinder Policy (Determinism, Performance, Ranked)</a></h3>
<p>Community pathfinders are allowed, but they are not a free-for-all in every mode:</p>
<ul>
<li><strong>Single-player / skirmish / custom lobbies:</strong> allowed by default (subject to normal WASM sandbox rules)</li>
<li><strong>Ranked queues / competitive ladders:</strong> disallowed by default unless a queue/community explicitly certifies and whitelists the pathfinder (hash + version + config schema)</li>
<li><strong>Determinism contract:</strong> no wall-clock time, no nondeterministic RNG, no filesystem/network I/O, no host APIs that expose machine-specific timing/order</li>
<li><strong>Performance contract:</strong> pathfinder modules must declare budget expectations and pass deterministic conformance + performance checks (<code>ic mod test</code>, <code>ic mod perf-test</code>) on the baseline hardware tier before certification</li>
<li><strong>Failure policy:</strong> if a pathfinder module fails validation/loading/perf certification for a ranked queue, the lobby rejects the configuration before match start (never mid-match fail-open)</li>
</ul>
<p>This preserves D013’s openness for experimentation while protecting ranked integrity, baseline hardware support, and deterministic simulation guarantees.</p>
<h3 id="relationship-to-existing-decisions-4"><a class="header" href="#relationship-to-existing-decisions-4">Relationship to Existing Decisions</a></h3>
<ul>
<li><strong>D013 (<code>Pathfinder</code> trait):</strong> Each preset is a separate <code>Pathfinder</code> trait implementation. <code>RemastersPathfinder</code>, <code>OpenRaPathfinder</code>, and <code>IcPathfinder</code> are all registered by the RA1 game module. Community mods add more via WASM. The trait boundary serves triple duty: it separates algorithmic families (grid vs. navmesh), behavioral families (Classic vs. Modern), AND first-party from community-provided implementations.</li>
<li><strong>D018 (<code>GameModule</code> trait):</strong> The RA1 game module ships all three first-party pathfinder implementations. Community pathfinders are registered by the mod loader alongside them. The lobby’s experience profile selection determines which one is active — <code>fn pathfinder()</code> returns whichever <code>Box&lt;dyn Pathfinder&gt;</code> was selected, whether first-party or community.</li>
<li><strong>D019 (balance presets):</strong> Parallel concept. Balance = what units can do. Pathfinding = how they get there. Both are sim-affecting, synced in multiplayer, and open to community alternatives.</li>
<li><strong>D043 (AI presets):</strong> Orthogonal. AI decides where to send units; pathfinding decides how they move. An AI preset + pathfinding preset combination determines overall movement behavior. Both are modder-selectable.</li>
<li><strong>D033 (QoL toggles):</strong> Some implementation-specific parameters (harvester stuck fix, infantry scatter smoothing) could be classified as QoL. Presets bundle them for consistency; individual toggles in advanced settings allow fine-tuning.</li>
<li><strong>D048 (render modes):</strong> Same modder-selectable pattern. Mods select or provide render modes; mods select or provide pathfinders. The trait-per-subsystem architecture means every pluggable system follows the same model.</li>
</ul>
<h3 id="alternatives-considered-3"><a class="header" href="#alternatives-considered-3">Alternatives Considered</a></h3>
<ul>
<li><strong>One “best” pathfinding only</strong> (rejected — Classic RA movement feel is part of the nostalgia and is critical for original scenario compatibility; forcing modern pathing on purists would alienate them AND break existing missions)</li>
<li><strong>Pathfinding differences handled by balance presets</strong> (rejected — movement behavior is fundamentally different from numeric values; a separate axis deserves separate selection)</li>
<li><strong>One parameterized implementation that emulates all three</strong> (rejected — Remastered pathfinding and IC flowfield pathfinding are fundamentally different algorithms with different data structures and different computational models; parameterizing one to approximate the other produces a neither-fish-nor-fowl result that reproduces neither accurately; separate implementations are honest and maintainable)</li>
<li><strong>Only IC Default pathfinding, with “classic mode” as a cosmetic approximation</strong> (rejected — scenario compatibility requires <em>actual</em> reproduction of original movement behavior, not an approximation; bridge missions, chokepoint defense, harvester timing all depend on specific pathfinding quirks)</li>
</ul>
<hr>
<hr>
<h2 id="d048-switchable-render-modes--classic-hd-and-3d-in-one-game"><a class="header" href="#d048-switchable-render-modes--classic-hd-and-3d-in-one-game">D048: Switchable Render Modes — Classic, HD, and 3D in One Game</a></h2>
<p><strong>Status:</strong> Accepted
<strong>Scope:</strong> <code>ic-render</code>, <code>ic-game</code>, <code>ic-ui</code>
<strong>Phase:</strong> Phase 2 (render mode infrastructure), Phase 3 (toggle UI), Phase 6a (3D mode mod support)</p>
<h3 id="the-problem-4"><a class="header" href="#the-problem-4">The Problem</a></h3>
<p>The C&amp;C Remastered Collection’s most iconic UX feature is pressing F1 to instantly toggle between classic 320×200 sprites and hand-painted HD art — mid-game, no loading screen. This isn’t just swapping sprites. It’s switching the <em>entire visual presentation</em>: sprite resolution, palette handling, terrain tiles, shadow rendering, UI chrome, and scaling behavior. The engine already has pieces to support this (resource packs in <code>04-MODDING.md</code>, dual asset rendering in D029, <code>Renderable</code> trait, <code>ScreenToWorld</code> trait, 3D render mods in <code>02-ARCHITECTURE.md</code>), but they exist as independent systems with no unified mechanism for “switch everything at once.” Furthermore, the current design treats 3D rendering exclusively as a Tier 3 WASM mod that <strong>replaces</strong> the default renderer — there’s no concept of a game or mod that ships <em>both</em> 2D and 3D views and lets the player toggle between them.</p>
<h3 id="decision-3"><a class="header" href="#decision-3">Decision</a></h3>
<p>Introduce <strong>render modes</strong> as a first-class engine concept. A render mode bundles a rendering backend, camera system, resource pack selection, and visual configuration into a named, instantly-switchable unit. Game modules and mods can register multiple render modes; the player toggles between them with a keybind or settings menu.</p>
<h3 id="what-a-render-mode-is"><a class="header" href="#what-a-render-mode-is">What a Render Mode Is</a></h3>
<p>A render mode composes four concerns that must change together:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>What Changes</th><th>Trait / System</th></tr>
</thead>
<tbody>
<tr><td><strong>Render backend</strong></td><td>Sprite renderer vs. mesh renderer vs. voxel renderer</td><td><code>Renderable</code> impl</td></tr>
<tr><td><strong>Camera</strong></td><td>Isometric orthographic vs. free 3D perspective; zoom range</td><td><code>ScreenToWorld</code> impl + <code>CameraConfig</code></td></tr>
<tr><td><strong>Resource packs</strong></td><td>Which asset set to use (classic <code>.shp</code>, HD sprites, GLTF models)</td><td>Resource pack selection</td></tr>
<tr><td><strong>Visual config</strong></td><td>Scaling mode, palette handling, shadow style, post-FX preset</td><td><code>RenderSettings</code> subset</td></tr>
</tbody>
</table>
</div>
<p>A render mode is NOT a game module. The simulation, pathfinding, networking, balance, and game rules are completely unchanged between modes. Two players in the same multiplayer game can use different render modes — the sim is view-agnostic (this is already an established architectural property).</p>
<h3 id="render-mode-registration"><a class="header" href="#render-mode-registration">Render Mode Registration</a></h3>
<p>Game modules register their supported render modes via the <code>GameModule</code> trait:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RenderMode {
    pub id: String,                        // "classic", "hd", "3d"
    pub display_name: String,              // "Classic (320×200)", "HD Sprites", "3D View"
    pub render_backend: RenderBackendId,   // Which Renderable impl to use
    pub camera: CameraMode,                // Isometric, Perspective, FreeRotate
    pub camera_config: CameraConfig,       // Zoom range, pan speed (see 02-ARCHITECTURE.md § Camera)
    pub resource_pack_overrides: Vec&lt;ResourcePackRef&gt;, // Per-category pack selections
    pub visual_config: VisualConfig,       // Scaling, palette, shadow, post-FX
    pub keybind: Option&lt;KeyCode&gt;,          // Optional dedicated toggle key
}

pub struct CameraConfig {
    pub zoom_min: f32,                     // minimum zoom (0.5 = zoomed way out)
    pub zoom_max: f32,                     // maximum zoom (4.0 = close-up)
    pub zoom_default: f32,                 // starting zoom level (1.0)
    pub integer_snap: bool,                // snap to integer scale for pixel art (Classic mode)
}

pub struct VisualConfig {
    pub scaling: ScalingMode,              // IntegerNearest, Bilinear, Native
    pub palette_mode: PaletteMode,         // IndexedPalette, DirectColor
    pub shadow_style: ShadowStyle,         // SpriteShadow, ProjectedShadow, None
    pub post_fx: PostFxPreset,             // None, Classic, Enhanced
}
<span class="boring">}</span></code></pre>
<p>The RA1 game module would register:</p>
<pre><code class="language-yaml">render_modes:
  classic:
    display_name: "Classic"
    render_backend: sprite
    camera: isometric
    camera_config:
      zoom_min: 0.5
      zoom_max: 3.0
      zoom_default: 1.0
      integer_snap: true           # snap OrthographicProjection.scale to integer multiples
    resource_packs:
      sprites: classic-shp
      terrain: classic-tiles
    visual_config:
      scaling: integer_nearest
      palette_mode: indexed
      shadow_style: sprite_shadow
      post_fx: none
    description: "Original 320×200 pixel art, integer-scaled"

  hd:
    display_name: "HD"
    render_backend: sprite
    camera: isometric
    camera_config:
      zoom_min: 0.5
      zoom_max: 4.0
      zoom_default: 1.0
      integer_snap: false          # smooth zoom at all levels
    resource_packs:
      sprites: hd-sprites         # Requires HD sprite resource pack
      terrain: hd-terrain
    visual_config:
      scaling: native
      palette_mode: direct_color
      shadow_style: sprite_shadow
      post_fx: enhanced
    description: "High-definition sprites at native resolution"
</code></pre>
<p>A 3D render mod adds a third mode:</p>
<pre><code class="language-yaml"># 3d_mod/render_modes.yaml (extends base game module)
render_modes:
  3d:
    display_name: "3D View"
    render_backend: mesh            # Provided by the WASM mod
    camera: free_rotate
    camera_config:
      zoom_min: 0.25               # 3D allows wider zoom range
      zoom_max: 6.0
      zoom_default: 1.0
      integer_snap: false
    resource_packs:
      sprites: 3d-models           # GLTF meshes mapped to unit types
      terrain: 3d-terrain
    visual_config:
      scaling: native
      palette_mode: direct_color
      shadow_style: projected_shadow
      post_fx: enhanced
    description: "Full 3D rendering with free camera"
    requires_mod: "3d-ra"          # Only available when this mod is loaded
</code></pre>
<h3 id="toggle-mechanism"><a class="header" href="#toggle-mechanism">Toggle Mechanism</a></h3>
<p><strong>Default keybind:</strong> F1 cycles through available render modes (matching the Remastered Collection). A game with only <code>classic</code> and <code>hd</code> modes: F1 toggles between them. A game with three modes: F1 cycles classic → hd → 3d → classic. The cycle order matches the <code>render_modes</code> declaration order.</p>
<p><strong>Settings UI:</strong></p>
<pre><code>Settings → Graphics → Render Mode
┌───────────────────────────────────────────────┐
│ Active Render Mode:  [HD ▾]                   │
│                                               │
│ Toggle Key: [F1]                              │
│ Cycle Order: Classic → HD → 3D                │
│                                               │
│ Available Modes:                              │
│ ● Classic — Original pixel art, integer-scaled│
│ ● HD — High-definition sprites (requires      │
│         HD sprite pack)                       │
│ ● 3D View — Full 3D (requires 3D RA mod)     │
│              [Browse Workshop →]              │
└───────────────────────────────────────────────┘
</code></pre>
<p>Modes whose required resource packs or mods aren’t installed remain clickable — selecting one opens a guidance panel explaining what’s needed and linking directly to Workshop or settings (see D033 § “UX Principle: No Dead-End Buttons”). No greyed-out entries.</p>
<h3 id="how-the-switch-works-runtime"><a class="header" href="#how-the-switch-works-runtime">How the Switch Works (Runtime)</a></h3>
<p>The toggle is instant — no loading screen, no fade-to-black for same-backend switches:</p>
<ol>
<li>
<p><strong>Same render backend</strong> (classic ↔ hd): Swap <code>Handle</code> references on all <code>Renderable</code> components. Both asset sets are loaded at startup (or on first toggle). Bevy’s asset system makes this a single-frame operation — exactly like the Remastered Collection’s F1.</p>
</li>
<li>
<p><strong>Different render backend</strong> (2D ↔ 3D): Swap the active <code>Renderable</code> implementation and camera. This is heavier — the first switch loads the 3D asset set (brief loading indicator). Subsequent switches are instant because both backends stay resident. Camera interpolates smoothly between isometric and perspective over ~0.3 seconds.</p>
</li>
<li>
<p><strong>Multiplayer</strong>: Render mode is a client-only setting. The sim doesn’t know or care. No sync, no lobby lock. One player on Classic, one on HD, one on 3D — all in the same game. This already works architecturally; D048 just formalizes it.</p>
</li>
<li>
<p><strong>Replays</strong>: Render mode is switchable during replay playback. Watch a classic-era replay in 3D, or vice versa.</p>
</li>
</ol>
<h3 id="cross-view-multiplayer"><a class="header" href="#cross-view-multiplayer">Cross-View Multiplayer</a></h3>
<p>This deserves emphasis because it’s a feature no shipped C&amp;C game has offered: <strong>players using different visual presentations in the same multiplayer match.</strong> The sim/render split (Invariant #1, #9) makes this free. A competitive player who prefers classic pixel clarity plays against someone using 3D — same rules, same sim, same balance, different eyes.</p>
<p>Cross-view also means <strong>cross-view spectating</strong>: an observer can watch a tournament match in 3D while the players compete in classic 2D. This creates unique content creation and broadcasting opportunities.</p>
<h3 id="information-equivalence-across-render-modes"><a class="header" href="#information-equivalence-across-render-modes">Information Equivalence Across Render Modes</a></h3>
<p>Cross-view multiplayer is competitively safe because all render modes display <strong>identical game-state information:</strong></p>
<ul>
<li><strong>Fog of war:</strong> Visibility is computed by <code>FogProvider</code> in the sim. Every render mode receives the same <code>VisibilityGrid</code> — no mode can reveal fogged units or terrain that another mode hides.</li>
<li><strong>Unit visibility:</strong> Cloaked, burrowed, and disguised units are shown/hidden based on sim-side detection state (<code>DetectCloaked</code>, <code>IgnoresDisguise</code>). The render mode determines <em>how</em> a shimmer or disguise looks, not <em>whether</em> the player sees it.</li>
<li><strong>Health bars, status indicators, minimap:</strong> All driven by sim state. A unit at 50% health shows 50% health in every render mode. Minimap icons are derived from the same entity positions regardless of visual presentation.</li>
<li><strong>Selection and targeting:</strong> Click hitboxes are defined per render mode via <code>ScreenToWorld</code>, but the available actions and information (tooltip, stats panel) are identical.</li>
</ul>
<p>If a future render mode creates an information asymmetry (e.g., 3D terrain occlusion that hides units behind buildings when the 2D mode shows them), the mode must equalize information display — either by adding a visibility indicator or by using the sim’s visibility grid as the authority for what’s shown. <strong>The principle: render modes change how the game looks, never what the player knows.</strong></p>
<h3 id="relationship-to-existing-systems"><a class="header" href="#relationship-to-existing-systems">Relationship to Existing Systems</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>System</th><th>Before D048</th><th>After D048</th></tr>
</thead>
<tbody>
<tr><td><strong>Resource Packs</strong></td><td>Per-category asset selection in Settings</td><td>Resource packs become a <em>component</em> of render modes; the mode auto-selects the right packs</td></tr>
<tr><td><strong>D029 Dual Asset</strong></td><td>Dual asset handles per entity</td><td>Generalized to N render modes, not just two. D029’s mechanism is how same-backend switches work</td></tr>
<tr><td><strong>3D Render Mods</strong></td><td>Tier 3 WASM mod that <em>replaces</em> the default renderer</td><td>Tier 3 WASM mod that <em>adds</em> a render mode alongside the default — toggleable, not a replacement</td></tr>
<tr><td><strong>D032 UI Themes</strong></td><td>Switchable UI chrome</td><td>UI theme can optionally be paired with a render mode (classic mode + classic chrome)</td></tr>
<tr><td><strong>Render Quality Tiers</strong></td><td>Hardware-adaptive Baseline → Ultra</td><td>Tiers apply <em>within</em> a render mode. Classic mode on Tier 0 hardware; 3D mode requires Tier 2 minimum</td></tr>
<tr><td><strong>Experience Profiles</strong></td><td>Balance + theme + QoL + AI + pathfinding</td><td>Now also include a default render mode</td></tr>
</tbody>
</table>
</div>
<h3 id="what-mod-authors-need-to-do"><a class="header" href="#what-mod-authors-need-to-do">What Mod Authors Need to Do</a></h3>
<p><strong>For a sprite HD pack</strong> (most common case): Nothing new. Publish a resource pack with HD sprites. The game module’s <code>hd</code> render mode references it. The player installs it and F1 toggles.</p>
<p><strong>For a 3D rendering mod</strong> (Tier 3): Ship a WASM mod that provides a <code>Renderable</code> impl (mesh renderer) and a <code>ScreenToWorld</code> impl (3D camera). Declare a render mode in YAML that references these implementations and the 3D asset resource packs. The engine registers the mode alongside the built-in modes — F1 now cycles through all three.</p>
<p><strong>For a complete 3D game module</strong> (e.g., Generals clone): The game module can register only 3D render modes — no classic 2D at all. Or it can ship both. The architecture supports any combination.</p>
<h3 id="minimum-viable-scope"><a class="header" href="#minimum-viable-scope">Minimum Viable Scope</a></h3>
<p>Phase 2 delivers the infrastructure — render mode registration, asset handle swapping, the <code>RenderMode</code> struct. The HD/SD toggle (classic ↔ hd) works. Phase 3 adds the settings UI and keybind. Phase 6a supports mod-provided render modes (3D). The architecture supports all of this from day one; the phases gate what’s <em>tested and polished.</em></p>
<h3 id="alternatives-considered-4"><a class="header" href="#alternatives-considered-4">Alternatives Considered</a></h3>
<ol>
<li><strong>Resource packs only, no render mode concept</strong> — Rejected. Switching from 2D to 3D requires changing the render backend and camera, not just assets. Resource packs can’t do that.</li>
<li><strong>3D as a separate game module</strong> — Rejected. A “3D RA1” game module would duplicate all the rules, balance, and systems from the base RA1 module. The whole point is that the sim is unchanged.</li>
<li><strong>No 2D↔3D toggle; 3D replaces 2D permanently when mod is active</strong> — Rejected. The Remastered Collection proved that <em>toggling</em> is the feature, not just having two visual options. Players love comparing. Content creators use it for dramatic effect. It’s also a safety net — if the 3D mod has rendering bugs, you can toggle back.</li>
</ol>
<h3 id="lessons-from-the-remastered-collection"><a class="header" href="#lessons-from-the-remastered-collection">Lessons from the Remastered Collection</a></h3>
<p>The Remastered Collection’s F1 toggle is the gold-standard reference for this feature. Its architecture — recovered from the GPL source (<code>DLLInterface.cpp</code>) and our analysis (<code>research/remastered-collection-netcode-analysis.md</code> § 9) — reveals how Petroglyph achieved instant switching, and where IC can improve:</p>
<p><strong>How the Remastered toggle works internally:</strong></p>
<p>The Remastered Collection runs <strong>two rendering pipelines in parallel.</strong> The original C++ engine still software-renders every frame to <code>GraphicBufferClass</code> RAM buffers (palette-based 8-bit blitting) — exactly as in 1995. Simultaneously, <code>DLL_Draw_Intercept</code> captures every draw call as structured metadata (<code>CNCObjectStruct</code>: position, type, shape index, frame, palette, cloak state, health, selection) and forwards it to the C# GlyphX client via <code>CNC_Get_Game_State()</code>. The GlyphX layer renders the same scene using HD art and GPU acceleration. When the player presses Tab (their toggle key), the C# layer simply switches which final framebuffer is composited to screen — the classic software buffer or the HD GPU buffer. Both are always up-to-date because both render every frame.</p>
<p><strong>Why dual-render works for Remastered but is wrong for IC:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Remastered approach</th><th>IC approach</th><th>Why different</th></tr>
</thead>
<tbody>
<tr><td>Both pipelines render every frame</td><td>Only the active mode renders</td><td>The Remastered C++ engine is a sealed DLL — you can’t stop it rendering. IC owns both pipelines and can skip work. Rendering both wastes GPU budget.</td></tr>
<tr><td>Classic renderer is software (CPU blit to RAM)</td><td>Both modes are GPU-based (wgpu via Bevy)</td><td>Classic-mode GPU sprites are cheap but not free. Dual GPU render passes halve available GPU budget for post-FX, particles, unit count.</td></tr>
<tr><td>Switch is trivial: flip a “which buffer to present” flag</td><td>Switch swaps asset handles on live entities</td><td>Remastered pays for dual-render continuously to make the flip trivial. IC pays nothing continuously and does a one-frame swap at toggle time.</td></tr>
<tr><td>Two codebases: C++ (classic) and C# (HD)</td><td>One codebase: same Bevy systems, different data</td><td>IC’s approach is fundamentally lighter — same draw call dispatch, different texture atlases.</td></tr>
</tbody>
</table>
</div>
<p><strong>Key insight IC adopts:</strong> The Remastered Collection’s critical architectural win is that <strong>the sim is completely unaware of the render switch.</strong> The C++ sim DLL (<code>CNC_Advance_Instance</code>) has no knowledge of which visual mode is active — it advances identically in both cases. IC inherits this principle via Invariant #1 (sim is pure). The sim never imports from <code>ic-render</code>. Render mode is a purely client-side concern.</p>
<p><strong>Key insight IC rejects:</strong> Dual-rendering every frame is wasteful when you own both pipelines. The Remastered Collection pays this cost because the C++ DLL cannot be told “don’t render this frame” — <code>DLL_Draw_Intercept</code> fires unconditionally. IC has no such constraint. Only the active render mode’s systems should run.</p>
<h3 id="bevy-implementation-strategy"><a class="header" href="#bevy-implementation-strategy">Bevy Implementation Strategy</a></h3>
<p>The render mode switch is implementable entirely within Bevy’s existing architecture — no custom render passes, no engine modifications. The key mechanisms are <strong><code>Visibility</code> component toggling</strong>, <strong><code>Handle</code> swapping on <code>Sprite</code>/<code>Mesh</code> components</strong>, and <strong>Bevy’s system set run conditions</strong>.</p>
<h4 id="architecture-two-approaches-one-hybrid"><a class="header" href="#architecture-two-approaches-one-hybrid">Architecture: Two Approaches, One Hybrid</a></h4>
<p><strong>Approach A: Entity-per-mode (rejected for same-backend switches)</strong></p>
<p>Spawn separate sprite entities for classic and HD, toggle <code>Visibility</code>. Simple but doubles entity count (500 units × 2 = 1000 sprite entities) and doubles <code>Transform</code> sync work. Only justified for cross-backend switches (2D entity + 3D entity) where the components are structurally different.</p>
<p><strong>Approach B: Handle-swap on shared entity (adopted for same-backend switches)</strong></p>
<p>Each renderable entity has one <code>Sprite</code> component. On toggle, swap its <code>Handle&lt;Image&gt;</code> (or <code>TextureAtlas</code> index) from the classic atlas to the HD atlas. One entity, one transform, one visibility check — the sprite batch simply references different texture data. This is what <code>D029 Dual Asset</code> already designed.</p>
<p><strong>Hybrid: same-backend swaps use handle-swap; cross-backend swaps use visibility-gated entity groups.</strong></p>
<h4 id="core-ecs-components"><a class="header" href="#core-ecs-components">Core ECS Components</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Marker resource: the currently active render mode.
/// Changed via F1 keypress or settings UI.
/// Bevy change detection (Res&lt;ActiveRenderMode&gt;.is_changed()) triggers swap systems.
#[derive(Resource)]
pub struct ActiveRenderMode {
    pub current: RenderModeId,       // "classic", "hd", "3d"
    pub cycle: Vec&lt;RenderModeId&gt;,    // Ordered list for F1 cycling
    pub registry: HashMap&lt;RenderModeId, RenderModeConfig&gt;,
}

/// Per-entity component: maps this entity's render data for each available mode.
/// Populated at spawn time from the game module's YAML asset mappings.
#[derive(Component)]
pub struct RenderModeAssets {
    /// For same-backend modes (classic ↔ hd): alternative texture handles.
    /// Key = render mode id, Value = handle to that mode's texture atlas.
    pub sprite_handles: HashMap&lt;RenderModeId, Handle&lt;Image&gt;&gt;,
    /// For same-backend modes: alternative atlas layout indices.
    pub atlas_mappings: HashMap&lt;RenderModeId, TextureAtlasLayout&gt;,
    /// For cross-backend modes (2D ↔ 3D): entity IDs of the alternative representations.
    /// These entities exist but have Visibility::Hidden until their mode activates.
    pub cross_backend_entities: HashMap&lt;RenderModeId, Entity&gt;,
}

/// System set that only runs when a render mode switch just occurred.
/// Uses Bevy's run_if condition to avoid any per-frame cost when not switching.
#[derive(SystemSet, Debug, Clone, PartialEq, Eq, Hash)]
pub struct RenderModeSwitchSet;
<span class="boring">}</span></code></pre>
<h4 id="the-toggle-system-f1-handler"><a class="header" href="#the-toggle-system-f1-handler">The Toggle System (F1 Handler)</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Runs every frame (cheap: one key check).
fn handle_render_mode_toggle(
    input: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
    mut active: ResMut&lt;ActiveRenderMode&gt;,
) {
    if input.just_pressed(KeyCode::F1) {
        let idx = active.cycle.iter()
            .position(|id| *id == active.current)
            .unwrap_or(0);
        let next = (idx + 1) % active.cycle.len();
        active.current = active.cycle[next].clone();
        // Bevy change detection fires: active.is_changed() == true this frame.
        // All systems in RenderModeSwitchSet will run exactly once.
    }
}
<span class="boring">}</span></code></pre>
<h4 id="same-backend-swap-classic--hd"><a class="header" href="#same-backend-swap-classic--hd">Same-Backend Swap (Classic ↔ HD)</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Runs ONLY when ActiveRenderMode changes (run_if condition).
/// Cost: iterates all renderable entities ONCE, swaps Handle + atlas.
/// For 500 units + 200 buildings + terrain = ~1000 entities: &lt; 0.5ms.
fn swap_sprite_handles(
    active: Res&lt;ActiveRenderMode&gt;,
    mut query: Query&lt;(&amp;RenderModeAssets, &amp;mut Sprite)&gt;,
) {
    let mode = &amp;active.current;
    for (assets, mut sprite) in &amp;mut query {
        if let Some(handle) = assets.sprite_handles.get(mode) {
            sprite.image = handle.clone();
        }
        // Atlas layout swap happens similarly via TextureAtlas component
    }
}

/// Swap camera and visual settings when render mode changes.
/// Updates the GameCamera zoom range and the OrthographicProjection scaling mode.
/// Camera position is preserved across switches — only zoom behavior changes.
/// See 02-ARCHITECTURE.md § "Camera System" for the canonical GameCamera resource.
fn swap_visual_config(
    active: Res&lt;ActiveRenderMode&gt;,
    mut game_camera: ResMut&lt;GameCamera&gt;,
    mut camera_query: Query&lt;&amp;mut OrthographicProjection, With&lt;GameCameraMarker&gt;&gt;,
) {
    let config = &amp;active.registry[&amp;active.current];

    // Update zoom range from the new render mode's camera config.
    game_camera.zoom_min = config.camera_config.zoom_min;
    game_camera.zoom_max = config.camera_config.zoom_max;
    // Clamp current zoom to new range (e.g., 3D mode allows wider range than Classic).
    game_camera.zoom_target = game_camera.zoom_target
        .clamp(game_camera.zoom_min, game_camera.zoom_max);

    for mut proj in &amp;mut camera_query {
        proj.scaling_mode = match config.visual_config.scaling {
            ScalingMode::IntegerNearest =&gt; bevy::render::camera::ScalingMode::Fixed {
                width: 320.0, height: 200.0, // Classic RA viewport
            },
            ScalingMode::Native =&gt; bevy::render::camera::ScalingMode::AutoMin {
                min_width: 1280.0, min_height: 720.0,
            },
            // ...
        };
    }
}
<span class="boring">}</span></code></pre>
<h4 id="cross-backend-swap-2d--3d"><a class="header" href="#cross-backend-swap-2d--3d">Cross-Backend Swap (2D ↔ 3D)</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// For cross-backend switches: toggle Visibility on entity groups.
/// The 3D entities exist from the start but are Hidden.
/// Swap cost: iterate entities, flip Visibility enum. Still &lt; 1ms.
fn swap_render_backends(
    active: Res&lt;ActiveRenderMode&gt;,
    mut query: Query&lt;(&amp;RenderModeAssets, &amp;mut Visibility)&gt;,
    mut cross_entities: Query&lt;&amp;mut Visibility, Without&lt;RenderModeAssets&gt;&gt;,
) {
    let mode = &amp;active.current;
    let config = &amp;active.registry[mode];

    for (assets, mut vis) in &amp;mut query {
        // If this entity's backend matches the active mode, show it.
        // Otherwise, hide it and show the cross-backend counterpart.
        if assets.sprite_handles.contains_key(mode) {
            *vis = Visibility::Inherited;
            // Hide cross-backend counterparts
            for (other_mode, &amp;entity) in &amp;assets.cross_backend_entities {
                if *other_mode != *mode {
                    if let Ok(mut other_vis) = cross_entities.get_mut(entity) {
                        *other_vis = Visibility::Hidden;
                    }
                }
            }
        } else if let Some(&amp;entity) = assets.cross_backend_entities.get(mode) {
            *vis = Visibility::Hidden;
            if let Ok(mut other_vis) = cross_entities.get_mut(entity) {
                *other_vis = Visibility::Inherited;
            }
        }
    }
}
<span class="boring">}</span></code></pre>
<h4 id="system-scheduling"><a class="header" href="#system-scheduling">System Scheduling</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Plugin for RenderModePlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app.init_resource::&lt;ActiveRenderMode&gt;()
           // F1 handler runs every frame — trivially cheap (one key check).
           .add_systems(Update, handle_render_mode_toggle)
           // Swap systems run ONLY on the frame when ActiveRenderMode changes.
           .add_systems(Update, (
               swap_sprite_handles,
               swap_visual_config,
               swap_render_backends,
               swap_ui_theme,            // D032 theme pairing
               swap_post_fx_pipeline,    // Post-processing preset
               emit_render_mode_event,   // Telemetry: D031
           ).in_set(RenderModeSwitchSet)
            .run_if(resource_changed::&lt;ActiveRenderMode&gt;));
    }
}
<span class="boring">}</span></code></pre>
<h4 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Cost</th><th>When It Runs</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>F1 key check</td><td>~0 (one <code>HashMap</code> lookup)</td><td>Every frame</td><td>Bevy input system already processes keys; we just read</td></tr>
<tr><td>Same-backend swap (classic ↔ hd)</td><td>~0.3–0.5 ms for 1000 entities</td><td>Once on toggle</td><td>Iterate entities, write <code>Handle&lt;Image&gt;</code>. No GPU work. Bevy batches texture changes automatically on next draw.</td></tr>
<tr><td>Cross-backend swap (2D ↔ 3D)</td><td>~0.5–1 ms for 1000 entity pairs</td><td>Once on toggle</td><td>Toggle <code>Visibility</code>. Hidden entities are culled by Bevy’s visibility system — zero draw calls.</td></tr>
<tr><td>3D asset first-load</td><td>50–500 ms (one-time)</td><td>First toggle to 3D</td><td>GLTF meshes + textures loaded async by Bevy’s asset server. Brief loading indicator. Cached thereafter.</td></tr>
<tr><td>Steady-state (non-toggle frames)</td><td><strong>0 ms</strong></td><td>Every frame</td><td><code>run_if(resource_changed)</code> gates all swap systems. Zero per-frame overhead.</td></tr>
<tr><td>VRAM usage</td><td>Classic atlas (~8 MB) + HD atlas (~64 MB)</td><td>Resident when loaded</td><td>Both atlases stay in VRAM. Modern GPUs: trivial. Min-spec 512 MB VRAM: still &lt;15%.</td></tr>
</tbody>
</table>
</div>
<p><strong>Key property: zero per-frame cost.</strong> Bevy’s <code>resource_changed</code> run condition means the swap systems literally do not execute unless the player presses F1. Between toggles, the renderer treats the active atlas as the only atlas — standard sprite batching, standard draw calls, no branching.</p>
<h4 id="asset-pre-loading-strategy"><a class="header" href="#asset-pre-loading-strategy">Asset Pre-Loading Strategy</a></h4>
<p>The critical difference from the Remastered Collection: IC does NOT dual-render. Instead, it pre-loads both texture atlases into VRAM at match start (or lazily on first toggle):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Called during match loading. Pre-loads all registered render mode assets.
fn preload_render_mode_assets(
    active: Res&lt;ActiveRenderMode&gt;,
    asset_server: Res&lt;AssetServer&gt;,
    mut preload_handles: ResMut&lt;RenderModePreloadHandles&gt;,
) {
    for (mode_id, config) in &amp;active.registry {
        for pack_ref in &amp;config.resource_pack_overrides {
            // Bevy's asset server loads asynchronously.
            // We hold the Handle to keep the asset resident in memory.
            let handle = asset_server.load(pack_ref.atlas_path());
            preload_handles.retain.push(handle);
        }
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Loading strategy by mode type:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode pair</th><th>Pre-load?</th><th>Memory cost</th><th>Rationale</th></tr>
</thead>
<tbody>
<tr><td>Classic ↔ HD (same backend)</td><td>Yes, at match start</td><td>+64 MB VRAM for HD atlas</td><td>Both are texture atlases. Pre-loading makes F1 instant.</td></tr>
<tr><td>2D ↔ 3D (cross backend)</td><td>Lazy, on first toggle</td><td>+100–300 MB for 3D meshes</td><td>3D assets are large. Don’t penalize 2D-only players. Loading indicator on first 3D toggle.</td></tr>
<tr><td>Any ↔ Any (menu/lobby)</td><td>Active mode only</td><td>Minimal</td><td>No gameplay; loading time acceptable.</td></tr>
</tbody>
</table>
</div>
<h4 id="transform-synchronization-cross-backend-only"><a class="header" href="#transform-synchronization-cross-backend-only">Transform Synchronization (Cross-Backend Only)</a></h4>
<p>When 2D and 3D entities coexist (one hidden), their <code>Transform</code> must stay in sync so the switch looks seamless. The sim writes to a <code>SimPosition</code> component (in world coordinates). Both the 2D sprite entity and the 3D mesh entity read from the same <code>SimPosition</code> and compute their own <code>Transform</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Runs every frame for ALL visible renderable entities.
/// Converts SimPosition → entity Transform using the active camera model.
/// Hidden entities skip this (Bevy's visibility propagation prevents
/// transform updates on Hidden entities from triggering GPU uploads).
fn sync_render_transforms(
    active: Res&lt;ActiveRenderMode&gt;,
    mut query: Query&lt;(&amp;SimPosition, &amp;mut Transform), With&lt;Visibility&gt;&gt;,
) {
    let camera_model = &amp;active.registry[&amp;active.current].camera;
    for (sim_pos, mut transform) in &amp;mut query {
        *transform = camera_model.world_to_render(sim_pos);
    }
}
<span class="boring">}</span></code></pre>
<p>Bevy’s built-in visibility system already ensures that <code>Hidden</code> entities’ transforms aren’t uploaded to the GPU, so the 3D entity transforms are only computed when 3D mode is active.</p>
<h4 id="comparison-remastered-vs-ic-render-switch"><a class="header" href="#comparison-remastered-vs-ic-render-switch">Comparison: Remastered vs. IC Render Switch</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Remastered Collection</th><th>Iron Curtain</th></tr>
</thead>
<tbody>
<tr><td><strong>Architecture</strong></td><td>Dual-render: both pipelines run every frame</td><td>Single-render: only active mode draws</td></tr>
<tr><td><strong>Switch cost</strong></td><td>~0 (flip framebuffer pointer)</td><td>~0.5 ms (swap handles on ~1000 entities)</td></tr>
<tr><td><strong>Steady-state cost</strong></td><td>Full classic render every frame (~2-5ms CPU) even when showing HD</td><td><strong>0 ms</strong> — inactive mode has zero cost</td></tr>
<tr><td><strong>Why the trade-off</strong></td><td>C++ DLL can’t be told “don’t render”</td><td>IC owns both pipelines, can skip work</td></tr>
<tr><td><strong>Memory</strong></td><td>Classic (RAM buffer) + HD (VRAM)</td><td>Both atlases in VRAM (unified GPU memory)</td></tr>
<tr><td><strong>Cross-backend (2D↔3D)</strong></td><td>Not supported</td><td>Supported via visibility-gated entity groups</td></tr>
<tr><td><strong>Multiplayer</strong></td><td>Both players must use same mode</td><td>Cross-view: each player picks independently</td></tr>
<tr><td><strong>Camera</strong></td><td>Fixed isometric in both modes</td><td>Camera model switches with render mode</td></tr>
<tr><td><strong>UI chrome</strong></td><td>Switches with graphics mode</td><td>Independently switchable (D032) but can be paired</td></tr>
<tr><td><strong>Modder-extensible</strong></td><td>No</td><td>YAML registration + WASM render backends</td></tr>
</tbody>
</table>
</div>
<hr>
<hr>
<h2 id="d054-extended-switchability--transport-cryptographic-signatures-and-snapshot-serialization"><a class="header" href="#d054-extended-switchability--transport-cryptographic-signatures-and-snapshot-serialization">D054: Extended Switchability — Transport, Cryptographic Signatures, and Snapshot Serialization</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th></th><th></th></tr>
</thead>
<tbody>
<tr><td><strong>Status</strong></td><td>Accepted</td></tr>
<tr><td><strong>Driver</strong></td><td>Architecture switchability audit identified three subsystems that are currently hardcoded but carry meaningful risk of regret within 5–10 years</td></tr>
<tr><td><strong>Depends on</strong></td><td>D006 (NetworkModel), D010 (Snapshottable sim), D041 (Trait-abstracted subsystems), D052 (Community Servers &amp; SCR)</td></tr>
</tbody>
</table>
</div>
<h3 id="problem"><a class="header" href="#problem">Problem</a></h3>
<p>The engine already trait-abstracts 23 subsystems (D041 inventory) and data-drives 7 more through YAML/Lua. But an architecture switchability audit identified three remaining subsystems where the <em>implementation</em> is hardcoded below an existing abstraction layer, creating risks that are cheap to mitigate now but expensive to fix later:</p>
<ol>
<li>
<p><strong>Transport layer</strong> — <code>NetworkModel</code> abstracts the logical protocol (lockstep vs. rollback) but not the transport beneath it. Raw UDP is hardcoded. WASM builds cannot use raw UDP sockets at all — browser multiplayer is blocked until this is abstracted. WebTransport and QUIC are maturing rapidly and may supersede raw UDP for game transport within the engine’s lifetime.</p>
</li>
<li>
<p><strong>Cryptographic signature scheme</strong> — Ed25519 is hardcoded in ~15 callsites across the codebase: SCR records (D052), replay signature chains, Workshop index signing, <code>CertifiedMatchResult</code>, key rotation records, and community identity. Ed25519 is excellent today (128-bit security, fast, compact), but NIST’s post-quantum transition timeline (ML-DSA standardized 2024, recommended migration by ~2035) means the engine may need to swap signature algorithms without breaking every signed record in existence.</p>
</li>
<li>
<p><strong>Snapshot serialization codec</strong> — <code>SimSnapshot</code> is serialized with bincode + LZ4, hardcoded in the save/load path. Bincode is not self-describing — schema changes (adding a field, reordering an enum) silently produce corrupt deserialization rather than a clean error. Cross-version save compatibility requires codec-version awareness that doesn’t currently exist.</p>
</li>
</ol>
<p>Each uses the right abstraction mechanism for its specific situation: <strong>Transport</strong> gets a trait (open-ended, third-party implementations expected, hot path where monomorphization matters), <strong>SignatureScheme</strong> gets an enum (closed set of 2–3 algorithms, runtime dispatch needed for mixed-version verification), and <strong>SnapshotCodec</strong> gets version-tagged dispatch (internal versioning, no pluggability needed). The total cost is ~80 lines of definitions. The benefit is that none of these becomes a rewrite-required bottleneck when reality changes.</p>
<h3 id="the-principle-from-d041"><a class="header" href="#the-principle-from-d041">The Principle (from D041)</a></h3>
<p>Abstract the <em>transport mechanism</em>, not the <em>data</em>. If the concern is “which bytes go over which wire” or “which algorithm signs these bytes” or “which codec serializes this struct” — that’s a mechanism that can change independently of the logic above it. The logic (lockstep protocol, credential verification, snapshot semantics) stays identical regardless of which mechanism implements it.</p>
<h3 id="1-transport--network-transport-abstraction"><a class="header" href="#1-transport--network-transport-abstraction">1. <code>Transport</code> — Network Transport Abstraction</a></h3>
<p><strong>Risk level: HIGH.</strong> Browser multiplayer (Invariant #10: platform-agnostic) is blocked without this. WASM cannot open raw UDP sockets — it’s a platform API limitation, not a library gap. Every browser RTS (Chrono Divide, OpenRA-web experiments) solves this by abstracting transport. We already abstract the protocol layer (<code>NetworkModel</code>); failing to abstract the transport layer below it is an inconsistency.</p>
<p><strong>Current state:</strong> The connection establishment flow in <code>03-NETCODE.md</code> shows transport as a concern “below” <code>NetworkModel</code>:</p>
<pre><code>Discovery → Connection establishment → NetworkModel constructed → Game loop
</code></pre>
<p>But connection establishment hardcodes UDP. A <code>Transport</code> trait makes this explicit.</p>
<p><strong>Trait definition:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Abstracts a single bidirectional network channel beneath NetworkModel.
/// Each Transport instance represents ONE connection (to a relay, or to a
/// single peer in P2P). NetworkModel manages multiple Transport instances
/// for multi-peer P2P; relay mode uses a single Transport to the relay.
///
/// Lives in ic-net. NetworkModel implementations are generic over Transport.
///
/// Design: point-to-point, not connectionless. No endpoint parameter in
/// send/recv — the Transport IS the connection. For UDP, this maps to a
/// connected socket (UdpSocket::connect()). For WebSocket/QUIC, this is
/// the natural model. Multi-peer routing is NetworkModel's concern.
///
/// All transports expose datagram/message semantics. The protocol layer
/// (NetworkModel) always runs its own reliability and ordering — sequence
/// numbers, retransmission, frame resend (§ Frame Data Resilience). On
/// reliable transports (WebSocket), these mechanisms become no-ops at
/// runtime (retransmit timers never fire). This eliminates conditional
/// branches in NetworkModel and keeps a single code path and test matrix.
pub trait Transport: Send + Sync {
    /// Send a datagram/message to the connected peer. Non-blocking or
    /// returns WouldBlock. Data is a complete message (not a byte stream).
    fn send(&amp;self, data: &amp;[u8]) -&gt; Result&lt;(), TransportError&gt;;

    /// Receive the next available message, if any. Non-blocking.
    /// Returns the number of bytes written to `buf`, or None if no
    /// message is available.
    fn recv(&amp;self, buf: &amp;mut [u8]) -&gt; Result&lt;Option&lt;usize&gt;, TransportError&gt;;

    /// Maximum payload size for a single send() call.
    /// UdpTransport returns ~476 (MTU-safe). WebSocketTransport returns ~64KB.
    fn max_payload(&amp;self) -&gt; usize;

    /// Establish the connection to the target endpoint.
    fn connect(&amp;mut self, target: &amp;Endpoint) -&gt; Result&lt;(), TransportError&gt;;

    /// Tear down the connection.
    fn disconnect(&amp;mut self);
}
<span class="boring">}</span></code></pre>
<p><strong>Default implementations:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Implementation</th><th>Backing</th><th>Platform</th><th>Phase</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><code>UdpTransport</code></td><td><code>std::net::UdpSocket</code></td><td>Desktop, Server</td><td>5</td><td>Default. Raw UDP, MTU-aware, same as current hardcoded behavior.</td></tr>
<tr><td><code>WebSocketTransport</code></td><td><code>tungstenite</code> / browser WebSocket API</td><td>WASM, Fallback</td><td>5</td><td>Enables browser multiplayer. Reliable + ordered (NetworkModel’s retransmit logic becomes a no-op — single code path, zero conditional branches). Higher latency than UDP but functional.</td></tr>
<tr><td><code>WebTransportImpl</code></td><td>WebTransport API</td><td>WASM (future)</td><td>Future</td><td>Unreliable datagrams over QUIC. Best of both worlds — UDP-like semantics in the browser. Spec still maturing (W3C Working Draft).</td></tr>
<tr><td><code>QuicTransport</code></td><td><code>quinn</code></td><td>Desktop (future)</td><td>Future</td><td>Stream multiplexing, built-in encryption, 0-RTT reconnects. Candidate to replace raw UDP + custom reliability when QUIC ecosystem matures.</td></tr>
<tr><td><code>MemoryTransport</code></td><td><code>crossbeam</code> channel</td><td>Testing</td><td>2</td><td>Zero-latency, zero-loss in-process transport. Already implied by <code>LocalNetwork</code> — this makes it explicit as a <code>Transport</code>. NetworkModel manages a <code>Vec&lt;T&gt;</code> of these for multi-peer test scenarios.</td></tr>
</tbody>
</table>
</div>
<p><strong>Relationship to <code>NetworkModel</code>:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// NetworkModel becomes generic over Transport.
/// Existing code that constructs LockstepNetwork or RelayLockstepNetwork
/// now specifies a Transport. For desktop builds, this is UdpTransport.
/// For WASM builds, this is WebSocketTransport.
///
/// Relay mode: single Transport to the relay server.
/// P2P mode: Vec&lt;T&gt; — one Transport per peer connection.
pub struct LockstepNetwork&lt;T: Transport&gt; {
    transport: T,       // relay mode: connection to relay
    // ... existing fields unchanged
}

pub struct P2PLockstepNetwork&lt;T: Transport&gt; {
    peers: Vec&lt;T&gt;,      // one connection per peer
    // ... existing fields unchanged
}

impl&lt;T: Transport&gt; NetworkModel for LockstepNetwork&lt;T&gt; {
    // All existing logic unchanged. send()/recv() calls go through
    // self.transport instead of directly calling UdpSocket methods.
    // Reliability layer (sequence numbers, retransmit, frame resend)
    // runs identically regardless of transport — on reliable transports,
    // retransmit timers simply never fire.
}
<span class="boring">}</span></code></pre>
<p><strong>What does NOT change:</strong> The wire format (delta-compressed TLV), the <code>OrderCodec</code> trait, the <code>NetworkModel</code> trait API, connection discovery (join codes, tracking servers), or the relay server protocol. Transport is purely “how bytes move,” not “what bytes mean.”</p>
<p><strong>Why no <code>is_reliable()</code> method?</strong> Adding reliability awareness to <code>Transport</code> would create conditional branches in <code>NetworkModel</code> — one code path for unreliable transports (full retransmit logic) and another for reliable ones (skip retransmit). This doubles the test matrix and creates subtle behavioral differences between deployment targets. Instead, <code>NetworkModel</code> always runs its full reliability layer. On reliable transports (WebSocket), retransmit timers never fire and the redundancy costs nothing at runtime. One code path, one test matrix, zero conditional complexity. This is the same approach used by ENet, Valve’s GameNetworkingSockets, and most serious game networking libraries.</p>
<p><strong>Message lanes (from GNS):</strong> <code>NetworkModel</code> multiplexes multiple logical streams (lanes) over a single <code>Transport</code> connection — each with independent priority and weight. Lanes are a protocol-layer concern, not a transport-layer concern: <code>Transport</code> provides raw byte delivery; <code>NetworkModel</code> handles lane scheduling, priority draining, and per-lane buffering. See <code>03-NETCODE.md</code> § Message Lanes for the lane definitions (<code>Orders</code>, <code>Control</code>, <code>Chat</code>, <code>Voice</code>, <code>Bulk</code>) and scheduling policy. The lane system ensures time-critical orders are never delayed by chat traffic, voice data, or bulk data — a pattern validated by GNS’s configurable lane architecture (see <code>research/valve-github-analysis.md</code> § 1.4). The <code>Voice</code> lane (D059) carries relay-forwarded Opus VoIP frames as unreliable, best-effort traffic.</p>
<p><strong>Transport encryption (from GNS):</strong> All multiplayer transports are encrypted with AES-256-GCM over an X25519 key exchange — the same cryptographic suite used by Valve’s GameNetworkingSockets and DTLS 1.3. Encryption sits between <code>Transport</code> and <code>NetworkModel</code>, transparent to both layers. Each connection generates an ephemeral Curve25519 keypair for forward secrecy; the symmetric key is never reused across sessions. After key exchange, the handshake is signed with the player’s Ed25519 identity key (D052) to bind the encrypted channel to a verified identity. The GCM nonce incorporates the packet sequence number, preventing replay attacks. See <code>03-NETCODE.md</code> § Transport Encryption for the full specification and <code>06-SECURITY.md</code> for the threat model. <code>MemoryTransport</code> (testing) and <code>LocalNetwork</code> (single-player) skip encryption.</p>
<p><strong>Pluggable signaling (from GNS):</strong> Connection establishment is further decomposed into a <code>Signaling</code> trait — abstracting how peers exchange connection metadata (IP addresses, relay tokens, ICE candidates) before the <code>Transport</code> is established. This follows GNS’s <code>ISteamNetworkingConnectionSignaling</code> pattern. Different deployment contexts use different signaling: relay-brokered, rendezvous + hole-punch, direct IP, or WebRTC for browser builds. Adding a new connection method (e.g., Steamworks P2P, Epic Online Services) requires only a new <code>Signaling</code> implementation — no changes to <code>Transport</code> or <code>NetworkModel</code>. See <code>03-NETCODE.md</code> § Pluggable Signaling for trait definition and implementations.</p>
<p><strong>Why not abstract this earlier (D006/D041)?</strong> At D006 design time, browser multiplayer was a distant future target and raw UDP was the obvious choice. Invariant #10 (platform-agnostic) was added later, making the gap visible. D041 explicitly listed the transport layer in its inventory of <em>already-abstracted</em> concerns via <code>NetworkModel</code> — but <code>NetworkModel</code> abstracts the protocol, not the transport. This decision corrects that conflation.</p>
<h3 id="2-signaturescheme--cryptographic-algorithm-abstraction"><a class="header" href="#2-signaturescheme--cryptographic-algorithm-abstraction">2. <code>SignatureScheme</code> — Cryptographic Algorithm Abstraction</a></h3>
<p><strong>Risk level: HIGH.</strong> Ed25519 is hardcoded in ~15 callsites. NIST standardized ML-DSA (post-quantum signatures) in 2024 and recommends migration by ~2035. The engine’s 10+ year lifespan means a signature algorithm swap is probable, not speculative. More immediately: different deployment contexts may want different algorithms (Ed448 for higher security margin, ML-DSA-65 for post-quantum compliance).</p>
<p><strong>Current state:</strong> D052’s SCR format deliberately has “No algorithm field. Always Ed25519.” — this was the right call to prevent JWT’s algorithm confusion vulnerability (CVE-2015-9235). But the solution isn’t “hardcode one algorithm forever” — it’s “the version field implies the algorithm, and the verifier looks up the algorithm from the version, never from attacker-controlled input.”</p>
<p><strong>Why enum dispatch, not a trait?</strong> The set of signature algorithms is small and closed — realistically 2–3 over the engine’s entire lifetime (Ed25519 now, ML-DSA-65 later, possibly one more). This makes it fundamentally different from <code>Transport</code> (which is open-ended — anyone can write a new transport). A trait would introduce design tension: associated types (<code>PublicKey</code>, <code>SecretKey</code>, <code>Signature</code>) are not object-safe with <code>Clone</code>, meaning <code>dyn SignatureScheme</code> won’t compile. But runtime dispatch is <em>required</em> — a player’s credential file contains mixed-version SCRs (version 1 Ed25519 alongside future version 2 ML-DSA), and the verifier must handle both in the same loop. Workarounds exist (erase types to <code>Vec&lt;u8&gt;</code>, or drop <code>Clone</code>) but they sacrifice type safety that was the supposed benefit of the trait.</p>
<p>Enum dispatch resolves all of these tensions: exhaustive <code>match</code> with no default arm (compiler catches missing variants), <code>Clone</code>/<code>Copy</code> for free, zero vtable overhead, and idiomatic Rust for small closed sets. Adding a third algorithm someday means adding one enum variant — the compiler then flags every callsite that needs updating.</p>
<p><strong>Enum definition:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Signature algorithm selection for all signed records.
/// Lives in ic-net (signing + verification are I/O concerns; ic-sim
/// never signs or verifies anything — Invariant #1).
///
/// NOT a trait. The algorithm set is small and closed (2–3 variants
/// over the engine's lifetime). Enum dispatch gives:
/// - Exhaustive match (compiler catches missing variants on addition)
/// - Clone/Copy for free
/// - Zero vtable overhead
/// - Runtime dispatch without object-safety headaches
///
/// Third-party signature algorithms are out of scope — cryptographic
/// agility is a security risk (see JWT CVE-2015-9235). The engine
/// controls which algorithms it trusts.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum SignatureScheme {
    Ed25519,
    // MlDsa65,  // future: post-quantum (NIST FIPS 204)
}

impl SignatureScheme {
    /// Sign a message. Returns the signature bytes.
    pub fn sign(&amp;self, sk: &amp;[u8], msg: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
        match self {
            Self::Ed25519 =&gt; ed25519_sign(sk, msg),
            // Self::MlDsa65 =&gt; ml_dsa_65_sign(sk, msg),
        }
    }

    /// Verify a signature against a public key and message.
    pub fn verify(&amp;self, pk: &amp;[u8], msg: &amp;[u8], sig: &amp;[u8]) -&gt; bool {
        match self {
            Self::Ed25519 =&gt; ed25519_verify(pk, msg, sig),
            // Self::MlDsa65 =&gt; ml_dsa_65_verify(pk, msg, sig),
        }
    }

    /// Generate a new keypair. Returns (public_key, secret_key).
    pub fn generate_keypair(&amp;self) -&gt; (Vec&lt;u8&gt;, Vec&lt;u8&gt;) {
        match self {
            Self::Ed25519 =&gt; ed25519_generate_keypair(),
            // Self::MlDsa65 =&gt; ml_dsa_65_generate_keypair(),
        }
    }

    /// Public key size in bytes. Determines SCR binary format layout.
    pub fn public_key_len(&amp;self) -&gt; usize {
        match self {
            Self::Ed25519 =&gt; 32,
            // Self::MlDsa65 =&gt; 1952,
        }
    }

    /// Signature size in bytes. Determines SCR binary format layout.
    pub fn signature_len(&amp;self) -&gt; usize {
        match self {
            Self::Ed25519 =&gt; 64,
            // Self::MlDsa65 =&gt; 3309,
        }
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Algorithm variants:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Algorithm</th><th>Key Size</th><th>Sig Size</th><th>Phase</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><code>Ed25519</code></td><td>Ed25519</td><td>32 bytes</td><td>64 bytes</td><td>5</td><td>Default. Current behavior. 128-bit security. Fast, compact, battle-tested.</td></tr>
<tr><td><code>MlDsa65</code></td><td>ML-DSA-65</td><td>1952 bytes</td><td>3309 bytes</td><td>Future</td><td>Post-quantum. NIST FIPS 204. Larger keys/sigs but quantum-resistant.</td></tr>
</tbody>
</table>
</div>
<p><strong>Version-implies-algorithm (preserving D052’s anti-confusion guarantee):</strong></p>
<p>D052’s SCR format already has a <code>version</code> byte (currently <code>0x01</code>). The version-to-algorithm mapping is hardcoded in the <em>verifier</em>, never read from the record itself:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Version → SignatureScheme mapping.
/// This is the verifier's lookup table, NOT a field in the signed record.
/// Preserves D052's guarantee: no algorithm negotiation, no attacker-controlled
/// algorithm selection. The version byte is set by the issuer at signing time;
/// the verifier uses it to select the correct verification algorithm.
///
/// Returns Result, not panic — version bytes come from user-provided files
/// (credential stores, replays, save files) and must fail gracefully.
fn scheme_for_version(version: u8) -&gt; Result&lt;SignatureScheme, CredentialError&gt; {
    match version {
        0x01 =&gt; Ok(SignatureScheme::Ed25519),
        // 0x02 =&gt; Ok(SignatureScheme::MlDsa65),
        _ =&gt; Err(CredentialError::UnknownVersion(version)),
    }
}
<span class="boring">}</span></code></pre>
<p><strong>What changes in the SCR binary format:</strong> Nothing structurally. The <code>version</code> byte already exists. What changes is the <em>interpretation</em>:</p>
<ul>
<li><strong>Before (D052):</strong> “Version is for format evolution. Algorithm is always Ed25519.”</li>
<li><strong>After (D054):</strong> “Version implies both format layout AND algorithm. Version 1 = Ed25519 (32-byte keys, 64-byte sigs). Version 2 = ML-DSA-65 (1952-byte keys, 3309-byte sigs). The verifier dispatches on version, never on an attacker-controlled field.”</li>
</ul>
<p>The variable-length fields (<code>community_key</code>, <code>player_key</code>, <code>signature</code>) are already length-implied by <code>version</code> — version 1 readers know key=32, sig=64. Version 2 readers know key=1952, sig=3309. No length prefix needed because the version fully determines the layout.</p>
<p><strong>Backward compatibility:</strong> A version 1 SCR issued by a community running Ed25519 remains valid forever. A community migrating to ML-DSA-65 issues version 2 SCRs. Both can coexist in a player’s credential file. Version 1 SCRs don’t expire or become invalid — they just can’t be <em>newly issued</em> once the community upgrades.</p>
<p><strong>Affected callsites (all change from direct <code>ed25519_dalek</code> calls to <code>SignatureScheme</code> enum method calls):</strong></p>
<ul>
<li>SCR record signing/verification (D052 — community servers + client)</li>
<li>Replay signature chain (<code>TickSignature</code> in <code>05-FORMATS.md</code>)</li>
<li>Workshop index signing (D049 — CI signing pipeline)</li>
<li><code>CertifiedMatchResult</code> (D052 — relay server)</li>
<li>Key rotation records (D052 — community servers)</li>
<li>Player identity keypairs (D052/D053)</li>
</ul>
<p><strong>Why not a <code>version</code> field in each signature?</strong> Because that’s exactly JWT’s <code>alg</code> header vulnerability. The version lives in the <em>container</em> (SCR record header, replay file header, Workshop index header) — not in the signature itself. The container’s version is written by the issuer and verified structurally (known offset, not parsed from attacker-controlled payload). This is the same defense D052 already uses; D054 just extends it to support future algorithms.</p>
<h3 id="3-snapshotcodec--savereplay-serialization-versioning"><a class="header" href="#3-snapshotcodec--savereplay-serialization-versioning">3. <code>SnapshotCodec</code> — Save/Replay Serialization Versioning</a></h3>
<p><strong>Risk level: MEDIUM.</strong> Bincode is fast and compact but not self-describing — if any field in <code>SimSnapshot</code> is added, removed, or reordered, deserialization silently produces garbage or panics. The save format header already has a <code>version: u16</code> field (<code>05-FORMATS.md</code>), but no code dispatches on it. Today, version is always 1 and the codec is always bincode + LZ4. This works until the first schema change — which is inevitable as the sim evolves through Phase 2–7.</p>
<p><strong>This is NOT a trait in <code>ic-sim</code>.</strong> Snapshot serialization is I/O — it belongs in <code>ic-game</code> (save/load) and <code>ic-net</code> (snapshot transfer for late-join). The sim produces/consumes <code>SimSnapshot</code> as an in-memory struct. How that struct becomes bytes is the codec’s concern.</p>
<p><strong>Codec dispatch (version → codec):</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Version-to-codec dispatch for SimSnapshot serialization.
/// Lives in ic-game (save/load path) and ic-net (snapshot transfer).
///
/// NOT a trait — there's no pluggability need here. Game modules don't
/// provide custom codecs. This is internal versioning, not extensibility.
/// A match statement is simpler, more explicit, and easier to audit than
/// a trait registry.
pub fn encode_snapshot(
    snapshot: &amp;SimSnapshot,
    version: u16,
) -&gt; Result&lt;Vec&lt;u8&gt;, CodecError&gt; {
    let serialized = match version {
        1 =&gt; bincode::serialize(snapshot)
            .map_err(|e| CodecError::Serialize(e.to_string()))?,
        2 =&gt; postcard::to_allocvec(snapshot)
            .map_err(|e| CodecError::Serialize(e.to_string()))?,
        _ =&gt; return Err(CodecError::UnknownVersion(version)),
    };
    Ok(lz4_flex::compress_prepend_size(&amp;serialized))
}

pub fn decode_snapshot(
    data: &amp;[u8],
    version: u16,
) -&gt; Result&lt;SimSnapshot, CodecError&gt; {
    let decompressed = lz4_flex::decompress_size_prepended(data)
        .map_err(|e| CodecError::Decompress(e.to_string()))?;
    match version {
        1 =&gt; bincode::deserialize(&amp;decompressed)
            .map_err(|e| CodecError::Deserialize(e.to_string())),
        2 =&gt; postcard::from_bytes(&amp;decompressed)
            .map_err(|e| CodecError::Deserialize(e.to_string())),
        _ =&gt; Err(CodecError::UnknownVersion(version)),
    }
}

/// Errors from snapshot/replay codec operations. Surfaced in UI as
/// "incompatible save file" or "corrupted replay" — never a panic.
#[derive(Debug)]
pub enum CodecError {
    UnknownVersion(u16),
    Serialize(String),
    Deserialize(String),
    Decompress(String),
}
<span class="boring">}</span></code></pre>
<p><strong>Why postcard as the likely version 2?</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>bincode (v1)</th><th>postcard (v2 candidate)</th></tr>
</thead>
<tbody>
<tr><td>Self-describing</td><td>No</td><td>Yes (with <code>postcard-schema</code>)</td></tr>
<tr><td>Varint integers</td><td>No (fixed-width)</td><td>Yes (smaller payloads)</td></tr>
<tr><td>Schema evolution</td><td>Field add = silent corrupt</td><td>Field append = <code>#[serde(default)]</code> compatible (same as bincode); structural mismatch = detected and rejected at load time (vs. bincode’s silent corruption)</td></tr>
<tr><td><code>#[serde]</code> compat</td><td>Yes</td><td>Yes</td></tr>
<tr><td><code>no_std</code> support</td><td>Limited</td><td>Full (embedded-friendly)</td></tr>
<tr><td>Speed</td><td>Very fast</td><td>Very fast (within 5%)</td></tr>
<tr><td>WASM support</td><td>Yes</td><td>Yes (designed for it)</td></tr>
</tbody>
</table>
</div>
<p>The version 1 → 2 migration path: saves with version 1 headers decode via bincode. New saves write version 2 headers and encode via postcard. Old saves remain loadable forever. The <code>SimSnapshot</code> struct itself doesn’t change — only the codec that serializes it.</p>
<p><strong>Migration strategy (from Factorio + DFU analysis):</strong> Mojang’s DataFixerUpper uses algebraic optics (profunctor-based type-safe transformations) for Minecraft save migration — academically elegant but massively over-engineered for practical use (see <code>research/mojang-wube-modding-analysis.md</code>). Factorio’s two-tier migration system is the better model: (1) <strong>Declarative renames</strong> — a YAML mapping of <code>old_field_name → new_field_name</code> per category, applied automatically by version number, and (2) <strong>Lua migration scripts</strong> — for complex structural transformations that can’t be expressed as simple renames. Scripts are ordered by version and applied sequentially. This avoids DFU’s complexity while handling real-world schema evolution. Additionally, every IC YAML rule file should include a <code>format_version</code> field (e.g., <code>format_version: "1.0.0"</code>) — following the pattern used by both Minecraft Bedrock (<code>"format_version": "1.26.0"</code> in every JSON entity file) and Factorio (<code>"factorio_version": "2.0"</code> in <code>info.json</code>). This enables the migration system to detect and transform old formats without guessing.</p>
<p><strong>Why NOT a trait?</strong> Unlike Transport and SignatureScheme, snapshot codecs have zero pluggability requirement. No game module, mod, or community server needs to provide a custom snapshot serializer. This is purely internal version dispatch — a <code>match</code> statement is the right abstraction, not a trait. D041’s principle: “abstract the <em>algorithm</em>, not the <em>data</em>.” Snapshot serialization is data marshaling with no algorithmic variation — the right tool is version-tagged dispatch, not trait polymorphism.</p>
<p><strong>Relationship to replay format:</strong> The replay file format (<code>05-FORMATS.md</code>) also has a <code>version: u16</code> in its header. The same version-to-codec dispatch applies to replay tick frames (<code>ReplayTickFrame</code> serialization). Replay version 1 uses bincode + LZ4 block compression. A future version 2 could use postcard + LZ4. The replay header version and the save header version evolve independently — a replay viewer doesn’t need to understand save files and vice versa.</p>
<h3 id="what-still-does-not-need-abstraction"><a class="header" href="#what-still-does-not-need-abstraction">What Still Does NOT Need Abstraction</a></h3>
<p>This audit explicitly confirmed that the following remain correctly un-abstracted (extending D041’s “What Does NOT Need a Trait” table):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Subsystem</th><th>Why No Abstraction Needed</th></tr>
</thead>
<tbody>
<tr><td>YAML parser (<code>serde_yaml</code>)</td><td>Parser crate is a Cargo dependency swap — no trait needed, no code change beyond <code>Cargo.toml</code>.</td></tr>
<tr><td>Lua runtime (<code>mlua</code>)</td><td>Deeply integrated via <code>ic-script</code>. Switching Lua impls is a rewrite regardless of traits. The scripting <em>API</em> is the abstraction.</td></tr>
<tr><td>WASM runtime (<code>wasmtime</code>)</td><td>Same — the WASM API is the abstraction, not the runtime binary.</td></tr>
<tr><td>Compression (LZ4)</td><td>Used in exactly two places (snapshot, replay). Swapping is a one-line change. No trait overhead justified.</td></tr>
<tr><td>Bevy</td><td>The engine framework. Abstracting Bevy is abstracting gravity. If Bevy is replaced, everything is rewritten.</td></tr>
<tr><td>State hash algorithm</td><td>SHA-256 Merkle tree. Changing this requires coordinated protocol version bump across all clients — a trait wouldn’t help.</td></tr>
<tr><td>RNG (<code>DeterministicRng</code>)</td><td>Already deterministic and internal to <code>ic-sim</code>. Swapping PRNG algorithms is a single-struct replacement. No polymorphism needed.</td></tr>
</tbody>
</table>
</div>
<h3 id="alternatives-considered-5"><a class="header" href="#alternatives-considered-5">Alternatives Considered</a></h3>
<ul>
<li><strong>Abstract everything now</strong> (rejected — violates D015’s “no speculative abstractions”; the 7 items above don’t carry meaningful regret risk)</li>
<li><strong>Abstract nothing, handle it later</strong> (rejected — Transport blocks WASM multiplayer <em>now</em>; SignatureScheme’s 15 hardcoded callsites grow with every feature; SnapshotCodec’s first schema change will force an emergency versioning retrofit)</li>
<li><strong>Use <code>dyn</code> trait objects instead of generics for Transport</strong> (rejected — <code>dyn Transport</code> adds vtable overhead on every <code>send()</code>/<code>recv()</code> in the hot network path; monomorphized generics are zero-cost. <code>Transport</code> is used in tight loops — static dispatch is correct here)</li>
<li><strong>Make SignatureScheme a trait with associated types</strong> (rejected — associated types are not object-safe with <code>Clone</code>, but runtime dispatch is required for mixed-version SCR verification. Erasing types to <code>Vec&lt;u8&gt;</code> sacrifices the type safety that was the supposed benefit. Enum dispatch gives exhaustive match, <code>Clone</code>/<code>Copy</code>, zero vtable, and compiler-enforced completeness when adding variants)</li>
<li><strong>Make SignatureScheme a trait with <code>&amp;[u8]</code> params (object-safe)</strong> (rejected — works technically, but the algorithm set is small and closed. A trait implies open extensibility; the engine deliberately controls which algorithms it trusts. Enum is the idiomatic Rust pattern for closed dispatch)</li>
<li><strong>Add algorithm negotiation to SCR</strong> (rejected — this IS JWT’s <code>alg</code> header. Version-implies-algorithm is strictly safer and already fits D052’s format)</li>
<li><strong>Use protobuf/flatbuffers for snapshot serialization</strong> (rejected — adds external IDL dependency, <code>.proto</code> file maintenance, code generation step. Postcard gives schema stability within the <code>serde</code> ecosystem IC already uses)</li>
<li><strong>Make SnapshotCodec a trait</strong> (rejected — no pluggability requirement exists. A <code>match</code> statement is simpler and more auditable than a trait registry for internal version dispatch)</li>
<li><strong>Add <code>is_reliable()</code> to Transport</strong> (rejected — would create conditional branches in NetworkModel: one code path for unreliable transports with full retransmit, another for reliable transports that skips it. Doubles the test matrix. Instead, NetworkModel always runs its reliability layer; on reliable transports the retransmit timers simply never fire. Zero runtime cost, one code path)</li>
<li><strong>Connectionless (endpoint-addressed) Transport API</strong> (rejected — creates impedance mismatch: UDP is connectionless but WebSocket/QUIC are connection-oriented. Point-to-point model fits all transports naturally. For UDP, use connected sockets. Multi-peer routing is NetworkModel’s concern, not Transport’s)</li>
</ul>
<h3 id="relationship-to-existing-decisions-5"><a class="header" href="#relationship-to-existing-decisions-5">Relationship to Existing Decisions</a></h3>
<ul>
<li><strong>D006 (NetworkModel):</strong> <code>Transport</code> lives below <code>NetworkModel</code>. The connection establishment flow becomes: Discovery → Transport::connect() → NetworkModel constructed over Transport → Game loop. <code>NetworkModel</code> gains a <code>T: Transport</code> type parameter.</li>
<li><strong>D010 (Snapshottable sim):</strong> Snapshot encoding/decoding is the I/O layer around D010’s <code>SimSnapshot</code>. D010 defines the struct; D054 defines how it becomes bytes.</li>
<li><strong>D041 (Trait-abstracted subsystems):</strong> <code>Transport</code> is added to D041’s inventory table. <code>SignatureScheme</code> uses enum dispatch (not a trait) — it belongs in the “closed set” category alongside <code>SnapshotCodec</code>’s version dispatch. Both are version-tagged, exhaustive, and compiler-enforced. Neither needs the open extensibility that traits provide.</li>
<li><strong>D052 (Community Servers &amp; SCR):</strong> The <code>version</code> byte in SCR format now implies the signature algorithm. D052’s anti-algorithm-confusion guarantee is preserved — the defense shifts from “hardcode one algorithm” to “version determines algorithm, verifier never reads algorithm from attacker input.”</li>
<li><strong>Invariant #10 (Platform-agnostic):</strong> <code>Transport</code> trait directly enables WASM multiplayer, the primary platform gap.</li>
</ul>
<h3 id="phase"><a class="header" href="#phase">Phase</a></h3>
<ul>
<li><strong>Phase 2:</strong> <code>MemoryTransport</code> for testing (already implied by <code>LocalNetwork</code>; making it explicit as a <code>Transport</code>). <code>SnapshotCodec</code> version dispatch (v1 = bincode + LZ4, matching current behavior).</li>
<li><strong>Phase 5:</strong> <code>UdpTransport</code>, <code>WebSocketTransport</code> (matching current hardcoded behavior — the trait boundary exists, the implementation is unchanged). <code>SignatureScheme::Ed25519</code> enum variant wired into all D052 SCR code, replacing direct <code>ed25519_dalek</code> calls.</li>
<li><strong>Future:</strong> <code>WebTransportImpl</code> (when spec stabilizes), <code>QuicTransport</code> (when ecosystem matures), <code>SignatureScheme::MlDsa65</code> variant (when post-quantum migration timeline firms up), <code>SnapshotCodec</code> v2 (postcard, when first <code>SimSnapshot</code> schema change occurs).</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../decisions/09c-modding.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../decisions/09e-community.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../decisions/09c-modding.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../decisions/09e-community.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-c2a407aa.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
