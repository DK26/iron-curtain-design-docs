<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tools &amp; Editor - Iron Curtain — Design Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Design docs for a Rust-native Red Alert RTS engine">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-cb71b11f.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-b4a6e245.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Iron Curtain — Design Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/DK26/iron-curtain-design-docs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>
                        <a href="https://github.com/DK26/iron-curtain-design-docs/edit/main/src/decisions/09f-tools.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <span class=fa-svg id="git-edit-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M421.7 220.3l-11.3 11.3-22.6 22.6-205 205c-6.6 6.6-14.8 11.5-23.8 14.1L30.8 511c-8.4 2.5-17.5 .2-23.7-6.1S-1.5 489.7 1 481.2L38.7 353.1c2.6-9 7.5-17.2 14.1-23.8l205-205 22.6-22.6 11.3-11.3 33.9 33.9 62.1 62.1 33.9 33.9zM96 353.9l-9.3 9.3c-.9 .9-1.6 2.1-2 3.4l-25.3 86 86-25.3c1.3-.4 2.5-1.1 3.4-2l9.3-9.3H112c-8.8 0-16-7.2-16-16V353.9zM453.3 19.3l39.4 39.4c25 25 25 65.5 0 90.5l-14.5 14.5-22.6 22.6-11.3 11.3-33.9-33.9-62.1-62.1L314.3 67.7l11.3-11.3 22.6-22.6 14.5-14.5c25-25 65.5-25 90.5 0z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="decision-log--tools--editor"><a class="header" href="#decision-log--tools--editor">Decision Log — Tools &amp; Editor</a></h1>
<p>LLM mission generation, scenario editor, asset studio, LLM configuration, foreign replays, and skill library.</p>
<hr>
<h2 id="d016-llm-generated-missions-and-campaigns"><a class="header" href="#d016-llm-generated-missions-and-campaigns">D016: LLM-Generated Missions and Campaigns</a></h2>
<p><strong>Decision:</strong> Provide an optional LLM-powered mission generation system (Phase 7) via the <code>ic-llm</code> crate. Players bring their own LLM provider (BYOLLM) — the engine never ships or requires one. Every game feature works fully without an LLM configured.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Transforms Red Alert from finite content to infinite content — for players who opt in</li>
<li>Generated output is standard YAML + Lua — fully editable, shareable, learnable</li>
<li>No other RTS (Red Alert or otherwise) offers this capability</li>
<li>LLM quality is sufficient for terrain layout, objective design, AI behavior scripting</li>
<li><strong>Strictly optional:</strong> <code>ic-llm</code> crate is optional, game works without it. No feature — campaigns, skirmish, multiplayer, modding, analytics — depends on LLM availability. The LLM enhances the experience; it never gates it</li>
</ul>
<p><strong>Scope:</strong></p>
<ul>
<li>Phase 7: single mission generation (terrain, objectives, enemy composition, triggers, briefing)</li>
<li>Phase 7: player-aware generation — LLM reads local SQLite (D034) for faction history, unit preferences, win rates, campaign roster state; injects player context into prompts for personalized missions, adaptive briefings, post-match commentary, coaching suggestions, and rivalry narratives</li>
<li>Phase 7: replay-to-scenario narrative generation — LLM reads gameplay event logs from replays to generate briefings, objectives, dialogue, and story context for scenarios extracted from real matches (see D038 § Replay-to-Scenario Pipeline)</li>
<li>Phase 7: <strong>generative campaigns</strong> — full multi-mission branching campaigns generated progressively as the player advances (see Generative Campaign Mode below)</li>
<li>Phase 7: <strong>generative media</strong> — AI-generated voice lines, music, sound FX for campaigns and missions via pluggable provider traits (see Generative Media Pipeline below)</li>
<li>Phase 7+ / Future: AI-generated cutscenes/video (depends on technology maturity)</li>
<li>Future: cooperative scenario design, community challenge campaigns</li>
</ul>
<blockquote>
<p><strong>Positioning note:</strong> LLM features are a quiet power-user capability, not a project headline. The primary single-player story is the hand-authored branching campaign system (D021), which requires no LLM and is genuinely excellent on its own merits. LLM generation is for players who want more content — it should never appear before D021 in marketing or documentation ordering. The word “AI” in gaming contexts attracts immediate hostility from a significant audience segment regardless of implementation quality. Lead with campaigns, reveal LLM as “also, modders and power users can use AI tools if they want.”</p>
</blockquote>
<p><strong>Implementation approach:</strong></p>
<ul>
<li>LLM generates YAML map definition + Lua trigger scripts</li>
<li>Same format as hand-crafted missions — no special runtime</li>
<li>Validation pass ensures generated content is playable (valid unit types, reachable objectives)</li>
<li>Can use local models or API-based models (user choice)</li>
<li>Player data for personalization comes from local SQLite queries (read-only) — no data leaves the device unless the user’s LLM provider is cloud-based (BYOLLM architecture)</li>
</ul>
<p><strong>Bring-Your-Own-LLM (BYOLLM) architecture:</strong></p>
<ul>
<li><code>ic-llm</code> defines a <code>LlmProvider</code> trait — any backend that accepts a prompt and returns structured text</li>
<li>Built-in providers: OpenAI-compatible API, local Ollama/llama.cpp, Anthropic API</li>
<li>Users configure their provider in settings (API key, endpoint, model name)</li>
<li>The engine never ships or requires a specific model — the user chooses</li>
<li>Provider is a runtime setting, not a compile-time dependency</li>
<li>All prompts and responses are logged (opt-in) for debugging and sharing</li>
<li>Offline mode: pre-generated content works without any LLM connection</li>
</ul>
<h3 id="generative-campaign-mode"><a class="header" href="#generative-campaign-mode">Generative Campaign Mode</a></h3>
<p>The single biggest use of LLM generation: <strong>full branching campaigns created on the fly.</strong> The player picks a faction, adjusts parameters (or accepts defaults), and the LLM generates an entire campaign — backstory, missions, branching paths, persistent characters, and narrative arc — progressively as they play. Every generated campaign is a standard D021 campaign: YAML graph, Lua scripts, maps, briefings. Once generated, a campaign is <strong>fully playable without an LLM</strong> — generation is the creative act; playing is standard IC.</p>
<h4 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h4>
<p><strong>Step 1 — Campaign Setup (one screen, defaults provided):</strong></p>
<p>The player opens “New Generative Campaign” from the main menu. If no LLM provider is configured, the button is still clickable — it opens a guidance panel: “Generative campaigns need an LLM provider to create missions. [Configure LLM Provider →] You can also browse pre-generated campaigns on the Workshop. [Browse Workshop →]” (see D033 § “UX Principle: No Dead-End Buttons”). Once an LLM is configured, the same button opens the configuration screen with defaults and an “Advanced” expander for fine-tuning:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Player faction</strong></td><td>(must pick)</td><td>Soviet, Allied, or a modded faction. Determines primary enemies and narrative allegiance.</td></tr>
<tr><td><strong>Campaign length</strong></td><td>24 missions</td><td>Total missions in the campaign arc. Configurable: 8 (short), 16 (medium), 24 (standard), 32+ (epic), or <strong>open-ended</strong> (no fixed count — campaign ends when victory conditions are met; see Open-Ended Campaigns below).</td></tr>
<tr><td><strong>Branching density</strong></td><td>Medium</td><td>How many branch points. Low = mostly linear with occasional forks. High = every mission has 2–3 outcomes leading to different paths.</td></tr>
<tr><td><strong>Tone</strong></td><td>Military thriller</td><td>Narrative style: military thriller, pulp action, dark/gritty, campy Cold War, espionage, or freeform text description.</td></tr>
<tr><td><strong>Story style</strong></td><td>C&amp;C Classic</td><td>Story structure and character voice. See “Story Style Presets” below. Options: C&amp;C Classic (default — over-the-top military drama with memorable personalities), Realistic Military, Political Thriller, Pulp Sci-Fi, Character Drama, or freeform text description. Note: “Military thriller” tone + “C&amp;C Classic” story style is the canonical pairing — they are complementary, not contradictory. C&amp;C IS a military thriller, played at maximum volume with camp and conviction (see 13-PHILOSOPHY.md § Principle 20). The tone governs atmospheric tension; the story style governs character voice and narrative structure.</td></tr>
<tr><td><strong>Difficulty curve</strong></td><td>Adaptive</td><td>Start easy, escalate. Options: flat, escalating, adaptive (adjusts based on player performance), brutal (hard from mission 1).</td></tr>
<tr><td><strong>Roster persistence</strong></td><td>Enabled</td><td>Surviving units carry forward (D021 carryover). Disabled = fresh forces each mission.</td></tr>
<tr><td><strong>Named characters</strong></td><td>3–5</td><td>How many recurring characters the LLM creates. Built using personality-driven construction (see Character Construction Principles below). These can survive, die, betray, return.</td></tr>
<tr><td><strong>Theater</strong></td><td>Random</td><td>European, Arctic, Desert, Pacific, Global (mixed), or a specific setting.</td></tr>
<tr><td><strong>Game module</strong></td><td>(current)</td><td>RA1, TD, or any installed game module.</td></tr>
</tbody>
</table>
</div>
<p><strong>Advanced parameters</strong> (hidden by default):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Mission variety targets</strong></td><td>Balanced</td><td>Distribution of mission types: assault, defense, stealth, escort, naval, combined arms. The LLM aims for this mix but adapts based on narrative flow.</td></tr>
<tr><td><strong>Faction purity</strong></td><td>90%</td><td>Percentage of missions fighting the opposing faction. Remainder = rogue elements of your own faction, third parties, or storyline twists (civil war, betrayal missions).</td></tr>
<tr><td><strong>Resource level</strong></td><td>Standard</td><td>Starting resources per mission. Scarce = more survival-focused. Abundant = more action-focused.</td></tr>
<tr><td><strong>Weather variation</strong></td><td>Enabled</td><td>LLM introduces weather changes across the campaign arc (D022). Arctic campaign starts mild, ends in blizzard.</td></tr>
<tr><td><strong>Workshop resources</strong></td><td>Configured sources</td><td>Which Workshop sources (D030) the LLM can pull assets from (maps, terrain packs, music, voice lines). Only resources with <code>ai_usage: Allow</code> are eligible.</td></tr>
<tr><td><strong>Custom instructions</strong></td><td>(empty)</td><td>Freeform text the player adds to every prompt. “Include lots of naval missions.” “Make Tanya a villain.” “Based on actual WW2 Eastern Front operations.”</td></tr>
<tr><td><strong>Moral complexity</strong></td><td>Low</td><td>How often the LLM generates tactical dilemmas with no clean answer, and how much character personality drives the fallout. Low = straightforward objectives. Medium = occasional trade-offs with character consequences. High = genuine moral weight with long-tail consequences across missions. See “Moral Complexity Parameter” under Extended Generative Campaign Modes.</td></tr>
<tr><td><strong>Victory conditions</strong></td><td>(fixed length only)</td><td>For open-ended campaigns: a set of conditions that define campaign victory. Examples: “Eliminate General Morrison,” “Capture all three Allied capitals,” “Survive 30 missions.” The LLM works toward these conditions narratively — building tension, creating setbacks, escalating stakes — and generates the final mission when conditions are ripe. Ignored when campaign length is fixed.</td></tr>
</tbody>
</table>
</div>
<p>The player clicks “Generate Campaign” — the LLM produces the campaign skeleton before the first mission starts (typically 10–30 seconds depending on provider).</p>
<p><strong>Step 2 — Campaign Skeleton (generated once, upfront):</strong></p>
<p>Before the first mission, the LLM generates a <strong>campaign skeleton</strong> — the high-level arc that provides coherence across all missions:</p>
<pre><code class="language-yaml"># Generated campaign skeleton (stored in campaign save)
generative_campaign:
  id: gen_soviet_2026-02-14_001
  title: "Operation Iron Tide"           # LLM-generated title
  faction: soviet
  enemy_faction: allied
  theater: european
  length: 24
  
  # Narrative arc — the LLM's plan for the full campaign
  arc:
    act_1: "Establishing foothold in Eastern Europe (missions 1–8)"
    act_2: "Push through Central Europe, betrayal from within (missions 9–16)"
    act_3: "Final assault on Allied HQ, resolution (missions 17–24)"
  
  # Named characters (persistent across the campaign)
  characters:
    - name: "Colonel Petrov"
      role: player_commander
      allegiance: soviet           # current allegiance (can change mid-campaign)
      loyalty: 100                 # 0–100; below threshold triggers defection risk
      personality:
        mbti: ISTJ                 # Personality type — guides dialogue voice, decision patterns, stress reactions
        core_traits: ["pragmatic", "veteran", "distrusts politicians"]
        flaw: "Rigid adherence to doctrine; struggles when improvisation is required"
        desire: "Protect his soldiers and win the war with minimal casualties"
        fear: "Becoming the kind of officer who treats troops as expendable"
        speech_style: "Clipped military brevity. No metaphors. States facts, expects action."
      arc: "Loyal commander who questions orders in Act 2"
      hidden_agenda: null          # no secret agenda
    - name: "Lieutenant Sonya"
      role: intelligence_officer
      allegiance: soviet
      loyalty: 75                  # not fully committed — exploitable
      personality:
        mbti: ENTJ                 # Ambitious leader type — strategic, direct, will challenge authority
        core_traits: ["brilliant", "ambitious", "morally flexible"]
        flaw: "Believes the ends always justify the means; increasingly willing to cross lines"
        desire: "Power and control over the outcome of the war"
        fear: "Being a pawn in someone else's game — which is exactly what she is"
        speech_style: "Precise intelligence language with subtle manipulation. Plants ideas as questions."
      arc: "Provides intel briefings; has a hidden agenda revealed in Act 2"
      hidden_agenda: "secretly working for a rogue faction; will betray if loyalty drops below 40"
    - name: "Sergeant Volkov"
      role: field_hero
      allegiance: soviet
      loyalty: 100
      unit_type: commando
      personality:
        mbti: ESTP                 # Action-oriented operator — lives in the moment, reads the battlefield
        core_traits: ["fearless", "blunt", "fiercely loyal"]
        flaw: "Impulsive; acts first, thinks later; puts himself at unnecessary risk"
        desire: "To be in the fight. Peace terrifies him more than bullets."
        fear: "Being sidelined or deemed unfit for combat"
        speech_style: "Short, punchy, darkly humorous. Gallows humor under fire. Calls everyone by nickname."
      arc: "Accompanies the player; can die permanently"
      hidden_agenda: null
    - name: "General Morrison"
      role: antagonist
      allegiance: allied
      loyalty: 90
      personality:
        mbti: INTJ                 # Strategic mastermind — plans 10 moves ahead, emotionally distant
        core_traits: ["strategic genius", "ruthless", "respects worthy opponents"]
        flaw: "Arrogance — sees the player as a puzzle to solve, not a genuine threat, until it's too late"
        desire: "To prove the intellectual superiority of his approach to warfare"
        fear: "Losing to brute force rather than strategy — it would invalidate his entire philosophy"
        speech_style: "Calm, measured, laced with classical references. Never raises his voice. Compliments the player before threatening them."
      arc: "Allied commander; grows from distant threat to personal rival"
      hidden_agenda: "may offer a secret truce if the player's reputation is high enough"
  
  # Backstory and context (fed to the LLM for every subsequent mission prompt)
  backstory: |
    The year is 1953. The Allied peace treaty has collapsed after the
    assassination of the Soviet delegate at the Vienna Conference.
    Colonel Petrov leads a reformed armored division tasked with...
  
  # Planned branch points (approximate — adjusted as the player plays)
  branch_points:
    - mission: 4
      theme: "betray or protect civilian population"
    - mission: 8
      theme: "follow orders or defy command"
    - mission: 12
      theme: "Sonya's loyalty revealed"
    - mission: 16
      theme: "ally with rogue faction or destroy them"
    - mission: 20
      theme: "mercy or ruthlessness in final push"
</code></pre>
<p>The skeleton is a plan, not a commitment. The LLM adapts it as the player makes choices and encounters different outcomes. Act 2’s betrayal might happen in mission 10 or mission 14 depending on how the player’s story unfolds.</p>
<h4 id="character-construction-principles"><a class="header" href="#character-construction-principles">Character Construction Principles</a></h4>
<p>Generative campaigns live or die on character quality. A procedurally generated mission with a mediocre map is forgettable. A procedurally generated mission where a character you care about betrays you is unforgettable. The LLM’s system prompt includes explicit character construction guidance drawn from proven storytelling principles.</p>
<p><strong>Personality-first construction:</strong></p>
<p>Every named character is built from a personality model, not just a role label. The LLM assigns each character:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Purpose</th><th>Example (Sonya)</th></tr>
</thead>
<tbody>
<tr><td><strong>MBTI type</strong></td><td>Governs decision-making patterns, stress reactions, communication style, and interpersonal dynamics</td><td>ENTJ — ambitious strategist who leads from the front and challenges authority</td></tr>
<tr><td><strong>Core traits</strong></td><td>3–5 adjectives that define the character’s public-facing personality</td><td>Brilliant, ambitious, morally flexible</td></tr>
<tr><td><strong>Flaw</strong></td><td>A specific weakness that creates dramatic tension and makes the character human</td><td>Believes the ends always justify the means</td></tr>
<tr><td><strong>Desire</strong></td><td>What the character wants — drives their actions and alliances</td><td>Power and control over the outcome of the war</td></tr>
<tr><td><strong>Fear</strong></td><td>What the character dreads — drives their mistakes and vulnerabilities</td><td>Being a pawn in someone else’s game</td></tr>
<tr><td><strong>Speech style</strong></td><td>Concrete voice direction so dialogue sounds like a person, not a bot</td><td>“Precise intelligence language with subtle manipulation”</td></tr>
</tbody>
</table>
</div>
<p>The MBTI type is not a horoscope — it’s a <strong>consistency framework</strong>. When the LLM generates dialogue, decisions, and reactions over 24 missions, the personality type keeps the character’s voice and behavior coherent. An ISTJ commander (Petrov) responds to a crisis differently than an ESTP commando (Volkov): Petrov consults doctrine, Volkov acts immediately. An ENTJ intelligence officer (Sonya) challenges the player’s plan head-on; an INFJ would express doubts obliquely. The LLM’s system prompt maps each type to concrete behavioral patterns:</p>
<ul>
<li><strong>Under stress:</strong> How the character cracks (ISTJ → becomes rigidly procedural; ESTP → reckless improvisation; ENTJ → autocratic overreach; INTJ → cold withdrawal)</li>
<li><strong>In conflict:</strong> How they argue (ST types cite facts; NF types appeal to values; TJ types issue ultimatums; FP types walk away)</li>
<li><strong>Loyalty shifts:</strong> What makes them stay or leave (SJ types value duty and chain of command; NP types value autonomy and moral alignment; NT types follow competence; SF types follow personal bonds)</li>
<li><strong>Dialogue voice:</strong> How they talk (specific sentence structures, vocabulary patterns, verbal tics, and what they never say)</li>
</ul>
<p><strong>The flaw/desire/fear triangle</strong> is the engine of character drama. Every meaningful character moment comes from the collision between what a character wants, what they’re afraid of, and the weakness that undermines them. Sonya <em>wants</em> control, <em>fears</em> being a pawn, and her <em>flaw</em> (ends justify means) is exactly what makes her vulnerable to becoming the thing she fears. The LLM uses this triangle to generate character arcs that feel authored, not random.</p>
<p><strong>Ensemble dynamics:</strong></p>
<p>The LLM doesn’t build characters in isolation — it builds a cast with deliberate personality contrasts. The system prompt instructs:</p>
<ul>
<li><strong>No duplicate MBTI types</strong> in the core cast (3–5 characters). Personality diversity creates natural interpersonal tension.</li>
<li><strong>Complementary and opposing pairs.</strong> Petrov (ISTJ, duty-bound) and Sonya (ENTJ, ambitious) disagree on <em>why</em> they’re fighting. Volkov (ESTP, lives-for-combat) and a hypothetical diplomat character (INFJ, seeks-peace) disagree on <em>whether</em> they should be. These pairings generate conflict without scripting.</li>
<li><strong>Role alignment — or deliberate misalignment.</strong> A character whose MBTI fits their role (ISTJ commander) is reliable. A character whose personality clashes with their role (ENFP intelligence officer — creative but unfocused) creates tension that pays off during crises.</li>
</ul>
<p><strong>Inter-character dynamics (MBTI interaction simulation):</strong></p>
<p>Characters don’t exist in isolation — they interact with each other, and those interactions are where the best drama lives. The LLM uses MBTI compatibility and tension patterns to simulate how characters relate, argue, collaborate, and clash <em>with each other</em> — not just with the player.</p>
<p>The system prompt maps personality pairings to interaction patterns:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pairing dynamic</th><th>Example</th><th>Interaction pattern</th></tr>
</thead>
<tbody>
<tr><td><strong>NT + NT</strong> (strategist meets strategist)</td><td>Sonya (ENTJ) vs. Morrison (INTJ)</td><td>Intellectual respect masking mutual threat. Each anticipates the other’s moves. Conversations are chess games. If forced to cooperate, they’re devastatingly effective — but neither trusts the other to stay loyal.</td></tr>
<tr><td><strong>ST + NF</strong> (realist meets idealist)</td><td>Petrov (ISTJ) + diplomat (INFJ)</td><td>Petrov dismisses idealism as naïve; the diplomat sees Petrov as a blunt instrument. Under pressure, the diplomat’s moral clarity gives Petrov purpose he didn’t know he lacked.</td></tr>
<tr><td><strong>SP + SJ</strong> (improviser meets rule-follower)</td><td>Volkov (ESTP) + Petrov (ISTJ)</td><td>Volkov breaks protocol; Petrov enforces it. They argue constantly — but Volkov’s improvisation saves the squad when doctrine fails, and Petrov’s discipline saves them when improvisation gets reckless. Grudging mutual respect over time.</td></tr>
<tr><td><strong>TJ + FP</strong> (commander meets rebel)</td><td>Sonya (ENTJ) + a resistance leader (ISFP)</td><td>Sonya issues orders; the ISFP resists on principle. Sonya sees inefficiency; the ISFP sees tyranny. The conflict escalates until one of them is proven right — or both are proven wrong.</td></tr>
</tbody>
</table>
</div>
<p>The LLM generates inter-character dialogue — not just player-facing briefings — by simulating how each character would respond to the other’s personality. When Petrov delivers a mission debrief and Volkov interrupts with a joke, the LLM knows Petrov’s ISTJ response is clipped disapproval (“This isn’t the time, Sergeant”), not laughter. When Sonya proposes a morally questionable plan, the LLM knows which characters push back (NF types, SF types) and which support it (NT types, pragmatic ST types).</p>
<p>Over a 24-mission campaign, these simulated interactions create emergent relationships that the LLM tracks in narrative threads. A Petrov-Volkov friction arc might evolve from mutual irritation (missions 1–5) to grudging respect (missions 6–12) to genuine trust (missions 13–20) to devastating loss if one of them dies. None of this is scripted — it emerges from consistent MBTI-driven behavioral simulation applied to the campaign’s actual events.</p>
<p><strong>Story Style Presets:</strong></p>
<p>The <code>story_style</code> parameter controls how the LLM constructs both characters and narrative. The default — <strong>C&amp;C Classic</strong> — is designed to feel like an actual C&amp;C campaign:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Style</th><th>Character Voice</th><th>Narrative Feel</th><th>Inspired By</th></tr>
</thead>
<tbody>
<tr><td><strong>C&amp;C Classic</strong> (default)</td><td>Over-the-top military personalities. Commanders are larger-than-life. Villains monologue. Heroes quip under fire. Every character is memorable on first briefing.</td><td>Bombastic Cold War drama with genuine tension underneath. Betrayals. Superweapons. Last stands. The war is absurd and deadly serious at the same time.</td><td>RA1/RA2 campaigns, Tanya’s one-liners, Stalin’s theatrics, Yuri’s menace, Carville’s charm</td></tr>
<tr><td><strong>Realistic Military</strong></td><td>Understated professionalism. Characters speak in military shorthand. Emotions are implied, not stated.</td><td>Band of Brothers tone. The horror of war comes from what’s <em>not</em> said. Missions feel like operations, not adventures.</td><td>Generation Kill, Black Hawk Down, early Tom Clancy</td></tr>
<tr><td><strong>Political Thriller</strong></td><td>Everyone has an agenda. Dialogue is subtext-heavy. Trust is currency.</td><td>Slow-burn intrigue with sudden violence. The real enemy is often on your own side.</td><td>The Americans, Tinker Tailor Soldier Spy, Metal Gear Solid</td></tr>
<tr><td><strong>Pulp Sci-Fi</strong></td><td>Characters are archetypes turned to 11. Scientists are mad. Soldiers are grizzled. Villains are theatrical.</td><td>Experimental tech, dimension portals, time travel, alien artifacts. Camp embraced, not apologized for.</td><td>RA2 Yuri’s Revenge, C&amp;C Renegade, Starship Troopers</td></tr>
<tr><td><strong>Character Drama</strong></td><td>Deeply human characters with complex motivations. Relationships shift over the campaign.</td><td>The war is the backdrop; the story is about the people. Victory feels bittersweet. Loss feels personal.</td><td>The Wire, Battlestar Galatica, This War of Mine</td></tr>
</tbody>
</table>
</div>
<p>The default (C&amp;C Classic) exists because generative campaigns should feel like C&amp;C out of the box — not generic military fiction. Kane, Tanya, Yuri, and Carville are memorable because they’re <em>specific</em>: exaggerated personalities with distinctive voices, clear motivations, and dramatic reveals. The LLM’s system prompt for C&amp;C Classic includes explicit guidance: “Characters should be instantly recognizable from their first line of dialogue. A commander who speaks in forgettable military platitudes is a failed character. Every briefing should have a line worth quoting.”</p>
<p>Players who want a different narrative texture pick a different style — or write a freeform description. The <code>custom_instructions</code> field in Advanced parameters stacks with the style preset, so a player can select “C&amp;C Classic” and add “but make the villain sympathetic” for a hybrid tone.</p>
<p><strong>C&amp;C Classic — Narrative DNA (LLM System Prompt Guidelines):</strong></p>
<p>The “C&amp;C Classic” preset isn’t just a label — it’s a set of concrete generation rules derived from Principle #20 (Narrative Identity) in <a href="13-PHILOSOPHY.html">13-PHILOSOPHY.md</a>. When the LLM generates content in this style, its system prompt includes the following directives. These also serve as authoring guidelines for hand-crafted IC campaigns.</p>
<p><em>Tone rules:</em></p>
<ol>
<li><strong>Play everything straight.</strong> Never acknowledge absurdity. A psychic weapon is presented with the same military gravitas as a tank column. A trained attack dolphin gets a unit briefing, not a joke. The audience finds the humor because the world takes itself seriously — the moment the writing winks, the spell breaks.</li>
<li><strong>Escalate constantly.</strong> Every act raises the stakes. If mission 1 is “secure a bridge,” mission 8 should involve a superweapon, and mission 20 should threaten civilization. C&amp;C campaigns climb from tactical skirmish to existential crisis. Never de-escalate the macro arc, even if individual missions provide breathers.</li>
<li><strong>Make it quotable.</strong> Before finalizing any briefing, villain monologue, or unit voice line, apply the quotability test: would a player repeat this line to a friend? Would it work as a forum signature? If a line communicates information but isn’t memorable, rewrite it until it is.</li>
</ol>
<p><em>Character rules:</em></p>
<ol start="4">
<li><strong>First line establishes personality.</strong> A character’s introduction must immediately communicate who they are. Generic: “Commander, I’ll be your intelligence officer.” C&amp;C Classic: “Commander, I’ve read your file. Impressive — if any of it is true.” The personality is the introduction.</li>
<li><strong>Villains believe they’re right.</strong> C&amp;C villains — Kane, Yuri, Stalin — are compelling because they have genuine convictions. Kane isn’t evil for evil’s sake; he has a vision. Generate villains with philosophy, not just malice. The best villain dialogue makes the player pause and think “…he has a point.”</li>
<li><strong>Heroes have attitude, not perfection.</strong> Tanya isn’t a generic soldier — she’s cocky, impatient, and treats war like a playground. Carville isn’t a generic general — he’s folksy, irreverent, and drops Southern metaphors. Generate heroes with specific personality quirks that make them fun, not admirable.</li>
<li><strong>Betrayal is always personal.</strong> C&amp;C campaigns are built on betrayals — and the best ones hurt because you liked the character. If the campaign skeleton includes a betrayal arc, invest missions in making that character genuinely likeable first. A betrayal by a cipher is plot. A betrayal by someone you trusted is drama.</li>
</ol>
<p><em>World-building rules:</em></p>
<ol start="8">
<li><strong>Cold War as mythology, not history.</strong> Real Cold War events are raw material, not constraints. Einstein erasing Hitler, chronosphere technology, psychic amplifiers, orbital ion cannons — these are mythological amplifications of real anxieties. Generate world details that feel like Cold War fever dreams, not Wikipedia entries.</li>
<li><strong>Technology is dramatic, not realistic.</strong> Every weapon and structure should evoke a feeling. “GAP generator” isn’t just radar jamming — it’s shrouding your base in mystery. “Iron Curtain device” isn’t just invulnerability — it’s invoking the most famous metaphor of the Cold War era. Name technologies for dramatic impact, not technical accuracy.</li>
<li><strong>Factions are worldviews.</strong> Allied briefings should feel like Western military confidence: professional, optimistic, technologically superior, with an undercurrent of “we’re the good guys, right?” Soviet briefings should feel like revolutionary conviction: the individual serves the collective, sacrifice is glory, industrial might is beautiful. Generate faction-specific vocabulary, sentence structure, and emotional register — not just different unit names.</li>
</ol>
<p><em>Structural rules:</em></p>
<ol start="11">
<li><strong>Every mission has a “moment.”</strong> A moment is a scripted event that creates an emotional peak — a character’s dramatic entrance, a surprise betrayal, a superweapon firing, an unexpected ally, a desperate last stand. Missions without moments are forgettable. Generate at least one moment per mission, placed at a dramatically appropriate time (not always the climax — a mid-mission gut punch is often stronger).</li>
<li><strong>Briefings sell the mission.</strong> The briefing exists to make the player <em>want</em> to play the next mission. It should end with a question (explicit or implied) that the mission answers. “Can we take the beachhead before Morrison moves his armor south?” The player clicks “Deploy” because they want to find out.</li>
<li><strong>Debriefs acknowledge what happened.</strong> Post-mission debriefs should reference specific battle report outcomes: casualties, key moments, named units that survived or died. A debrief that says “Well done, Commander” regardless of outcome is a failed debrief. React to the player’s actual experience.</li>
</ol>
<blockquote>
<p><strong>Cross-reference:</strong> These rules derive from Principle #20 (Narrative Identity — Earnest Commitment, Never Ironic Distance) in <a href="13-PHILOSOPHY.html">13-PHILOSOPHY.md</a>, which establishes the seven C&amp;C narrative pillars. The rules above are the specific, actionable LLM directives and human authoring guidelines that implement those pillars for content generation. Other story style presets (Realistic Military, Political Thriller, etc.) have their own rule sets — but C&amp;C Classic is the default because it captures the franchise’s actual identity.</p>
</blockquote>
<p><strong>Step 3 — Post-Mission Inspection &amp; Progressive Generation:</strong></p>
<p>After each mission, the system collects a detailed <strong>battle report</strong> — not just “win/lose” but a structured account of what happened during gameplay. This report is the LLM’s primary input for generating the next mission. The LLM inspects what actually occurred and reacts to it against the backstory and campaign arc.</p>
<p><strong>What the battle report captures:</strong></p>
<ul>
<li><strong>Outcome:</strong> which named outcome the player achieved (victory variant, defeat variant)</li>
<li><strong>Casualties:</strong> units lost by type, how they died (combat, friendly fire, sacrificed), named characters killed or wounded</li>
<li><strong>Surviving forces:</strong> exact roster state — what the player has left to carry forward</li>
<li><strong>Buildings:</strong> structures built, destroyed, captured (especially enemy structures)</li>
<li><strong>Economy:</strong> resources gathered, spent, remaining; whether the player was resource-starved or flush</li>
<li><strong>Timeline:</strong> mission duration, how quickly objectives were completed, idle periods</li>
<li><strong>Territory:</strong> areas controlled at mission end, ground gained or lost</li>
<li><strong>Key moments:</strong> scripted triggers that fired (or didn’t), secondary objectives attempted, hidden objectives discovered</li>
<li><strong>Enemy state:</strong> what enemy forces survived, whether the enemy retreated or was annihilated, enemy structures remaining</li>
<li><strong>Player behavior patterns:</strong> aggressive vs. defensive play, tech rush vs. mass production, micromanagement intensity (from D042 event logs)</li>
</ul>
<p>The LLM receives this battle report alongside the campaign context and generates the next mission <strong>as a direct reaction to what happened.</strong> This is not “fill in the next slot in a pre-planned arc” — it’s “inspect the battlefield aftermath and decide what happens next in the story.”</p>
<p><strong>How inspection drives generation:</strong></p>
<ol>
<li><strong>Narrative consequences.</strong> The LLM sees the player barely survived mission 5 with 3 tanks and no base — the next mission isn’t a large-scale assault. It’s a desperate retreat, a scavenging mission, or a resistance operation behind enemy lines. The campaign <em>genre</em> shifts based on the player’s actual situation.</li>
<li><strong>Escalation and de-escalation.</strong> If the player steamrolled mission 3, the LLM escalates: the enemy regroups, brings reinforcements, changes tactics. If the player struggled, the LLM provides a breather mission — resupply, ally arrival, intelligence gathering.</li>
<li><strong>Story continuity.</strong> The LLM references specific events: “Commander, the bridge at Danzig we lost in the last operation — the enemy is using it to move armor south. We need it back.” Because the player actually lost that bridge.</li>
<li><strong>Character reactions.</strong> Named characters react to what happened. Volkov’s briefing changes if the player sacrificed civilians in the last mission. Sonya questions the commander’s judgment after heavy losses. Morrison taunts the player after a defensive victory: “You held the line. Impressive. It won’t save you.”</li>
<li><strong>Campaign arc awareness.</strong> The LLM knows where it is in the story — mission 8 of 24, end of Act 1 — and paces accordingly. Early missions establish, middle missions complicate, late missions resolve. But the <em>specific</em> complications come from the battle reports, not from a pre-written script.</li>
<li><strong>Mission number context.</strong> The LLM knows which mission number it’s generating relative to the total (or relative to victory conditions in open-ended mode). Mission 3/24 gets an establishing tone. Mission 20/24 gets climactic urgency. The story progression scales accordingly — the LLM won’t generate a “final confrontation” at mission 6 unless the campaign is 8 missions long.</li>
</ol>
<p><strong>Generation pipeline per mission:</strong></p>
<pre><code>┌─────────────────────────────────────────────────────────┐
│                 Mission Generation Pipeline              │
│                                                          │
│  Inputs:                                                 │
│  ├── Campaign skeleton (backstory, arc, characters)      │
│  ├── Campaign context (accumulated state — see below)    │
│  ├── Player's campaign state (roster, flags, path taken) │
│  ├── Last mission battle report (detailed telemetry)     │
│  ├── Player profile (D042 — playstyle, preferences)      │
│  ├── Campaign parameters (difficulty, tone, etc.)        │
│  ├── Victory condition progress (open-ended campaigns)   │
│  └── Available Workshop resources (maps, assets)         │
│                                                          │
│  LLM generates:                                          │
│  ├── Mission briefing (text, character dialogue)         │
│  ├── Map layout (YAML terrain definition)                │
│  ├── Objectives (primary + secondary + hidden)           │
│  ├── Enemy composition and AI behavior                   │
│  ├── Triggers and scripted events (Lua)                  │
│  ├── Named outcomes (2–4 per mission)                    │
│  ├── Carryover configuration (roster, equipment, flags)  │
│  ├── Weather schedule (D022)                             │
│  ├── Debrief per outcome (text, story flag effects)      │
│  ├── Cinematic sequences (mid-mission + pre/post)        │
│  ├── Dynamic music playlist + mood tags                  │
│  ├── Radar comm events (in-mission character dialogue)   │
│  ├── In-mission branching dialogues (RPG-style choices)  │
│  ├── EVA notification scripts (custom voice cues)        │
│  └── Intermission dialogue trees (between missions)      │
│                                                          │
│  Validation pass:                                        │
│  ├── All unit types exist in the game module             │
│  ├── All map references resolve                          │
│  ├── Objectives are reachable (pathfinding check)        │
│  ├── Lua scripts parse and sandbox-check                 │
│  ├── Named outcomes have valid transitions               │
│  └── Difficulty budget is within configured range        │
│                                                          │
│  Output: standard D021 mission node (YAML + Lua + map)   │
└─────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>Step 4 — Campaign Context (the LLM’s memory):</strong></p>
<p>The LLM doesn’t have inherent memory between generation calls. The system maintains a <strong>campaign context</strong> document — a structured summary of everything that has happened — and includes it in every generation prompt. This is the bridge between “generate mission N” and “generate mission N+1 that makes sense.”</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Accumulated campaign context — passed to the LLM with each generation request.
/// Grows over the campaign but is summarized/compressed to fit context windows.
#[derive(Serialize, Deserialize, Clone)]
pub struct GenerativeCampaignContext {
    /// The original campaign skeleton (backstory, arc, characters).
    pub skeleton: CampaignSkeleton,
    
    /// Campaign parameters chosen by the player at setup.
    pub parameters: CampaignParameters,
    
    /// Per-mission summary of what happened (compressed narrative, not raw state).
    pub mission_history: Vec&lt;MissionSummary&gt;,
    
    /// Current state of each named character — tracks everything the LLM needs
    /// to write them consistently and evolve their arc.
    pub character_states: Vec&lt;CharacterState&gt;,
    
    /// Active story flags and campaign variables (D021 persistent state).
    pub flags: HashMap&lt;String, Value&gt;,
    
    /// Current unit roster summary (unit counts by type, veterancy distribution,
    /// named units — not individual unit state, which is too granular for prompts).
    pub roster_summary: RosterSummary,
    
    /// Narrative threads the LLM is tracking (set up in skeleton, updated per mission).
    /// e.g., "Sonya's betrayal — foreshadowed in missions 3, 5; reveal planned for ~mission 12"
    pub active_threads: Vec&lt;NarrativeThread&gt;,
    
    /// Player tendency observations (from D042 profile + mission outcomes).
    /// e.g., "Player favors aggressive strategies, rarely uses naval units,
    /// tends to protect civilians"
    pub player_tendencies: Vec&lt;String&gt;,
    
    /// The planned arc position — where we are in the narrative structure.
    /// e.g., "Act 2, rising action, approaching midpoint crisis"
    pub arc_position: String,
}

pub struct MissionSummary {
    pub mission_number: u32,
    pub title: String,
    pub outcome: String,            // the named outcome the player achieved
    pub narrative_summary: String,  // 2-3 sentence LLM-generated summary
    pub key_events: Vec&lt;String&gt;,    // "Volkov killed", "bridge destroyed", "civilians saved"
    pub performance: MissionPerformance, // time, casualties, rating
}

/// Detailed battle telemetry collected after each mission.
/// This is what the LLM "inspects" to decide what happens next.
pub struct BattleReport {
    pub units_lost: HashMap&lt;String, u32&gt;,        // unit type → count lost
    pub units_surviving: HashMap&lt;String, u32&gt;,   // unit type → count remaining
    pub named_casualties: Vec&lt;String&gt;,           // named characters killed this mission
    pub buildings_destroyed: Vec&lt;String&gt;,        // player structures lost
    pub buildings_captured: Vec&lt;String&gt;,         // enemy structures captured
    pub enemy_forces_remaining: EnemyState,      // annihilated, retreated, regrouping, entrenched
    pub resources_gathered: i64,
    pub resources_spent: i64,
    pub mission_duration_seconds: u32,
    pub territory_control_permille: i32,          // 0–1000, fraction of map controlled (fixed-point, not f32)
    pub objectives_completed: Vec&lt;String&gt;,       // primary + secondary + hidden
    pub objectives_failed: Vec&lt;String&gt;,
    pub player_behavior: PlayerBehaviorSnapshot, // from D042 event classification
}

/// Tracks a named character's evolving state across the campaign.
/// The LLM reads this to write consistent, reactive character behavior.
pub struct CharacterState {
    pub name: String,
    pub status: CharacterStatus,         // Alive, Dead, MIA, Captured, Defected
    pub allegiance: String,              // current faction — can change mid-campaign
    pub loyalty: u8,                     // 0–100; LLM adjusts based on player actions
    pub relationship_to_player: i8,      // -100 to +100 (hostile → loyal)
    pub hidden_agenda: Option&lt;String&gt;,   // secret motivation; revealed when conditions trigger
    pub personality_type: String,        // MBTI code (e.g., "ISTJ") — personality consistency anchor
    pub speech_style: String,            // dialogue voice guidance for the LLM
    pub flaw: String,                    // dramatic weakness — drives character conflict
    pub desire: String,                  // what they want — drives their actions
    pub fear: String,                    // what they dread — drives their mistakes
    pub missions_appeared: Vec&lt;u32&gt;,     // which missions this character appeared in
    pub kills: u32,                      // if a field unit — combat track record
    pub notable_events: Vec&lt;String&gt;,     // "betrayed the player in mission 12", "saved Volkov in mission 7"
    pub current_narrative_role: String,  // "ally", "antagonist", "rival", "prisoner", "rogue"
}

pub enum CharacterStatus {
    Alive,
    Dead { mission: u32, cause: String },     // permanently gone
    MIA { since_mission: u32 },                // may return
    Captured { by_faction: String },           // rescue or prisoner exchange possible
    Defected { to_faction: String, mission: u32 }, // switched sides
    Rogue { since_mission: u32 },              // operating independently
}
<span class="boring">}</span></code></pre>
<p><strong>Context window management:</strong> The context grows with each mission. For long campaigns (24+ missions), the system compresses older mission summaries into shorter recaps (the LLM itself does this compression: “Summarize missions 1–8 in 200 words, retaining key plot points and character developments”). This keeps the prompt within typical context window limits (~8K–32K tokens for the campaign context, leaving room for the generation instructions and output).</p>
<h4 id="generated-output--standard-d021-campaigns"><a class="header" href="#generated-output--standard-d021-campaigns">Generated Output = Standard D021 Campaigns</a></h4>
<p>Everything the LLM generates is standard IC format:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Generated artifact</th><th>Format</th><th>Same as hand-crafted?</th></tr>
</thead>
<tbody>
<tr><td>Campaign graph</td><td>D021 YAML (<code>campaign.yaml</code>)</td><td>Identical</td></tr>
<tr><td>Mission maps</td><td>YAML map definition</td><td>Identical</td></tr>
<tr><td>Triggers / scripts</td><td>Lua (same API as <code>04-MODDING.md</code>)</td><td>Identical</td></tr>
<tr><td>Briefings</td><td>YAML text + character references</td><td>Identical</td></tr>
<tr><td>Named characters</td><td>D038 Named Characters format</td><td>Identical</td></tr>
<tr><td>Carryover config</td><td>D021 carryover modes</td><td>Identical</td></tr>
<tr><td>Story flags</td><td>D021 <code>flags</code></td><td>Identical</td></tr>
<tr><td>Intermissions</td><td>D038 Intermission Screens (briefing, debrief, roster mgmt, dialogue)</td><td>Identical</td></tr>
<tr><td>Cinematic sequences</td><td>D038 Cinematic Sequence module (YAML step list)</td><td>Identical</td></tr>
<tr><td>Dynamic music config</td><td>D038 Music Playlist module (mood-tagged track lists)</td><td>Identical</td></tr>
<tr><td>Radar comm events</td><td>D038 Video Playback / Radar Comm module</td><td>Identical</td></tr>
<tr><td>In-mission dialogues</td><td>D038 Dialogue Editor format (branching tree YAML)</td><td>Identical</td></tr>
<tr><td>EVA notifications</td><td>D038 EVA module (custom event → audio + text)</td><td>Identical</td></tr>
<tr><td>Ambient sound zones</td><td>D038 Ambient Sound Zone module</td><td>Identical</td></tr>
</tbody>
</table>
</div>
<p>This is the key architectural decision: <strong>there is no “generative campaign runtime.”</strong> The LLM is a content creation tool. Once a mission is generated, it’s a normal mission. Once the full campaign is complete (all 24 missions played), it’s a normal D021 campaign — playable by anyone, with or without an LLM.</p>
<h4 id="cinematic--narrative-generation"><a class="header" href="#cinematic--narrative-generation">Cinematic &amp; Narrative Generation</a></h4>
<p>A generated mission that plays well but <em>feels</em> empty — no mid-mission dialogue, no music shifts, no character moments, no dramatic reveals — is a mission that fails the C&amp;C fantasy. The original Red Alert didn’t just have good missions; it had missions where Stavros called you on the radar mid-battle, where the music shifted from ambient to Hell March when the tanks rolled in, where Tanya dropped a one-liner before breaching the base. That’s the standard.</p>
<p>The LLM generates the <strong>full cinematic layer</strong> for each mission — not just objectives and unit placement, but the narrative moments that make a mission feel authored:</p>
<p><strong>Mid-mission radar comm events:</strong></p>
<p>The classic C&amp;C moment: your radar screen flickers, a character’s face appears, they deliver intel or a dramatic line. The LLM generates these as D038 Radar Comm modules, triggered by game events:</p>
<pre><code class="language-yaml"># LLM-generated radar comm event
radar_comms:
  - id: bridge_warning
    trigger:
      type: unit_enters_region
      region: bridge_approach
      faction: player
    speaker: "General Stavros"
    portrait: stavros_concerned
    text: "Commander, our scouts report heavy armor at the bridge. Going in head-on would be suicide. There's a ford upstream — shallow enough for infantry."
    audio: null                        # TTS if available, silent otherwise
    display_mode: radar_comm           # replaces radar panel
    duration: 6.0                      # seconds, then radar returns
    
  - id: betrayal_reveal
    trigger:
      type: objective_complete
      objective: capture_command_post
    speaker: "Colonel Vasquez"
    portrait: vasquez_smug
    text: "Surprised to see me, Commander? Your General Stavros sold you out. These men now answer to me."
    display_mode: radar_comm
    effects:
      - set_flag: vasquez_betrayal
      - convert_units:                 # allied garrison turns hostile
          region: command_post_interior
          from_faction: player
          to_faction: enemy
    cinematic: true                    # brief letterbox + game pause for drama
</code></pre>
<p>The LLM decides <em>when</em> these moments should happen based on the mission’s narrative arc. A routine mission might have 1-2 comms (intel at start, debrief at end). A story-critical mission might have 5-6, including a mid-battle betrayal, a desperate plea for reinforcements, and a climactic confrontation.</p>
<p><strong>In-mission branching dialogues (RPG-style choices):</strong></p>
<p>Not just in intermissions — branching dialogue can happen <em>during</em> a mission. An NPC unit is reached, a dialogue triggers, the player makes a choice that affects the mission in real-time:</p>
<pre><code class="language-yaml">mid_mission_dialogues:
  - id: prisoner_interrogation
    trigger:
      type: unit_enters_region
      unit: tanya
      region: prison_compound
    pause_game: true                   # freezes game during dialogue
    tree:
      - speaker: "Captured Officer"
        portrait: captured_officer
        text: "I'll tell you everything — the mine locations, the patrol routes. Just let me live."
        choices:
          - label: "Talk. Now."
            effects:
              - reveal_shroud: minefield_region
              - set_flag: intel_acquired
            next: officer_cooperates
          - label: "We don't negotiate with the enemy."
            effects:
              - set_flag: officer_executed
              - adjust_character: { name: "Tanya", loyalty: -5 }
            next: tanya_reacts
          - label: "You'll come with us. Command will want to talk to you."
            effects:
              - spawn_unit: { type: prisoner_escort, region: prison_compound }
              - add_objective: { text: "Extract the prisoner to the LZ", type: secondary }
            next: extraction_added
      
      - id: officer_cooperates
        speaker: "Captured Officer"
        text: "The mines are along the ridge — I'll mark them on your map. And Commander... the base commander is planning to retreat at 0400."
        effects:
          - add_objective: { text: "Destroy the base before 0400", type: bonus, timer: 300 }
      
      - id: tanya_reacts
        speaker: "Tanya"
        portrait: tanya_cold
        text: "Your call, Commander. But he might have known something useful."
</code></pre>
<p>These are <strong>full D038 Dialogue Editor trees</strong> — the same format a human designer would create. The LLM generates them with awareness of the mission’s objectives, characters, and narrative context. The choices have <em>mechanical consequences</em> — revealing shroud, adding objectives, changing timers, spawning units, adjusting character loyalty.</p>
<p>The LLM can also generate <strong>consequence chains</strong> — a choice in Mission 5’s dialogue affects Mission 7’s setup (via story flags). “You spared the officer in Mission 5” → in Mission 7, that officer appears as an informant. The LLM tracks these across the campaign context.</p>
<p><strong>Dynamic music generation:</strong></p>
<p>The LLM doesn’t compose music — it curates it. For each mission, the LLM generates a D038 Music Playlist with mood-tagged tracks selected from the game module’s soundtrack and any Workshop music packs the player has installed:</p>
<pre><code class="language-yaml">music:
  mode: dynamic
  tracks:
    ambient:
      - fogger                         # game module default
      - workshop:cold-war-ost/frozen_fields   # from Workshop music pack
    combat:
      - hell_march
      - grinder
    tension:
      - radio_2
      - workshop:cold-war-ost/countdown
    victory:
      - credits
  
  # Scripted music cues (override dynamic system at specific moments)
  scripted_cues:
    - trigger: { type: timer, seconds: 0 }         # mission start
      track: fogger
      fade_in: 3.0
    - trigger: { type: objective_complete, objective: breach_wall }
      track: hell_march
      fade_in: 0.5                                  # hard cut — dramatic
    - trigger: { type: flag_set, flag: vasquez_betrayal }
      track: workshop:cold-war-ost/countdown
      fade_in: 1.0
</code></pre>
<p>The LLM picks tracks that match the mission’s tone. A desperate defense mission gets tense ambient tracks and hard-hitting combat music. A stealth infiltration gets quiet ambient and reserves the intense tracks for when the alarm triggers. The scripted cues tie specific music moments to narrative beats — the betrayal hits differently when the music shifts at exactly the right moment.</p>
<p><strong>Cinematic sequences:</strong></p>
<p>For high-stakes moments, the LLM generates full D038 Cinematic Sequences — multi-step scripted events combining camera movement, dialogue, music, unit spawns, and letterbox:</p>
<pre><code class="language-yaml">cinematic_sequences:
  - id: reinforcement_arrival
    trigger:
      type: objective_complete
      objective: hold_position_2_min
    skippable: true
    steps:
      - type: letterbox
        enable: true
        transition_time: 0.5
      - type: camera_pan
        from: player_base
        to: beach_landing
        duration: 3.0
        easing: ease_in_out
      - type: play_music
        track: hell_march
        fade_in: 0.5
      - type: spawn_units
        units: [medium_tank, medium_tank, medium_tank, apc, apc]
        position: beach_landing
        faction: player
        arrival: landing_craft          # visual: landing craft delivers them
      - type: dialogue
        speaker: "Admiral Kowalski"
        portrait: kowalski_grinning
        text: "The cavalry has arrived, Commander. Where do you want us?"
        duration: 4.0
      - type: camera_pan
        to: player_base
        duration: 2.0
      - type: letterbox
        enable: false
        transition_time: 0.5
</code></pre>
<p>The LLM generates these for <strong>key narrative moments</strong> — not every trigger. Typical placement:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Moment</th><th>Frequency</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><strong>Mission intro</strong></td><td>Every mission</td><td>Camera pan across the battlefield, briefing dialogue overlay</td></tr>
<tr><td><strong>Reinforcement arrival</strong></td><td>30-50% of missions</td><td>Camera shows troops landing/parachuting in, commander dialogue</td></tr>
<tr><td><strong>Mid-mission plot twist</strong></td><td>20-40% of missions</td><td>Betrayal reveal, surprise enemy, intel discovery</td></tr>
<tr><td><strong>Objective climax</strong></td><td>Key objectives only</td><td>Bridge explosion, base breach, hostage rescue</td></tr>
<tr><td><strong>Mission conclusion</strong></td><td>Every mission</td><td>Victory/defeat sequence, debrief comm</td></tr>
</tbody>
</table>
</div>
<p><strong>Intermission dialogue and narrative scenes:</strong></p>
<p>Between missions, the LLM generates intermission screens that go beyond simple briefings:</p>
<ul>
<li><strong>Branching dialogue with consequences</strong> — “General, do we reinforce the eastern front or push west?” The choice affects the next mission’s setup, available forces, or strategic position.</li>
<li><strong>Character moments</strong> — two named characters argue about strategy. The player’s choice affects their loyalty and relationship. A character whose advice is ignored too many times might defect (Campaign Event Patterns).</li>
<li><strong>Intel briefings</strong> — the player reviews intelligence gathered from the previous mission. What they focus on (or ignore) shapes the next mission’s surprises.</li>
<li><strong>Moral dilemmas</strong> — execute the prisoner or extract intel? Bomb the civilian bridge or let the enemy escape? These set story flags that ripple forward through the campaign.</li>
</ul>
<p>The LLM generates these as D038 Intermission Screens using the Dialogue template with Choice panels. Every choice links to a story flag; every flag feeds back into the LLM’s campaign context for future mission generation.</p>
<p><strong>EVA and ambient audio:</strong></p>
<p>The LLM generates custom EVA notification scripts — mission-specific voice cues beyond the default “Unit lost” / “Construction complete”:</p>
<pre><code class="language-yaml">custom_eva:
  - event: unit_enters_region
    region: minefield_zone
    text: "Warning: mines detected in this area."
    priority: high
    cooldown: 30                       # don't repeat for 30 seconds
    
  - event: building_captured
    building: enemy_radar
    text: "Enemy radar facility captured. Shroud cleared."
    priority: normal
    
  - event: timer_warning
    timer: evacuation_timer
    remaining: 60
    text: "60 seconds until evacuation window closes."
    priority: critical
</code></pre>
<p>The LLM also generates ambient sound zone definitions for narrative atmosphere — a mission in a forest gets wind and bird sounds; a mission in a bombed-out city gets distant gunfire and sirens.</p>
<p><strong>What this means in practice:</strong></p>
<p>A generated mission doesn’t just drop units on a map with objectives. A generated mission:</p>
<ol>
<li>Opens with a <strong>cinematic pan</strong> across the battlefield while the commander briefs you</li>
<li>Plays <strong>ambient music</strong> that matches the terrain and mood</li>
<li>Calls you on the <strong>radar</strong> when something important happens — a new threat, a character moment, a plot development</li>
<li>Presents <strong>RPG-style dialogue choices</strong> when you reach key locations or NPCs</li>
<li><strong>Shifts the music</strong> from ambient to combat when the fighting starts</li>
<li>Triggers a <strong>mid-mission cinematic</strong> when the plot twists — a betrayal, a reinforcement arrival, a bridge explosion</li>
<li>Announces custom <strong>EVA warnings</strong> for mission-specific hazards</li>
<li>Ends with a <strong>conclusion sequence</strong> — victory celebration or desperate evacuation</li>
<li>Transitions to an <strong>intermission</strong> with character dialogue, choices, and consequences</li>
</ol>
<p>All of it is standard D038 format. All of it is editable after generation. All of it works exactly like hand-crafted content. The LLM just writes it faster.</p>
<h4 id="generative-media-pipeline-forward-looking"><a class="header" href="#generative-media-pipeline-forward-looking">Generative Media Pipeline (Forward-Looking)</a></h4>
<p>The sections above describe the LLM generating <em>text</em>: YAML definitions, Lua triggers, briefing scripts, dialogue trees. But the full C&amp;C experience isn’t text — it’s voice-acted briefings, dynamic music, sound effects, and cutscenes. Currently, generative campaigns use existing media assets: game module sound libraries, Workshop music packs, the player’s installed voice collections. A mission briefing is <em>text</em> that the player reads; a radar comm event is a text bubble without voice audio.</p>
<p>AI-generated media — voice synthesis, music generation, sound effect creation, and eventually video/cutscene generation — is advancing rapidly. By the time IC reaches Phase 7, production-quality AI voice synthesis will be mature (it largely is already in 2025–2026), AI music generation is approaching usable quality, and AI video is on a clear trajectory. The generative media pipeline prepares for this without creating obstacles for a media-free fallback.</p>
<p><strong>Core design principle: every generative media feature is a progressive enhancement.</strong> A generative campaign plays identically with or without media generation. Text briefings work. Music from the existing library works. Silent radar comms with text work. When AI media providers are available, they <em>enhance</em> the experience — voiced briefings, custom music, generated sound effects — but nothing <em>depends</em> on them.</p>
<p><strong>Three tiers of generative media (from most ambitious to most conservative):</strong></p>
<p><strong>Tier 1 — Live generation during generative campaigns:</strong></p>
<p>The most ambitious mode. The player is playing a generative campaign. Between missions, during the loading/intermission screen, the system generates media for the next mission in real-time. The player reads the text briefing while voice synthesis runs in the background; when ready, the briefing replays with voice. If voice generation isn’t finished in time, the text-only version is already playing — no delay.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Media Type</th><th>Generation Window</th><th>Fallback (if not ready or unavailable)</th><th>Provider Class</th></tr>
</thead>
<tbody>
<tr><td><strong>Voice lines</strong></td><td>Loading screen / intermission (~15–30s)</td><td>Text-only briefing, text bubble radar comms</td><td>Voice synthesis (ElevenLabs, local TTS, XTTS, Bark, Piper)</td></tr>
<tr><td><strong>Music tracks</strong></td><td>Pre-generated during campaign setup or between missions</td><td>Existing game module soundtrack, Workshop packs</td><td>Music generation (Suno, Udio, MusicGen, local models)</td></tr>
<tr><td><strong>Sound FX</strong></td><td>Pre-generated during mission generation</td><td>Game module default sound library</td><td>Sound generation (AudioGen, Stable Audio, local models)</td></tr>
<tr><td><strong>Cutscenes</strong></td><td>Pre-generated between missions (longer)</td><td>Text+portrait briefing, radar comm text overlay</td><td>Video generation (future — Sora class, Runway, local models)</td></tr>
</tbody>
</table>
</div>
<p><strong>Architecture:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Trait for media generation providers. Same BYOLLM pattern as LlmProvider.
/// Each media type has its own trait — providers are specialized.
pub trait VoiceProvider: Send + Sync {
    /// Generate speech audio from text + voice profile.
    /// Returns audio data in a standard format (WAV/OGG).
    fn synthesize(
        &amp;self,
        text: &amp;str,
        voice_profile: &amp;VoiceProfile,
        options: &amp;VoiceSynthesisOptions,
    ) -&gt; Result&lt;AudioData&gt;;
}

pub trait MusicProvider: Send + Sync {
    /// Generate a music track from mood/style description.
    /// Returns audio data in a standard format.
    fn generate_track(
        &amp;self,
        description: &amp;MusicPrompt,
        duration_secs: f32,
        options: &amp;MusicGenerationOptions,
    ) -&gt; Result&lt;AudioData&gt;;
}

pub trait SoundFxProvider: Send + Sync {
    /// Generate a sound effect from description.
    fn generate_sfx(
        &amp;self,
        description: &amp;str,
        duration_secs: f32,
    ) -&gt; Result&lt;AudioData&gt;;
}

pub trait VideoProvider: Send + Sync {
    /// Generate a video clip from description + character portraits + context.
    fn generate_video(
        &amp;self,
        description: &amp;VideoPrompt,
        options: &amp;VideoGenerationOptions,
    ) -&gt; Result&lt;VideoData&gt;;
}

/// Voice profile for consistent character voices across a campaign.
/// Stored in campaign context alongside CharacterState.
pub struct VoiceProfile {
    /// Character name — links to campaign skeleton character.
    pub character_name: String,
    /// Voice description for the provider (text prompt).
    /// e.g., "Deep male voice, Russian accent, military authority, clipped speech."
    pub voice_description: String,
    /// Provider-specific voice ID (if using a cloned/preset voice).
    pub voice_id: Option&lt;String&gt;,
    /// Reference audio sample (if provider supports voice cloning from sample).
    pub reference_audio: Option&lt;AudioData&gt;,
}
<span class="boring">}</span></code></pre>
<p><strong>Voice consistency model:</strong> The most critical challenge for campaign voice generation is consistency — the same character must sound the same across 24 missions. The <code>VoiceProfile</code> is created during campaign skeleton generation (Step 2) and persisted in <code>GenerativeCampaignContext</code>. The LLM generates the voice description from the character’s personality profile (Principle #20 — a ISTJ commander sounds different from an ESTP commando). If the provider supports voice cloning from a sample, the system generates one calibration line during setup and uses that sample as the reference for all subsequent voice generation. If not, the text description must be consistent enough that the provider produces recognizably similar output.</p>
<p><strong>Music mood integration:</strong> The generation pipeline already produces music playlists with mood tags (combat, tension, ambient, victory). When a <code>MusicProvider</code> is configured, the system can generate mission-specific tracks from these mood tags instead of selecting from existing libraries. The LLM adds mission-specific context to the music prompt: “Tense ambient track for a night infiltration mission in an Arctic setting, building to war drums when combat triggers fire.” Generated tracks are cached in the campaign save — once created, they’re standard audio files.</p>
<p><strong>Tier 2 — Pre-generated campaign (full media creation upfront):</strong></p>
<p>The more conservative mode. The player configures a generative campaign, clicks “Generate Campaign,” and the system creates the entire campaign — all missions, all briefings, all media — before the first mission starts. This takes longer (minutes to hours depending on provider speed and campaign length) but produces a complete, polished campaign package.</p>
<p>This mode is also the <strong>content creator workflow</strong>: a modder or community member generates a campaign, reviews/edits it in the SDK (D038), replaces any weak AI-generated media with hand-crafted alternatives, and publishes the polished result to the Workshop. The AI-generated media is a <em>starting point</em>, not a final product.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Advantage</th><th>Trade-off</th></tr>
</thead>
<tbody>
<tr><td>Complete before play begins</td><td>Long generation time (depends on provider)</td></tr>
<tr><td>All media reviewable in SDK</td><td>Higher API cost (all media generated at once)</td></tr>
<tr><td>Publishable to Workshop as-is</td><td>Less reactive to player choices (media pre-committed, not adaptive)</td></tr>
<tr><td>Can replace weak media by hand</td><td>Requires all providers configured upfront</td></tr>
</tbody>
</table>
</div>
<p><strong>Generation pipeline (extends Step 2 — Campaign Skeleton):</strong></p>
<p>After the campaign skeleton is generated, the media pipeline runs:</p>
<ol>
<li><strong>Voice profiles</strong> — create <code>VoiceProfile</code> for each named character. If voice cloning is supported, generate calibration samples.</li>
<li><strong>All mission briefings</strong> — generate voice audio for every briefing text, every radar comm event, every intermission dialogue line.</li>
<li><strong>Mission music</strong> — generate mood-appropriate tracks for each mission (or select from existing library + generate only gap-filling tracks).</li>
<li><strong>Mission-specific sound FX</strong> — generate any custom sound effects referenced in mission scripts (ambient weather, unique weapon sounds, environmental audio).</li>
<li><strong>Cutscenes</strong> (future) — generate video sequences for mission intros, mid-mission cinematics, campaign intro/outro.</li>
</ol>
<p>Each step is independently skippable — a player might configure voice synthesis but skip music generation, using the game’s built-in soundtrack. The campaign save tracks which media was generated vs. sourced from existing libraries.</p>
<p><strong>Tier 3 — SDK Asset Studio integration:</strong></p>
<p>This tier already exists architecturally (D040 § Layer 3 — Agentic Asset Generation) but currently covers only visual assets (sprites, palettes, terrain, chrome). The generative media pipeline extends the Asset Studio to cover audio and video:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Capability</th><th>Asset Studio Tool</th><th>Provider Trait</th></tr>
</thead>
<tbody>
<tr><td><strong>Voice acting</strong></td><td>Record text → generate voice → preview on timeline → adjust pitch/speed → export .ogg/.wav</td><td><code>VoiceProvider</code></td></tr>
<tr><td><strong>EVA line generation</strong></td><td>Select EVA event type → generate authoritative voice → preview in-game → export to sound library</td><td><code>VoiceProvider</code></td></tr>
<tr><td><strong>Music composition</strong></td><td>Describe mood/style → generate track → preview against gameplay footage → trim/fade → export .ogg</td><td><code>MusicProvider</code></td></tr>
<tr><td><strong>Sound FX design</strong></td><td>Describe effect → generate → preview → layer with existing FX → export .wav</td><td><code>SoundFxProvider</code></td></tr>
<tr><td><strong>Cutscene creation</strong></td><td>Write script → generate video → preview in briefing player → edit → export .mp4/.webm</td><td><code>VideoProvider</code></td></tr>
<tr><td><strong>Voice pack creation</strong></td><td>Define character → generate all voice lines → organize → preview → publish as Workshop voice pack</td><td><code>VoiceProvider</code></td></tr>
</tbody>
</table>
</div>
<p>This is the modder-facing tooling. A modder creating a total conversion can generate an entire voice pack for their custom EVA, unit voice lines for new unit types, ambient music that matches their mod’s theme, and briefing videos — all within the SDK, using the same BYOLLM infrastructure.</p>
<p><strong>Crate boundaries:</strong></p>
<ul>
<li><strong><code>ic-llm</code></strong> — implements all provider traits (<code>VoiceProvider</code>, <code>MusicProvider</code>, <code>SoundFxProvider</code>, <code>VideoProvider</code>). Routes to configured providers via D047 task routing. Handles API communication, format conversion, caching.</li>
<li><strong><code>ic-editor</code></strong> (SDK) — defines the provider traits (same pattern as <code>AssetGenerator</code>). Provides UI for media preview, editing, and export. Tier 3 tools live here.</li>
<li><strong><code>ic-game</code></strong> — wires providers at startup. In generative campaign mode, triggers Tier 1 generation during loading/intermission. Plays generated media through standard <code>ic-audio</code> and video playback systems.</li>
<li><strong><code>ic-audio</code></strong> — plays generated audio identically to pre-existing audio. No awareness of generation source.</li>
</ul>
<p><strong>What the AI does NOT replace:</strong></p>
<ul>
<li><strong>Professional voice acting.</strong> AI voice synthesis is serviceable for procedural content but cannot match a skilled human performance. Hand-crafted campaigns (D021) will always benefit from real voice actors. The AI-generated voice is a first draft, not a final product.</li>
<li><strong>Composed music.</strong> Frank Klepacki’s Hell March was not generated by an algorithm. AI music fills gaps and provides variety; it doesn’t replace composed soundtracks. The game module ships with a human-composed soundtrack; AI supplements it.</li>
<li><strong>Quality judgment.</strong> The modder/player decides if generated media meets their standards. The SDK shows it in context. The Workshop provides a distribution channel for polished results.</li>
</ul>
<p><strong>D047 integration — task routing for media providers:</strong></p>
<p>The LLM Configuration Manager (D047) extends its task routing to include media generation tasks:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Task</th><th>Provider Type</th><th>Typical Routing</th></tr>
</thead>
<tbody>
<tr><td>Mission Generation</td><td><code>LlmProvider</code></td><td>Cloud API (quality)</td></tr>
<tr><td>Campaign Briefings</td><td><code>LlmProvider</code></td><td>Cloud API (quality)</td></tr>
<tr><td>Voice Synthesis</td><td><code>VoiceProvider</code></td><td>ElevenLabs / Local TTS (quality vs. speed trade-off)</td></tr>
<tr><td>Music Generation</td><td><code>MusicProvider</code></td><td>Suno API / Local MusicGen</td></tr>
<tr><td>Sound FX Generation</td><td><code>SoundFxProvider</code></td><td>AudioGen / Stable Audio</td></tr>
<tr><td>Video/Cutscene (future)</td><td><code>VideoProvider</code></td><td>Cloud API (when mature)</td></tr>
<tr><td>Asset Generation (visual)</td><td><code>AssetGenerator</code></td><td>DALL-E / Stable Diffusion / Local</td></tr>
<tr><td>AI Orchestrator</td><td><code>LlmProvider</code></td><td>Local Ollama (fast)</td></tr>
<tr><td>Post-Match Coaching</td><td><code>LlmProvider</code></td><td>Local model (fast)</td></tr>
</tbody>
</table>
</div>
<p>Each media provider type is independently configurable. A player might have voice synthesis (local Piper TTS — free, fast, lower quality) but no music generation. The system adapts: generated missions get voiced briefings but use the existing soundtrack.</p>
<p><strong>Phase:</strong></p>
<ul>
<li><strong>Phase 7:</strong> Voice synthesis integration (<code>VoiceProvider</code> trait, ElevenLabs/Piper/XTTS providers, voice profile system, Tier 1 live generation, Tier 2 pre-generation, Tier 3 SDK voice tools). Voice is the highest-impact media type and the most mature AI capability.</li>
<li><strong>Phase 7:</strong> Music generation integration (<code>MusicProvider</code> trait, Suno/MusicGen providers, mood-to-prompt translation). Lower priority than voice — existing soundtrack provides good coverage.</li>
<li><strong>Phase 7+:</strong> Sound FX generation (<code>SoundFxProvider</code>). Useful but niche — game module sound libraries cover most needs.</li>
<li><strong>Future:</strong> Video/cutscene generation (<code>VideoProvider</code>). Depends on AI video technology maturity. The trait is defined now so the architecture is ready; implementation waits until quality meets the bar. The Asset Studio video pipeline (D040 — .mp4/.webm/.vqa conversion) provides the playback infrastructure.</li>
</ul>
<blockquote>
<p><strong>Architectural note:</strong> The design deliberately separates provider traits by media type rather than using a single unified <code>MediaProvider</code>. Voice, music, sound, and video providers have fundamentally different inputs, outputs, quality curves, and maturity timelines. A player may have excellent voice synthesis available but no music generation at all. Per-type traits and per-type D047 task routing enable this mix-and-match reality. The progressive enhancement principle ensures every combination works — from “no media providers” (text-only, existing assets) to “all providers configured” (fully generated multimedia campaigns).</p>
</blockquote>
<h4 id="saving-replaying-and-sharing"><a class="header" href="#saving-replaying-and-sharing">Saving, Replaying, and Sharing</a></h4>
<p><strong>Campaign library:</strong></p>
<p>Every generative campaign is saved to the player’s local campaign list:</p>
<pre><code>┌──────────────────────────────────────────────────────┐
│  My Campaigns                                         │
│                                                       │
│  📖 Operation Iron Tide          Soviet  24/24  ★★★★  │
│     Generated 2026-02-14  |  Completed  |  18h 42m   │
│  📖 Arctic Vengeance             Allied  12/16  ▶︎    │
│     Generated 2026-02-10  |  In Progress              │
│  📖 Desert Crossroads            Soviet   8/8   ★★★   │
│     Generated 2026-02-08  |  Completed  |  6h 15m    │
│  📕 Red Alert (Hand-crafted)     Soviet  14/14  ★★★★★ │
│     Built-in campaign                                 │
│                                                       │
│  [+ New Generative Campaign]  [Import...]             │
└──────────────────────────────────────────────────────┘
</code></pre>
<ul>
<li><strong>Auto-naming:</strong> The LLM names each campaign at skeleton generation. The player can rename.</li>
<li><strong>Progress tracking:</strong> Shows mission count (played / total), completion status, play time.</li>
<li><strong>Rating:</strong> Player can rate their own campaign (personal quality bookmark).</li>
<li><strong>Resume:</strong> In-progress campaigns resume from the last completed mission. The next mission generates on resume if not already cached.</li>
</ul>
<p><strong>Replayability:</strong></p>
<p>A completed generative campaign is a complete D021 campaign — all 24 missions exist as YAML + Lua + maps. The player (or anyone they share it with) can replay it from the start without an LLM. The campaign graph, all branching paths, and all mission content are materialized. A replayer can take different branches than the original player did, experiencing the missions the original player never saw.</p>
<p><strong>Sharing:</strong></p>
<p>Campaigns are shareable as standard IC campaign packages:</p>
<ul>
<li><strong>Export:</strong> <code>ic campaign export "Operation Iron Tide"</code> → produces a <code>.icpkg</code> campaign package (ZIP with <code>campaign.yaml</code>, mission files, maps, Lua scripts, assets). Same format as any hand-crafted campaign.</li>
<li><strong>Workshop publish:</strong> One-click publish to Workshop (D030). The campaign appears alongside hand-crafted campaigns — there’s no second-class status. Tags indicate “LLM-generated” for discoverability, not segregation.</li>
<li><strong>Import:</strong> Other players install the campaign like any Workshop content. No LLM needed to play.</li>
</ul>
<p><strong>Community refinement:</strong></p>
<p>Shared campaigns are standard IC content — fully editable. Community members can:</p>
<ul>
<li><strong>Open in the Campaign Editor (D038):</strong> See the full mission graph, edit transitions, adjust difficulty, fix LLM-generated rough spots.</li>
<li><strong>Modify missions in the Scenario Editor:</strong> Adjust unit placement, triggers, objectives, terrain. Polish LLM output into hand-crafted quality.</li>
<li><strong>Edit campaign parameters:</strong> The campaign package includes the original <code>CampaignParameters</code> and <code>CampaignSkeleton</code> YAML. A modder can adjust these and re-generate specific missions (if they have an LLM configured), or directly edit the generated output.</li>
<li><strong>Edit inner prompts:</strong> The campaign package preserves the generation prompts used for each mission. A modder can modify these prompts — adjusting tone, adding constraints, changing character behavior — and re-generate specific missions to see different results. This is the “prompt as mod parameter” principle: the LLM instructions are part of the campaign’s editable content, not hidden internals.</li>
<li><strong>Fork and republish:</strong> Take someone’s campaign, improve it, publish as a new version. Standard Workshop versioning applies. Credit the original via Workshop dependency metadata.</li>
</ul>
<p>This creates a <strong>generation → curation → refinement pipeline</strong>: the LLM generates raw material, the community curates the best campaigns (Workshop ratings, downloads), and skilled modders refine them into polished experiences. The LLM is a starting gun, not the finish line.</p>
<h4 id="branching-in-generative-campaigns"><a class="header" href="#branching-in-generative-campaigns">Branching in Generative Campaigns</a></h4>
<p>Branching is central to generative campaigns, not optional. The LLM generates missions with multiple named outcomes (D021), and the player’s choice of outcome drives the next generation.</p>
<p><strong>Within-mission branching:</strong></p>
<p>Each generated mission has 2–4 named outcomes. These aren’t just win/lose — they’re narrative forks:</p>
<ul>
<li>“Victory — civilians evacuated” vs. “Victory — civilians sacrificed for tactical advantage”</li>
<li>“Victory — Volkov survived” vs. “Victory — Volkov killed covering the retreat”</li>
<li>“Defeat — orderly retreat” vs. “Defeat — routed, heavy losses”</li>
</ul>
<p>The LLM generates different outcome descriptions and assigns different story flag effects to each. The next mission is generated based on which outcome the player achieved.</p>
<p><strong>Between-mission branching:</strong></p>
<p>The campaign skeleton includes planned branch points (approximately every 4–6 missions). At these points, the LLM generates 2–3 possible next missions and lets the campaign graph branch. The player’s outcome determines which branch they take — but since missions are generated progressively, the LLM only generates the branch the player actually enters (plus one mission lookahead on the most likely alternate path, for pacing).</p>
<p><strong>Branch convergence:</strong></p>
<p>Not every branch diverges permanently. The LLM’s skeleton includes convergence points — moments where different paths lead to the same narrative beat (e.g., “regardless of which route you took, the final assault on Berlin begins”). This prevents the campaign from sprawling into an unmanageable tree. The skeleton’s act structure naturally creates convergence: all Act 1 paths converge at the Act 2 opening, all Act 2 paths converge at the climax.</p>
<p><strong>Why branching matters even with LLM generation:</strong></p>
<p>One might argue that since the LLM generates each mission dynamically, branching is unnecessary — just generate whatever comes next. But branching serves a critical purpose: <strong>the generated campaign must be replayable without an LLM.</strong> Once materialized, the campaign graph must contain the branches the player <em>didn’t</em> take too, so a replayer (or the same player on a second playthrough) can explore alternate paths. The LLM generates branches ahead of time. Progressive generation generates the branches as they become relevant — not all 24 missions on day one, but also not waiting until the player finishes mission 7 to generate mission 8’s alternatives.</p>
<h4 id="campaign-event-patterns"><a class="header" href="#campaign-event-patterns">Campaign Event Patterns</a></h4>
<p>The LLM doesn’t just generate “attack this base” missions in sequence. It draws from a vocabulary of <strong>dramatic event patterns</strong> — narrative structures inspired by the C&amp;C franchise’s most memorable campaign moments and classic military fiction. These patterns are documented in the system prompt so the LLM has a rich palette to paint from.</p>
<p>The LLM chooses when and how to deploy these patterns based on the campaign context, battle reports, character states, and narrative pacing. None are scripted in advance — they emerge from the interplay of the player’s actions and the LLM’s storytelling.</p>
<p><strong>Betrayal &amp; defection patterns:</strong></p>
<ul>
<li><strong>The backstab.</strong> A trusted ally — an intelligence officer, a fellow commander, a political advisor — switches sides mid-campaign. The turn is foreshadowed in briefings (the LLM plants hints over 2–3 missions: contradictory intel, suspicious absences, intercepted communications), then triggered by a story flag or a player decision. Inspired by: Nadia poisoning Stalin (RA1), Yuri’s betrayal (RA2).</li>
<li><strong>Defection offer.</strong> An enemy commander, impressed by the player’s performance or disillusioned with their own side, secretly offers to defect. The player must decide: accept (gaining intelligence + units but risking a double agent) or refuse. The LLM uses the <code>relationship_to_player</code> score from battle reports — if the player spared enemy forces in previous missions, defection becomes plausible.</li>
<li><strong>Loyalty erosion.</strong> A character’s <code>loyalty</code> score drops based on player actions: sacrificing troops carelessly, ignoring a character’s advice repeatedly, making morally questionable choices. When loyalty drops below a threshold, the LLM generates a confrontation mission — the character either leaves, turns hostile, or issues an ultimatum.</li>
<li><strong>The double agent.</strong> A rescued prisoner, a defector from the enemy, a “helpful” neutral — someone the player trusted turns out to be feeding intelligence to the other side. The reveal comes when the player notices the enemy is always prepared for their strategies (the LLM has been describing suspiciously well-prepared enemies for several missions).</li>
</ul>
<p><strong>Rogue faction patterns:</strong></p>
<ul>
<li><strong>Splinter group.</strong> Part of the player’s own faction breaks away — a rogue general forms a splinter army, or a political faction seizes a province and declares independence. The player must fight former allies with the same unit types and tactics. Inspired by: Yuri’s army splitting from the Soviets (RA2), rogue Soviet generals in RA1.</li>
<li><strong>Third-party emergence.</strong> A faction that didn’t exist at campaign start appears mid-campaign: a resistance movement, a mercenary army, a scientific cult with experimental weapons. The LLM introduces them as a complication — sometimes an optional ally, sometimes an enemy, sometimes both at different times.</li>
<li><strong>Warlord territory.</strong> In open-ended campaigns, regions not controlled by either main faction become warlord territories — autonomous zones with their own mini-armies and demands. The LLM generates negotiation or conquest missions for these zones.</li>
</ul>
<p><strong>Plot twist patterns:</strong></p>
<ul>
<li><strong>Secret weapon reveal.</strong> The enemy unveils a devastating new technology: a superweapon, an experimental unit, a weaponized chronosphere. The LLM builds toward the reveal (intelligence fragments over 2–3 missions), then the player faces it in a desperate defense mission. Follow-up missions involve stealing or destroying it.</li>
<li><strong>True enemy reveal.</strong> The faction the player has been fighting isn’t the real threat. A larger power has been manipulating both sides. The campaign pivots to a temporary alliance with the former enemy against the true threat. Inspired by: RA2 Yuri’s Revenge (Allies and Soviets team up against Yuri).</li>
<li><strong>The war was a lie.</strong> The player’s own command has been giving false intelligence. The “enemy base” the player destroyed in mission 5 was a civilian research facility. The “war hero” the player is protecting is a war criminal. Moral complexity emerges from the campaign’s own history, not from a pre-written script.</li>
<li><strong>Time pressure crisis.</strong> A countdown starts: nuclear launch, superweapon charging, allied capital about to fall. The next 2–3 missions are a race against time, each one clearing a prerequisite for the final mission (destroy the radar, capture the codes, reach the launch site). The LLM paces this urgently — short missions, high stakes, no breathers.</li>
</ul>
<p><strong>Force dynamics patterns:</strong></p>
<ul>
<li><strong>Army to resistance.</strong> After a catastrophic loss, the player’s conventional army is shattered. The campaign genre shifts: smaller forces, guerrilla objectives (sabotage, assassination, intelligence gathering), no base building. The LLM generates this naturally when the battle report shows heavy losses. Rebuilding over subsequent missions gradually restores conventional operations.</li>
<li><strong>Underdog to superpower.</strong> The inverse: the player starts with a small force and grows mission by mission. The LLM scales enemy composition accordingly, and the tone shifts from desperate survival to strategic dominance. Late-campaign missions are large-scale assaults the player couldn’t have dreamed of in mission 2.</li>
<li><strong>Siege / last stand.</strong> The player must hold a critical position against overwhelming odds. Reinforcement timing is the drama — will they arrive? The LLM generates increasingly desperate defensive waves, with the outcome determining whether the campaign continues as a retreat or a counter-attack.</li>
<li><strong>Behind enemy lines.</strong> A commando mission deep in enemy territory with a small, hand-picked squad. No reinforcements, no base, limited resources. Named characters shine here. Inspired by: virtually every Tanya mission in the RA franchise.</li>
</ul>
<p><strong>Character-driven patterns:</strong></p>
<ul>
<li><strong>Rescue the captured.</strong> A named character is captured during a mission (or between missions, as a narrative event). The player faces a choice: launch a risky rescue operation, negotiate a prisoner exchange (giving up tactical advantage), or abandon them (with loyalty consequences for other characters). A rescued character returns with changed traits — traumatized, radicalized, or more loyal than ever.</li>
<li><strong>Rival commander.</strong> The LLM develops a specific enemy commander as the player’s nemesis. This character appears in briefings, taunts the player after defeats, acts surprised after losses. The rivalry develops over 5–10 missions before the final confrontation. The enemy commander reacts to the player’s tactics: if the player favors air power, the rival starts deploying heavy AA and mocking the strategy.</li>
<li><strong>Mentor’s fall.</strong> An experienced commander who guided the player in early missions is killed, goes MIA, or turns traitor. The player must continue without their guidance — the tone shifts from “following orders” to “making hard calls alone.”</li>
<li><strong>Character return.</strong> A character thought dead or MIA resurfaces — changed. An MIA character returns with intelligence gained during capture. A “dead” character survived and is now leading a resistance cell. A defected character has second thoughts. The LLM tracks <code>CharacterStatus::MIA</code> and <code>CharacterStatus::Dead</code> and can reverse them with narrative justification.</li>
</ul>
<p><strong>Diplomatic &amp; political patterns:</strong></p>
<ul>
<li><strong>Temporary alliance.</strong> The player’s faction and the enemy faction must cooperate against a common threat (rogue faction, third-party invasion, natural disaster). Missions feature mixed unit control — the player commands some enemy units. Trust is fragile; the alliance may end in betrayal.</li>
<li><strong>Ceasefire and cold war.</strong> Fighting pauses for 2–3 missions while the LLM generates espionage, infiltration, and political maneuvering missions. The player builds up forces during the ceasefire, knowing combat will resume. When and how it resumes depends on the player’s actions during the ceasefire.</li>
<li><strong>Civilian dynamics.</strong> Missions where civilians matter: evacuate a city before a bombing, protect a refugee convoy, decide whether to commandeer civilian infrastructure. The player’s treatment of civilians affects the campaign’s politics — a player who protects civilians gains partisan support; one who sacrifices them faces insurgencies on their own territory.</li>
</ul>
<p>These patterns are examples, not an exhaustive list. The LLM’s system prompt includes them as inspiration. The LLM can also invent novel patterns that don’t fit these categories — the constraint is that every event must produce standard D021 missions and respect the campaign’s current state, not that every event must match a template.</p>
<h4 id="open-ended-campaigns"><a class="header" href="#open-ended-campaigns">Open-Ended Campaigns</a></h4>
<p>Fixed-length campaigns (8, 16, 24 missions) suit players who want a structured experience. But the most interesting generative campaigns may be <strong>open-ended</strong> — where the campaign continues until victory conditions are met, and the LLM determines the pacing.</p>
<p><strong>How open-ended campaigns work:</strong></p>
<p>Instead of “generate 24 missions,” the player defines <strong>victory conditions</strong> — a set of goals that, when achieved, trigger the campaign finale:</p>
<pre><code class="language-yaml">victory_conditions:
  # Any ONE of these triggers the final mission sequence
  - type: eliminate_character
    target: "General Morrison"
    description: "Hunt down and eliminate the Allied Supreme Commander"
  - type: capture_locations
    targets: ["London", "Paris", "Washington"]
    description: "Capture all three Allied capitals"
  - type: survival
    missions: 30
    description: "Survive 30 missions against escalating odds"

# Optional: defeat conditions that end the campaign in failure
defeat_conditions:
  - type: roster_depleted
    threshold: 0       # lose all named characters
    description: "All commanders killed — the war is lost"
  - type: lose_streak
    count: 3
    description: "Three consecutive mission failures — command is relieved"
</code></pre>
<p>The LLM sees these conditions and works toward them narratively. It doesn’t just generate missions until the player happens to kill Morrison — it builds a story arc where Morrison is an escalating threat, intelligence about his location is gathered over missions, near-misses create tension, and the final confrontation feels earned.</p>
<p><strong>Dynamic narrative shifts:</strong></p>
<p>Open-ended campaigns enable dramatic genre shifts that fixed-length campaigns can’t. The LLM inspects the battle report and can pivot the entire campaign direction:</p>
<ul>
<li><strong>Army → Resistance.</strong> The player starts with a full division. After a devastating defeat in mission 8, they lose most forces. The LLM generates mission 9 as a guerrilla operation — small squad, no base building, ambush tactics, sabotage objectives. The campaign has organically shifted from conventional warfare to an insurgency. If the player rebuilds over the next few missions, it shifts back.</li>
<li><strong>Hunter → Hunted.</strong> The player is pursuing a VIP target. The VIP escapes repeatedly. The LLM decides the VIP has learned the player’s tactics and launches a counter-offensive. Now the player is defending against an enemy who knows their weaknesses.</li>
<li><strong>Rising power → Civil war.</strong> The player’s faction is winning the war. Political factions within their own side start competing for control. The LLM introduces betrayal missions where the player fights former allies.</li>
<li><strong>Conventional → Desperate.</strong> Resources dry up. Supply lines are cut. The LLM generates missions with scarce starting resources, forcing the player to capture enemy supplies or scavenge the battlefield.</li>
</ul>
<p>These shifts emerge naturally from the battle reports. The LLM doesn’t follow a script — it reads the game state and decides what makes a good story.</p>
<p><strong>Escalation mechanics:</strong></p>
<p>In open-ended campaigns, the enemy isn’t static. The LLM uses a concept of <strong>enemy adaptation</strong> — the longer the campaign runs, the more the enemy evolves:</p>
<ul>
<li><strong>VIP escalation.</strong> A fleeing VIP gains experience and resources the longer they survive. Early missions to catch them are straightforward pursuits. By mission 15, the VIP has fortified a stronghold, recruited allies, and developed counter-strategies. The difficulty curve is driven by the narrative, not a slider.</li>
<li><strong>Enemy learning.</strong> The LLM tracks what strategies the player uses (from battle reports) and has the enemy adapt. Player loves tank rushes? The enemy starts mining approaches and building anti-armor defenses. Player relies on air power? The enemy invests in AA.</li>
<li><strong>Resource escalation.</strong> Both sides grow over the campaign. Early missions are skirmishes. Late missions are full-scale battles. The LLM scales force composition to match the campaign’s progression.</li>
<li><strong>Alliance shifts.</strong> Neutral factions that appeared in early missions may become allies or enemies based on the player’s choices. The political landscape evolves.</li>
</ul>
<p><strong>How the LLM decides “it’s time for the finale”:</strong></p>
<p>The LLM doesn’t just check <code>if conditions_met { generate_finale(); }</code>. It builds toward the conclusion:</p>
<ol>
<li><strong>Sensing readiness.</strong> The LLM evaluates whether the player’s current roster, position, and narrative momentum make a finale satisfying. If the player barely survived the last mission, the finale waits — a recovery mission first.</li>
<li><strong>Creating the opportunity.</strong> When conditions are approaching (the player has captured 2/3 capitals, Morrison’s location is almost known), the LLM generates missions that create the <em>opportunity</em> for the final push — intelligence missions, staging operations, securing supply lines.</li>
<li><strong>The finale sequence.</strong> The final mission (or final 2–3 missions) are generated as a climactic arc, not a single mission. The LLM knows these are the last ones and gives them appropriate weight — cutscene-worthy briefings, all surviving named characters present, callbacks to early campaign events.</li>
<li><strong>Earning the ending.</strong> The campaign length is indeterminate but not infinite. The LLM aims for a satisfying arc — typically 15–40 missions depending on the victory conditions. If the campaign has gone on “too long” without progress toward victory (the player keeps failing to advance), the LLM introduces narrative catalysts: an unexpected ally, a turning point event, or a vulnerability in the enemy’s position.</li>
</ol>
<p><strong>Open-ended campaign identity:</strong></p>
<p>What makes open-ended campaigns distinct from fixed-length ones:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Fixed-length (24 missions)</th><th>Open-ended</th></tr>
</thead>
<tbody>
<tr><td><strong>End condition</strong></td><td>Mission count reached</td><td>Victory conditions met</td></tr>
<tr><td><strong>Skeleton</strong></td><td>Full arc planned upfront</td><td>Backstory + conditions + characters; arc emerges</td></tr>
<tr><td><strong>Pacing</strong></td><td>LLM knows position in arc (mission 8/24)</td><td>LLM estimates narrative momentum</td></tr>
<tr><td><strong>Narrative shifts</strong></td><td>Planned at branch points</td><td>Emerge from battle reports</td></tr>
<tr><td><strong>Difficulty</strong></td><td>Follows configured curve</td><td>Driven by enemy adaptation + player state</td></tr>
<tr><td><strong>Replayability</strong></td><td>Take different branches</td><td>Entirely different campaign length and arc</td></tr>
<tr><td><strong>Typical length</strong></td><td>Exactly as configured</td><td>15–40 missions (emergent)</td></tr>
</tbody>
</table>
</div>
<p>Both modes produce standard D021 campaigns. Both are saveable, shareable, and replayable without an LLM. The difference is in how much creative control the LLM exercises during generation.</p>
<h4 id="world-domination-campaign"><a class="header" href="#world-domination-campaign">World Domination Campaign</a></h4>
<p>A third generative campaign mode — distinct from both fixed-length narrative campaigns and open-ended condition-based campaigns. <strong>World Domination</strong> is an LLM-driven narrative campaign where the story plays out across a world map. The LLM is the narrative director — it generates missions, drives the story, and decides what happens next based on the player’s real-time battle results. The world map is the visualization: territory expands when you win, contracts when you lose, and shifts when the narrative demands it.</p>
<p>This is the mode where the campaign <em>is</em> the map.</p>
<p><strong>How it works:</strong></p>
<p>The player starts in a region — say, Greece — and fights toward a goal: conquer Europe, defend the homeland, push west to the Atlantic. The LLM generates each mission based on where the player stands on the map, what happened in previous battles, and where the narrative is heading. The player doesn’t pick targets from a strategy menu — the LLM presents the next mission (or a choice between missions) based on the story it’s building.</p>
<p>After each RTS battle, the results feed back to the LLM. Won decisively? Territory advances. Lost badly? The enemy pushes into your territory. But it’s not purely mechanical — the LLM controls the narrative arc. Maybe you lose three missions in a row, your territory shrinks, things look dire — and then the LLM introduces a turning point: your engineers develop a new weapon, a neutral faction joins your side, a storm destroys the enemy’s supply lines. Or maybe there’s no rescue — you simply lose. The LLM decides based on accumulated battle results, the story it’s been building, and the dramatic pacing.</p>
<pre><code class="language-yaml"># World Domination campaign setup (extends standard CampaignParameters)
world_domination:
  map: "europe_1953"                  # world map asset (see World Map Assets below)
  starting_region: "athens"           # where the player's campaign begins
  factions:
    - id: soviet
      name: "Soviet Union"
      color: "#CC0000"
      starting_regions: ["moscow", "leningrad", "stalingrad", "kiev", "minsk"]
      ai_personality: null             # player-controlled
    - id: allied
      name: "Allied Forces"
      color: "#0044CC"
      starting_regions: ["london", "paris", "washington", "rome", "berlin"]
      ai_personality: "strategic"      # AI-controlled (D043 preset)
    - id: neutral
      name: "Neutral States"
      color: "#888888"
      starting_regions: ["stockholm", "bern", "ankara", "cairo"]
      ai_personality: "defensive"      # defends territory, doesn't expand
  
  # The LLM decides when and how the campaign ends — these are hints, not hard rules.
  # The LLM may end the campaign with a climactic finale at 60% control, or let 
  # the player push to 90% if the narrative supports it.
  narrative_hints:
    goal_direction: west               # general direction of conquest (flavor for LLM)
    domination_target: "Europe"        # what "winning" means narratively
    tone: military_drama              # narrative tone: military_drama, pulp, dark, heroic
</code></pre>
<p><strong>The campaign loop:</strong></p>
<pre><code>┌────────────────────────────────────────────────────────────────┐
│                    World Domination Loop                        │
│                                                                │
│  1. VIEW WORLD MAP                                             │
│     ├── See your territory, enemy territory, contested zones   │
│     ├── See the frontline — where your campaign stands         │
│     └── See the narrative state (briefing, intel, context)     │
│                                                                │
│  2. LLM PRESENTS NEXT MISSION                                  │
│     ├── Based on current frontline and strategic situation      │
│     ├── Based on accumulated battle results and player actions  │
│     ├── Based on narrative arc (pacing, tension, stakes)        │
│     ├── May offer a choice: "Attack Crete or reinforce Athens?" │
│     └── May force a scenario: "Enemy launches surprise attack!" │
│                                                                │
│  3. PLAY RTS MISSION (standard IC gameplay)                    │
│     └── Full real-time battle — this is the game                │
│                                                                │
│  4. RESULTS FEED BACK TO LLM                                   │
│     ├── Battle outcome (victory, defeat, pyrrhic, decisive)    │
│     ├── Casualties, surviving units, player tactics used        │
│     ├── Objectives completed or failed                         │
│     └── Time taken, resources spent, player style               │
│                                                                │
│  5. LLM UPDATES THE WORLD                                      │
│     ├── Territory changes (advance, retreat, or hold)           │
│     ├── Narrative consequences (new allies, betrayals, tech)    │
│     ├── Story progression (turning points, escalation, arcs)   │
│     └── May introduce recovery or setback events               │
│                                                                │
│  6. GOTO 1                                                     │
└────────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>Region properties:</strong></p>
<p>Each region on the world map has strategic properties that affect mission generation:</p>
<pre><code class="language-yaml">regions:
  berlin:
    display_name: "Berlin"
    terrain_type: urban              # affects generated map terrain
    climate: temperate               # affects weather (D022)
    resource_value: 3                # economic importance (LLM considers for narrative weight)
    fortification: heavy             # affects defender advantage
    population: civilian_heavy       # affects civilian presence in missions
    adjacent: ["warsaw", "prague", "hamburg", "munich"]
    special_features:
      - type: factory_complex        # bonus: faster unit production
      - type: airfield               # bonus: air support in adjacent battles
    strategic_importance: critical    # LLM emphasizes this in narrative

  arctic_outpost:
    display_name: "Arctic Research Station"
    terrain_type: arctic
    climate: arctic
    resource_value: 1
    fortification: light
    population: minimal
    adjacent: ["murmansk", "arctic_sea"]
    special_features:
      - type: research_lab           # bonus: unlocks special units/tech
    strategic_importance: moderate
</code></pre>
<p><strong>Progress and regression:</strong></p>
<p>The world map is not a one-way march to victory. The LLM drives territory changes based on battle outcomes <em>and</em> narrative arc:</p>
<ul>
<li><strong>Win a mission</strong> → territory typically advances. The LLM decides how much — a minor victory might push one region forward, a decisive rout might cascade into capturing two or three.</li>
<li><strong>Lose a mission</strong> → the enemy pushes in. The LLM decides the severity — a narrow loss might mean holding the line but losing influence, while a collapse means the enemy sweeps through multiple regions.</li>
<li><strong>Pyrrhic victory</strong> → you won, but at what cost? The LLM might advance your territory but weaken your forces so severely that the next mission is a desperate defense.</li>
</ul>
<p>But it’s not a mechanical formula. The LLM is a <strong>narrative director</strong>, not a spreadsheet. It mixes battle results with story:</p>
<ul>
<li><strong>Recovery arcs:</strong> You’ve lost three missions. Your territory has shrunk to a handful of regions. Things look hopeless — and then the LLM introduces a breakthrough. Maybe your engineers develop a new superweapon. Maybe a neutral faction defects to your side. Maybe a brutal winter slows the enemy advance and buys you time. The recovery feels earned because it follows real setbacks.</li>
<li><strong>Deus ex machina:</strong> Rarely, the LLM creates a dramatic reversal — an earthquake destroys the enemy’s main base, a rogue commander switches sides, an intelligence coup reveals the enemy’s plans. These are narratively justified and infrequent enough to feel special.</li>
<li><strong>Escalation:</strong> You’re winning too easily? The LLM introduces complications — a second front opens, the enemy deploys experimental weapons, an ally betrays you. The world map shifts to reflect the new threat.</li>
<li><strong>Inevitable defeat:</strong> Sometimes there’s no rescue. If the player keeps losing badly and the narrative can’t credibly save them, the campaign ends in defeat. The LLM builds to a dramatic conclusion — a last stand, a desperate evacuation, a bitter retreat — rather than just showing “Game Over.”</li>
</ul>
<p>The key insight: <strong>the player’s agency is in the RTS battles.</strong> How well you fight determines the raw material the LLM works with. Win well and consistently, and the narrative carries you forward. Fight poorly, and the LLM builds a story of struggle and potential collapse. But the LLM always has latitude to shape the pacing — it’s telling a war story, not just calculating territory percentages.</p>
<p><strong>Force persistence across the map:</strong></p>
<p>Units aren’t disposable between battles. The world domination mode uses a <strong>per-region force pool</strong>:</p>
<ul>
<li>Each region the player controls has a garrison (force pool). The player deploys from these forces when attacking from or defending that region.</li>
<li>Casualties in battle reduce the garrison. Reinforcements arrive as the narrative progresses (based on controlled factories, resource income, and narrative events).</li>
<li>Veteran units from previous battles remain — a region with battle-hardened veterans is harder to defeat than one with fresh recruits.</li>
<li>Named characters (D038 Named Characters) can be assigned to regions. Moving them to a front gives bonuses but risks their death.</li>
<li>D021’s roster persistence and carryover apply within the campaign — the “roster” is the regional garrison.</li>
</ul>
<p><strong>Mission generation from campaign state:</strong></p>
<p>The LLM generates each mission from the <strong>strategic situation</strong> — it’s not picking from a random pool, it’s reading the state of the world and crafting a battle that makes sense:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Input</th><th>How it affects the mission</th></tr>
</thead>
<tbody>
<tr><td><strong>Region terrain type</strong></td><td>Map terrain (urban streets, arctic tundra, rural farmland, desert, mountain pass)</td></tr>
<tr><td><strong>Attacker’s force pool</strong></td><td>Player’s starting units (drawn from the garrison)</td></tr>
<tr><td><strong>Defender’s force pool</strong></td><td>Enemy’s garrison strength (affects enemy unit count and quality)</td></tr>
<tr><td><strong>Fortification level</strong></td><td>Defender gets pre-built structures, mines, walls</td></tr>
<tr><td><strong>Campaign progression</strong></td><td>Tech level escalation — later in the campaign unlocks higher-tier units</td></tr>
<tr><td><strong>Adjacent region bonuses</strong></td><td>Airfield = air support; factory = reinforcements mid-mission; radar = revealed shroud</td></tr>
<tr><td><strong>Special features</strong></td><td>Research lab = experimental units; port = naval elements</td></tr>
<tr><td><strong>Battle history</strong></td><td>Regions fought over multiple times get war-torn terrain (destroyed buildings, craters)</td></tr>
<tr><td><strong>Narrative arc</strong></td><td>Briefing, character dialogue, story events, turning points, named objectives</td></tr>
<tr><td><strong>Player battle results</strong></td><td>Previous performance shapes difficulty, tone, and stakes of the next mission</td></tr>
</tbody>
</table>
</div>
<p>Without an LLM, missions are generated from <strong>templates</strong> — the system picks a template matching the terrain type and action type (urban assault, rural defense, naval landing, etc.) and populates it with forces from the strategic state. With an LLM, the missions are crafted: the briefing tells a story, characters react to what you did last mission, the objectives reflect the narrative the LLM is building.</p>
<p><strong>The world map between missions:</strong></p>
<p>Between missions, the player sees the world map — the D038 World Map intermission template, elevated into the primary campaign interface. The map shows the story so far: where you’ve been, what you control, and where the narrative is taking you next.</p>
<pre><code>┌────────────────────────────────────────────────────────────────────────┐
│  WORLD DOMINATION — Operation Iron Tide          Mission 14  Soviet   │
│                                                                        │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │                                                                │    │
│  │           ██ MURMANSK                                          │    │
│  │          ░░░░                                                  │    │
│  │    ██ STOCKHOLM    ██ LENINGRAD                                │    │
│  │      ░░░░░        ████████                                     │    │
│  │  ▓▓ LONDON    ▓▓ BERLIN   ██ MOSCOW    Legend:                 │    │
│  │  ▓▓▓▓▓▓▓▓   ░░░░░░░░   ████████████   ██ Soviet (You)        │    │
│  │  ▓▓ PARIS    ▓▓ PRAGUE   ██ KIEV       ▓▓ Allied (Enemy)      │    │
│  │  ▓▓▓▓▓▓▓▓   ░░ VIENNA   ██ STALINGRAD ░░ Contested           │    │
│  │  ▓▓ ROME     ░░ BUDAPEST ██ MINSK      ▒▒ Neutral             │    │
│  │              ▒▒ ISTANBUL                                       │    │
│  │              ▒▒ CAIRO                                          │    │
│  │                                                                │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                        │
│  Territory: 12/28 regions (43%)                                        │
│                                                                        │
│  ┌─ BRIEFING ────────────────────────────────────────────────────┐    │
│  │  General Volkov has ordered an advance into Central Europe.   │    │
│  │  Berlin is contested — Allied forces are dug in. Our victory  │    │
│  │  at Warsaw has opened the road west, but intelligence reports │    │
│  │  a counterattack forming from Hamburg.                        │    │
│  │                                                                │    │
│  │  "We push now, or we lose the initiative." — Col. Petrov      │    │
│  └───────────────────────────────────────────────────────────────┘    │
│                                                                        │
│  [BEGIN MISSION: Battle for Berlin]                  [Save &amp; Quit]    │
└────────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>The map is the campaign. The player sees their progress and regression at a glance — territory expanding and contracting as the war ebbs and flows. The LLM presents the next mission through narrative briefing, not through a strategy game menu. Sometimes the LLM offers a choice (“Reinforce the eastern front or press the western advance?”) — but the choices are narrative, not board-game actions.</p>
<p><strong>Comparison to narrative campaigns:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Narrative Campaign (fixed/open-ended)</th><th>World Domination</th></tr>
</thead>
<tbody>
<tr><td><strong>Structure</strong></td><td>Linear/branching mission graph</td><td>LLM-driven narrative across a world map</td></tr>
<tr><td><strong>Mission order</strong></td><td>Determined by story arc</td><td>Determined by LLM based on map state + results</td></tr>
<tr><td><strong>Progress model</strong></td><td>Mission completion advances the story</td><td>Territory changes visualize campaign progress</td></tr>
<tr><td><strong>Regression</strong></td><td>Rarely (defeat branches to different path)</td><td>Frequent — battles lost = territory lost</td></tr>
<tr><td><strong>Recovery</strong></td><td>Fixed by story branches</td><td>LLM-driven: new tech, allies, events, or defeat</td></tr>
<tr><td><strong>Player agency</strong></td><td>Choose outcomes within missions</td><td>Fight well in RTS battles; LLM shapes consequences</td></tr>
<tr><td><strong>LLM role</strong></td><td>Story arc, characters, narrative pacing</td><td>Narrative director — drives the entire campaign</td></tr>
<tr><td><strong>Without LLM</strong></td><td>Requires shared/imported campaign</td><td>Playable with templates (loses narrative richness)</td></tr>
<tr><td><strong>Replayability</strong></td><td>Different branches</td><td>Different narrative every time</td></tr>
<tr><td><strong>Inspired by</strong></td><td>C&amp;C campaign structure + Total War</td><td>C&amp;C campaign feel + dynamic world map</td></tr>
</tbody>
</table>
</div>
<p><strong>World domination without LLM:</strong></p>
<p>World Domination is <strong>playable without an LLM</strong>, though it loses its defining feature. Without the LLM, the system falls back to template-generated missions — pick a template matching the terrain and action type, populate it with forces from the strategic state. Territory advances/retreats follow mechanical rules (win = advance, lose = retreat) instead of narrative-driven pacing. There are no recovery arcs, no turning points, no deus ex machina — just a deterministic strategic layer. It still works as a campaign, but it’s closer to a Risk-style conquest game than the narrative experience the LLM provides. The LLM is what makes World Domination feel like a <em>war story</em> rather than a <em>board game</em>.</p>
<p><strong>Strategic AI for non-player factions (no-LLM fallback):</strong></p>
<p>When the LLM drives the campaign, non-player factions behave according to the narrative — the LLM decides when and where the enemy attacks, retreats, or introduces surprises. Without an LLM, a mechanical <strong>strategic AI</strong> controls non-player faction behavior on the world map:</p>
<ul>
<li>Each AI faction has an <code>ai_personality</code> (D043 preset): <code>aggressive</code> (expands toward player), <code>defensive</code> (holds territory, counter-attacks only), <code>opportunistic</code> (attacks weakened regions), <code>strategic</code> (balances expansion and defense).</li>
<li>The AI evaluates regions by adjacency, garrison strength, and strategic importance. It prioritizes attacking weak borders and reinforcing threatened ones.</li>
<li>If the player pushes hard on one front, the AI opens a second front on an undefended border — simple but effective strategic pressure.</li>
<li>The AI’s behavior is deterministic given the campaign state, ensuring consistent replay behavior.</li>
</ul>
<p>This strategic AI is separate from the tactical RTS AI (D043) — it operates on the world map layer, not within individual missions. The tactical AI still controls enemy units during RTS battles.</p>
<h4 id="world-map-assets"><a class="header" href="#world-map-assets">World Map Assets</a></h4>
<p>World maps are <strong>game-module-provided and moddable assets</strong> — not hardcoded. A world map can represent anything: Cold War Europe, the entire globe, a fictional continent, an alien planet, a galactic star map, a subway network — whatever fits the game or mod. The engine doesn’t care what the map <em>is</em>, only that it has regions with connections. Each game module ships with default world maps, and modders can create their own for any setting they imagine.</p>
<p><strong>World map definition:</strong></p>
<pre><code class="language-yaml"># World map asset — shipped with the game module or created by modders
world_map:
  id: "europe_1953"
  display_name: "Europe 1953"
  game_module: red_alert              # which game module this map is for
  
  # Visual asset — the actual map image
  # Supports multiple render modes (D048): sprite, vector, or 3D globe
  visual:
    base_image: "maps/world/europe_1953.png"    # background image
    region_overlays: "maps/world/europe_1953_regions.png"  # color-coded regions
    faction_colors: true                         # color regions by controlling faction
    animation: frontline_glow                    # animated frontlines between factions
  
  # Region definitions (see region YAML above)
  regions:
    # ... region definitions with adjacency, terrain, resources, etc.
  
  # Starting configurations (selectable in setup)
  scenarios:
    - id: "cold_war_heats_up"
      description: "Classical East vs. West. Soviets hold Eastern Europe, Allies hold the West."
      faction_assignments:
        soviet: ["moscow", "leningrad", "stalingrad", "kiev", "minsk", "warsaw"]
        allied: ["london", "paris", "rome", "berlin", "madrid"]
        neutral: ["stockholm", "bern", "ankara", "cairo", "istanbul"]
    - id: "last_stand"
      description: "Soviets control most of Europe. Allies hold only Britain and France."
      faction_assignments:
        soviet: ["moscow", "leningrad", "stalingrad", "kiev", "minsk", "warsaw", "berlin", "prague", "vienna", "budapest", "rome"]
        allied: ["london", "paris"]
        neutral: ["stockholm", "bern", "ankara", "cairo", "istanbul"]
</code></pre>
<p><strong>Game-module world maps:</strong></p>
<p>Each game module provides at least one default world map:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Game module</th><th>Default world map</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Red Alert</td><td><code>europe_1953</code></td><td>Cold War Europe — Soviets vs. Allies</td></tr>
<tr><td>Tiberian Dawn</td><td><code>gdi_nod_global</code></td><td>Global map — GDI vs. Nod, Tiberium spread zones</td></tr>
<tr><td>(Community)</td><td>Anything</td><td>The map is whatever the modder wants it to be</td></tr>
</tbody>
</table>
</div>
<p>Community world map examples (the kind of thing modders could create):</p>
<ul>
<li><strong>Pacific Theater</strong> — island-hopping across the Pacific; naval-heavy campaigns</li>
<li><strong>Entire globe</strong> — six continents, dozens of regions, full world war</li>
<li><strong>Fictional continent</strong> — Westeros, Middle-earth, or an original fantasy setting</li>
<li><strong>Galactic star map</strong> — planets as regions, fleets as garrisons, a sci-fi total conversion</li>
<li><strong>Single city</strong> — district-by-district urban warfare; each “region” is a city block or neighborhood</li>
<li><strong>Underground network</strong> — cavern systems, bunker complexes, tunnel connections</li>
<li><strong>Alternate history</strong> — what if the Roman Empire never fell? What if the Cold War went hot in 1962?</li>
<li><strong>Abstract/non-geographic</strong> — a network of space stations, a corporate org chart, whatever the mod needs</li>
</ul>
<p>The world map is a YAML + image asset, loadable from any source: game module defaults, Workshop (D030), or local mod folders. The Campaign Editor (D038) includes a world map editor for creating and editing regions, adjacencies, and starting scenarios.</p>
<p><strong>World maps as Workshop resources:</strong></p>
<p>World maps are a first-class Workshop resource category (<code>category: world-map</code>). This makes them discoverable, installable, version-tracked, and composable like any other Workshop content:</p>
<pre><code class="language-yaml"># Workshop manifest for a world map package
package:
  name: "galactic-conquest-map"
  publisher: "scifi-modding-collective"
  version: "2.1.0"
  license: "CC-BY-SA-4.0"
  description: "A 40-region galactic star map for sci-fi total conversions"
  category: world-map
  game_module: any                     # or a specific module
  engine_version: "^0.3.0"
  
  tags: ["sci-fi", "galactic", "space", "large"]
  ai_usage: allow                       # LLM can select this map for generated campaigns
  
  dependencies:
    - id: "scifi-modding-collective/space-faction-pack"
      version: "^1.0"                  # faction definitions this map references

files:
  world_map.yaml: { sha256: "..." }   # region definitions, adjacency, scenarios
  assets/galaxy_background.png: { sha256: "..." }
  assets/region_overlays.png: { sha256: "..." }
  assets/faction_icons/: {}            # per-faction marker icons
  preview.png: { sha256: "..." }       # Workshop listing thumbnail
</code></pre>
<p>Workshop world maps support the full Workshop lifecycle:</p>
<ul>
<li><strong>Discovery</strong> — browse/search by game module, region count, theme tags, rating. Filter by “maps with 20+ regions” or “fantasy setting” or “historical.”</li>
<li><strong>One-click install</strong> — download the <code>.icpkg</code>, world map appears in the campaign setup screen under “Community Maps.”</li>
<li><strong>Dependency resolution</strong> — a world map can depend on faction packs, terrain packs, or sprite sets. Workshop resolves and installs dependencies automatically.</li>
<li><strong>Versioning</strong> — semver; breaking changes (region ID renames, adjacency changes) require major version bumps. Saved campaigns pin the world map version they were started with.</li>
<li><strong>Forking</strong> — any published world map can be forked. “I like that galactic map but I want to add a wormhole network” → fork, edit in Campaign Editor, republish as a derivative (license permitting).</li>
<li><strong>LLM integration</strong> — world maps with <code>ai_usage: allow</code> can be discovered by the LLM during campaign generation. The LLM reads region metadata (terrain types, strategic values, flavor text) to generate contextually appropriate missions. A rich, well-annotated world map gives the LLM more material to work with.</li>
<li><strong>Composition</strong> — a world map can reference other Workshop resources. Faction packs define the factions. Terrain packs provide the visual assets. Music packs set the atmosphere. The world map is the strategic skeleton; other Workshop resources flesh it out.</li>
<li><strong>Rating and reviews</strong> — community rates world maps on balance, visual quality, replayability. High-rated maps surface in “Featured” listings.</li>
</ul>
<p><strong>World map as an engine feature, not a campaign feature:</strong></p>
<p>The world map renderer is in <code>ic-ui</code> — it’s a general-purpose interactive map component. The World Domination campaign mode uses it as its primary interface, but the same component powers:</p>
<ul>
<li>The “World Map” intermission template in D038 (for non-domination campaigns that want a mission-select map)</li>
<li>Strategic overview displays in Game Master mode</li>
<li>Multiplayer lobby map selection (showing region-based game modes)</li>
<li>Mod-defined strategic layers (e.g., a Generals mod with a global war on terror, a Star Wars mod with a galactic conquest, a fantasy mod with a continent map)</li>
</ul>
<p>The engine imposes no assumptions about what the map represents. Regions are abstract nodes with connections, properties, and an image overlay. Whether those nodes are countries, planets, city districts, or dungeon rooms is entirely up to the content creator. The engine provides the map renderer; the game module and mods provide the map data.</p>
<p>Because world maps are Workshop resources, the community can build a library of strategic maps independently of the engine team. A thriving Workshop means a player launching World Domination for the first time can browse dozens of community-created maps — historical, fictional, fantastical — and start a campaign on any of them without the modder needing to ship a full game module.</p>
<h4 id="workshop-resource-integration"><a class="header" href="#workshop-resource-integration">Workshop Resource Integration</a></h4>
<p>The LLM doesn’t generate everything from scratch. It draws on the player’s configured Workshop sources (D030) for maps, terrain packs, music, and other assets — the same pipeline described in § LLM-Driven Resource Discovery above.</p>
<p><strong>How this works in campaign generation:</strong></p>
<ol>
<li>The LLM plans a mission: “Arctic base assault in a fjord.”</li>
<li>The generation system searches Workshop: <code>tags=["arctic", "fjord", "base"], ai_usage=Allow</code>.</li>
<li>If a suitable map exists → use it as the terrain base, generate objectives/triggers/briefing on top.</li>
<li>If no map exists → generate the map from scratch (YAML terrain definition).</li>
<li>Music, ambient audio, and voice packs from Workshop enhance the atmosphere — the LLM selects thematically appropriate resources from those available.</li>
</ol>
<p>This makes generative campaigns richer in communities with active Workshop content creators. A well-stocked Workshop full of diverse maps and assets becomes a palette the LLM paints from. Resource attribution is tracked: the campaign’s <code>mod.yaml</code> lists all Workshop dependencies, crediting the original creators.</p>
<h4 id="no-llm-campaign-still-works"><a class="header" href="#no-llm-campaign-still-works">No LLM? Campaign Still Works</a></h4>
<p>The generative campaign system follows the core D016 principle: <strong>LLM is for creation, not for play.</strong></p>
<ul>
<li>A player with an LLM generates a campaign → plays it → it’s saved as standard D021.</li>
<li>A player without an LLM → imports and plays a shared campaign from Workshop. No different from playing a hand-crafted campaign.</li>
<li>A player starts a generative campaign, generates 12/24 missions, then loses LLM access → the 12 generated missions are fully playable. The campaign is “shorter than planned” but complete up to that point. When LLM access returns, generation resumes from mission 12.</li>
<li>A community member takes a generated 24-mission campaign, opens it in the Campaign Editor, and hand-edits missions 15–24 to improve them. No LLM needed for editing.</li>
</ul>
<p>The LLM is a tool in the content creation pipeline — the same pipeline that includes the Scenario Editor, Campaign Editor, and hand-authored YAML. Generated campaigns are first-class citizens of the same content ecosystem.</p>
<h4 id="multiplayer--co-op-generative-campaigns"><a class="header" href="#multiplayer--co-op-generative-campaigns">Multiplayer &amp; Co-op Generative Campaigns</a></h4>
<p>Everything described above — narrative campaigns, open-ended campaigns, world domination, cinematic generation — works in multiplayer. The generative campaign system builds on D038’s co-op infrastructure (Player Slots, Co-op Mission Modes, Per-Player Objectives) and the D010 snapshottable sim. These are the multiplayer modes the generative system supports:</p>
<p><strong>Co-op generative campaigns:</strong></p>
<p>Two or more players share a generative campaign. They play together, the LLM generates for all of them, and the campaign adapts to their combined performance.</p>
<pre><code class="language-yaml"># Co-op generative campaign setup
campaign_parameters:
  mode: generative
  player_count: 2                      # 2-4 players
  co_op_mode: allied_factions          # each player controls their own faction
  # Alternative modes from D038:
  # shared_command — both control the same army
  # commander_ops — one builds, one fights
  # split_objectives — different goals on the same map
  # asymmetric — one RTS player, one GM/support

  faction_player_1: soviet
  faction_player_2: allied             # co-op doesn't mean same faction
  difficulty: hard
  campaign_type: narrative             # or open_ended, world_domination
  length: 16
  tone: serious
</code></pre>
<p><strong>What the LLM generates differently for co-op:</strong></p>
<p>The LLM knows it’s generating for multiple players. This changes mission design:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Single-player</th><th>Co-op</th></tr>
</thead>
<tbody>
<tr><td><strong>Map layout</strong></td><td>One base, one frontline</td><td>Multiple bases or sectors per player</td></tr>
<tr><td><strong>Objectives</strong></td><td>Unified objective list</td><td>Per-player objectives + shared goals</td></tr>
<tr><td><strong>Briefings</strong></td><td>One briefing</td><td>Per-player briefings (different intel, different roles)</td></tr>
<tr><td><strong>Radar comms</strong></td><td>Addressed to “Commander”</td><td>Addressed to specific players by role/faction</td></tr>
<tr><td><strong>Dialogue choices</strong></td><td>One player decides</td><td>Each player gets their own choices; disagreements create narrative tension</td></tr>
<tr><td><strong>Character assignment</strong></td><td>All characters with the player</td><td>Named characters distributed across players</td></tr>
<tr><td><strong>Mission difficulty</strong></td><td>Scaled for one</td><td>Scaled for combined player power + coordination challenge</td></tr>
<tr><td><strong>Narrative</strong></td><td>One protagonist’s story</td><td>Interweaving storylines that converge at key moments</td></tr>
</tbody>
</table>
</div>
<p><strong>Player disagreements as narrative fuel:</strong></p>
<p>The most interesting co-op feature: <strong>what happens when players disagree.</strong> In a single-player campaign, the player makes all dialogue choices. In co-op, each player makes their own choices in intermissions and mid-mission dialogues. The LLM uses disagreements as narrative material:</p>
<ul>
<li>Player 1 wants to spare the prisoner. Player 2 wants to execute them. The LLM generates a confrontation scene between the players’ commanding officers, then resolves based on a configurable rule: majority wins, mission commander decides (rotating role), or the choice splits into two consequences.</li>
<li>Player 1 wants to attack the eastern front. Player 2 wants to defend the west. In World Domination mode, they can split — each player tackles a different region simultaneously (parallel missions at the same point in the campaign).</li>
<li>Persistent disagreements shift character loyalties — an NPC commander who keeps getting overruled becomes resentful, potentially defecting (Campaign Event Patterns).</li>
</ul>
<p><strong>Saving, pausing, and resuming co-op campaigns:</strong></p>
<p>Co-op campaigns are long. Players can’t always finish in one sitting. The system supports <strong>pause, save, and resume</strong> for multiplayer campaigns:</p>
<pre><code>┌────────────────────────────────────────────────────────────────┐
│                  Co-op Campaign Session Flow                    │
│                                                                │
│  1. Player A creates a co-op generative campaign               │
│     └── Campaign saved to Player A's local storage             │
│                                                                │
│  2. Player A invites Player B (friend list, lobby code, link)  │
│     └── Player B receives campaign metadata + join token       │
│                                                                │
│  3. Both players play missions together                        │
│     └── Campaign state synced: both have a local copy          │
│                                                                │
│  4. Mid-campaign: players want to stop                         │
│     ├── Either player can request pause                        │
│     ├── Current mission: standard multiplayer save (D010)      │
│     │   └── Full sim snapshot + order history + campaign state  │
│     └── Campaign state saved: mission progress, roster, flags  │
│                                                                │
│  5. Resume later (hours, days, weeks)                          │
│     ├── Player A loads campaign from "My Campaigns"            │
│     ├── Player A re-invites Player B                           │
│     ├── Player B's client receives the campaign state delta    │
│     └── Resume from exactly where they left off                │
│                                                                │
│  6. Player B unavailable? Options:                             │
│     ├── Wait for Player B                                      │
│     ├── AI takes Player B's slot (temporary)                   │
│     ├── Invite Player C to take over (with B's consent)        │
│     └── Continue solo (B's faction runs on AI)                 │
└────────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>How multiplayer save works (technically):</strong></p>
<ul>
<li><strong>Mid-mission save:</strong> Uses D010 — full sim snapshot. Both players receive the snapshot. Either player can host the resume session. The save file is a standard <code>.icsave</code> containing the sim snapshot, order history, and campaign state.</li>
<li><strong>Between-mission save:</strong> The natural pause point. Campaign state (D021) is serialized — roster, flags, mission graph position, world map state (if World Domination). No sim snapshot needed — the next mission hasn’t started yet.</li>
<li><strong>Campaign ownership:</strong> The campaign is “owned” by the creating player but the save state is portable. If Player A disappears, Player B has a full local copy and can resume solo or with a new partner.</li>
</ul>
<p><strong>Co-op World Domination:</strong></p>
<p>World Domination campaigns with multiple human players — each controlling a faction on the world map. The LLM generates missions for all players, weaving their actions into a shared narrative. Two modes:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><strong>Allied co-op</strong></td><td>Players share a team against AI factions. They coordinate attacks on different fronts simultaneously. One player attacks Berlin while the other defends Moscow.</td><td>2 players (Soviet team) vs. AI (Allied + Neutral)</td></tr>
<tr><td><strong>Competitive co-op</strong></td><td>Players are rival factions on the same map. Each plays their own campaign missions. When players’ territories are adjacent, they fight each other. An AI faction provides a shared threat.</td><td>Player 1 (Soviet) vs. Player 2 (Allied) vs. AI (Rogue faction)</td></tr>
</tbody>
</table>
</div>
<p>Allied co-op World Domination is particularly compelling — two friends on voice chat, splitting their forces across a continent, coordinating strategy: “I’ll push into Scandinavia if you hold the Polish border.” The LLM generates missions for both fronts simultaneously, with narrative crossover: “Intelligence reports your ally has broken through in Norway. Allied forces are retreating south — expect increased resistance on your front.”</p>
<p><strong>Asynchronous campaign play:</strong></p>
<p>Not every multiplayer session needs to be real-time. For players in different time zones or with unpredictable schedules, the system supports <strong>asynchronous play</strong> in competitive World Domination campaigns:</p>
<pre><code class="language-yaml">async_config:
  mode: async_competitive              # players play their campaigns asynchronously
  move_deadline: 48h                   # max time before AI plays your next mission
  notification: true                   # notify when the other player has completed a mission
  ai_fallback_on_deadline: true        # AI plays your mission if you don't show up
</code></pre>
<p>How it works:</p>
<ol>
<li>Player A logs in, sees the world map. The LLM (or template system) presents their next mission — an attack, defense, or narrative event.</li>
<li>Player A plays the RTS mission in real-time. The mission resolves. The campaign state updates. Notification sent to Player B.</li>
<li>Player B logs in hours/days later. They see how the map changed based on Player A’s results. The LLM presents Player B’s next mission based on the updated state.</li>
<li>Player B plays their mission. The map updates again. Notification sent to Player A.</li>
</ol>
<p>The RTS missions are fully real-time (you play a complete battle). The asynchronous part is <em>when</em> each player sits down to play — not what they do when they’re playing. The LLM (or strategic AI fallback) generates narrative that acknowledges the asynchronous pacing — no urgent “the enemy is attacking NOW!” when the other player won’t see it for 12 hours.</p>
<p><strong>Generative challenge campaigns:</strong></p>
<p>The LLM generates short, self-contained challenges that the community can attempt and compete on:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Challenge type</th><th>Description</th><th>Competitive element</th></tr>
</thead>
<tbody>
<tr><td><strong>Weekly challenge</strong></td><td>A generated 3-mission mini-campaign with a leaderboard. Same seed = same campaign for all players.</td><td>Score (time, casualties, objectives)</td></tr>
<tr><td><strong>Ironman run</strong></td><td>A generated campaign with permadeath — no save/reload. Campaign ends when you lose.</td><td>How far you get (mission count)</td></tr>
<tr><td><strong>Speed campaign</strong></td><td>Generated campaign optimized for speed — short missions, tight timers.</td><td>Total completion time</td></tr>
<tr><td><strong>Impossible odds</strong></td><td>Generated campaign where the LLM deliberately creates unfair scenarios.</td><td>Binary: did you survive?</td></tr>
<tr><td><strong>Community vote</strong></td><td>Players vote on campaign parameters. The LLM generates one campaign that everyone plays.</td><td>Score leaderboard</td></tr>
</tbody>
</table>
</div>
<p>Weekly challenges reuse the same seed and LLM output — the campaign is generated once, published to the community, and everyone plays the identical missions. This is fair because the content is deterministic once generated. Leaderboards are per-challenge, stored via the community server (D052) with signed credential records.</p>
<p><strong>Spectator and observer mode:</strong></p>
<p>Live campaigns (especially co-op and competitive World Domination) can be observed:</p>
<ul>
<li><strong>Live spectator</strong> — watch a co-op campaign in progress (delay configurable for competitive fairness). See both players’ perspectives.</li>
<li><strong>Replay spectator</strong> — watch a completed campaign, switching between player perspectives. The replay includes all dialogue choices, intermission decisions, and world map actions.</li>
<li><strong>Commentary mode</strong> — a spectator can record voice commentary over a replay, creating a “let’s play” package sharable on Workshop.</li>
<li><strong>Campaign streaming</strong> — the campaign state can be broadcast to a spectator server. Community members watch the world map update in real-time during community events.</li>
<li><strong>Author-guided camera</strong> — scenario authors place Spectator Bookmark modules (D038) at key map locations and wire them to triggers. Spectators cycle bookmarks with hotkeys; replays auto-cut to bookmarks at dramatic moments. Free camera remains available — bookmarks are hints, not constraints.</li>
<li><strong>Spectator appeal as design input</strong> — Among Us became a cultural phenomenon through streaming because social dynamics are more entertaining to <em>watch</em> than many games are to play. Modes like Mystery (accusation moments), Nemesis (escalating rivalry), and Defection (betrayal) are inherently watchable — LLM-generated dialogue, character reactions, and dramatic pivots create spectator-friendly narrative beats. This is a validation of the existing spectator infrastructure, not a new feature: the commentary mode, War Dispatches, and replay system already capture these moments. When the LLM generates campaign content, it should mark <strong>spectator-highlight moments</strong> (accusations, betrayals, nemesis confrontations, moral dilemmas) in the campaign save so replays can auto-cut to them.</li>
</ul>
<p><strong>Co-op resilience (eliminated player engagement):</strong></p>
<p>In any co-op campaign, a critical question: what happens when one player’s forces are devastated mid-mission? Among Us’s insight is that eliminated players keep playing — dead crewmates complete tasks and observe. IC applies this principle: a player whose army is destroyed doesn’t sit idle. Options compose from existing systems:</p>
<ul>
<li><strong>Intelligence/advisor role</strong> — the eliminated player transitions to managing the intermission-layer intelligence network (Espionage mode) or providing strategic guidance through the shared chat. They see the full battlefield (observer perspective) and can ping locations, mark threats, and coordinate with the surviving player.</li>
<li><strong>Reinforcement controller</strong> — the eliminated player controls reinforcement timing and positioning for the surviving partner. They decide <em>when</em> and <em>where</em> reserve units deploy, adding a cooperative command layer.</li>
<li><strong>Rebuild mission</strong> — the eliminated player receives a smaller side-mission to re-establish from a secondary base or rally point. Success in the side-mission provides reinforcements to the surviving player’s main mission.</li>
<li><strong>Game Master lite</strong> — using the scenario’s reserve pool, the eliminated player places emergency supply drops, triggers scripted reinforcements, or activates defensive structures. A subset of Game Master (D038) powers, scoped to assist rather than control.</li>
</ul>
<p>The specific role available depends on the campaign mode and scenario design. The key principle: <strong>no player should ever watch an empty screen in a co-op campaign</strong>. Even total military defeat is a phase transition, not an ejection.</p>
<p><strong>Generative multiplayer scenarios (non-campaign):</strong></p>
<p>Beyond campaigns, the LLM generates one-off multiplayer scenarios:</p>
<ul>
<li><strong>Generated skirmish maps</strong> — “Generate a 4-player free-for-all map with lots of chokepoints and limited resources.” The LLM creates a balanced multiplayer map.</li>
<li><strong>Generated team scenarios</strong> — “Create a 2v2 co-op defense mission against waves of enemies.” The LLM generates a PvE scenario with scaling difficulty.</li>
<li><strong>Generated party modes</strong> — “Make a king-of-the-hill map where the hill moves every 5 minutes.” Creative game modes generated on demand.</li>
<li><strong>Tournament map packs</strong> — “Generate 7 balanced 1v1 maps for a tournament, varied terrain, no water.” A set of maps with consistent quality and design language.</li>
</ul>
<p>These generate as standard IC content — the same maps and scenarios that human designers create. They can be played immediately, saved, edited, or published to Workshop.</p>
<h4 id="persistent-heroes--named-squads"><a class="header" href="#persistent-heroes--named-squads">Persistent Heroes &amp; Named Squads</a></h4>
<p>The infrastructure for hero-centric, squad-based campaigns with long-term character development is fully supported by existing systems — no new engine features required. Everything described below composes from D021 (persistent rosters), D016 (character construction + CharacterState), D029 (component library), the veterancy system, and YAML/Lua modding.</p>
<p><strong>What the engine already provides:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Capability</th><th>Source</th><th>How it applies</th></tr>
</thead>
<tbody>
<tr><td>Named units persist across missions</td><td>D021 carryover modes</td><td>A hero unit that survives mission 3 is the <em>same entity</em> in mission 15 — same health, same veterancy, same kill count</td></tr>
<tr><td>Veterancy accumulates permanently</td><td>D021 + veterancy system</td><td>A commando who kills 50 enemies across 10 missions earns promotions that change their stats, voice lines, and visual appearance</td></tr>
<tr><td>Permanent death</td><td>D021 + CharacterState</td><td>If Volkov dies in mission 7, <code>CharacterStatus::Dead</code> — he’s gone forever. The campaign adapts around his absence. No reloading in Iron Man mode.</td></tr>
<tr><td>Character personality persists</td><td>D016 CharacterState</td><td>MBTI type, speech style, flaw/desire/fear, loyalty, relationship — all tracked and evolved by the LLM across the full campaign</td></tr>
<tr><td>Characters react to their own history</td><td>D016 battle reports + narrative threads</td><td>A hero who was nearly killed in mission 5 develops caution. One who was betrayed develops trust issues. The LLM reads <code>notable_events</code> and adjusts behavior.</td></tr>
<tr><td>Squad composition matters</td><td>D021 roster + D029 components</td><td>A hand-picked 5-unit squad with complementary abilities (commando + engineer + sniper + medic + demolitions) plays differently than a conventional army. Equipment captured in one mission equips the squad in the next.</td></tr>
<tr><td>Upgrades and equipment persist</td><td>D021 equipment carryover + D029 upgrade system</td><td>A hero’s captured experimental weapon, earned battlefield upgrades, and scavenged equipment carry forward permanently</td></tr>
<tr><td>Customizable unit identity</td><td>YAML unit definitions + Lua</td><td>Named units can have custom names, visual markings (kill tallies, custom insignia via Lua), and unique voice lines</td></tr>
</tbody>
</table>
</div>
<p><strong>Campaign modes this enables:</strong></p>
<p><strong>Commando campaign (“Tanya Mode”):</strong> A series of behind-enemy-lines missions with 1–3 hero units and no base building. Every mission is a commando operation. The heroes accumulate kills, earn abilities, and develop personality through LLM-generated briefing dialogue. Losing your commando ends the campaign (Iron Man) or branches to a rescue mission (standard). The LLM generates increasingly personal rivalry between your commando and an enemy commander who’s hunting them.</p>
<p><strong>Squad campaign (“Band of Brothers”):</strong> A persistent squad of 5–12 named soldiers. Each squad member has an MBTI personality, a role specialization, and a relationship to the others. Between missions, the LLM generates squad interactions — arguments, bonding moments, confessions, humor — driven by MBTI dynamics and recent battle events. A medic (ISFJ) who saved the sniper (INTJ) in mission 4 develops a protective bond. The demolitions expert (ESTP) and the squad leader (ISTJ) clash over tactics. When a squad member dies, the LLM writes the other characters’ grief responses consistent with their personalities and relationships. Replacements arrive — but they’re new personalities who have to earn the squad’s trust.</p>
<p><strong>Hero army campaign (“Generals”):</strong> A conventional campaign where 3–5 hero units lead a full army. Heroes are special units with unique abilities, voice lines, and narrative arcs. They appear in briefings, issue orders to the player, argue with each other about strategy, and can be sent on solo objectives within larger missions. Losing a hero doesn’t end the campaign but permanently changes it — the army loses a capability, the other heroes react, and the enemy adapts.</p>
<p><strong>Cross-campaign hero persistence (“Legacy”):</strong> Heroes from a completed campaign carry over to the next campaign. A veteran commando from “Soviet Campaign” appears as a grizzled mentor in “Soviet Campaign 2” — with their full history, personality evolution, and kill count. <code>CharacterState</code> serializes to campaign save files and can be imported. The LLM reads the imported history and writes the character accordingly — a war hero is treated like a war hero.</p>
<p><strong>Iron Man integration:</strong> All hero modes compose with Iron Man (no save/reload). Death is permanent. The campaign adapts. This is where the character investment pays off most intensely — the player who nursed a hero through 15 missions has real emotional stakes when that hero is sent into a dangerous situation. The LLM knows this and uses it: “Volkov volunteers for the suicide mission. He’s your best commando. But if he goes in alone, he won’t come back.”</p>
<p><strong>Modding support:</strong> All of this is achievable through YAML + Lua (Tier 1-2 modding). A modder defines named hero units in YAML with custom stats, abilities, and visual markings. Lua scripts handle special hero abilities (“Volkov plants the charges — 30-second timer”), squad interaction triggers, and custom carryover rules. The LLM’s character construction system works with any modder-defined units — the MBTI framework and flaw/desire/fear triangle apply regardless of the game module. A Total Conversion mod in a fantasy setting could have a persistent party of heroes with swords instead of guns — the personality simulation works the same way.</p>
<h4 id="extended-generative-campaign-modes"><a class="header" href="#extended-generative-campaign-modes">Extended Generative Campaign Modes</a></h4>
<p>The three core generative modes — <strong>Narrative</strong> (fixed-length), <strong>Open-Ended</strong> (condition-driven), and <strong>World Domination</strong> (world map + LLM narrative director) — are the structural foundations. But the LLM’s expressive range and IC’s compositional architecture enable a much wider vocabulary of campaign experiences. Each mode below composes from existing systems (D021 branching, CharacterState, MBTI dynamics, battle reports, roster persistence, story flags, world map renderer, Workshop resources) — no new engine changes required.</p>
<p>These modes are drawn from the deepest wells of human storytelling: philosophy, cinema, literature, military history, game design, and the universal experiences that make stories resonate across cultures. The test for each: <strong>does it make the toy soldiers come alive in a way no other mode does?</strong></p>
<hr>
<p><strong>The Long March (Survival Exodus)</strong></p>
<p><em>Inspired by: Battlestar Galactica, FTL: Faster Than Light, the Biblical Exodus, Xenophon’s Anabasis, the real Long March, Oregon Trail, refugee crises throughout history.</em></p>
<p>You’re not conquering — you’re surviving. Your army has been shattered, your homeland overrun. You must lead what remains of your people across hostile territory to safety. Every mission is a waypoint on a desperate journey. The world map shows your route — not territory you hold, but ground you must cross.</p>
<p>The LLM generates waypoint encounters: ambushes at river crossings, abandoned supply depots (trap or salvation?), hostile garrisons blocking mountain passes, civilian populations who might shelter you or sell you out. The defining tension is <strong>resource scarcity</strong> — you can’t replace what you lose. A tank destroyed in mission 4 is gone forever. A hero killed at the third river crossing never reaches the promised land. Every engagement forces a calculation: fight (risk losses), sneak (risk detection), or negotiate (risk betrayal).</p>
<p>What makes this profoundly different from conquest modes: the emotional arc is inverted. In a normal campaign, the player grows stronger. Here, the player holds on. Victory isn’t domination — it’s survival. The LLM tracks the convoy’s dwindling strength and generates missions that match: early missions are organized retreats with rear-guard actions; mid-campaign missions are desperate scavenging operations; late missions are harrowing last stands at chokepoints. The finale isn’t assaulting the enemy capital — it’s crossing the final border with whatever you have left.</p>
<p>Every unit that makes it to the end feels earned. A veteran tank that survived 20 missions of running battles, ambushes, and near-misses isn’t just a unit — it’s a story.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Solo</th><th>Multiplayer</th></tr>
</thead>
<tbody>
<tr><td><strong>Structure</strong></td><td>One player leads the exodus</td><td>Co-op: each player commands part of the convoy. Split up to cover more ground (faster but weaker) or stay together (slower but safer).</td></tr>
<tr><td><strong>Tension</strong></td><td>Resource triage — what do you leave behind?</td><td>Social triage — whose forces protect the rear guard? Who gets the last supply drop?</td></tr>
<tr><td><strong>Failure</strong></td><td>Convoy destroyed or starved</td><td>One player’s column is wiped out — the other must continue without their forces. Or go back for them.</td></tr>
</tbody>
</table>
</div>
<hr>
<p><strong>Cold War Espionage (The Intelligence Campaign)</strong></p>
<p><em>Inspired by: John le Carré (The Spy Who Came in from the Cold, Tinker Tailor Soldier Spy), The Americans (TV), Bridge of Spies, Metal Gear Solid, the real Cold War intelligence apparatus.</em></p>
<p>The war is fought with purpose. Every mission is a full RTS engagement — Extract→Build→Amass→Crush — but the <em>objectives</em> are intelligence-driven. You assault a fortified compound to extract a defecting scientist before the enemy can evacuate them. You defend a relay station for 15 minutes while your signals team intercepts a critical transmission. You raid a convoy to capture communications equipment that reveals the next enemy offensive. The LLM generates these intelligence-flavored objectives, but what the player actually <em>does</em> is build bases, train armies, and fight battles.</p>
<p>Between missions, the player manages an intelligence network in the intermission layer. The LLM generates a web of agents, double agents, handlers, and informants, each with MBTI-driven motivations that determine when they cooperate, when they lie, and when they defect. Each recruited agent has a loyalty score, a personality type, and a price. An ISFJ agent spies out of duty but breaks under moral pressure. An ENTP agent spies for the thrill but gets bored with routine operations. The LLM uses these personality models to simulate when an agent provides good intelligence, when they feed disinformation (intentionally or under duress), and when they get burned.</p>
<p>Intelligence gathered between missions shapes the next battle. Good intel reveals enemy base locations, unlocks alternative starting positions, weakens enemy forces through pre-mission sabotage, or provides reinforcement timelines. Bad intel — from burned agents or double agents feeding disinformation — sends the player into missions with false intelligence: the enemy base isn’t where your agent said it was, the “lightly defended” outpost is a trap, the reinforcements that were supposed to arrive don’t exist. The campaign’s strategic metagame is information quality; the moment-to-moment gameplay is commanding armies.</p>
<p>The MBTI interaction system drives the intermission layer: every agent conversation is a negotiation, every character is potentially lying, and reading people’s personalities correctly determines the quality of intel you bring into battle. Petrov (ISTJ) can be trusted because duty-bound types don’t betray without extreme cause. Sonya (ENTJ) is useful but dangerous — her ambition makes her a powerful asset and an unpredictable risk. The LLM simulates these dynamics through dialogue that reveals (or conceals) character intentions based on their personality models.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Solo</th><th>Multiplayer</th></tr>
</thead>
<tbody>
<tr><td><strong>Structure</strong></td><td>RTS missions with intelligence-driven objectives; agent network between</td><td>Adversarial: two players run competing spy networks between missions. Better intel = battlefield advantage in the next engagement.</td></tr>
<tr><td><strong>Tension</strong></td><td>Is your intel good — or did a burned agent just send you into a trap?</td><td>Your best double agent might be feeding your opponent better intel than you. The battlefield reveals who was lied to.</td></tr>
<tr><td><strong>Async multiplayer</strong></td><td>N/A</td><td>Espionage metagame is inherently asynchronous. Plant an operation between missions, see the results on the next battlefield.</td></tr>
</tbody>
</table>
</div>
<hr>
<p><strong>The Defection (Two Wars in One)</strong></p>
<p><em>Inspired by: The Americans, Metal Gear Solid 3: Snake Eater, Bridge of Spies, real Cold War defection stories (Oleg Gordievsky, Aldrich Ames), Star Wars: The Force Awakens (Finn’s defection).</em></p>
<p>Act 1: You fight for one side. You know your commanders. You trust (or distrust) your team. You fight the enemy as defined by your faction. Then something happens — an order you can’t follow, a truth you can’t ignore, an atrocity that changes everything. Act 2: You defect. Everything inverts. Your former allies hunt you with the tactics you taught them. Your new allies don’t trust you. The characters you built relationships with in Act 1 react to your betrayal according to their MBTI types — the ISTJ commander feels personally betrayed, the ESTP commando grudgingly respects your courage, the ENTJ intelligence officer was expecting it and already has a contingency plan.</p>
<p>What makes this structurally unique: the same CharacterState instances exist in both acts, but their <code>allegiance</code> and <code>relationship_to_player</code> values flip. The LLM generates Act 2 dialogue where former friends reference specific events from Act 1 — “I trusted you at the bridge, Commander. I won’t make that mistake again.” The personality system ensures each character’s reaction to the defection is psychologically consistent: some hunt you with rage, some with sorrow, some with professional detachment.</p>
<p>The defection trigger can be player-chosen (a moral crisis) or narrative-driven (you discover your faction’s war crimes). The LLM builds toward it across Act 1 — uncomfortable orders, suspicious intelligence, moral gray areas — so it feels earned, not arbitrary. The <code>hidden_agenda</code> field and <code>loyalty</code> score track the player’s growing doubts through story flags.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Solo</th><th>Multiplayer</th></tr>
</thead>
<tbody>
<tr><td><strong>Structure</strong></td><td>One player, two acts, two factions</td><td>Co-op: both players defect, or one defects and the other doesn’t — the campaign splits. Former co-op partners become enemies.</td></tr>
<tr><td><strong>Tension</strong></td><td>Your knowledge of your old faction is your weapon — and your vulnerability</td><td>The betrayal is social, not just narrative. Your co-op partner didn’t expect you to switch sides.</td></tr>
<tr><td><strong>Emotional core</strong></td><td>“Were we ever fighting for the right side?”</td><td>“Can I trust someone who’s already betrayed one allegiance?”</td></tr>
</tbody>
</table>
</div>
<hr>
<p><strong>Nemesis (The Personal War)</strong></p>
<p><em>Inspired by: Shadow of Mordor’s Nemesis system, Captain Ahab and the white whale (Moby-Dick), Holmes/Moriarty, Batman/Joker, Heat (Mann), the primal human experience of rivalry.</em></p>
<p>The entire campaign is structured around a single, escalating rivalry with an enemy commander who adapts, learns, remembers, and grows. The Nemesis isn’t a scripted boss — they’re a fully realized CharacterState with an MBTI personality, their own flaw/desire/fear triangle, and a relationship to the player that evolves based on actual battle outcomes.</p>
<p>The LLM reads every battle report and updates the Nemesis’s behavior. Player loves tank rushes? The Nemesis develops anti-armor obsession — mines every approach, builds AT walls, taunts the player about predictability. Player won convincingly in mission 5? The Nemesis retreats to rebuild, and the LLM generates 2-3 missions of fragile peace before the Nemesis returns with a new strategy and a grudge. Player barely wins? The Nemesis respects the challenge and begins treating the war as a personal duel rather than a strategic campaign.</p>
<p>What separates this from the existing “Rival commander” pattern: the Nemesis IS the campaign. Not a subplot — the main plot. The arc follows the classical rivalry structure: introduction (missions 1-3), first confrontation (4-5), escalation (6-12), reversal (the Nemesis wins one — 13-14), obsession (15-18), and final reckoning (19-24). Both characters are changed by the end. The LLM generates the Nemesis’s personal narrative — their own setbacks, alliances, and moral evolution — and delivers fragments through intercepted communications, captured intel, and enemy officer interrogations.</p>
<p>The deepest philosophical parallel: the Nemesis is a mirror. Their MBTI type is deliberately chosen as the player’s faction’s shadow — strategically complementary, personally incompatible. An INTJ strategic mastermind opposing the player’s blunt-force army creates a “brains vs. brawn” struggle. An ENFP charismatic rebel opposing the player’s disciplined advance creates “heart vs. machine.” The LLM makes the Nemesis compelling enough that defeating them feels bittersweet.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Solo</th><th>Multiplayer</th></tr>
</thead>
<tbody>
<tr><td><strong>Structure</strong></td><td>Player vs. LLM-driven Nemesis</td><td>Symmetric: each player IS the other’s Nemesis. Your victories write their villain’s story.</td></tr>
<tr><td><strong>Adaptation</strong></td><td>The Nemesis learns from your battle reports</td><td>Both players adapt simultaneously — a genuine arms race with narrative weight.</td></tr>
<tr><td><strong>Climax</strong></td><td>Final confrontation after 20+ missions of escalation</td><td>The players meet in a final battle that their entire campaign has been building toward.</td></tr>
<tr><td><strong>Export</strong></td><td>After finishing, export your Nemesis as a Workshop character — other players face the villain YOUR campaign created</td><td>Post-campaign, challenge a friend: “Can you beat the commander who almost beat me?”</td></tr>
</tbody>
</table>
</div>
<hr>
<p><strong>Moral Complexity Parameter (Tactical Dilemmas)</strong></p>
<p><em>Inspired by: Spec Ops: The Line (tonal caution), Papers Please (systemic moral choices), the trolley problem (Philippa Foot), Walzer’s “Just and Unjust Wars,” the enduring human interest in difficult decisions under pressure.</em></p>
<p>Moral complexity is not a standalone campaign mode — it’s a <strong>parameter available on any generative campaign mode</strong>. It controls how often the LLM generates tactical dilemmas with no clean answer, and how much character personality drives the fallout. Three levels:</p>
<ul>
<li><strong>Low</strong> (default): Straightforward tactical choices. The mission has a clear objective; characters react to victory and defeat but not to moral ambiguity. Standard C&amp;C fare — good guys, bad guys, blow stuff up.</li>
<li><strong>Medium</strong>: Tactical trade-offs with character consequences. Occasional missions present two valid approaches with different costs. Destroy the bridge to cut off enemy reinforcements, or leave it intact so civilians can evacuate? The choice affects the next mission’s conditions AND how your MBTI-typed commanders view your leadership. No wrong answer — but each choice shifts character loyalty.</li>
<li><strong>High</strong>: Genuine moral weight with long-tail consequences. The LLM generates dilemmas where both options have defensible logic and painful costs. Tactical, not gratuitous — these stay within the toy-soldier abstraction of C&amp;C:
<ul>
<li>A fortified enemy position is using a civilian structure as cover. Shelling it ends the siege quickly but your ISFJ field commander loses respect for your methods. Flanking costs time and units but preserves your team’s trust.</li>
<li>You’ve intercepted intelligence that an enemy officer wants to defect — but extracting them requires diverting forces from a critical defensive position. Commit to the extraction (gain a valuable asset, risk the defense) or hold the line (lose the defector, secure the front).</li>
<li>Two allied positions are under simultaneous attack. You can only reinforce one in time. The LLM ensures both positions have named characters the player has built relationships with. Whoever you don’t reinforce takes heavy casualties — and remembers.</li>
</ul>
</li>
</ul>
<p>The LLM tracks choices in campaign story flags and generates <strong>long-tail consequences</strong>. A choice from mission 3 might resurface in mission 15 — the officer you extracted becomes a critical ally, or the position you didn’t reinforce never fully trusts your judgment again. Characters react according to their MBTI type: TJ types evaluate consequences; FP types evaluate intent; SJ types evaluate duty; NP types evaluate principle. Loyalty shifts based on personality-consistent moral frameworks, not a universal morality scale.</p>
<p>At <strong>High</strong> in co-op campaigns, both players must agree on dilemma choices — creating genuine social negotiation. “Do we divert for the extraction or hold the line?” becomes a real conversation between real people with different strategic instincts.</p>
<p>This parameter composes with every mode: a Nemesis campaign at High moral complexity generates dilemmas where the Nemesis exploits the player’s past choices. A Generational Saga at High carries moral consequences across generations — Generation 3 lives with Generation 1’s trade-offs. A Mystery campaign at Medium lets the traitor steer the player toward choices that look reasonable but serve enemy interests.</p>
<hr>
<p><strong>Generational Saga (The Hundred-Year War)</strong></p>
<p><em>Inspired by: Crusader Kings (Paradox), Foundation (Asimov), Dune (Herbert), The Godfather trilogy, Fire Emblem (permadeath + inheritance), the lived experience of generational trauma and inherited conflict.</em></p>
<p>The war spans three generations. Each generation is ~8 missions. Characters age, retire, die of old age or in combat. Young lieutenants from Generation 1 are old generals in Generation 3. The decisions of grandparents shape the world their grandchildren inherit.</p>
<p>Generation 1 establishes the conflict. The player’s commanders are young, idealistic, sometimes reckless. Their victories and failures set the starting conditions for everything that follows. The LLM generates the world state that Generation 2 inherits: borders drawn by Generation 1’s campaigns, alliances forged by their diplomacy, grudges created by their atrocities, technology unlocked by their captured facilities.</p>
<p>Generation 2 lives in their predecessors’ shadow. The LLM generates characters who are the children or proteges of Generation 1’s heroes — with inherited MBTIs modified by upbringing. A legendary commander’s daughter might be an ENTJ like her father… or an INFP who rejects everything he stood for. The Nemesis from Generation 1 might be dead, but their successor inherited their grudge and their tactical files. “Your father destroyed my father’s army at Stalingrad. I’ve spent 20 years studying how.”</p>
<p>Generation 3 brings resolution. The war’s original cause may be forgotten — the LLM tracks how meaning shifts across generations. What started as liberation becomes occupation becomes tradition becomes identity. The final generation must either find peace or perpetuate a war that nobody remembers starting. The LLM generates characters who question why they’re fighting — and the MBTI system determines who accepts “it’s always been this way” (SJ types) and who demands “but why?” (NP types).</p>
<p>Cross-campaign hero persistence (Legacy mode) provides the technical infrastructure. CharacterState serializes between generations. Veterancy, notable events, and relationship history persist in the save. The LLM writes Generation 3’s dialogue with explicit callbacks to Generation 1’s battles — events the <em>player</em> remembers but the <em>characters</em> only know as stories.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Solo</th><th>Multiplayer</th></tr>
</thead>
<tbody>
<tr><td><strong>Structure</strong></td><td>One player, three eras, one evolving war</td><td>Two dynasties: each player leads a family across three generations. Your grandfather’s enemy’s grandson is your rival.</td></tr>
<tr><td><strong>Investment</strong></td><td>Watching characters age and pass the torch</td><td>Shared 20+ year fictional history between two real players</td></tr>
<tr><td><strong>Climax</strong></td><td>Generation 3 resolves (or doesn’t) the conflict that Generation 1 started</td><td>The final generation can negotiate peace — or realize they’ve become exactly what Generation 1 fought against</td></tr>
</tbody>
</table>
</div>
<hr>
<p><strong>Parallel Timelines (The Chronosphere Fracture)</strong></p>
<p><em>Inspired by: Sliding Doors (film), Everything Everywhere All at Once, Bioshock Infinite, the Many-Worlds interpretation of quantum mechanics, the universal human experience of “what if I’d chosen differently?”</em></p>
<p>This mode is uniquely suited to Red Alert’s lore — the Chronosphere is literally a time machine. A Chronosphere malfunction fractures reality into two parallel timelines diverging from a single critical decision. The player alternates missions between Timeline A (where they made one choice) and Timeline B (where they made the opposite).</p>
<p>The LLM generates both timelines from the same campaign skeleton but with diverging consequences. In Timeline A, you destroyed the bridge — the enemy can’t advance, but your reinforcements can’t reach you either. In Timeline B, you saved the bridge — the enemy pours across, but so do your reserves. The same characters exist in both timelines but develop differently based on divergent circumstances. Sonya (ENTJ) in Timeline A seizes power during the chaos; Sonya in Timeline B remains loyal because the bridge gave her the resources she needed. Same personality, different circumstances, different trajectory — the MBTI system ensures both versions are psychologically plausible.</p>
<p>The player experiences both consequences simultaneously. Every 2 missions, the timeline switches. The LLM generates narrative parallels and contrasts — events that rhyme across timelines. Mission 6A is a desperate defense; Mission 6B is an easy victory. But the easy victory in B created a complacency that sets up a devastating ambush in 8B, while the desperate defense in A forged a harder, warier force that handles 8A better. The timelines teach different lessons.</p>
<p>The climax: the timelines threaten to collapse into each other (Chronosphere overload). The player must choose which timeline becomes “real” — with full knowledge of what they’re giving up. Or, in the boldest variant, the two timelines collide and the player must fight their way through a reality-fractured final mission where enemies and allies from both timelines coexist.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Solo</th><th>Multiplayer</th></tr>
</thead>
<tbody>
<tr><td><strong>Structure</strong></td><td>One player alternates between two timelines</td><td>Each player IS a timeline. They can’t communicate directly — but their timelines leak into each other (Chronosphere interference).</td></tr>
<tr><td><strong>Tension</strong></td><td>“Which timeline do I want to keep?”</td><td>“My partner’s timeline is falling apart because of a choice I made in mine”</td></tr>
<tr><td><strong>Lore fit</strong></td><td>The Chronosphere is already RA’s signature technology</td><td>Chronosphere multiplayer events: one player’s Chronosphere experiment affects the other’s battlefield</td></tr>
</tbody>
</table>
</div>
<hr>
<p><strong>The Mystery (Whodunit at War)</strong></p>
<p><em>Inspired by: Agatha Christie, The Thing (Carpenter), Among Us, Clue, Knives Out, the universal human fascination with deduction and betrayal.</em></p>
<p>Someone in your own command structure is sabotaging operations. Missions keep going wrong in ways that can’t be explained by bad luck — the enemy always knows your plans, supply convoys vanish, key systems fail at critical moments. The campaign is simultaneously a military campaign and a murder mystery. The player must figure out which of their named characters is the traitor — while still winning a war.</p>
<p>The LLM randomly selects the traitor at campaign start from the named cast and plays that character’s MBTI type <em>as if they were loyal</em> — because a good traitor acts normal. But the LLM plants clues in mission outcomes and character behavior. An ISFJ traitor might “accidentally” route supplies to the wrong location (duty-driven guilt creates mistakes). An ENTJ traitor might push too hard for a specific strategic decision that happens to benefit the enemy (ambition overrides subtlety). An ESTP traitor makes bold, impulsive moves that look like heroism but create exploitable vulnerabilities.</p>
<p>The player gathers evidence through mission outcomes, character dialogue inconsistencies, and optional investigation objectives (hack a communications relay, interrogate a captured enemy, search a character’s quarters). At various points the campaign offers “accuse” branching — name the traitor and take action. Accuse correctly → the conspiracy unravels and the campaign pivots to hunting the traitor’s handlers. Accuse incorrectly → you’ve just purged a loyal officer, damaged morale, and the real traitor is still operating. The LLM generates the fallout either way.</p>
<p>What makes this work with MBTI: each character type hides guilt differently, leaks information differently, and responds to suspicion differently. The LLM generates behavioral tells that are personality-consistent — learnable but not obvious. Repeat playthroughs with the same characters but a different traitor create genuinely different mystery experiences because the deception patterns change with the traitor’s personality type.</p>
<p><strong>Marination — trust before betrayal:</strong> The LLM follows a deliberate escalation curve inspired by Among Us’s best impostors. The traitor character performs <em>exceptionally well</em> in early missions — perhaps saving the player from a tough situation, providing critical intelligence, or volunteering for dangerous assignments. The first 30–40% of the campaign builds genuine trust. Clues begin appearing only after the player has formed a real attachment to every character (including the traitor). In co-op Traitor mode, divergent objectives start trivially small — capture a minor building that barely affects the mission outcome — and escalate gradually as the campaign progresses. This ensures the eventual reveal feels earned rather than random, and the player’s “I trusted you” reaction has genuine emotional weight.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Solo</th><th>Multiplayer</th></tr>
</thead>
<tbody>
<tr><td><strong>Structure</strong></td><td>Player deduces the traitor from clues across missions</td><td>Co-op with explicit opt-in “Traitor” party mode: one player receives secret <em>divergent</em> objectives from the LLM (capture instead of destroy, let a specific unit escape, secure a specific building). Not sabotage — different priorities.</td></tr>
<tr><td><strong>Tension</strong></td><td>“Which of my commanders is lying to me?”</td><td>“Is my co-op partner pursuing a different objective, or are we playing the same mission?” Subtle divergence, not griefing.</td></tr>
<tr><td><strong>Climax</strong></td><td>The accusation — right or wrong, the campaign changes</td><td>The reveal — when divergent objectives surface, the campaign’s entire history is recontextualized. Both players were playing their own version of the war.</td></tr>
</tbody>
</table>
</div>
<p><strong>Verifiable actions (trust economy):</strong> In co-op Traitor mode, the system tracks <strong>verifiable actions</strong> — things that both players can confirm through shared battlefield data. “I defended the northern flank solo for 8 minutes” is system-confirmable from the replay. “I captured objective Alpha as requested” appears in the shared mission summary. A player building trust spends time on verifiable actions visible to their partner — but this diverts from optimal play or from pursuing secret divergent objectives. The traitor faces a genuine strategic choice: build trust through verifiable actions (slower divergent progress, safer cover) or pursue secret objectives aggressively (faster but riskier if the partner is watching closely). This creates an Among Us-style “visual tasks” dynamic where proving innocence has a real cost.</p>
<p><strong>Intelligence review (structured suspicion moments):</strong> In co-op Mystery campaigns, each intermission functions as an <strong>intelligence review</strong> — a structured moment where both players see a summary of mission outcomes and the LLM surfaces anomalies. “Objective Alpha was captured instead of destroyed — consistent with enemy priorities.” “Forces were diverted from Sector 7 during the final push — 12% efficiency loss.” The system generates this data automatically from divergent-objective tracking and presents it neutrally. Players discuss before the next mission — creating a natural accusation-or-trust moment without pausing gameplay. This mirrors Among Us’s emergency meeting mechanic: action stops, evidence is reviewed, and players must decide whether to confront suspicion or move on.</p>
<p><strong>Asymmetric briefings (information asymmetry in all co-op modes):</strong> Beyond Mystery, ALL co-op campaign modes benefit from a lesson Among Us teaches about information asymmetry: <strong>each player’s pre-mission briefing should include information the other player doesn’t have</strong>. Player A’s intelligence report mentions an enemy weapons cache in the southeast; Player B’s report warns of reinforcements arriving from the north. Neither briefing is wrong — they’re simply incomplete. This creates natural “wait, what did YOUR briefing say?” conversations that build cooperative engagement. In Mystery co-op, asymmetric briefings also provide cover for the traitor’s divergent objectives — they can claim “my briefing said to capture that building” and the other player can’t immediately verify it. The LLM generates briefing splits based on each player’s assigned intelligence network and agent roster.</p>
<hr>
<h4 id="solomultiplayer-bridges"><a class="header" href="#solomultiplayer-bridges">Solo–Multiplayer Bridges</a></h4>
<p>The modes above work as standalone solo or multiplayer experiences. But the most interesting innovation is allowing <strong>ideas to cross between solo and multiplayer</strong> — things you create alone become part of someone else’s experience, and vice versa. These bridges emerge naturally from IC’s existing architecture (CharacterState serialization, Workshop sharing, D042 player behavioral profiles, campaign save portability):</p>
<p><strong>Nemesis Export:</strong> Complete a Nemesis campaign. Your nemesis — their MBTI personality, their adapted tactics (learned from your battle reports), their grudge, their dialogue patterns — serializes to a Workshop-sharable character file. Another player imports your nemesis into their own campaign. Now they’re fighting a villain that was forged by YOUR gameplay. The nemesis “remembers” their history and references it: “The last commander who tried that tactic… I made them regret it.” Community-curated nemesis libraries let players challenge themselves against the most compelling villain characters the community has generated.</p>
<p><strong>Ghost Operations (Asynchronous Competition):</strong> A solo player completes a campaign. Their campaign save — including every tactical decision, unit composition, timing, and outcome — becomes a “ghost.” Another player plays the same campaign seed but races against the ghost’s performance. Not a replay — a parallel run. The ghost’s per-mission results appear as benchmark data: “The ghost completed this mission in 12 minutes with 3 casualties. Can you do better?” This transforms solo campaigns into asynchronous races. Weekly challenges already use fixed seeds; ghost operations extend this to full campaigns.</p>
<p><strong>War Dispatches (Narrative Fragments):</strong> A solo player’s campaign generates “dispatches” — short, LLM-written narrative summaries of key campaign moments, formatted as fictional news reports, radio intercepts, or intelligence briefings. These dispatches are shareable. Other players can subscribe to a friend’s campaign dispatches — following their war as a serialized story. A dispatch might say: “Reports confirm the destruction of the 3rd Allied Armored Division at the Rhine crossing. Soviet commander [player name] is advancing unchecked.” The reader sees the story; the player lived it.</p>
<p><strong>Community Front Lines (Persistent World):</strong> Every solo player’s World Domination campaign contributes to a shared community war map. Your victories advance your faction’s front lines; your defeats push them back. Weekly aggregation: the community’s collective Solo campaigns determine the global state. Weekly community briefings (LLM-generated from aggregate data) report on the state of the war. “The Allied front in Northern Europe has collapsed after 847 Soviet campaign victories this week. The community’s attention shifts to the Pacific theater.” This doesn’t affect individual campaigns — it’s a metagame visualization. But it creates the feeling that your solo campaign matters to something larger.</p>
<p><strong>Tactical DNA (D042 Profile as Challenge):</strong> Complete a campaign. Your D042 player behavioral profile — which tracks your strategic tendencies, unit preferences, micro patterns — exports as a “tactical DNA” file. An AI opponent can load your tactical DNA and play <em>as you</em>. Another player can challenge your tactical DNA: “Can you beat the AI version of Copilot? They love air rushes, never build naval, and always go for the tech tree.” This creates asymmetric AI opponents that are genuinely personal — not generic difficulty levels, but specific human-like play patterns. Community members share and compete against each other’s tactical DNA in skirmish mode.</p>
<hr>
<p>All extended modes produce standard D021 campaigns. All are playable without an LLM once generated. All are saveable, shareable via Workshop, editable in the Campaign Editor, and replayable. The LLM provides the creative act; the engine provides the infrastructure. Modders can create new modes by combining the same building blocks differently — the modes above are a curated library, not an exhaustive list.</p>
<blockquote>
<p><strong>See also D057 (Skill Library):</strong> Proven mission generation patterns — which scene template combinations, parameter values, and narrative structures produce highly-rated missions — are stored in the skill library and retrieved as few-shot examples for future generation. This makes D016’s template-filling approach more reliable over time without changing the generation architecture.</p>
</blockquote>
<h3 id="llm-generated-custom-factions"><a class="header" href="#llm-generated-custom-factions">LLM-Generated Custom Factions</a></h3>
<p>Beyond missions and campaigns, the LLM can generate <strong>complete custom factions</strong> — a tech tree, unit roster, building roster, unique mechanics, visual identity, and faction personality — from a natural language description. The output is standard YAML (Tier 1), optionally with Lua scripts (Tier 2) for unique abilities. A generated faction is immediately playable in skirmish and custom games, shareable via Workshop, and fully editable by hand.</p>
<p><strong>Why this matters:</strong> Creating a new faction in any RTS is one of the hardest modding tasks. It requires designing 15-30+ units with coherent roles, a tech tree with meaningful progression, counter-relationships against existing factions, visual identity, and balance — all simultaneously. Most aspiring modders give up before finishing. An LLM that can generate a complete, validated faction from a description like “a guerrilla faction that relies on stealth, traps, and hit-and-run tactics” lowers the barrier from months of work to minutes of iteration.</p>
<p><strong>Available resource pool:</strong> The LLM has access to everything the engine knows about:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Source</th><th>What the LLM Can Reference</th><th>How</th></tr>
</thead>
<tbody>
<tr><td><strong>Base game units/weapons/structures</strong></td><td>All YAML definitions from the active game module (RA1, TD, etc.) including stats, counter relationships, prerequisites, and <code>llm:</code> metadata</td><td>Direct YAML read at generation time</td></tr>
<tr><td><strong>Balance presets (D019)</strong></td><td>All preset values — the LLM knows what “Classic” vs “OpenRA” Tanya stats look like and can calibrate accordingly</td><td>Preset YAML loaded alongside base definitions</td></tr>
<tr><td><strong>Workshop resources (D030)</strong></td><td>Published mods, unit packs, sprite sheets, sound packs, weapon definitions — anything the player has installed or that the Workshop index describes</td><td>Workshop metadata queries via <code>LLM</code> Lua global (Phase 7); local installed resources via filesystem; remote resources via Workshop API with <code>ai_usage</code> consent check (D030 § Author Consent)</td></tr>
<tr><td><strong>Skill Library (D057)</strong></td><td>Previously generated factions that were rated highly by players; proven unit archetypes, tech tree patterns, and balance relationships</td><td>Semantic search retrieval as few-shot examples</td></tr>
<tr><td><strong>Player data (D034)</strong></td><td>The player’s gameplay history: preferred playstyles, unit usage patterns, faction win rates</td><td>Local SQLite queries (read-only) for personalization</td></tr>
</tbody>
</table>
</div>
<p><strong>Generation pipeline:</strong></p>
<pre><code>User prompt                    "A faction based on weather control and
                                environmental warfare"
         │
         ▼
┌─────────────────────────────────────────────────────────┐
│  1. CONCEPT GENERATION                                  │
│     LLM generates faction identity:                     │
│     - Name, theme, visual style                         │
│     - Core mechanic ("weather weapons that affect       │
│       terrain and visibility")                          │
│     - Asymmetry axis ("environmental control vs          │
│       direct firepower — strong area denial,            │
│       weak in direct unit-to-unit combat")              │
│     - Design pillars (3-4 one-line principles)          │
└─────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────┐
│  2. TECH TREE GENERATION                                │
│     LLM designs the tech tree:                          │
│     - Building unlock chain (3-4 tiers)                 │
│     - Each tier unlocks 2-5 units/abilities             │
│     - Prerequisites form a DAG (validated)              │
│     - Key decision points ("at Tier 3, choose           │
│       Tornado Generator OR Blizzard Chamber —           │
│       not both")                                        │
│     References: base game tech tree structure,           │
│     D019 balance philosophy Principle 5                  │
│     (shared foundation + unique exceptions)             │
└─────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────┐
│  3. UNIT ROSTER GENERATION                              │
│     For each unit slot in the tech tree:                │
│     - Generate full YAML unit definition                │
│     - Stats calibrated against existing factions        │
│     - Counter relationships defined (Principle 2)       │
│     - `llm:` metadata block filled in                   │
│     - Weapon definitions generated or reused            │
│     Workshop query: "Are there existing sprite packs    │
│     or weapon definitions I can reference?"             │
│     Skill library query: "What unit archetypes work     │
│     well for area-denial factions?"                     │
└─────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────┐
│  4. BALANCE VALIDATION                                  │
│     Automated checks (no LLM needed):                   │
│     - Total faction cost curve vs existing factions     │
│     - DPS-per-cost distribution within normal range     │
│     - Every unit has counters AND is countered by       │
│     - Tech tree is a valid DAG (no cycles,              │
│       every unit reachable)                             │
│     - No unit duplicates another unit's role exactly    │
│     - Name/identifier uniqueness                        │
│     If validation fails → feedback to LLM for          │
│     iteration (up to 3 retries per issue)               │
└─────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────┐
│  5. OUTPUT                                              │
│     Standard mod directory:                             │
│     factions/weather_control/                           │
│       faction.yaml     # faction identity + color       │
│       tech_tree.yaml   # prerequisite graph             │
│       units/           # one .yaml per unit             │
│       weapons/         # weapon definitions             │
│       structures/      # building definitions           │
│       abilities.lua    # unique mechanics (Tier 2)      │
│       preview.png      # generated or placeholder       │
│       README.md        # faction lore + design notes    │
│                                                         │
│     Playable immediately. Editable by hand.             │
│     Publishable to Workshop.                            │
└─────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>Example generation session:</strong></p>
<pre><code>Player: "Create a faction that uses mind control and
         psychic technology. Fragile units but powerful
         area effects. Should be viable against both
         Allies and Soviets in the Classic preset."

LLM generates:
  Faction: Psi Corps
  Theme: Psychic warfare — control, confusion, area denial
  Asymmetry: Weak individual units, powerful area abilities.
             Can turn enemy units into assets. Vulnerable
             to fast rushes before psychic tech is online.

  Tech tree:
    Tier 1: Psi Barracks → Initiate (basic infantry, weak attack,
            can detect cloaked), Psi Trooper (anti-vehicle mind blast)
    Tier 2: Psi Lab → Mentalist (area confusion — enemies attack
            each other for 10s), Mind Reader (reveals fog in radius)
    Tier 3: Amplifier Tower → Dominator (permanently converts one
            enemy unit, long cooldown, expensive)
    Tier 3 alt: Psychic Beacon → mass area slow + damage over time
    ...

  Balance validation:
    ✓ Total faction DPS-per-cost: 0.87x Allied average (intended —
      compensated by mind control economy)
    ✓ Counter relationships complete: Psi units weak to vehicles
      (can't mind-control machines), strong vs infantry
    ✓ Tech tree DAG valid, all units reachable
    ⚠ Dominator ability may be too strong in team games —
      suggest adding "one active Dominator per player" cap
    → LLM adjusts and re-validates
</code></pre>
<p><strong>Workshop asset integration:</strong> The LLM can reference Workshop resources with compatible licenses and <code>ai_usage: allow</code> consent (D030 § Author Consent):</p>
<ul>
<li><strong>Sprite packs:</strong> “Use ‘alice/psychic-infantry-sprites’ for the Initiate’s visual” — the generated YAML references the Workshop package as a dependency</li>
<li><strong>Sound packs:</strong> “Use ‘bob/sci-fi-weapon-sounds’ for the mind blast weapon audio”</li>
<li><strong>Weapon definitions:</strong> “Inherit from ‘carol/energy-weapons/plasma_bolt’ and adjust damage for psychic theme”</li>
<li><strong>Existing unit definitions:</strong> “The Mentalist’s confusion ability works like ‘dave/chaos-mod/confusion_gas’ but with psychic visuals instead of chemical”</li>
</ul>
<p>This means a generated faction can have real art, real sounds, and tested mechanics from day one — not just placeholder stats waiting for assets. The Workshop becomes a <strong>component library</strong> for LLM faction assembly.</p>
<p><strong>What this is NOT:</strong></p>
<ul>
<li><strong>Not allowed in ranked play.</strong> LLM-generated factions are for skirmish, custom lobbies, and single-player. Ranked games use curated balance presets (D019/D055).</li>
<li><strong>Not autonomous.</strong> The LLM proposes; the player reviews, edits, and approves. The generation UI shows every unit definition and lets the player tweak stats, rename units, or regenerate individual components before saving.</li>
<li><strong>Not a substitute for hand-crafted factions.</strong> The built-in Allied and Soviet factions are carefully designed from EA source code values. Generated factions are community content — fun, creative, potentially brilliant, but not curated to the same standard.</li>
<li><strong>Not dependent on specific assets.</strong> If a referenced Workshop sprite pack isn’t installed, the faction still loads with placeholder sprites. Assets are enhancement, not requirements.</li>
</ul>
<p><strong>Iterative refinement:</strong> After generating, the player can:</p>
<ol>
<li><strong>Playtest</strong> the faction in a skirmish against AI</li>
<li><strong>Request adjustments:</strong> “Make the Tier 2 units cheaper but weaker” or “Add a naval unit”</li>
<li>The LLM regenerates affected units with context from the existing faction definition</li>
<li><strong>Manually edit</strong> any YAML file — the generated output is standard IC content</li>
<li><strong>Publish to Workshop</strong> for others to play, rate, and fork</li>
</ol>
<p><strong>Phase:</strong> Phase 7 (alongside other LLM generation features). Requires: YAML unit/faction definition system (Phase 2), Workshop resource API (Phase 6a), <code>ic-llm</code> provider system, skill library (D057).</p>
<hr>
<hr>
<h2 id="d038--scenario-editor-ofpeden-inspired-sdk"><a class="header" href="#d038--scenario-editor-ofpeden-inspired-sdk">D038 — Scenario Editor (OFP/Eden-Inspired, SDK)</a></h2>
<p><strong>Resolves:</strong> P005 (Map editor architecture)</p>
<p><strong>Decision:</strong> Visual scenario editor — not just a map/terrain painter, but a full mission authoring tool inspired by Operation Flashpoint’s mission editor (2001) and Arma 3’s Eden Editor (2016). Ships as part of the <strong>IC SDK</strong> (separate application from the game — see D040 § SDK Architecture). Live isometric preview via shared Bevy crates. Combines terrain editing (tiles, resources, cliffs) with scenario logic editing (unit placement, triggers, waypoints, modules). Two complexity tiers: Simple mode (accessible) and Advanced mode (full power).</p>
<p><strong>Rationale:</strong></p>
<p>The OFP mission editor is one of the most successful content creation tools in gaming history. It shipped with a $40 game in 2001 and generated thousands of community missions across 15 years — despite having no undo button. Its success came from three principles:</p>
<ol>
<li><strong>Accessibility through layered complexity.</strong> Easy mode hides advanced fields. A beginner places units and waypoints in minutes. An advanced user adds triggers, conditions, probability of presence, and scripting. Same data, different UI.</li>
<li><strong>Emergent behavior from simple building blocks.</strong> Guard + Guarded By creates dynamic multi-group defense behavior from pure placement — zero scripting. Synchronization lines coordinate multi-group operations. Triggers with countdown/timeout timers and min/mid/max randomization create unpredictable encounters.</li>
<li><strong>Instant preview collapses the edit→test loop.</strong> Place things on the actual map, hit “Test” to launch the game with your scenario loaded. Hot-reload keeps the loop tight — edit in the SDK, changes appear in the running game within seconds.</li>
</ol>
<p>Eden Editor (2016) evolved these principles: 3D placement, undo/redo, 154 pre-built modules (complex logic as drag-and-drop nodes), compositions (reusable prefabs), layers (organizational folders), and Steam Workshop publishing directly from the editor. Arma Reforger (2022) added budget systems, behavior trees for waypoints, controller support, and a real-time Game Master mode.</p>
<p><strong>Iron Curtain applies these lessons to the RTS genre.</strong> An RTS scenario editor has different needs than a military sim — isometric view instead of first-person, base-building and resource placement instead of terrain sculpting, wave-based encounters instead of patrol routes. But the underlying principles are identical: layered complexity, emergent behavior from simple rules, and zero barrier between editing and playing.</p>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<p>The scenario editor lives in the <code>ic-editor</code> crate and ships as part of the <strong>IC SDK</strong> — a separate Bevy application from the game (see D040 § SDK Architecture for the full separation rationale). It reuses the game’s rendering and simulation crates: <code>ic-render</code> (isometric viewport), <code>ic-sim</code> (preview playback), <code>ic-ui</code> (shared UI components like panels and attribute editors), and <code>ic-protocol</code> (order types for preview). <code>ic-game</code> does NOT depend on <code>ic-editor</code> — the game binary has zero editor code. The SDK binary (<code>ic-sdk</code>) bundles the scenario editor, asset studio (D040), campaign editor, and Game Master mode in a single application with a tab-based workspace.</p>
<p><strong>Test/preview communication:</strong> When the user hits “Test,” the SDK serializes the current scenario and launches <code>ic-game</code> with it loaded, using a <code>LocalNetwork</code> (from <code>ic-net</code>). The game runs the scenario identically to normal gameplay — the sim never knows it was launched from the SDK. For quick in-SDK preview (without launching the full game), the SDK can also run <code>ic-sim</code> internally with a lightweight preview viewport. Editor-generated inputs (e.g., placing a debug unit mid-preview) are submitted as <code>PlayerOrder</code>s through <code>ic-protocol</code>. The hot-reload bridge watches for file changes and pushes updates to the running game test session.</p>
<pre><code>┌─────────────────────────────────────────────────┐
│                 Scenario Editor                  │
│                                                  │
│  ┌──────────┐  ┌──────────┐  ┌───────────────┐ │
│  │  Terrain  │  │  Entity   │  │   Logic       │ │
│  │  Painter  │  │  Placer   │  │   Editor      │ │
│  │           │  │           │  │               │ │
│  │ tiles     │  │ units     │  │ triggers      │ │
│  │ resources │  │ buildings │  │ waypoints     │ │
│  │ cliffs    │  │ props     │  │ modules       │ │
│  │ water     │  │ markers   │  │ regions       │ │
│  └──────────┘  └──────────┘  └───────────────┘ │
│                                                  │
│  ┌──────────────────────────────────────────┐   │
│  │            Attributes Panel               │   │
│  │  Per-entity properties (GUI, not code)    │   │
│  └──────────────────────────────────────────┘   │
│                                                  │
│  ┌─────────┐  ┌──────────┐  ┌──────────────┐   │
│  │ Layers  │  │ Comps    │  │ Preview/Test │   │
│  │ Panel   │  │ Library  │  │ Button       │   │
│  └─────────┘  └──────────┘  └──────────────┘   │
│                                                  │
│  ┌─────────┐  ┌──────────┐  ┌──────────────┐   │
│  │ Script  │  │ Vars     │  │ Complexity   │   │
│  │ Editor  │  │ Panel    │  │ Meter        │   │
│  └─────────┘  └──────────┘  └──────────────┘   │
│                                                  │
│  ┌──────────────────────────────────────────┐   │
│  │           Campaign Editor                 │   │
│  │  Graph · State · Intermissions · Dialogue │   │
│  └──────────────────────────────────────────┘   │
│                                                  │
│  Crate: ic-editor                                │
│  Uses:  ic-render (isometric view)               │
│         ic-sim   (preview playback)              │
│         ic-ui    (shared panels, attributes)     │
└─────────────────────────────────────────────────┘
</code></pre>
<h3 id="editing-modes"><a class="header" href="#editing-modes">Editing Modes</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Purpose</th><th>OFP Equivalent</th></tr>
</thead>
<tbody>
<tr><td><strong>Terrain</strong></td><td>Paint tiles, place resources (ore/gems), sculpt cliffs, water</td><td>N/A (OFP had fixed terrains)</td></tr>
<tr><td><strong>Entities</strong></td><td>Place units, buildings, props, markers</td><td>F1 (Units) + F6 (Markers)</td></tr>
<tr><td><strong>Groups</strong></td><td>Organize units into squads/formations, set group behavior</td><td>F2 (Groups)</td></tr>
<tr><td><strong>Triggers</strong></td><td>Place area-based conditional logic (win/lose, events, spawns)</td><td>F3 (Triggers)</td></tr>
<tr><td><strong>Waypoints</strong></td><td>Assign movement/behavior orders to groups</td><td>F4 (Waypoints)</td></tr>
<tr><td><strong>Connections</strong></td><td>Link triggers ↔ waypoints ↔ modules visually</td><td>F5 (Synchronization)</td></tr>
<tr><td><strong>Modules</strong></td><td>Pre-packaged game logic nodes</td><td>F7 (Modules)</td></tr>
<tr><td><strong>Regions</strong></td><td>Draw named spatial zones reusable across triggers and scripts</td><td>N/A (AoE2/StarCraft concept)</td></tr>
<tr><td><strong>Scripts</strong></td><td>Browse and edit external <code>.lua</code> files referenced by inline scripts</td><td>OFP mission folder <code>.sqs</code>/<code>.sqf</code> files</td></tr>
<tr><td><strong>Campaign</strong></td><td>Visual campaign graph — mission ordering, branching, persistent state</td><td>N/A (no RTS editor has this)</td></tr>
</tbody>
</table>
</div>
<h3 id="entity-palette-ux"><a class="header" href="#entity-palette-ux">Entity Palette UX</a></h3>
<p>The Entities mode panel provides the primary browse/select interface for all placeable objects. Inspired by Garry’s Mod’s spawn menu (<code>Q</code> menu) — the gold standard for navigating massive asset libraries — the palette includes:</p>
<ul>
<li><strong>Search-as-you-type</strong> across all entities (units, structures, props, modules, compositions) — filters the tree in real time</li>
<li><strong>Favorites list</strong> — star frequently-used items; persisted per-user in SQLite (D034). A dedicated Favorites tab at the top of the palette</li>
<li><strong>Recently placed</strong> — shows the last 20 entities placed this session, most recent first. One click to re-select</li>
<li><strong>Per-category browsing</strong> with collapsible subcategories (faction → unit type → specific unit). Categories are game-module-defined via YAML</li>
<li><strong>Thumbnail previews</strong> — small sprite/icon preview next to each entry. Hovering shows a larger preview with stats summary</li>
</ul>
<p>The same palette UX applies to the Compositions Library panel, the Module selector, and the Trigger type picker — search/favorites/recents are universal navigation patterns across all editor panels.</p>
<h3 id="entity-attributes-panel"><a class="header" href="#entity-attributes-panel">Entity Attributes Panel</a></h3>
<p>Every placed entity has a GUI properties panel (no code required). This replaces OFP’s “Init” field for most use cases while keeping advanced scripting available.</p>
<p><strong>Unit attributes (example):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Type</strong></td><td>dropdown</td><td>Unit class (filtered by faction)</td></tr>
<tr><td><strong>Name</strong></td><td>text</td><td>Variable name for Lua scripting</td></tr>
<tr><td><strong>Faction</strong></td><td>dropdown</td><td>Owner: Player 1–8, Neutral, Creeps</td></tr>
<tr><td><strong>Facing</strong></td><td>slider 0–360</td><td>Starting direction</td></tr>
<tr><td><strong>Stance</strong></td><td>enum</td><td>Guard / Patrol / Hold / Aggressive</td></tr>
<tr><td><strong>Health</strong></td><td>slider 0–100%</td><td>Starting hit points</td></tr>
<tr><td><strong>Veterancy</strong></td><td>enum</td><td>None / Rookie / Veteran / Elite</td></tr>
<tr><td><strong>Probability of Presence</strong></td><td>slider 0–100%</td><td>Random chance to exist at mission start</td></tr>
<tr><td><strong>Condition of Presence</strong></td><td>expression</td><td>Lua boolean (e.g., <code>difficulty &gt;= "hard"</code>)</td></tr>
<tr><td><strong>Placement Radius</strong></td><td>slider 0–10 cells</td><td>Random starting position within radius</td></tr>
<tr><td><strong>Init Script</strong></td><td>text (multi-line)</td><td>Inline Lua — the primary scripting surface</td></tr>
</tbody>
</table>
</div>
<p><strong>Probability of Presence</strong> is the single most important replayability feature from OFP. Every entity — units, buildings, resource patches, props — can have a percentage chance of existing when the mission loads. Combined with Condition of Presence, this creates two-factor randomization: “50% chance this tank platoon spawns, but only on Hard difficulty.” A player replaying the same mission encounters different enemy compositions each time. This is trivially deterministic — the mission seed determines all rolls.</p>
<h3 id="named-regions"><a class="header" href="#named-regions">Named Regions</a></h3>
<p>Inspired by Age of Empires II’s trigger areas and StarCraft’s “locations” — both independently proved that named spatial zones are how non-programmers think about RTS mission logic. A <strong>region</strong> is a named area on the map (rectangle or ellipse) that can be referenced by name across multiple triggers, modules, and scripts.</p>
<p>Regions are NOT triggers — they have no logic of their own. They are spatial labels. A region named <code>bridge_crossing</code> can be referenced by:</p>
<ul>
<li>Trigger 1: “IF Player 1 faction present in <code>bridge_crossing</code> → activate reinforcements”</li>
<li>Trigger 2: “IF <code>bridge_crossing</code> has no enemies → play victory audio”</li>
<li>Lua script: <code>Region.unit_count("bridge_crossing", faction.allied) &gt;= 5</code></li>
<li>Module: Wave Spawner configured to spawn at <code>bridge_crossing</code></li>
</ul>
<p>This separation prevents the common RTS editor mistake of coupling spatial areas to individual triggers. In AoE2, if three triggers need to reference the same map area, you create three identical areas. In IC, you create one region and reference it three times.</p>
<p><strong>Region attributes:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Name</strong></td><td>text</td><td>Unique identifier (e.g., <code>enemy_base</code>, <code>ambush_zone</code>)</td></tr>
<tr><td><strong>Shape</strong></td><td>rect / ellipse</td><td>Cell-aligned or free-form</td></tr>
<tr><td><strong>Color</strong></td><td>color picker</td><td>Editor visualization color (not visible in-game)</td></tr>
<tr><td><strong>Tags</strong></td><td>text[]</td><td>Optional categorization for search/filter</td></tr>
<tr><td><strong>Z-layer</strong></td><td>ground / air / any</td><td>Which unit layers the region applies to</td></tr>
</tbody>
</table>
</div>
<h3 id="inline-scripting-ofp-style"><a class="header" href="#inline-scripting-ofp-style">Inline Scripting (OFP-Style)</a></h3>
<p>OFP’s most powerful feature was also its simplest: double-click a unit, type a line of SQF in the Init field, done. No separate IDE, no file management, no project setup. The scripting lived <em>on the entity</em>. For anything complex, the Init field called an external script file — one line bridges the gap between visual editing and full programming.</p>
<p>IC follows the same model with Lua. The <strong>Init Script</strong> field on every entity is the primary scripting surface — not a secondary afterthought.</p>
<p><strong>Inline scripting examples:</strong></p>
<pre><code class="language-lua">-- Simple: one-liner directly on the entity
this:set_stance("hold")

-- Medium: a few lines of inline behavior
this:set_patrol_route("north_road")
this:on_damaged(function() Var.set("alarm_triggered", true) end)

-- Complex: inline calls an external script file
dofile("scripts/elite_guard.lua")(this)

-- OFP equivalent of `nul = [this] execVM "patrol.sqf"`
run_script("scripts/convoy_escort.lua", { unit = this, route = "highway" })
</code></pre>
<p>This is exactly how OFP worked: most units have no Init script at all (pure visual placement). Some have one-liners. A few call external files for complex behavior. The progression is organic — a designer starts with visual placement, realizes they need a small tweak, types a line, and naturally graduates to scripting when they’re ready. No mode switch, no separate tool.</p>
<p><strong>Inline scripts run at entity spawn time</strong> — when the mission loads (or when the entity is dynamically spawned by a trigger/module). The <code>this</code> variable refers to the entity the script is attached to.</p>
<p><strong>Triggers and modules also have inline script fields:</strong></p>
<ul>
<li>Trigger <strong>On Activation</strong>: inline Lua that runs when the trigger fires</li>
<li>Trigger <strong>On Deactivation</strong>: inline Lua for repeatable triggers</li>
<li>Module <strong>Custom Logic</strong>: override or extend a module’s default behavior</li>
</ul>
<p>Every inline script field has:</p>
<ul>
<li><strong>Syntax highlighting</strong> for Lua with IC API keywords</li>
<li><strong>Autocompletion</strong> for entity names, region names, variables, and the IC Lua API (D024)</li>
<li><strong>Error markers</strong> shown inline before preview (not in a crash log)</li>
<li><strong>Expand button</strong> — opens the field in a larger editing pane for multi-line scripts without leaving the entity’s properties panel</li>
</ul>
<h3 id="script-files-panel"><a class="header" href="#script-files-panel">Script Files Panel</a></h3>
<p>When inline scripts call external files (<code>dofile("scripts/ambush.lua")</code>), those files need to live somewhere. The <strong>Script Files Panel</strong> manages them — it’s the editor for the external script files that inline scripts reference.</p>
<p>This is the same progression OFP used: Init field → <code>execVM "script.sqf"</code> → the .sqf file lives in the mission folder. IC keeps the external files <em>inside the editor</em> rather than requiring alt-tab to a text editor.</p>
<p><strong>Script Files Panel features:</strong></p>
<ul>
<li><strong>File browser</strong> — lists all <code>.lua</code> files in the mission</li>
<li><strong>New file</strong> — create a script file, it’s immediately available to inline <code>dofile()</code> calls</li>
<li><strong>Syntax highlighting</strong> and <strong>autocompletion</strong> (same as inline fields)</li>
<li><strong>Live reload</strong> — edit a script file during preview, save, changes take effect next tick</li>
<li><strong>API reference sidebar</strong> — searchable IC Lua API docs without leaving the editor</li>
<li><strong>Breakpoints and watch</strong> (Advanced mode) — pause the sim on a breakpoint, inspect variables</li>
</ul>
<p><strong>Script scope hierarchy (mirrors the natural progression):</strong></p>
<pre><code>Inline init scripts  — on entities, run at spawn (the starting point)
Inline trigger scripts — on triggers, run on activation/deactivation
External script files  — called by inline scripts for complex logic
Mission init script    — special file that runs once at mission start
</code></pre>
<p>The tiered model: most users never write a script. Some write one-liners on entities. A few create external files. The progression is seamless — there’s no cliff between “visual editing” and “programming,” just a gentle slope that starts with <code>this:set_stance("hold")</code>.</p>
<h3 id="variables-panel"><a class="header" href="#variables-panel">Variables Panel</a></h3>
<p>AoE2 scenario designers used invisible units placed off-screen as makeshift variables. StarCraft modders abused the “deaths” counter as integer storage. Both are hacks because the editors lacked native state management.</p>
<p>IC provides a <strong>Variables Panel</strong> — mission-wide state visible and editable in the GUI. Triggers and modules can read/write variables without Lua.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variable Type</th><th>Example</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><strong>Switch</strong></td><td><code>bridge_destroyed</code> (on/off)</td><td>Boolean flags for trigger conditions</td></tr>
<tr><td><strong>Counter</strong></td><td><code>waves_survived</code> (integer)</td><td>Counting events, tracking progress</td></tr>
<tr><td><strong>Timer</strong></td><td><code>mission_clock</code> (ticks)</td><td>Elapsed time tracking</td></tr>
<tr><td><strong>Text</strong></td><td><code>player_callsign</code> (string)</td><td>Dynamic text for briefings/dialogue</td></tr>
</tbody>
</table>
</div>
<p><strong>Variable operations in triggers (no Lua required):</strong></p>
<ul>
<li>Set variable, increment/decrement counter, toggle switch</li>
<li>Condition: “IF <code>waves_survived</code> &gt;= 5 → trigger victory”</li>
<li>Module connection: Wave Spawner increments <code>waves_survived</code> after each wave</li>
</ul>
<p>Variables are visible in the Variables Panel, named by the designer, and referenced by name everywhere. Lua scripts access them via <code>Var.get("waves_survived")</code> / <code>Var.set("waves_survived", 5)</code>. All variables are deterministic sim state (included in snapshots and replays).</p>
<h3 id="scenario-complexity-meter"><a class="header" href="#scenario-complexity-meter">Scenario Complexity Meter</a></h3>
<p>Inspired by TimeSplitters’ memory bar — a persistent, always-visible indicator of scenario complexity and estimated performance impact.</p>
<pre><code>┌──────────────────────────────────────────────┐
│  Complexity: ████████████░░░░░░░░  58%       │
│  Entities: 247/500  Triggers: 34/200         │
│  Scripts: 3 files   Regions: 12              │
└──────────────────────────────────────────────┘
</code></pre>
<p>The meter reflects:</p>
<ul>
<li><strong>Entity count</strong> vs recommended maximum (per target platform)</li>
<li><strong>Trigger count</strong> and nesting depth</li>
<li><strong>Script complexity</strong> (line count, hook count)</li>
<li><strong>Estimated tick cost</strong> — based on entity types and AI behaviors</li>
</ul>
<p>The meter is a <strong>guideline, not a hard limit</strong>. Exceeding 100% shows a warning (“This scenario may perform poorly on lower-end hardware”) but doesn’t prevent saving or publishing. Power users can push past it; casual creators stay within safe bounds without thinking about performance.</p>
<h3 id="trigger-organization"><a class="header" href="#trigger-organization">Trigger Organization</a></h3>
<p>The AoE2 Scenario Editor’s trigger list collapses into an unmanageable wall at 200+ triggers — no folders, no search, no visual overview. IC prevents this from day one:</p>
<ul>
<li><strong>Folders</strong> — group triggers by purpose (“Phase 1”, “Enemy AI”, “Cinematics”, “Victory Conditions”)</li>
<li><strong>Search / Filter</strong> — find triggers by name, condition type, connected entity, or variable reference</li>
<li><strong>Color coding</strong> — triggers inherit their folder’s color for visual scanning</li>
<li><strong>Flow graph view</strong> — toggle between list view and a visual node graph showing trigger chains, connections to modules, and variable flow. Read-only visualization, not a node-based editor (that’s the “Alternatives Considered” item). Lets designers see the big picture of complex mission logic without reading every trigger.</li>
<li><strong>Collapse / expand</strong> — folders collapse to single lines; individual triggers collapse to show only name + condition summary</li>
</ul>
<h3 id="undo--redo"><a class="header" href="#undo--redo">Undo / Redo</a></h3>
<p>OFP’s editor shipped without undo. Eden added it 15 years later. IC ships with full undo/redo from day one.</p>
<ul>
<li><strong>Unlimited undo stack</strong> (bounded by memory, not count)</li>
<li>Covers all operations: entity placement/deletion/move, trigger edits, terrain painting, variable changes, layer operations</li>
<li><strong>Redo</strong> restores undone actions until a new action branches the history</li>
<li>Undo history survives save/load within a session</li>
<li><strong>Ctrl+Z / Ctrl+Y</strong> (desktop), equivalent bindings on controller</li>
</ul>
<h3 id="autosave--crash-recovery"><a class="header" href="#autosave--crash-recovery">Autosave &amp; Crash Recovery</a></h3>
<p>OFP’s editor had no undo and no autosave — one misclick or crash could destroy hours of work. IC ships with both from day one.</p>
<ul>
<li><strong>Autosave</strong> — configurable interval (default: every 5 minutes). Writes to a rotating set of 3 autosave slots so a corrupted save doesn’t overwrite the only backup</li>
<li><strong>Pre-preview save</strong> — the editor automatically saves a snapshot before entering preview mode. If the game crashes during preview, the editor state is preserved</li>
<li><strong>Recovery on launch</strong> — if the editor detects an unclean shutdown (crash), it offers to restore from the most recent autosave: “The editor was not closed properly. Restore from autosave (2 minutes ago)? [Restore] [Discard]”</li>
<li><strong>Undo history persistence</strong> — the undo stack is included in autosaves. Restoring from autosave also restores the ability to undo recent changes</li>
<li><strong>Manual save is always available</strong> — Ctrl+S saves to the scenario file. Autosave supplements manual save, never replaces it</li>
</ul>
<h3 id="trigger-system-rts-adapted"><a class="header" href="#trigger-system-rts-adapted">Trigger System (RTS-Adapted)</a></h3>
<p>OFP’s trigger system adapted for RTS gameplay:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Area</strong></td><td>Rectangle or ellipse on the isometric map (cell-aligned or free-form)</td></tr>
<tr><td><strong>Activation</strong></td><td>Who triggers it: Any Player / Specific Player / Any Unit / Faction Units / No Unit (condition-only)</td></tr>
<tr><td><strong>Condition Type</strong></td><td>Present / Not Present / Destroyed / Built / Captured / Harvested</td></tr>
<tr><td><strong>Custom Condition</strong></td><td>Lua expression (e.g., <code>Player.cash(1) &gt;= 5000</code>)</td></tr>
<tr><td><strong>Repeatable</strong></td><td>Once or Repeatedly (with re-arm)</td></tr>
<tr><td><strong>Timer</strong></td><td>Countdown (fires after delay, condition can lapse) or Timeout (condition must persist for full duration)</td></tr>
<tr><td><strong>Timer Values</strong></td><td>Min / Mid / Max — randomized, gravitating toward Mid. Prevents predictable timing.</td></tr>
<tr><td><strong>Trigger Type</strong></td><td>None / Victory / Defeat / Reveal Area / Spawn Wave / Play Audio / Weather Change / Reinforcements / Objective Update</td></tr>
<tr><td><strong>On Activation</strong></td><td>Advanced: Lua script</td></tr>
<tr><td><strong>On Deactivation</strong></td><td>Advanced: Lua script (repeatable triggers only)</td></tr>
<tr><td><strong>Effects</strong></td><td>Play music / Play sound / Play video / Show message / Camera flash / Screen shake / Enter cinematic mode</td></tr>
</tbody>
</table>
</div>
<p><strong>RTS-specific trigger conditions:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Condition</th><th>Description</th><th>OFP Equivalent</th></tr>
</thead>
<tbody>
<tr><td><code>faction_present</code></td><td>Any unit of faction X is alive inside the trigger area</td><td>Side Present</td></tr>
<tr><td><code>faction_not_present</code></td><td>No units of faction X inside trigger area</td><td>Side Not Present</td></tr>
<tr><td><code>building_destroyed</code></td><td>Specific building is destroyed</td><td>N/A</td></tr>
<tr><td><code>building_captured</code></td><td>Specific building changed ownership</td><td>N/A</td></tr>
<tr><td><code>building_built</code></td><td>Player has constructed building type X</td><td>N/A</td></tr>
<tr><td><code>unit_count</code></td><td>Faction has ≥ N units of type X alive</td><td>N/A</td></tr>
<tr><td><code>resources_collected</code></td><td>Player has harvested ≥ N resources</td><td>N/A</td></tr>
<tr><td><code>timer_elapsed</code></td><td>N ticks since mission start (or since trigger activation)</td><td>N/A</td></tr>
<tr><td><code>area_seized</code></td><td>Faction dominates the trigger area (adapted from OFP’s “Seized by”)</td><td>Seized by Side</td></tr>
<tr><td><code>all_destroyed_in_area</code></td><td>Every enemy unit/building inside the area is destroyed</td><td>N/A</td></tr>
<tr><td><code>custom_lua</code></td><td>Arbitrary Lua expression</td><td>Custom Condition</td></tr>
</tbody>
</table>
</div>
<p><strong>Countdown vs Timeout with Min/Mid/Max</strong> is crucial for RTS missions. Example: “Reinforcements arrive 3–7 minutes after the player captures the bridge” (Countdown, Min=3m, Mid=5m, Max=7m). The player can’t memorize the exact timing. In OFP, this was the key to making missions feel alive rather than scripted.</p>
<h3 id="module-system-pre-packaged-logic-nodes"><a class="header" href="#module-system-pre-packaged-logic-nodes">Module System (Pre-Packaged Logic Nodes)</a></h3>
<p>Modules are IC’s equivalent of Eden Editor’s 154 built-in modules — complex game logic packaged as drag-and-drop nodes with a properties panel. Non-programmers get 80% of the power without writing Lua.</p>
<p><strong>Built-in module library (initial set):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Module</th><th>Parameters</th><th>Logic</th></tr>
</thead>
<tbody>
<tr><td><strong>Spawning</strong></td><td>Wave Spawner</td><td>waves[], interval, escalation, entry_points[]</td><td>Spawns enemy units in configurable waves</td></tr>
<tr><td><strong>Spawning</strong></td><td>Reinforcements</td><td>units[], entry_point, trigger, delay</td><td>Sends units from map edge on trigger</td></tr>
<tr><td><strong>Spawning</strong></td><td>Probability Group</td><td>units[], probability 0–100%</td><td>Group exists only if random roll passes (visual wrapper around Probability of Presence)</td></tr>
<tr><td><strong>AI Behavior</strong></td><td>Patrol Route</td><td>waypoints[], alert_radius, response</td><td>Units cycle waypoints, engage if threat detected</td></tr>
<tr><td><strong>AI Behavior</strong></td><td>Guard Position</td><td>position, radius, priority</td><td>Units defend location; peel to attack nearby threats (OFP Guard/Guarded By pattern)</td></tr>
<tr><td><strong>AI Behavior</strong></td><td>Hunt and Destroy</td><td>area, unit_types[], aggression</td><td>AI actively searches for and engages enemies in area</td></tr>
<tr><td><strong>AI Behavior</strong></td><td>Harvest Zone</td><td>area, harvesters, refinery</td><td>AI harvests resources in designated zone</td></tr>
<tr><td><strong>Objectives</strong></td><td>Destroy Target</td><td>target, description, optional</td><td>Player must destroy specific building/unit</td></tr>
<tr><td><strong>Objectives</strong></td><td>Capture Building</td><td>building, description, optional</td><td>Player must engineer-capture building</td></tr>
<tr><td><strong>Objectives</strong></td><td>Defend Position</td><td>area, duration, description</td><td>Player must keep faction presence in area for N ticks</td></tr>
<tr><td><strong>Objectives</strong></td><td>Timed Objective</td><td>target, time_limit, failure_consequence</td><td>Objective with countdown timer</td></tr>
<tr><td><strong>Objectives</strong></td><td>Escort Convoy</td><td>convoy_units[], route, description</td><td>Protect moving units along a path</td></tr>
<tr><td><strong>Events</strong></td><td>Reveal Map Area</td><td>area, trigger, delay</td><td>Removes shroud from an area</td></tr>
<tr><td><strong>Events</strong></td><td>Play Briefing</td><td>text, audio_ref, portrait</td><td>Shows briefing panel with text and audio</td></tr>
<tr><td><strong>Events</strong></td><td>Camera Pan</td><td>from, to, duration, trigger</td><td>Cinematic camera movement on trigger</td></tr>
<tr><td><strong>Events</strong></td><td>Weather Change</td><td>type, intensity, transition_time, trigger</td><td>Changes weather on trigger activation</td></tr>
<tr><td><strong>Events</strong></td><td>Dialogue</td><td>lines[], trigger</td><td>In-game dialogue sequence</td></tr>
<tr><td><strong>Flow</strong></td><td>Mission Timer</td><td>duration, visible, warning_threshold</td><td>Global countdown affecting mission end</td></tr>
<tr><td><strong>Flow</strong></td><td>Checkpoint</td><td>trigger, save_state</td><td>Auto-save when trigger fires</td></tr>
<tr><td><strong>Flow</strong></td><td>Branch</td><td>condition, true_path, false_path</td><td>Campaign branching point (D021)</td></tr>
<tr><td><strong>Flow</strong></td><td>Difficulty Gate</td><td>min_difficulty, entities[]</td><td>Entities only exist above threshold difficulty</td></tr>
<tr><td><strong>Effects</strong></td><td>Explosion</td><td>position, size, trigger</td><td>Cosmetic explosion on trigger</td></tr>
<tr><td><strong>Effects</strong></td><td>Sound Emitter</td><td>sound_ref, trigger, loop, 3d</td><td>Play sound effect — positional (3D) or global</td></tr>
<tr><td><strong>Effects</strong></td><td>Music Trigger</td><td>track, trigger, fade_time</td><td>Change music track on trigger activation</td></tr>
<tr><td><strong>Media</strong></td><td>Video Playback</td><td>video_ref, trigger, display_mode, skippable</td><td>Play video — fullscreen, radar_comm, or picture_in_picture (see 04-MODDING.md)</td></tr>
<tr><td><strong>Media</strong></td><td>Cinematic Sequence</td><td>steps[], trigger, skippable</td><td>Chain camera pans + dialogue + music + video + letterbox into a scripted sequence</td></tr>
<tr><td><strong>Media</strong></td><td>Ambient Sound Zone</td><td>region, sound_ref, volume, falloff</td><td>Looping positional audio tied to a named region (forest, river, factory hum)</td></tr>
<tr><td><strong>Media</strong></td><td>Music Playlist</td><td>tracks[], mode, trigger</td><td>Set active playlist — sequential, shuffle, or dynamic (combat/ambient/tension)</td></tr>
<tr><td><strong>Media</strong></td><td>Radar Comm</td><td>portrait, audio_ref, text, duration, trigger</td><td>RA2-style comm overlay in radar panel — portrait + voice + subtitle (no video required)</td></tr>
<tr><td><strong>Media</strong></td><td>EVA Notification</td><td>event_type, text, audio_ref, trigger</td><td>Play EVA-style notification with audio + text banner</td></tr>
<tr><td><strong>Media</strong></td><td>Letterbox Mode</td><td>trigger, duration, enter_time, exit_time</td><td>Toggle cinematic letterbox bars — hides HUD, enters cinematic aspect ratio</td></tr>
<tr><td><strong>Multiplayer</strong></td><td>Spawn Point</td><td>faction, position</td><td>Player starting location in MP scenarios</td></tr>
<tr><td><strong>Multiplayer</strong></td><td>Crate Drop</td><td>position, trigger, contents</td><td>Random powerup/crate on trigger</td></tr>
<tr><td><strong>Multiplayer</strong></td><td>Spectator Bookmark</td><td>position, label, trigger, camera_angle</td><td>Author-defined camera bookmark for spectator/replay mode — marks key locations and dramatic moments. Spectators can cycle bookmarks with hotkeys. Replays auto-cut to bookmarks when triggered.</td></tr>
<tr><td><strong>Tutorial</strong></td><td>Tutorial Step</td><td>step_id, title, hint, completion, focus_area, highlight_ui, eva_line</td><td>Defines a tutorial step with instructional overlay, completion condition, and optional camera/UI focus. Equivalent to <code>Tutorial.SetStep()</code> in Lua but configurable without scripting. Connects to triggers for step sequencing. (D065)</td></tr>
<tr><td><strong>Tutorial</strong></td><td>Tutorial Hint</td><td>text, position, duration, icon, eva_line, dismissable</td><td>Shows a one-shot contextual hint. Equivalent to <code>Tutorial.ShowHint()</code> in Lua. Connect to a trigger to control when the hint appears. (D065)</td></tr>
<tr><td><strong>Tutorial</strong></td><td>Tutorial Gate</td><td>allowed_build_types[], allowed_orders[], restrict_sidebar</td><td>Restricts player actions for pedagogical pacing — limits what can be built or ordered until a trigger releases the gate. Equivalent to <code>Tutorial.RestrictBuildOptions()</code> / <code>Tutorial.RestrictOrders()</code> in Lua. (D065)</td></tr>
<tr><td><strong>Tutorial</strong></td><td>Skill Check</td><td>action_type, target_count, time_limit</td><td>Monitors player performance on a specific action (selection speed, combat accuracy, etc.) and fires success/fail outputs. Used for skill assessment exercises and remedial branching. (D065)</td></tr>
</tbody>
</table>
</div>
<p>Modules connect to triggers and other entities via <strong>visual connection lines</strong> — same as OFP’s synchronization system. A “Reinforcements” module connected to a trigger means the reinforcements arrive when the trigger fires. No scripting required.</p>
<p><strong>Custom modules</strong> can be created by modders — a YAML definition + Lua implementation, publishable via Workshop (D030). The community can extend the module library indefinitely.</p>
<h3 id="compositions-reusable-building-blocks"><a class="header" href="#compositions-reusable-building-blocks">Compositions (Reusable Building Blocks)</a></h3>
<p>Compositions are saved groups of entities, triggers, modules, and connections — like Eden Editor’s custom compositions. They bridge the gap between individual entity placement and full scene templates (04-MODDING.md).</p>
<p><strong>Hierarchy:</strong></p>
<pre><code>Entity           — single unit, building, trigger, or module
  ↓ grouped into
Composition      — reusable cluster (base layout, defensive formation, scripted encounter)
  ↓ assembled into
Scenario         — complete mission with objectives, terrain, all compositions placed
  ↓ sequenced into (via Campaign Editor)
Campaign         — branching multi-mission graph with persistent state, intermissions, and dialogue (D021)
</code></pre>
<p><strong>Built-in compositions:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Composition</th><th>Contents</th></tr>
</thead>
<tbody>
<tr><td>Soviet Base (Small)</td><td>Construction Yard, Power Plant, Barracks, Ore Refinery, 3 harvesters, guard units</td></tr>
<tr><td>Allied Outpost</td><td>Pillbox ×2, AA Gun, Power Plant, guard units with patrol waypoints</td></tr>
<tr><td>Ore Field (Rich)</td><td>Ore cells + ore truck spawn trigger</td></tr>
<tr><td>Ambush Point</td><td>Hidden units + area trigger + attack waypoints (Probability of Presence per unit)</td></tr>
<tr><td>Bridge Checkpoint</td><td>Bridge + guarding units + trigger for crossing detection</td></tr>
<tr><td>Air Patrol</td><td>Aircraft with looping patrol waypoints + scramble trigger</td></tr>
<tr><td>Coastal Defense</td><td>Naval turrets + submarine patrol + radar</td></tr>
</tbody>
</table>
</div>
<p><strong>Workflow:</strong></p>
<ol>
<li>Place entities, arrange them, connect triggers/modules</li>
<li>Select all → “Save as Composition” → name, category, description, tags, thumbnail</li>
<li>Composition appears in the Compositions Library panel (searchable, with favorites — same palette UX as the entity panel)</li>
<li>Drag composition onto any map to place a pre-built cluster</li>
<li>Publish to Workshop (D030) — community compositions become shared building blocks</li>
</ol>
<p><strong>Compositions are individually publishable.</strong> Unlike scenarios (which are complete missions), a single composition can be published as a standalone Workshop resource — a “Soviet Base (Large)” layout, a “Scripted Ambush” encounter template, a “Tournament Start” formation. Other designers browse and install individual compositions, just as Garry’s Mod’s Advanced Duplicator lets players share and browse individual contraptions independently of full maps. Composition metadata (name, description, thumbnail, tags, author, dependencies) enables a browsable composition library within the Workshop, not just a flat file list.</p>
<p>This completes the content creation pipeline: compositions are the visual-editor equivalent of scene templates (04-MODDING.md). Scene templates are YAML/Lua for programmatic use and LLM generation. Compositions are the same concept for visual editing. They share the same underlying data format — a composition saved in the editor can be loaded as a scene template by Lua/LLM, and vice versa.</p>
<h3 id="layers"><a class="header" href="#layers">Layers</a></h3>
<p>Organizational folders for managing complex scenarios:</p>
<ul>
<li>Group entities by purpose: “Phase 1 — Base Defense”, “Phase 2 — Counterattack”, “Enemy Patrols”, “Civilian Traffic”</li>
<li><strong>Visibility toggle</strong> — hide layers in the editor without affecting runtime (essential when a mission has 500+ entities)</li>
<li><strong>Lock toggle</strong> — prevent accidental edits to finalized layers</li>
<li><strong>Runtime show/hide</strong> — Lua can show/hide entire layers at runtime: <code>Layer.activate("Phase2_Reinforcements")</code> / <code>Layer.deactivate(...)</code>. Activating a layer spawns all entities in it as a batch; deactivating despawns them. These are <strong>sim operations</strong> (deterministic, included in snapshots and replays), not editor operations — the Lua API name uses <code>Layer</code>, not <code>Editor</code>, to make the boundary clear. Internally, each entity has a <code>layer: Option&lt;String&gt;</code> field; activation toggles a per-layer <code>active</code> flag that the spawn system reads. Entities in inactive layers do not exist in the sim — they are serialized in the scenario file but not instantiated until activation. <strong>Deactivation is destructive:</strong> calling <code>Layer.deactivate()</code> despawns all entities in the layer — any runtime state (damage taken, position changes, veterancy gained) is lost. Re-activating the layer spawns fresh copies from the scenario template. This is intentional: layers model “reinforcement waves” and “phase transitions,” not pausable unit groups. For scenarios that need to preserve unit state across activation cycles, use Lua variables or campaign state (D021) to snapshot and restore specific values</li>
</ul>
<h3 id="media--cinematics"><a class="header" href="#media--cinematics">Media &amp; Cinematics</a></h3>
<p>Original Red Alert’s campaign identity was defined as much by its media as its gameplay — FMV briefings before missions, the radar panel switching to a video feed during gameplay, Hell March driving the combat tempo, EVA voice lines as constant tactical feedback. A campaign editor that can’t orchestrate media is a campaign editor that can’t recreate what made C&amp;C campaigns feel like C&amp;C campaigns.</p>
<p>The modding layer (<code>04-MODDING.md</code>) defines the primitives: <code>video_playback</code> scene templates with display modes (<code>fullscreen</code>, <code>radar_comm</code>, <code>picture_in_picture</code>), <code>scripted_scene</code> templates, and the <code>Media</code> Lua global. The scenario editor surfaces all of these as <strong>visual modules</strong> — no Lua required for standard use, Lua available for advanced control.</p>
<h4 id="video-playback"><a class="header" href="#video-playback">Video Playback</a></h4>
<p>The <strong>Video Playback</strong> module plays video files (<code>.vqa</code>, <code>.mp4</code>, <code>.webm</code>) at a designer-specified trigger point. Three display modes (from <code>04-MODDING.md</code>):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Display Mode</th><th>Behavior</th><th>Inspiration</th></tr>
</thead>
<tbody>
<tr><td><code>fullscreen</code></td><td>Pauses gameplay, fills screen, letterboxed. Classic FMV briefing.</td><td>RA1 mission briefings</td></tr>
<tr><td><code>radar_comm</code></td><td>Video replaces the radar/minimap panel. Game continues. Sidebar stays functional.</td><td>RA2 EVA / commander video calls</td></tr>
<tr><td><code>picture_in_picture</code></td><td>Small floating video overlay in a corner. Game continues. Dismissible.</td><td>Modern RTS cinematics</td></tr>
</tbody>
</table>
</div>
<p><strong>Module properties in the editor:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Video</strong></td><td>file picker</td><td>Video file reference (from mission assets or Workshop dependency)</td></tr>
<tr><td><strong>Display mode</strong></td><td>dropdown</td><td><code>fullscreen</code> / <code>radar_comm</code> / <code>picture_in_picture</code></td></tr>
<tr><td><strong>Trigger</strong></td><td>connection</td><td>When to play — connected to a trigger, module, or “mission start”</td></tr>
<tr><td><strong>Skippable</strong></td><td>checkbox</td><td>Whether the player can press Escape to skip</td></tr>
<tr><td><strong>Subtitle</strong></td><td>text (optional)</td><td>Subtitle text shown during playback (accessibility)</td></tr>
<tr><td><strong>On Complete</strong></td><td>connection (optional)</td><td>Trigger or module to activate when the video finishes</td></tr>
</tbody>
</table>
</div>
<p><strong>Radar Comm</strong> deserves special emphasis — it’s the feature that makes in-mission storytelling possible without interrupting gameplay. A commander calls in during a battle, their face appears in the radar panel, they deliver a line, and the radar returns. The designer connects a Video Playback (mode: <code>radar_comm</code>) to a trigger, and that’s it. No scripting, no timeline editor, no separate cinematic tool.</p>
<p>For missions without custom video, the <strong>Radar Comm</strong> module (separate from Video Playback) provides the same radar-panel takeover using a static portrait + audio + subtitle text — the RA2 communication experience without requiring video production.</p>
<h4 id="cinematic-sequences"><a class="header" href="#cinematic-sequences">Cinematic Sequences</a></h4>
<p>Individual modules (Camera Pan, Video Playback, Dialogue, Music Trigger) handle single media events. A <strong>Cinematic Sequence</strong> chains them into a scripted multi-step sequence — the editor equivalent of a cutscene director.</p>
<p><strong>Sequence step types:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Step Type</th><th>Parameters</th><th>What It Does</th></tr>
</thead>
<tbody>
<tr><td><code>camera_pan</code></td><td>from, to, duration, easing</td><td>Smooth camera movement between positions</td></tr>
<tr><td><code>camera_shake</code></td><td>intensity, duration</td><td>Screen shake (explosion, impact)</td></tr>
<tr><td><code>dialogue</code></td><td>speaker, portrait, text, audio_ref, duration</td><td>Character speech bubble / subtitle overlay</td></tr>
<tr><td><code>play_video</code></td><td>video_ref, display_mode</td><td>Video playback (any display mode)</td></tr>
<tr><td><code>play_music</code></td><td>track, fade_in</td><td>Music change with crossfade</td></tr>
<tr><td><code>play_sound</code></td><td>sound_ref, position (optional)</td><td>Sound effect — positional or global</td></tr>
<tr><td><code>wait</code></td><td>duration</td><td>Pause between steps (in game ticks or seconds)</td></tr>
<tr><td><code>spawn_units</code></td><td>units[], position, faction</td><td>Dramatic unit reveal (reinforcements arriving on-camera)</td></tr>
<tr><td><code>destroy</code></td><td>target</td><td>Scripted destruction (building collapses, bridge blows)</td></tr>
<tr><td><code>weather</code></td><td>type, intensity, transition_time</td><td>Weather change synchronized with the sequence</td></tr>
<tr><td><code>letterbox</code></td><td>enable/disable, transition_time</td><td>Toggle cinematic letterbox bars</td></tr>
<tr><td><code>set_variable</code></td><td>name, value</td><td>Set a mission or campaign variable during the sequence</td></tr>
<tr><td><code>lua</code></td><td>script</td><td>Advanced: arbitrary Lua for anything not covered above</td></tr>
</tbody>
</table>
</div>
<p><strong>Cinematic Sequence module properties:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Steps</strong></td><td>ordered list</td><td>Sequence of steps (drag-to-reorder in the editor)</td></tr>
<tr><td><strong>Trigger</strong></td><td>connection</td><td>When to start the sequence</td></tr>
<tr><td><strong>Skippable</strong></td><td>checkbox</td><td>Whether the player can skip the entire sequence</td></tr>
<tr><td><strong>Pause sim</strong></td><td>checkbox</td><td>Whether gameplay pauses during the sequence (default: yes)</td></tr>
<tr><td><strong>Letterbox</strong></td><td>checkbox</td><td>Auto-enter letterbox mode when sequence starts (default: yes)</td></tr>
<tr><td><strong>On Complete</strong></td><td>connection (optional)</td><td>What fires when the sequence finishes</td></tr>
</tbody>
</table>
</div>
<p><strong>Visual editing:</strong> Steps are shown as a vertical timeline in the module’s expanded properties panel. Each step has a colored icon by type. Drag steps to reorder. Click a camera_pan step to see from/to positions highlighted on the map. Click “Preview from step” to test a subsequence without playing the whole thing.</p>
<p><strong>Example — mission intro cinematic:</strong></p>
<pre><code>Cinematic Sequence: "Mission 3 Intro"
  Trigger: mission_start
  Skippable: yes
  Pause sim: yes

  Steps:
  1. [letterbox]   enable, 0.5s transition
  2. [camera_pan]  from: player_base → to: enemy_fortress, 3s, ease_in_out
  3. [dialogue]    Stavros: "The enemy has fortified the river crossing."
  4. [play_sound]  artillery_distant.wav (global)
  5. [camera_shake] intensity: 0.3, duration: 0.5s
  6. [camera_pan]  to: bridge_crossing, 2s
  7. [dialogue]    Tanya: "I see a weak point in their eastern wall."
  8. [play_music]  "hell_march_v2", fade_in: 2s
  9. [letterbox]   disable, 0.5s transition
</code></pre>
<p>This replaces what would be 40+ lines of Lua with a visual drag-and-drop sequence. The designer sees the whole flow, reorders steps, previews specific moments, and never touches code.</p>
<h4 id="dynamic-music"><a class="header" href="#dynamic-music">Dynamic Music</a></h4>
<p><code>ic-audio</code> supports dynamic music states (combat/ambient/tension) that respond to game state (see <code>13-PHILOSOPHY.md</code> — Klepacki’s game-tempo philosophy). The editor exposes this through two mechanisms:</p>
<p><strong>1. Music Trigger module</strong> — simple track swap on trigger activation. Already in the module table. Good for scripted moments (“play Hell March when the tanks roll out”).</p>
<p><strong>2. Music Playlist module</strong> — manages an active playlist with playback modes:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>sequential</code></td><td>Play tracks in order, loop</td></tr>
<tr><td><code>shuffle</code></td><td>Random order, no immediate repeats</td></tr>
<tr><td><code>dynamic</code></td><td>Engine selects track based on game state — <code>combat</code> / <code>ambient</code> / <code>tension</code> / <code>victory</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Dynamic mode</strong> is the key feature. The designer tags tracks by mood:</p>
<pre><code class="language-yaml">music_playlist:
  combat:
    - hell_march
    - grinder
    - drill
  ambient:
    - fogger
    - trenches
    - mud
  tension:
    - radio_2
    - face_the_enemy
  victory:
    - credits
</code></pre>
<p>The engine monitors game state (active combat, unit losses, base threat, objective progress) and crossfades between mood categories automatically. No triggers required — the music responds to what’s happening. The designer curates the playlist; the engine handles transitions.</p>
<p><strong>Crossfade control:</strong> Music Trigger and Music Playlist modules both support <code>fade_time</code> — the duration of the crossfade between the current track and the new one. Default: 2 seconds. Set to 0 for a hard cut (dramatic moments).</p>
<h4 id="ambient-sound-zones"><a class="header" href="#ambient-sound-zones">Ambient Sound Zones</a></h4>
<p><strong>Ambient Sound Zone</strong> modules tie looping environmental audio to named regions. Walk units near a river — hear water. Move through a forest — hear birds and wind. Approach a factory — hear industrial machinery.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Region</strong></td><td>region picker</td><td>Named region this sound zone covers</td></tr>
<tr><td><strong>Sound</strong></td><td>file picker</td><td>Looping audio file</td></tr>
<tr><td><strong>Volume</strong></td><td>slider 0–100%</td><td>Base volume at the center of the region</td></tr>
<tr><td><strong>Falloff</strong></td><td>slider</td><td>How quickly sound fades at region edges (sharp → gradual)</td></tr>
<tr><td><strong>Active</strong></td><td>checkbox</td><td>Whether the zone starts active (can be toggled by triggers/Lua)</td></tr>
<tr><td><strong>Layer</strong></td><td>text</td><td>Optional layer assignment — zone activates/deactivates with its layer</td></tr>
</tbody>
</table>
</div>
<p>Ambient Sound Zones are <strong>render-side only</strong> (<code>ic-audio</code>) — they have zero sim impact and are not deterministic. They exist purely for atmosphere. The sound is spatialized: the camera’s position determines what the player hears and at what volume.</p>
<p>Multiple overlapping zones blend naturally. A bridge over a river in a forest plays water + birds + wind, with each source fading based on camera proximity to its region.</p>
<h4 id="eva-notification-system"><a class="header" href="#eva-notification-system">EVA Notification System</a></h4>
<p>EVA voice lines are how C&amp;C communicates game events to the player — “Construction complete,” “Unit lost,” “Enemy approaching.” The editor exposes EVA as a module for custom notifications:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Event type</strong></td><td>dropdown</td><td><code>custom</code> / <code>warning</code> / <code>info</code> / <code>critical</code></td></tr>
<tr><td><strong>Text</strong></td><td>text</td><td>Notification text shown in the message area</td></tr>
<tr><td><strong>Audio</strong></td><td>file picker</td><td>Voice line audio file</td></tr>
<tr><td><strong>Trigger</strong></td><td>connection</td><td>When to fire the notification</td></tr>
<tr><td><strong>Cooldown</strong></td><td>slider</td><td>Minimum time before this notification can fire again</td></tr>
<tr><td><strong>Priority</strong></td><td>dropdown</td><td><code>low</code> / <code>normal</code> / <code>high</code> / <code>critical</code></td></tr>
</tbody>
</table>
</div>
<p>Priority determines queuing behavior — critical notifications interrupt lower-priority ones; low-priority notifications wait. This prevents EVA spam during intense battles while ensuring critical alerts always play.</p>
<p><strong>Built-in EVA events</strong> (game module provides defaults for standard events: unit lost, building destroyed, harvester under attack, insufficient funds, etc.). Custom EVA modules are for mission-specific notifications — “The bridge has been rigged with explosives,” “Reinforcements are en route.”</p>
<h4 id="letterbox--cinematic-mode"><a class="header" href="#letterbox--cinematic-mode">Letterbox / Cinematic Mode</a></h4>
<p>The <strong>Letterbox Mode</strong> module toggles cinematic presentation:</p>
<ul>
<li><strong>Letterbox bars</strong> — black bars at top and bottom of screen, creating a widescreen aspect ratio</li>
<li><strong>HUD hidden</strong> — sidebar, minimap, resource bar, unit selection all hidden</li>
<li><strong>Input restricted</strong> — player cannot issue orders (optional — some sequences allow camera panning)</li>
<li><strong>Transition time</strong> — bars slide in/out smoothly (configurable)</li>
</ul>
<p>Letterbox mode is automatically entered by Cinematic Sequences when <code>letterbox: true</code> (the default). It can also be triggered independently — a Letterbox Mode module connected to a trigger enters cinematic mode for dramatic moments without a full sequence (e.g., a dramatic camera pan to a nuclear explosion, then back to gameplay).</p>
<h4 id="media-in-campaigns"><a class="header" href="#media-in-campaigns">Media in Campaigns</a></h4>
<p>All media modules work within the campaign editor’s intermission system:</p>
<ul>
<li><strong>Fullscreen video</strong> before missions (briefing FMVs)</li>
<li><strong>Music Playlist</strong> per campaign node (each mission can have its own playlist, or inherit from the campaign default)</li>
<li><strong>Dialogue with audio</strong> in intermission screens — character portraits with voice-over</li>
<li><strong>Ambient sound</strong> in intermission screens (command tent ambiance, war room hum)</li>
</ul>
<p>The campaign node properties (briefing, debriefing) support media references:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Briefing video</strong></td><td>file picker</td><td>Optional FMV played before the mission (fullscreen)</td></tr>
<tr><td><strong>Briefing audio</strong></td><td>file picker</td><td>Voice-over for text briefing (if no video)</td></tr>
<tr><td><strong>Briefing music</strong></td><td>track picker</td><td>Music playing during the briefing screen</td></tr>
<tr><td><strong>Debrief audio</strong></td><td>file picker (×N)</td><td>Per-outcome voice-over for debrief screens</td></tr>
<tr><td><strong>Debrief video</strong></td><td>file picker (×N)</td><td>Per-outcome FMV (optional)</td></tr>
</tbody>
</table>
</div>
<p>This means a campaign creator can build the full original RA experience — FMV briefing → mission with in-game radar comms → debrief with per-outcome results — entirely through the visual editor.</p>
<h4 id="lua-media-api-advanced"><a class="header" href="#lua-media-api-advanced">Lua Media API (Advanced)</a></h4>
<p>All media modules map to Lua functions for advanced scripting. The <code>Media</code> global (OpenRA-compatible, D024) provides the baseline; IC extensions add richer control:</p>
<pre><code class="language-lua">-- OpenRA-compatible (work identically)
Media.PlaySpeech("eva_building_captured")    -- EVA notification
Media.PlaySound("explosion_large")           -- Sound effect
Media.PlayMusic("hell_march")                -- Music track
Media.DisplayMessage("Bridge destroyed!", "warning")  -- Text message

-- IC extensions (additive)
Media.PlayVideo("briefing_03.vqa", "fullscreen", { skippable = true })
Media.PlayVideo("commander_call.mp4", "radar_comm")
Media.PlayVideo("heli_arrives.webm", "picture_in_picture")

Media.SetMusicPlaylist({ "hell_march", "grinder" }, "shuffle")
Media.SetMusicMode("dynamic")    -- switch to dynamic mood-based selection
Media.CrossfadeTo("fogger", 3.0) -- manual crossfade with duration

Media.SetAmbientZone("forest_region", "birds_wind.ogg", { volume = 0.7 })
Media.SetAmbientZone("river_region", "water_flow.ogg", { volume = 0.5 })

-- Cinematic sequence from Lua (for procedural cutscenes)
local seq = Media.CreateSequence({ skippable = true, pause_sim = true })
seq:AddStep("letterbox", { enable = true, transition = 0.5 })
seq:AddStep("camera_pan", { to = bridge_pos, duration = 3.0 })
seq:AddStep("dialogue", { speaker = "Tanya", text = "I see them.", audio = "tanya_03.wav" })
seq:AddStep("play_sound", { ref = "artillery.wav" })
seq:AddStep("camera_shake", { intensity = 0.4, duration = 0.5 })
seq:AddStep("letterbox", { enable = false, transition = 0.5 })
seq:Play()
</code></pre>
<p>The visual modules and Lua API are interchangeable — a Cinematic Sequence created in the editor generates the same data as one built in Lua. Advanced users can start with the visual editor and extend with Lua; Lua-first users get the same capabilities without the GUI.</p>
<h3 id="preview--test"><a class="header" href="#preview--test">Preview / Test</a></h3>
<ul>
<li><strong>Preview button</strong> — starts the sim from current editor state. Play the mission, then return to editor. No compilation, no export, no separate process.</li>
<li><strong>Play from cursor</strong> — start the preview with the camera at the current editor position (Eden Editor’s “play from here”)</li>
<li><strong>Speed controls</strong> — preview at 2x/4x/8x to quickly reach later mission stages</li>
<li><strong>Instant restart</strong> — reset to editor state without re-entering the editor</li>
</ul>
<h3 id="simple-vs-advanced-mode"><a class="header" href="#simple-vs-advanced-mode">Simple vs Advanced Mode</a></h3>
<p>Inspired by OFP’s Easy/Advanced toggle:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Simple Mode</th><th>Advanced Mode</th></tr>
</thead>
<tbody>
<tr><td>Entity placement</td><td>✓</td><td>✓</td></tr>
<tr><td>Faction/facing/health</td><td>✓</td><td>✓</td></tr>
<tr><td>Basic triggers (win/lose/timer)</td><td>✓</td><td>✓</td></tr>
<tr><td>Waypoints (move/patrol/guard)</td><td>✓</td><td>✓</td></tr>
<tr><td>Modules</td><td>✓</td><td>✓</td></tr>
<tr><td>Probability of Presence</td><td>—</td><td>✓</td></tr>
<tr><td>Condition of Presence</td><td>—</td><td>✓</td></tr>
<tr><td>Custom Lua conditions</td><td>—</td><td>✓</td></tr>
<tr><td>Init scripts per entity</td><td>—</td><td>✓</td></tr>
<tr><td>Countdown/Timeout timers</td><td>—</td><td>✓</td></tr>
<tr><td>Min/Mid/Max randomization</td><td>—</td><td>✓</td></tr>
<tr><td>Connection lines</td><td>—</td><td>✓</td></tr>
<tr><td>Layer management</td><td>—</td><td>✓</td></tr>
<tr><td>Campaign editor</td><td>—</td><td>✓</td></tr>
<tr><td>Named regions</td><td>—</td><td>✓</td></tr>
<tr><td>Variables panel</td><td>—</td><td>✓</td></tr>
<tr><td>Inline Lua scripts on entities</td><td>—</td><td>✓</td></tr>
<tr><td>External script files panel</td><td>—</td><td>✓</td></tr>
<tr><td>Trigger folders &amp; flow graph</td><td>—</td><td>✓</td></tr>
<tr><td>Media modules (basic)</td><td>✓</td><td>✓</td></tr>
<tr><td>Video playback</td><td>✓</td><td>✓</td></tr>
<tr><td>Music trigger / playlist</td><td>✓</td><td>✓</td></tr>
<tr><td>Cinematic sequences</td><td>—</td><td>✓</td></tr>
<tr><td>Ambient sound zones</td><td>—</td><td>✓</td></tr>
<tr><td>Letterbox / cinematic mode</td><td>—</td><td>✓</td></tr>
<tr><td>Lua Media API</td><td>—</td><td>✓</td></tr>
<tr><td>Intermission screens</td><td>—</td><td>✓</td></tr>
<tr><td>Dialogue editor</td><td>—</td><td>✓</td></tr>
<tr><td>Campaign state dashboard</td><td>—</td><td>✓</td></tr>
<tr><td>Multiplayer / co-op properties</td><td>—</td><td>✓</td></tr>
<tr><td>Game mode templates</td><td>✓</td><td>✓</td></tr>
</tbody>
</table>
</div>
<p>Simple mode covers 80% of what a casual scenario creator needs. Advanced mode exposes the full power. Same data format — a mission created in Simple mode can be opened in Advanced mode and extended.</p>
<h3 id="campaign-editor"><a class="header" href="#campaign-editor">Campaign Editor</a></h3>
<p>D021 defines the campaign <em>system</em> — branching mission graphs, persistent rosters, story flags. But a system without an editor means campaigns are hand-authored YAML, which limits who can create them. The Campaign Editor makes D021’s full power visual.</p>
<p>Every RTS editor ever shipped treats missions as isolated units. Warcraft III’s World Editor came closest — it had a campaign screen with mission ordering and global variables — but even that was a flat list with linear flow. No visual branching, no state flow visualization, no intermission screens, no dialogue trees. The result: almost nobody creates custom RTS campaigns, because the tooling makes it miserable.</p>
<p>The Campaign Editor operates at a level above the Scenario Editor. Where the Scenario Editor zooms into one mission, the Campaign Editor zooms out to see the entire campaign structure. Double-click a mission node → the Scenario Editor opens for that mission. Back out → you’re at the campaign graph again.</p>
<h4 id="visual-campaign-graph"><a class="header" href="#visual-campaign-graph">Visual Campaign Graph</a></h4>
<p>The core view: missions as nodes, outcomes as directed edges.</p>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                    Campaign: Red Tide Rising                     │
│                                                                  │
│    ┌─────────┐   victory    ┌──────────┐   bridge_held           │
│    │ Mission │─────────────→│ Mission  │───────────────→ ...     │
│    │   1     │              │   2      │                         │
│    │ Beach   │   defeat     │ Bridge   │   bridge_lost           │
│    │ Landing │──────┐       │ Assault  │──────┐                  │
│    └─────────┘      │       └──────────┘      │                  │
│                     │                         │                  │
│                     ▼                         ▼                  │
│               ┌──────────┐             ┌──────────┐             │
│               │ Mission  │             │ Mission  │             │
│               │   1B     │             │   3B     │             │
│               │ Retreat  │             │ Fallback │             │
│               └──────────┘             └──────────┘             │
│                                                                  │
│   [+ Add Mission]  [+ Add Transition]  [Validate Graph]         │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>Node (mission) properties:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Mission file</strong></td><td>Link to the scenario (created in Scenario Editor)</td></tr>
<tr><td><strong>Display name</strong></td><td>Shown in campaign graph and briefing</td></tr>
<tr><td><strong>Outcomes</strong></td><td>Named results this mission can produce (e.g., <code>victory</code>, <code>defeat</code>, <code>bridge_intact</code>)</td></tr>
<tr><td><strong>Briefing</strong></td><td>Text/audio/portrait shown before the mission</td></tr>
<tr><td><strong>Debriefing</strong></td><td>Text/audio shown after the mission, per outcome</td></tr>
<tr><td><strong>Intermission</strong></td><td>Optional between-mission screen (see Intermission Screens below)</td></tr>
<tr><td><strong>Roster in</strong></td><td>What units the player receives: <code>none</code>, <code>carry_forward</code>, <code>preset</code>, <code>merge</code></td></tr>
<tr><td><strong>Roster out</strong></td><td>Carryover mode for surviving units: <code>none</code>, <code>surviving</code>, <code>extracted</code>, <code>selected</code>, <code>custom</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Edge (transition) properties:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>From outcome</strong></td><td>Which named outcome triggers this transition</td></tr>
<tr><td><strong>To mission</strong></td><td>Destination mission node</td></tr>
<tr><td><strong>Condition</strong></td><td>Optional Lua expression or story flag check (e.g., <code>Flag.get("scientist_rescued")</code>)</td></tr>
<tr><td><strong>Weight</strong></td><td>Probability weight when multiple edges share the same outcome (see below)</td></tr>
<tr><td><strong>Roster filter</strong></td><td>Override roster carryover for this specific path</td></tr>
</tbody>
</table>
</div>
<h4 id="randomized-and-conditional-paths"><a class="header" href="#randomized-and-conditional-paths">Randomized and Conditional Paths</a></h4>
<p>D021 defines deterministic branching — outcome X always leads to mission Y. The Campaign Editor extends this with weighted and conditional edges, enabling randomized campaign structures.</p>
<p><strong>Weighted random:</strong> When multiple edges share the same outcome, weights determine probability. The roll is seeded from the campaign save (deterministic for replays).</p>
<pre><code class="language-yaml"># Mission 3 outcome "victory" → random next mission
transitions:
  - from_outcome: victory
    to: mission_4a_snow      # weight 40%
    weight: 40
  - from_outcome: victory
    to: mission_4b_desert    # weight 60%
    weight: 60
</code></pre>
<p>Visually in the graph editor, weighted edges show their probability and use varying line thickness.</p>
<p><strong>Conditional edges:</strong> An edge with a condition is only eligible if the condition passes. Conditions are evaluated before weights. This enables “if you rescued the scientist, always go to the lab mission; otherwise, random between two alternatives.”</p>
<p><strong>Mission pools:</strong> A pool node represents “pick N missions from this set” — the campaign equivalent of side quests. The player gets a random subset, plays them in any order, then proceeds. Enables roguelike campaign structures.</p>
<pre><code>┌──────────┐         ┌─────────────────┐         ┌──────────┐
│ Mission  │────────→│   Side Mission   │────────→│ Mission  │
│    3     │         │   Pool (2 of 5)  │         │    4     │
└──────────┘         │                  │         └──────────┘
                     │ ☐ Raid Supply    │
                     │ ☐ Rescue POWs    │
                     │ ☐ Sabotage Rail  │
                     │ ☐ Defend Village │
                     │ ☐ Naval Strike   │
                     └─────────────────┘
</code></pre>
<p>Mission pools are a natural fit for the persistent roster system — side missions that strengthen (or deplete) the player’s forces before a major battle.</p>
<h4 id="classic-globe-mission-select-ra1-style"><a class="header" href="#classic-globe-mission-select-ra1-style">Classic Globe Mission Select (RA1-Style)</a></h4>
<p>The original Red Alert featured a <strong>globe screen</strong> between certain missions — the camera zooms to a region, and the player chooses between 2-3 highlighted countries to attack next. “Do we strike Greece or Turkey?” Each choice leads to a different mission variant, and the unchosen mission is skipped. This was one of RA1’s most memorable campaign features — the feeling that <em>you</em> decided where the war went next. It was also one of the things OpenRA never reproduced; OpenRA campaigns are strictly linear mission lists.</p>
<p>IC supports this natively. It’s not a special mode — it falls out of the existing building blocks:</p>
<p><strong>How it works:</strong> A campaign graph node has multiple outgoing edges. Instead of selecting the next mission via a text menu or automatic branching, the campaign uses a <strong>World Map intermission</strong> to present the choice visually. The player sees the map with highlighted regions, picks one, and that edge is taken.</p>
<pre><code class="language-yaml"># Campaign graph — classic RA globe-style mission select
nodes:
  mission_5:
    name: "Allies Regroup"
    # After completing this mission, show the globe
    post_intermission:
      template: world-map
      config:
        zoom_to: "eastern_mediterranean"
        choices:
          - region: greece
            label: "Strike Athens"
            target_node: mission_6a_greece
            briefing_preview: "Greek resistance is weak. Take the port city."
          - region: turkey
            label: "Assault Istanbul"
            target_node: mission_6b_turkey
            briefing_preview: "Istanbul controls the straits. High risk, strategic value."
        display:
          highlight_available: true      # glow effect on selectable regions
          show_enemy_strength: true      # "Light/Medium/Heavy resistance"
          camera_animation: globe_spin   # classic RA globe spin to region

  mission_6a_greece:
    name: "Mediterranean Assault"
    # ... mission definition

  mission_6b_turkey:
    name: "Straits of War"
    # ... mission definition
</code></pre>
<p>This is a <strong>D021 branching campaign</strong> with a <strong>D038 World Map intermission</strong> as the branch selector. The campaign graph has the branching structure; the world map is just the presentation layer for the player’s choice. No strategic territory tracking, no force pools, no turn-based meta-layer — just a map that asks “where do you want to fight next?”</p>
<p><strong>Comparison to World Domination:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Globe Mission Select (RA1-style)</th><th>World Domination</th></tr>
</thead>
<tbody>
<tr><td><strong>Purpose</strong></td><td>Choose between pre-authored mission variants</td><td>Emergent strategic territory war</td></tr>
<tr><td><strong>Number of choices</strong></td><td>2-3 per decision point</td><td>All adjacent regions</td></tr>
<tr><td><strong>Missions</strong></td><td>Pre-authored (designer-created)</td><td>Generated from strategic state</td></tr>
<tr><td><strong>Map role</strong></td><td>Presentation for a branch choice</td><td>Primary campaign interface</td></tr>
<tr><td><strong>Territory tracking</strong></td><td>None — cosmetic only</td><td>Full (gains, losses, garrisons)</td></tr>
<tr><td><strong>Complexity</strong></td><td>Simple — just a campaign graph + map UI</td><td>Complex — full strategic layer</td></tr>
<tr><td><strong>OpenRA support</strong></td><td>No</td><td>No</td></tr>
<tr><td><strong>IC support</strong></td><td>Yes — D021 graph + D038 World Map intermission</td><td>Yes — World Domination mode (D016)</td></tr>
</tbody>
</table>
</div>
<p>The globe mission select is the <strong>simplest</strong> use of the world map component — a visual branch selector for hand-crafted campaigns. World Domination is the most complex — a full strategic meta-layer. Everything in between is supported too: a map that shows your progress through a linear campaign (locations lighting up as you complete them), a map with side-mission markers, a map that shows enemy territory shrinking as you advance.</p>
<p><strong>RA1 game module default:</strong> The Red Alert game module ships with a campaign that recreates the original RA1 globe-style mission select at the same decision points as the original game. When the original RA1 campaign asked “Greece or Turkey?”, IC’s RA1 campaign shows the same choice on the same map — but with IC’s modern World Map renderer instead of the original 320×200 pre-rendered globe FMV.</p>
<h4 id="persistent-state-dashboard"><a class="header" href="#persistent-state-dashboard">Persistent State Dashboard</a></h4>
<p>The biggest reason campaign creation is painful in every RTS editor: you can’t see what state flows between missions. Story flags are set in Lua buried inside mission scripts. Roster carryover is configured in YAML you never visualize. Variables disappear between missions unless you manually manage them.</p>
<p>The <strong>Persistent State Dashboard</strong> makes campaign state visible and editable in the GUI.</p>
<p><strong>Roster view:</strong></p>
<pre><code>┌──────────────────────────────────────────────────────┐
│  Campaign Roster                                      │
│                                                       │
│  Mission 1 → Mission 2:  Carryover: surviving         │
│  ├── Tanya (named hero)     ★ Must survive            │
│  ├── Medium Tanks ×4        ↝ Survivors carry forward  │
│  └── Engineers ×2           ↝ Survivors carry forward  │
│                                                       │
│  Mission 2 → Mission 3:  Carryover: extracted          │
│  ├── Extraction zone: bridge_south                    │
│  └── Only units in zone at mission end carry forward  │
│                                                       │
│  Named Characters: Tanya, Volkov, Stavros              │
│  Equipment Pool: Captured MiG, Prototype Chrono        │
└──────────────────────────────────────────────────────┘
</code></pre>
<p><strong>Story flags view:</strong> A table of every flag across the entire campaign — where it’s set, where it’s read, current value in test runs. See at a glance: “The flag <code>bridge_destroyed</code> is set in Mission 2’s trigger #14, read in Mission 4’s Condition of Presence on the bridge entity and Mission 5’s briefing text.”</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Flag</th><th>Set in</th><th>Read in</th><th>Type</th></tr>
</thead>
<tbody>
<tr><td><code>bridge_destroyed</code></td><td>Mission 2, trigger 14</td><td>Mission 4 (CoP), Mission 5 (briefing)</td><td>switch</td></tr>
<tr><td><code>scientist_rescued</code></td><td>Mission 3, Lua script</td><td>Mission 4 (edge condition)</td><td>switch</td></tr>
<tr><td><code>tanks_captured</code></td><td>Mission 2, debrief</td><td>Mission 3 (roster merge)</td><td>counter</td></tr>
<tr><td><code>player_reputation</code></td><td>Multiple missions</td><td>Mission 6 (dialogue branches)</td><td>counter</td></tr>
</tbody>
</table>
</div>
<p><strong>Campaign variables:</strong> Separate from per-mission variables (Variables Panel). Campaign variables persist across ALL missions. Per-mission variables reset. The dashboard shows which scope each variable belongs to and highlights conflicts (same name in both scopes).</p>
<h4 id="intermission-screens"><a class="header" href="#intermission-screens">Intermission Screens</a></h4>
<p>Between missions, the player sees an intermission — not just a text briefing, but a customizable screen layout. This is where campaigns become more than “mission list” and start feeling like a <em>game within the game</em>.</p>
<p><strong>Built-in intermission templates:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Template</th><th>Layout</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><strong>Briefing Only</strong></td><td>Portrait + text + “Begin Mission” button</td><td>Simple campaigns, classic RA style</td></tr>
<tr><td><strong>Roster Management</strong></td><td>Unit list with keep/dismiss, equipment assignment, formation arrangement</td><td>OFP: Resistance style unit management</td></tr>
<tr><td><strong>Base Screen</strong></td><td>Persistent base view — spend resources on upgrades that carry forward</td><td>Between-mission base building (C&amp;C3 style)</td></tr>
<tr><td><strong>Shop / Armory</strong></td><td>Campaign inventory + purchase panel + currency</td><td>RPG-style equipment management</td></tr>
<tr><td><strong>Dialogue</strong></td><td>Portrait + branching text choices (see Dialogue Editor below)</td><td>Story-driven campaigns, RPG conversations</td></tr>
<tr><td><strong>World Map</strong></td><td>Map with mission locations — player chooses next mission from available nodes. In World Domination campaigns (D016), shows faction territories, frontlines, and the LLM-generated briefing for the next mission</td><td>Non-linear campaigns, World Domination</td></tr>
<tr><td><strong>Debrief + Stats</strong></td><td>Mission results, casualties, performance grade, story flag changes</td><td>Post-mission feedback</td></tr>
<tr><td><strong>Credits</strong></td><td>Auto-scrolling text with section headers, role/name columns, optional background video/image and music track. Supports contributor photos, logo display, and “special thanks” sections. Speed and style (classic scroll / paginated / cinematic) configurable per-campaign.</td><td>Campaign completion, mod credits, jam credits</td></tr>
<tr><td><strong>Custom</strong></td><td>Empty canvas — arrange any combination of panels via the layout editor</td><td>Total creative freedom</td></tr>
</tbody>
</table>
</div>
<p>Intermissions are defined per campaign node (between “finish Mission 2” and “start Mission 3”). They can chain: debrief → roster management → briefing → begin mission. A typical campaign ending chains: final debrief → credits → return to campaign select (or main menu).</p>
<p><strong>Intermission panels (building blocks):</strong></p>
<ul>
<li><strong>Text panel</strong> — rich text with variable substitution (<code>"Commander, we lost {Var.get('casualties')} soldiers."</code>).</li>
<li><strong>Portrait panel</strong> — character portrait + name. Links to Named Characters.</li>
<li><strong>Roster panel</strong> — surviving units from previous mission. Player can dismiss, reorganize, assign equipment.</li>
<li><strong>Inventory panel</strong> — campaign-wide items. Drag onto units to equip. Purchase from shop with campaign currency.</li>
<li><strong>Choice panel</strong> — buttons that set story flags or campaign variables. “Execute the prisoner? [Yes] [No]” → sets <code>prisoner_executed</code> flag.</li>
<li><strong>Map panel</strong> — shows campaign geography. Highlights available next missions if using mission pools. In World Domination mode, renders the world map with faction-colored regions, animated frontlines, and narrative briefing panel. The LLM presents the next mission through the briefing; the player sees their territory and the story context, not a strategy game menu.</li>
<li><strong>Stats panel</strong> — mission performance: time, casualties, objectives completed, units destroyed.</li>
<li><strong>Credits panel</strong> — auto-scrolling rich text optimized for credits display. Supports section headers (“Cast,” “Design,” “Special Thanks”), two-column role/name layout, contributor portraits, logo images, and configurable scroll speed. The text source can be inline, loaded from a <code>credits.yaml</code> file (for reuse across campaigns), or generated dynamically via Lua. Scroll style options: <code>classic</code> (continuous upward scroll, Star Wars / RA1 style), <code>paginated</code> (fade between pages), <code>cinematic</code> (camera-tracked text over background video). Music reference plays for the duration. The panel emits a <code>credits_finished</code> event when scrolling completes — chain to a Choice panel (“Play Again?” / “Return to Menu”) or auto-advance.</li>
<li><strong>Custom Lua panel</strong> — advanced panel that runs arbitrary Lua to generate content dynamically.</li>
</ul>
<p>These panels compose freely. A “Base Screen” template is just a preset arrangement: roster panel on the left, inventory panel center, stats panel right, briefing text bottom. The Custom template starts empty and lets the designer arrange any combination.</p>
<p><strong>Per-player intermission variants:</strong> In co-op campaigns, each intermission can optionally define per-player layouts. The intermission editor exposes a “Player Variant” selector: Default (all players see the same screen) or per-slot overrides (Player 1 sees layout A, Player 2 sees layout B). Per-player briefing text is always supported regardless of this setting. Per-player layouts go further — different panel arrangements, different choice options, different map highlights per player slot. This is what makes co-op campaigns feel like each player has a genuine role, not just a shared screen. Variant layouts share the same panel library; only the arrangement and content differ.</p>
<h4 id="dialogue-editor"><a class="header" href="#dialogue-editor">Dialogue Editor</a></h4>
<p>Branching dialogue isn’t RPG-exclusive — it’s what separates a campaign with a story from a campaign that’s just a mission list. “Commander, we’ve intercepted enemy communications. Do we attack now or wait for reinforcements?” That’s a dialogue tree. The choice sets a story flag that changes the next mission’s layout.</p>
<p>The Dialogue Editor is a visual branching tree editor, similar to tools like Twine or Ink but built into the scenario editor.</p>
<pre><code>┌──────────────────────────────────────────────────────┐
│  Dialogue: Mission 3 Briefing                         │
│                                                       │
│  ┌────────────────────┐                               │
│  │ STAVROS:            │                               │
│  │ "The bridge is       │                               │
│  │  heavily defended." │                               │
│  └────────┬───────────┘                               │
│           │                                            │
│     ┌─────┴─────┐                                      │
│     │           │                                      │
│  ┌──▼───┐  ┌───▼────┐                                  │
│  │Attack│  │Flank   │                                  │
│  │Now   │  │Through │                                  │
│  │      │  │Forest  │                                  │
│  └──┬───┘  └───┬────┘                                  │
│     │          │                                       │
│  sets:       sets:                                     │
│  approach=   approach=                                 │
│  "direct"    "flank"                                   │
│     │          │                                       │
│  ┌──▼──────────▼──┐                                    │
│  │ TANYA:          │                                    │
│  │ "I'll take       │                                    │
│  │  point."         │                                    │
│  └─────────────────┘                                    │
└──────────────────────────────────────────────────────┘
</code></pre>
<p><strong>Dialogue node properties:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Speaker</strong></td><td>Character name + portrait reference</td></tr>
<tr><td><strong>Text</strong></td><td>Dialogue line (supports variable substitution)</td></tr>
<tr><td><strong>Audio</strong></td><td>Optional voice-over reference</td></tr>
<tr><td><strong>Choices</strong></td><td>Player responses — each is an outgoing edge</td></tr>
<tr><td><strong>Condition</strong></td><td>Node only appears if condition is true (enables adaptive dialogue)</td></tr>
<tr><td><strong>Effects</strong></td><td>On reaching this node: set flags, adjust variables, give items</td></tr>
</tbody>
</table>
</div>
<p><strong>Conditional dialogue:</strong> Nodes can have conditions — “Only show this line if <code>scientist_rescued</code> is true.” This means the same dialogue tree adapts to campaign state. A character references events from earlier missions without the designer creating separate trees per path.</p>
<p><strong>Dialogue in missions:</strong> Dialogue trees aren’t limited to intermissions. They can trigger during a mission — an NPC unit triggers a dialogue when approached or when a trigger fires. The dialogue pauses the game (or runs alongside it, designer’s choice) and the player’s choice sets flags that affect the mission in real-time.</p>
<h4 id="named-characters"><a class="header" href="#named-characters">Named Characters</a></h4>
<p>A <strong>named character</strong> is a persistent entity identity that survives across missions. Not a specific unit instance (those die) — a character definition that can have multiple appearances.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Name</strong></td><td>Display name (“Tanya”, “Commander Volkov”)</td></tr>
<tr><td><strong>Portrait</strong></td><td>Image reference for dialogue and intermission screens</td></tr>
<tr><td><strong>Unit type</strong></td><td>Default unit type when spawned (can change per mission)</td></tr>
<tr><td><strong>Traits</strong></td><td>Arbitrary key-value pairs (strength, charisma, rank — designer-defined)</td></tr>
<tr><td><strong>Inventory</strong></td><td>Items this character carries (from campaign inventory system)</td></tr>
<tr><td><strong>Biography</strong></td><td>Text shown in roster screen, updated by Lua as the campaign progresses</td></tr>
<tr><td><strong>Must survive</strong></td><td>If true, character death → mission failure (or specific outcome)</td></tr>
<tr><td><strong>Death outcome</strong></td><td>Named outcome triggered if this character dies (e.g., <code>tanya_killed</code>)</td></tr>
</tbody>
</table>
</div>
<p>Named characters bridge scenarios and intermissions. Tanya in Mission 1 is the same Tanya in Mission 5 — same veterancy, same kill count, same equipment. If she dies in Mission 3 and doesn’t have “must survive,” the campaign continues without her — and future dialogue trees skip her lines via conditions.</p>
<p>This is the primitive that makes RPG campaigns possible. A designer creates 6 named characters, gives them traits and portraits, writes dialogue between them, and lets the player manage their roster between missions. That’s an RPG party in an RTS shell — no engine changes required, just creative use of the campaign editor’s building blocks.</p>
<h4 id="campaign-inventory"><a class="header" href="#campaign-inventory">Campaign Inventory</a></h4>
<p>Persistent items that exist at the campaign level, not within any specific mission.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Name</strong></td><td>Item identifier (<code>prototype_chrono</code>, <code>captured_mig</code>)</td></tr>
<tr><td><strong>Display</strong></td><td>Name, icon, description shown in intermission screens</td></tr>
<tr><td><strong>Quantity</strong></td><td>Stack count (1 for unique items, N for consumables)</td></tr>
<tr><td><strong>Category</strong></td><td>Grouping for inventory panel (equipment, intel, resources)</td></tr>
<tr><td><strong>Effects</strong></td><td>Optional Lua — what happens when used/equipped</td></tr>
<tr><td><strong>Assignable</strong></td><td>Can be assigned to named characters in roster screen</td></tr>
</tbody>
</table>
</div>
<p>Items are added via Lua (<code>Campaign.add_item("captured_mig", 1)</code>) or via debrief/intermission choices. They’re spent, equipped, or consumed in later missions or intermissions.</p>
<p>Combined with named characters and the roster screen: a player captures enemy equipment in Mission 2, assigns it to a character in the intermission, and that character spawns with it in Mission 3. The system is general-purpose — “items” can be weapons, vehicles, intel documents, key cards, magical artifacts, or anything the designer defines.</p>
<h4 id="campaign-testing"><a class="header" href="#campaign-testing">Campaign Testing</a></h4>
<p>The Campaign Editor includes tools for testing campaign flow without playing every mission to completion:</p>
<ul>
<li><strong>Graph validation</strong> — checks for dead ends (outcomes with no outgoing edge), unreachable missions, circular paths (unless intentional), and missing mission files</li>
<li><strong>Jump to mission</strong> — start any mission with simulated campaign state (set flags, roster, and inventory to test a specific path)</li>
<li><strong>Fast-forward state</strong> — manually set campaign variables and flags to simulate having played earlier missions</li>
<li><strong>Path coverage</strong> — highlights which campaign paths have been test-played and which haven’t. Color-coded: green (tested), yellow (partially tested), red (untested)</li>
<li><strong>Campaign playthrough</strong> — play the entire campaign with accelerated sim (or auto-resolve missions) to verify flow and state propagation</li>
<li><strong>State inspector</strong> — during preview, shows live campaign state: current flags, roster, inventory, variables, which path was taken</li>
</ul>
<h4 id="reference-material-campaign-editors"><a class="header" href="#reference-material-campaign-editors">Reference Material (Campaign Editors)</a></h4>
<p>The campaign editor design draws from these (in addition to the scenario editor references above):</p>
<ul>
<li><strong>Warcraft III World Editor (2002):</strong> The closest any RTS came to campaign editing — campaign screen with mission ordering, cinematic editor, global variables persistent across maps. Still linear and limited: no visual branching, no roster management, no intermission screen customization. IC takes WC3’s foundation and adds the graph, state, and intermission layers.</li>
<li><strong>RPG Maker (1992–present):</strong> Campaign-level persistent variables, party management, item/equipment systems, branching dialogue. Proves these systems work for non-programmers. IC adapts the persistence model for RTS context.</li>
<li><strong>Twine / Ink (interactive fiction tools):</strong> Visual branching narrative editors. Twine’s node-and-edge graph directly inspired IC’s campaign graph view. Ink’s conditional text (“You remember the bridge{bridge_destroyed: ’s destruction| still standing}”) inspired IC’s variable substitution in dialogue.</li>
<li><strong>Heroes of Might and Magic III (1999):</strong> Campaign with carryover — hero stats, army, artifacts persist between maps. Proved that persistent state between RTS-adjacent missions creates investment. Limited to linear ordering.</li>
<li><strong>FTL / Slay the Spire (roguelikes):</strong> Randomized mission path selection, persistent resources, risk/reward side missions. Inspired IC’s mission pools and weighted random paths.</li>
<li><strong>OFP: Resistance (2002):</strong> The gold standard for persistent campaigns — surviving soldiers, captured equipment, emotional investment. Every feature in IC’s campaign editor exists because OFP: Resistance proved persistent campaigns are transformative.</li>
</ul>
<h3 id="game-master-mode-zeus-inspired"><a class="header" href="#game-master-mode-zeus-inspired">Game Master Mode (Zeus-Inspired)</a></h3>
<p>A real-time scenario manipulation mode where one player (the Game Master) controls the scenario while others play. Derived from the scenario editor’s UI but operates on a live game.</p>
<p><strong>Use cases:</strong></p>
<ul>
<li><strong>Cooperative campaigns</strong> — a human GM controls the enemy faction, placing reinforcements, directing attacks, adjusting difficulty in real-time based on how players are doing</li>
<li><strong>Training</strong> — a GM creates escalating challenges for new players</li>
<li><strong>Events</strong> — community game nights with a live GM creating surprises</li>
<li><strong>Content testing</strong> — mission designers test their scenarios with real players while making live adjustments</li>
</ul>
<p><strong>Game Master controls:</strong></p>
<ul>
<li>Place/remove units and buildings (from a budget — prevents flooding)</li>
<li>Direct AI unit groups (attack here, retreat, patrol)</li>
<li>Change weather, time of day</li>
<li>Trigger scripted events (reinforcements, briefings, explosions)</li>
<li>Reveal/hide map areas</li>
<li>Adjust resource levels</li>
<li>Pause sim for dramatic reveals (if all players agree)</li>
</ul>
<p><strong>Not included at launch:</strong> Player control of individual units (RTS is about armies, not individual soldiers). The GM operates at the strategic level — directing groups, managing resources, triggering events.</p>
<p><strong>Per-player undo:</strong> In multiplayer editing contexts (and Game Master mode specifically), undo is scoped per-actor. The GM’s undo reverts only GM actions, not player orders or other players’ actions. This follows Garry’s Mod’s per-player undo model — in a shared session, pressing undo reverts YOUR last action, not the last global action. For the single-player editor, undo is global (only one actor).</p>
<p><strong>Phase:</strong> Game Master mode is a Phase 6b deliverable. It reuses 90% of the scenario editor’s systems — the main new work is the real-time overlay UI and budget/permission system.</p>
<h3 id="publishing"><a class="header" href="#publishing">Publishing</a></h3>
<p>Scenarios created in the editor export as standard IC mission format (YAML map + Lua scripts + assets). They can be:</p>
<ul>
<li>Saved locally</li>
<li>Published to Workshop (D030) with one click</li>
<li>Shared as files</li>
<li>Used in campaigns (D021) — or created directly in the Campaign Editor</li>
<li>Assembled into full campaigns and published as campaign packs</li>
<li>Loaded by the LLM for remixing (D016)</li>
</ul>
<h3 id="replay-to-scenario-pipeline"><a class="header" href="#replay-to-scenario-pipeline">Replay-to-Scenario Pipeline</a></h3>
<p>Replays are the richest source of gameplay data in any RTS — every order, every battle, every building placement, every dramatic moment. IC already stores replays as deterministic order streams and enriches them with structured gameplay events (D031) in SQLite (D034). The Replay-to-Scenario pipeline turns that data into editable scenarios.</p>
<p>Replays already contain what’s hardest to design from scratch: pacing, escalation, and dramatic turning points. The pipeline extracts that structure into an editable scenario skeleton — a designer adds narrative and polish on top.</p>
<h4 id="two-modes-direct-extraction-and-llm-generation"><a class="header" href="#two-modes-direct-extraction-and-llm-generation">Two Modes: Direct Extraction and LLM Generation</a></h4>
<p><strong>Direct extraction (no LLM required):</strong> Deterministic, mechanical conversion of replay data into editor entities. This always works, even without an LLM configured.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Extracted Element</th><th>Source Data</th><th>Editor Result</th></tr>
</thead>
<tbody>
<tr><td><strong>Map &amp; terrain</strong></td><td>Replay’s initial map state</td><td>Full terrain imported — tiles, resources, cliffs, water</td></tr>
<tr><td><strong>Starting positions</strong></td><td>Initial unit/building placements per player</td><td>Entities placed with correct faction, position, facing</td></tr>
<tr><td><strong>Movement paths</strong></td><td><code>OrderIssued</code> (move orders) over time</td><td>Waypoints along actual routes taken — patrol paths, attack routes, retreat lines</td></tr>
<tr><td><strong>Build order timeline</strong></td><td><code>BuildingPlaced</code> events with tick timestamps</td><td>Building entities with <code>timer_elapsed</code> triggers matching the original timing</td></tr>
<tr><td><strong>Combat hotspots</strong></td><td>Clusters of <code>CombatEngagement</code> events in spatial proximity</td><td>Named regions at cluster centroids — “Combat Zone 1 (2400, 1800),” “Combat Zone 2 (800, 3200).” The LLM path (below) upgrades these to human-readable names like “Bridge Assault” using map feature context.</td></tr>
<tr><td><strong>Unit composition</strong></td><td><code>UnitCreated</code> events per faction per time window</td><td>Wave Spawner modules mimicking the original army buildup timing</td></tr>
<tr><td><strong>Key moments</strong></td><td>Spikes in event density (kills/sec, orders/sec)</td><td>Trigger markers at dramatic moments — editor highlights them in the timeline</td></tr>
<tr><td><strong>Resource flow</strong></td><td><code>HarvestDelivered</code> events</td><td>Resource deposits and harvester assignments matching the original economy</td></tr>
</tbody>
</table>
</div>
<p>The result: a scenario skeleton with correct terrain, unit placements, waypoints tracing the actual battle flow, and trigger points at dramatic moments. It’s mechanically accurate but has no story — no briefing, no objectives, no dialogue. A designer opens it in the editor and adds narrative on top.</p>
<p><strong>LLM-powered generation (D016, requires LLM configured):</strong> The LLM reads the gameplay event log and generates the narrative layer that direct extraction can’t provide.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Generated Element</th><th>LLM Input</th><th>LLM Output</th></tr>
</thead>
<tbody>
<tr><td><strong>Mission briefing</strong></td><td>Event timeline summary, factions, map name, outcome</td><td>“Commander, intelligence reports enemy armor massing at the river crossing…”</td></tr>
<tr><td><strong>Objectives</strong></td><td>Key events + outcome</td><td>Primary: “Destroy the enemy base.” Secondary: “Capture the tech center before it’s razed.”</td></tr>
<tr><td><strong>Dialogue</strong></td><td>Combat events, faction interactions, dramatic moments</td><td>In-mission dialogue triggered at key moments — characters react to what originally happened</td></tr>
<tr><td><strong>Difficulty curve</strong></td><td>Event density over time, casualty rates</td><td>Wave timing and composition tuned to recreate the original difficulty arc</td></tr>
<tr><td><strong>Story context</strong></td><td>Faction composition, map geography, battle outcome</td><td>Narrative framing that makes the mechanical events feel like a story</td></tr>
<tr><td><strong>Named characters</strong></td><td>High-performing units (most kills, longest survival)</td><td>Surviving units promoted to named characters with generated backstories</td></tr>
<tr><td><strong>Alternative paths</strong></td><td>What-if analysis of critical moments</td><td>Branch points: “What if the bridge assault failed?” → generates alternate mission variant</td></tr>
</tbody>
</table>
</div>
<p>The LLM output is standard YAML + Lua — the same format as hand-crafted missions. Everything is editable in the editor. The LLM is a starting point, not a black box.</p>
<h4 id="workflow"><a class="header" href="#workflow">Workflow</a></h4>
<pre><code>┌─────────────┐     ┌──────────────────┐     ┌────────────────────┐     ┌──────────────┐
│   Replay    │────→│  Event Log       │────→│  Replay-to-Scenario │────→│   Scenario   │
│   Browser   │     │  (SQLite, D034)  │     │  Pipeline           │     │   Editor     │
└─────────────┘     └──────────────────┘     │                     │     └──────────────┘
                                             │  Direct extraction  │
                                             │  + LLM (optional)   │
                                             └────────────────────┘
</code></pre>
<ol>
<li><strong>Browse replays</strong> — open the replay browser, select a replay (or multiple — a tournament series, a campaign run)</li>
<li><strong>“Create Scenario from Replay”</strong> — button in the replay browser context menu</li>
<li><strong>Import settings dialog:</strong></li>
</ol>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Setting</th><th>Options</th><th>Default</th></tr>
</thead>
<tbody>
<tr><td><strong>Perspective</strong></td><td>Player 1’s view / Player 2’s view / Observer (full map)</td><td>Player 1</td></tr>
<tr><td><strong>Time range</strong></td><td>Full replay / Custom range (tick start – tick end)</td><td>Full replay</td></tr>
<tr><td><strong>Extract waypoints</strong></td><td>All movement / Combat movement only / Key maneuvers only</td><td>Key maneuvers only</td></tr>
<tr><td><strong>Combat zones</strong></td><td>Mark all engagements / Major battles only (threshold)</td><td>Major battles only</td></tr>
<tr><td><strong>Generate narrative</strong></td><td>Yes (requires LLM) / No (direct extraction only)</td><td>Yes if LLM available</td></tr>
<tr><td><strong>Difficulty</strong></td><td>Match original / Easier / Harder / Let LLM tune</td><td>Match original</td></tr>
<tr><td><strong>Playable as</strong></td><td>Player 1’s faction / Player 2’s faction / New player vs AI</td><td>New player vs AI</td></tr>
</tbody>
</table>
</div>
<ol start="4">
<li><strong>Pipeline runs</strong> — extraction is instant (SQL queries on the event log); LLM generation takes seconds to minutes depending on the provider</li>
<li><strong>Open in editor</strong> — the scenario opens with all extracted/generated content. Everything is editable. The designer adds, removes, or modifies anything before publishing.</li>
</ol>
<h4 id="perspective-conversion"><a class="header" href="#perspective-conversion">Perspective Conversion</a></h4>
<p>The key design challenge: a replay is a symmetric record (both sides played). A scenario is asymmetric (the player is one side, the AI is the other). The pipeline handles this conversion:</p>
<ul>
<li><strong>“Playable as Player 1”</strong> — Player 1’s units become the player’s starting forces. Player 2’s units, movements, and build order become AI-controlled entities with waypoints and triggers mimicking the replay behavior.</li>
<li><strong>“Playable as Player 2”</strong> — reversed.</li>
<li><strong>“New player vs AI”</strong> — the player starts fresh. The AI follows a behavior pattern extracted from the better-performing replay side. The LLM (if available) adjusts difficulty so the mission is winnable but challenging.</li>
<li><strong>“Observer (full map)”</strong> — both sides are AI-controlled, recreating the entire battle as a spectacle. Useful for “historical battle” recreations of famous tournament matches.</li>
</ul>
<p>Initial implementation targets 1v1 replays — perspective conversion maps cleanly to “one player side, one AI side.” 2v2 team games work by merging each team’s orders into a single AI side. FFA and larger multiplayer replays require per-faction AI assignment and are deferred to a future iteration. Observer mode is player-count-agnostic (all sides are AI-controlled regardless of player count).</p>
<h4 id="ai-behavior-extraction"><a class="header" href="#ai-behavior-extraction">AI Behavior Extraction</a></h4>
<p>The pipeline converts a player’s replay orders into AI modules that approximate the original behavior at the strategic level. The mapping is deterministic — no LLM required.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Replay Order Type</th><th>AI Module Generated</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>Move orders</td><td>Patrol waypoints</td><td>Unit moved A→B→C → patrol route with 3 waypoints</td></tr>
<tr><td>Attack-move orders</td><td>Attack-move zones</td><td>Attack-move toward (2400, 1800) → attack-move zone centered on that area</td></tr>
<tr><td>Build orders (structures)</td><td>Timed build queue</td><td>Barracks at tick 300, War Factory at tick 600 → build triggers at those offsets</td></tr>
<tr><td>Unit production orders</td><td>Wave Spawner timing</td><td>5 tanks produced ticks 800–1000 → Wave Spawner with matching composition</td></tr>
<tr><td>Harvest orders</td><td>Harvester assignment</td><td>3 harvesters assigned to ore field → harvester waypoints to that resource</td></tr>
</tbody>
</table>
</div>
<p>This isn’t “perfectly replicate a human player” — it’s “create an AI that does roughly the same thing in roughly the same order.” The Probability of Presence system (per-entity randomization) can be applied on top, so replaying the scenario doesn’t produce an identical experience every time.</p>
<p><strong>Crate boundary:</strong> The extraction logic lives in <code>ic-ai</code> behind a <code>ReplayBehaviorExtractor</code> trait. <code>ic-editor</code> calls this trait to generate AI modules from replay data. <code>ic-game</code> wires the concrete implementation. This keeps <code>ic-editor</code> decoupled from AI internals — the same pattern as sim/net separation.</p>
<h4 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h4>
<ul>
<li><strong>“That was an incredible game — let others experience it”</strong> — import your best multiplayer match, add briefing and objectives, publish as a community mission</li>
<li><strong>Tournament highlight missions</strong> — import famous tournament replays, let players play from either side. “Can you do better than the champion?”</li>
<li><strong>Training scenarios</strong> — import a skilled player’s replay, the new player faces an AI that follows the skilled player’s build order and attack patterns</li>
<li><strong>Campaign from history</strong> — import a series of replays from a ladder season or clan war, LLM generates connecting narrative → instant campaign</li>
<li><strong>Modder stress test</strong> — import a replay with 1000+ units to create a performance benchmark scenario</li>
<li><strong>Content creation</strong> — streamers import viewer-submitted replays and remix them into challenge missions live</li>
</ul>
<h4 id="batch-import-replay-series--campaign"><a class="header" href="#batch-import-replay-series--campaign">Batch Import: Replay Series → Campaign</a></h4>
<p>Multiple replays can be imported as a connected campaign:</p>
<ol>
<li>Select multiple replays (e.g., a best-of-5 tournament series)</li>
<li>Pipeline extracts each as a separate mission</li>
<li>LLM (if available) generates connecting narrative: briefings that reference previous missions, persistent characters who survive across matches, escalating stakes</li>
<li>Campaign graph auto-generated: linear (match order) or branching (win/loss → different next mission)</li>
<li>Open in Campaign Editor for refinement</li>
</ol>
<p>This is the fastest path from “cool replays” to “playable campaign” — and it’s entirely powered by existing systems (D016 + D021 + D031 + D034 + D038).</p>
<h4 id="what-this-does-not-do"><a class="header" href="#what-this-does-not-do">What This Does NOT Do</a></h4>
<ul>
<li><strong>Perfectly reproduce a human player’s micro</strong> — AI modules approximate human behavior at the strategic level. Precise micro (target switching, spell timing, retreat feints) is not captured. The goal is “similar army, similar timing, similar aggression,” not “frame-perfect recreation.”</li>
<li><strong>Work on corrupted or truncated replays</strong> — the pipeline requires a complete event log. Partial replays produce partial scenarios (with warnings).</li>
<li><strong>Replace mission design</strong> — direct extraction produces a mechanical skeleton, not a polished mission. The LLM adds narrative, but a human designer’s touch is what makes it feel crafted. The pipeline reduces the work from “start from scratch” to “edit and polish.”</li>
</ul>
<p><strong>Crate boundary for LLM integration:</strong> <code>ic-editor</code> defines a <code>NarrativeGenerator</code> trait (input: replay event summary → output: briefing, objectives, dialogue YAML). <code>ic-llm</code> implements it. <code>ic-game</code> wires the implementation at startup — if no LLM provider is configured, the trait is backed by a no-op that skips narrative generation. <code>ic-editor</code> never imports <code>ic-llm</code> directly. This mirrors the sim/net separation: the editor knows it <em>can</em> request narrative, but has zero knowledge of how it’s generated.</p>
<p><strong>Phase:</strong> Direct extraction ships with the scenario editor in <strong>Phase 6a</strong> (it’s just SQL queries + editor import — no new system needed). LLM-powered narrative generation ships in <strong>Phase 7</strong> (requires <code>ic-llm</code>). Batch campaign import is a <strong>Phase 7</strong> feature built on D021’s campaign graph.</p>
<h3 id="reference-material"><a class="header" href="#reference-material">Reference Material</a></h3>
<p>The scenario editor design draws from:</p>
<ul>
<li><strong>OFP mission editor (2001):</strong> Probability of Presence, triggers with countdown/timeout, Guard/Guarded By, synchronization, Easy/Advanced toggle. The gold standard for “simple, not bloated, not limiting.”</li>
<li><strong>OFP: Resistance (2002):</strong> Persistent campaign — surviving soldiers, captured equipment, emotional investment. The campaign editor exists because Resistance proved persistent campaigns are transformative.</li>
<li><strong>Arma 3 Eden Editor (2016):</strong> 3D placement, modules (154 built-in), compositions, layers, Workshop integration, undo/redo</li>
<li><strong>Arma Reforger Game Master (2022):</strong> Budget system, real-time manipulation, controller support, simplified objectives</li>
<li><strong>Age of Empires II Scenario Editor (1999):</strong> Condition-effect trigger system (the RTS gold standard — 25+ years of community use), trigger areas as spatial logic. Cautionary lesson: flat trigger list collapses at scale — IC adds folders, search, and flow graph to prevent this.</li>
<li><strong>StarCraft Campaign Editor / SCMDraft (1998+):</strong> Named locations (spatial regions referenced by name across triggers). The “location” concept directly inspired IC’s Named Regions. Also: open file format enabled community editors — validates IC’s YAML approach.</li>
<li><strong>Warcraft III World Editor:</strong> GUI-based triggers with conditions, actions, and variables. IC’s module system and Variables Panel serve the same role.</li>
<li><strong>TimeSplitters 2/3 MapMaker (2002/2005):</strong> Visible memory/complexity budget bar — always know what you can afford. Inspired IC’s Scenario Complexity Meter.</li>
<li><strong>Super Mario Maker (2015/2019):</strong> Element interactions create depth without parameter bloat. Behaviors emerge from spatial arrangement. Instant build-test loop measured in seconds.</li>
<li><strong>LittleBigPlanet 2 (2011):</strong> Pre-packaged logic modules (drop-in game patterns). Directly inspired IC’s module system. Cautionary lesson: server shutdown destroyed 10M+ creations — content survival is non-negotiable (IC uses local-first storage + Workshop export).</li>
<li><strong>RPG Maker (1992–present):</strong> Tiered complexity architecture (visual events → scripting). Validates IC’s Simple → Advanced → Lua progression.</li>
<li><strong>Halo Forge (2007–present):</strong> In-game real-time editing with instant playtesting. Evolution from minimal (Halo 3) to powerful (Infinite) proves: ship simple, grow over iterations. Also: game mode prefabs (Strongholds, CTF) that designers customize — directly inspired IC’s Game Mode Templates.</li>
<li><strong>Far Cry 2 Map Editor (2008):</strong> Terrain sculpting separated from mission logic. Proves environment creation and scenario scripting can be independent workflows.</li>
<li><strong>Divinity: Original Sin 2 (2017):</strong> Co-op campaign with persistent state, per-player dialogue choices that affect the shared story. Game Master mode with real-time scenario manipulation. Proved co-op campaign RPG works — and that the tooling for CREATING co-op content matters as much as the runtime support.</li>
<li><strong>Doom community editors (1994–present):</strong> Open data formats enable 30+ years of community tools. The WAD format’s openness is why Doom modding exists — validates IC’s YAML-based scenario format.</li>
<li><strong>OpenRA map editor:</strong> Terrain painting, resource placement, actor placement — standalone tool. IC improves by integrating a full creative toolchain in the SDK (scenario editor + asset studio + campaign editor)</li>
<li><strong>Garry’s Mod (2006–present):</strong> Spawn menu UX (search/favorites/recents for large asset libraries) directly inspired IC’s Entity Palette. Duplication system (save/share/browse entity groups) validates IC’s Compositions. Per-player undo in multiplayer sessions informed IC’s Game Master undo scoping. Community-built tools (Wire Mod, Expression 2) that became indistinguishable from first-party tools proved that a clean tool API matters more than shipping every tool yourself — directly inspired IC’s Workshop-distributed editor plugins. Sandbox mode as the default creative environment validated IC’s Sandbox template as the editor’s default preview mode. Cautionary lesson: unrestricted Lua access enabled the Glue Library incident (malicious addon update) — reinforces IC’s sandboxed Lua model (D004) and Workshop supply chain defenses (D030, <code>06-SECURITY.md</code> § Vulnerability 18)</li>
</ul>
<h3 id="multiplayer--co-op-scenario-tools"><a class="header" href="#multiplayer--co-op-scenario-tools">Multiplayer &amp; Co-op Scenario Tools</a></h3>
<p>Most RTS editors treat multiplayer as an afterthought — place some spawn points, done. Creating a proper co-op mission, a team scenario with split objectives, or a campaign playable by two friends requires hacking around the editor’s single-player assumptions. IC’s editor treats multiplayer and co-op as first-class authoring targets.</p>
<h4 id="player-slot-configuration"><a class="header" href="#player-slot-configuration">Player Slot Configuration</a></h4>
<p>Every scenario has a <strong>Player Slots panel</strong> — the central hub for multiplayer setup.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Slot count</strong></td><td>Number of human player slots (1–8). Solo missions = 1. Co-op = 2+.</td></tr>
<tr><td><strong>Faction</strong></td><td>Which faction each slot controls (or “any” for lobby selection)</td></tr>
<tr><td><strong>Team</strong></td><td>Team assignment (Team 1, Team 2, FFA, Configurable in lobby)</td></tr>
<tr><td><strong>Spawn area</strong></td><td>Starting position/area per slot</td></tr>
<tr><td><strong>Starting units</strong></td><td>Pre-placed entities assigned to this slot</td></tr>
<tr><td><strong>Color</strong></td><td>Default color (overridable in lobby)</td></tr>
<tr><td><strong>AI fallback</strong></td><td>What happens if this slot is unfilled: AI takes over, slot disabled, or required</td></tr>
</tbody>
</table>
</div>
<p>The designer places entities and assigns them to player slots via the Attributes Panel — a dropdown says “belongs to Player 1 / Player 2 / Player 3 / Any.” Triggers and objectives can be scoped to specific slots or shared.</p>
<h4 id="co-op-mission-modes"><a class="header" href="#co-op-mission-modes">Co-op Mission Modes</a></h4>
<p>The editor supports several co-op configurations. These are set per-mission in the scenario properties:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><strong>Allied Factions</strong></td><td>Each player controls a separate allied faction with their own base, army, and economy</td><td>Player 1: Allies infantry push. Player 2: Soviet armor support.</td></tr>
<tr><td><strong>Shared Command</strong></td><td>Players share a single faction. Units can be assigned to specific players or freely controlled by anyone.</td><td>One player manages economy/production, the other commands the army.</td></tr>
<tr><td><strong>Commander + Ops</strong></td><td>One player has the base and production (Commander), the other controls field units only (Operations).</td><td>Commander builds and sends reinforcements. Ops does all the fighting.</td></tr>
<tr><td><strong>Asymmetric</strong></td><td>Players have fundamentally different gameplay. One does RTS, the other does Game Master or support roles.</td><td>Player 1 plays the mission. Player 2 controls enemy as GM.</td></tr>
<tr><td><strong>Split Objectives</strong></td><td>Players have different objectives on the same map. Both must succeed for mission victory.</td><td>Player 1: capture the bridge. Player 2: defend the base.</td></tr>
</tbody>
</table>
</div>
<h4 id="per-player-objectives--triggers"><a class="header" href="#per-player-objectives--triggers">Per-Player Objectives &amp; Triggers</a></h4>
<p>The key to good co-op missions: players need their own goals, not just shared ones.</p>
<ul>
<li><strong>Objective assignment</strong> — each objective module has a “Player” dropdown: All Players, Player 1, Player 2, etc. Shared objectives require all assigned players to contribute. Per-player objectives belong to one player.</li>
<li><strong>Trigger scoping</strong> — triggers can fire based on a specific player’s actions: “When Player 2’s units enter this region” vs “When any allied unit enters this region.” The trigger’s faction/player filter handles this.</li>
<li><strong>Per-player briefings</strong> — the briefing module supports per-slot text: Player 1 sees “Commander, your objective is the bridge…” while Player 2 sees “Comrade, you will hold the flank…”</li>
<li><strong>Split victory conditions</strong> — the mission can require ALL players to complete their individual objectives, or ANY player, or a custom Lua condition combining them.</li>
</ul>
<h4 id="co-op-campaigns"><a class="header" href="#co-op-campaigns">Co-op Campaigns</a></h4>
<p>Co-op extends beyond individual missions into campaigns (D021). The Campaign Editor supports multi-player campaigns with these additional properties per mission node:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Player count</strong></td><td>Min and max human players for this mission (1 for solo-compatible, 2+ for co-op)</td></tr>
<tr><td><strong>Co-op mode</strong></td><td>Which mode applies (see table above)</td></tr>
<tr><td><strong>Solo fallback</strong></td><td>How the mission plays if solo: AI ally, simplified objectives, or unavailable</td></tr>
</tbody>
</table>
</div>
<p><strong>Shared roster management:</strong> In persistent campaigns, the carried-forward roster is shared between co-op players. The intermission screen shows the combined roster with options for dividing control:</p>
<ul>
<li><strong>Draft</strong> — players take turns picking units from the survivor pool (fantasy football for tanks)</li>
<li><strong>Split by type</strong> — infantry to Player 1, vehicles to Player 2 (configured by the scenario designer)</li>
<li><strong>Free claim</strong> — each player grabs what they want from the shared pool, first come first served</li>
<li><strong>Designer-assigned</strong> — the mission YAML specifies which named characters belong to which player slot</li>
</ul>
<p><strong>Drop-in / drop-out:</strong> If a co-op player disconnects mid-mission, their units revert to AI control (or a configurable fallback: pause, auto-extract, or continue without). Reconnection restores control.</p>
<h4 id="multiplayer-testing"><a class="header" href="#multiplayer-testing">Multiplayer Testing</a></h4>
<p>Testing multiplayer scenarios is painful in every editor — you normally need to launch two game instances and play both yourself. IC reduces this friction:</p>
<ul>
<li><strong>Multi-slot preview</strong> — preview the mission with AI controlling unfilled player slots. Test your co-op triggers and per-player objectives without needing a real partner.</li>
<li><strong>Slot switching</strong> — during preview, hot-switch between player viewpoints to verify each player’s experience (camera, fog of war, objectives).</li>
<li><strong>Network delay simulation</strong> — preview with configurable artificial latency to catch timing-sensitive trigger issues in multiplayer.</li>
<li><strong>Lobby preview</strong> — see how the mission appears in the multiplayer lobby before publishing: slot configuration, team layout, map preview, description.</li>
</ul>
<h3 id="game-mode-templates"><a class="header" href="#game-mode-templates">Game Mode Templates</a></h3>
<p>Almost every popular RTS game mode can be built with IC’s existing module system + triggers + Lua. But discoverability matters — a modder shouldn’t need to reinvent the Survival mode from scratch when the pattern is well-known.</p>
<p><strong>Game Mode Templates</strong> are pre-configured scenario setups: a starting point with the right modules, triggers, variables, and victory conditions already wired. The designer customizes the specifics (which units, which map, which waves) without building the infrastructure.</p>
<p><strong>Built-in templates:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Template</th><th>Inspired By</th><th>What’s Pre-Configured</th></tr>
</thead>
<tbody>
<tr><td><strong>Skirmish (Standard)</strong></td><td>Every RTS</td><td>Spawn points, tech tree, resource deposits, standard victory conditions (destroy all enemy buildings)</td></tr>
<tr><td><strong>Survival / Horde</strong></td><td>They Are Billions, CoD Zombies</td><td>Wave Spawners with escalation, base defense zone, wave counter variable, survival timer, difficulty scaling per wave</td></tr>
<tr><td><strong>King of the Hill</strong></td><td>FPS/RTS variants</td><td>Central capture zone, scoreboard tracking cumulative hold time per faction, configurable score-to-win</td></tr>
<tr><td><strong>Regicide</strong></td><td>AoE2</td><td>King/Commander unit per player (named character, must-survive), kill the king = victory, king abilities optional</td></tr>
<tr><td><strong>Treaty</strong></td><td>AoE2</td><td>No-combat timer (configurable), force peace during treaty, countdown display, auto-reveal on treaty end</td></tr>
<tr><td><strong>Nomad</strong></td><td>AoE2</td><td>No starting base — each player gets only an MCV (or equivalent). Random spawn positions. Land grab gameplay.</td></tr>
<tr><td><strong>Empire Wars</strong></td><td>AoE2 DE</td><td>Pre-built base per player (configurable: small/medium/large), starting army, skip early game</td></tr>
<tr><td><strong>Assassination</strong></td><td>StarCraft UMS</td><td>Commander unit per player (powerful but fragile), protect yours, kill theirs. Commander death = defeat.</td></tr>
<tr><td><strong>Tower Defense</strong></td><td>Desktop TD, custom WC3 maps</td><td>Pre-defined enemy paths (waypoints), restricted build zones, economy from kills, wave system with boss rounds</td></tr>
<tr><td><strong>Tug of War</strong></td><td>WC3 custom maps</td><td>Automated unit spawning on timer, player controls upgrades/abilities/composition. Push the enemy back.</td></tr>
<tr><td><strong>Base Defense</strong></td><td>They Are Billions, C&amp;C missions</td><td>Defend a position for N minutes/waves. Pre-placed base, incoming attacks from multiple directions, escalating difficulty.</td></tr>
<tr><td><strong>Capture the Flag</strong></td><td>FPS tradition</td><td>Each player has a flag entity (or MCV). Steal the opponent’s and return it to your base. Combines economy + raiding.</td></tr>
<tr><td><strong>Free for All</strong></td><td>Every RTS</td><td>3+ players, no alliances allowed. Last player standing. Diplomacy module optional (alliances that can be broken).</td></tr>
<tr><td><strong>Diplomacy</strong></td><td>Civilization, AoE4</td><td>FFA with dynamic alliance system. Players can propose/accept/break alliances. Shared vision opt-in. Betrayal is a game mechanic.</td></tr>
<tr><td><strong>Sandbox</strong></td><td>Garry’s Mod, Minecraft Creative</td><td>Unlimited resources, no enemies, no victory condition. Pure building and experimentation. Good for testing and screenshots.</td></tr>
<tr><td><strong>Co-op Survival</strong></td><td>Deep Rock Galactic, Helldivers</td><td>Multiple human players vs escalating AI waves. Shared base. Team objectives. Difficulty scales with player count.</td></tr>
<tr><td><strong>Sudden Death</strong></td><td>Various</td><td>No rebuilding — if a building is destroyed, it’s gone. Every engagement is high-stakes. Smaller starting armies.</td></tr>
</tbody>
</table>
</div>
<p><strong>Templates are starting points, not constraints.</strong> Open a template, add your own triggers/modules/Lua, publish to Workshop. Templates save 30–60 minutes of boilerplate setup and ensure the core game mode logic is correct.</p>
<p><strong>Phasing:</strong> Not all 17 templates ship simultaneously. <strong>Phase 6b core set</strong> (8 templates): Skirmish, Survival/Horde, King of the Hill, Regicide, Free for All, Co-op Survival, Sandbox, Base Defense — these cover the most common community needs and validate the template system. <strong>Phase 7 / community-contributed</strong> (9 templates): Treaty, Nomad, Empire Wars, Assassination, Tower Defense, Tug of War, Capture the Flag, Diplomacy, Sudden Death — these are well-defined patterns that the community can build and publish via Workshop before (or instead of) first-party implementation. Scope to what you have (Principle #6); don’t ship 17 mediocre templates when 8 excellent ones plus a thriving Workshop library serves players better.</p>
<p><strong>Custom game mode templates:</strong> Modders can create new templates and publish them to Workshop (D030). A “Zombie Survival” template, a “MOBA Lanes” template, a “RPG Quest Hub” template — the community extends the library indefinitely. Templates use the same composition + module + trigger format as everything else.</p>
<p><strong>Community tools &gt; first-party completeness.</strong> Garry’s Mod shipped ~25 built-in tools; the community built hundreds more that matched or exceeded first-party quality — because the tool API was clean enough that addon authors could. The same philosophy applies here: ship 8 excellent templates, make the authoring format so clean that community templates are indistinguishable from built-in ones, and let Workshop do the rest. The limiting factor should be community imagination, not API complexity.</p>
<p><strong>Sandbox as default preview.</strong> The Sandbox template (unlimited resources, no enemies, no victory condition) doubles as the default environment when the editor’s Preview button is pressed without a specific scenario loaded. This follows Garry’s Mod’s lesson: sandbox mode is how people <strong>learn the tools</strong> before making real content. A zero-pressure environment where every entity and module can be tested without mission constraints.</p>
<p><strong>Templates + Co-op:</strong> Several templates have natural co-op variants. Co-op Survival is explicit, but most templates work with 2+ players if the designer adds co-op spawn points and per-player objectives.</p>
<h3 id="workshop-distributed-editor-plugins"><a class="header" href="#workshop-distributed-editor-plugins">Workshop-Distributed Editor Plugins</a></h3>
<p>Garry’s Mod’s most powerful pattern: community-created tools appear alongside built-in tools in the same menu. The community doesn’t just create content — they <strong>extend the creation tools themselves.</strong> Wire Mod and Expression 2 are the canonical examples: community-built systems that became essential editor infrastructure, indistinguishable from first-party tools.</p>
<p>IC supports this explicitly. Workshop-published packages can contain:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Plugin Type</th><th>What It Adds</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><strong>Custom modules</strong></td><td>New entries in the Modules panel (YAML definition + Lua implementation)</td><td>“Convoy System” module — defines waypoints + spawn + escort</td></tr>
<tr><td><strong>Custom triggers</strong></td><td>New trigger condition/action types</td><td>“Music trigger” — plays specific track on activation</td></tr>
<tr><td><strong>Compositions</strong></td><td>Pre-built reusable entity groups (see Compositions section)</td><td>“Tournament 1v1 Start” — balanced spawn with resources</td></tr>
<tr><td><strong>Game mode templates</strong></td><td>Complete game mode setups (see Game Mode Templates section)</td><td>“MOBA Lanes” — 3-lane auto-spawner with towers and heroes</td></tr>
<tr><td><strong>Editor tools</strong></td><td>New editing tools and panels (Lua-based UI extensions, Phase 7)</td><td>“Formation Arranger” — visual grid formation editor tool</td></tr>
<tr><td><strong>Terrain brushes</strong></td><td>Custom terrain painting presets</td><td>“River Painter” — places water + bank tiles + bridge snaps</td></tr>
</tbody>
</table>
</div>
<p>All plugin types use the tiered modding system (invariant #3): YAML for data definitions, Lua for logic, WASM for complex tools. Plugins are sandboxed — an editor plugin cannot access the filesystem, network, or sim internals beyond the editor’s public API. They install via Workshop like any other resource and appear in the editor’s palettes automatically.</p>
<p>This aligns with philosophy principle #19 (“Build for surprise — expose primitives, not just parameterized behaviors”): the module/trigger/composition system is powerful enough that community extensions can create things the engine developers never imagined.</p>
<p><strong>Phase:</strong> Custom modules and compositions are publishable from Phase 6a (they use the existing YAML + Lua format). Custom editor tools (Lua-based UI extensions) are a Phase 7 capability that depends on the editor’s Lua plugin API.</p>
<h3 id="editor-onboarding-for-veterans"><a class="header" href="#editor-onboarding-for-veterans">Editor Onboarding for Veterans</a></h3>
<p>The IC editor’s concepts — triggers, waypoints, entities, layers — aren’t new. They’re the same ideas that OFP, AoE2, StarCraft, and WC3 editors have used for decades. But each editor uses different names, different hotkeys, and different workflows. A 20-year AoE2 scenario editor veteran has deep muscle memory that IC shouldn’t fight — it should channel.</p>
<p><strong>“Coming From” profile (first-launch):</strong></p>
<p>When the editor opens for the first time, a non-blocking welcome panel asks: “Which editor are you most familiar with?” Options:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Profile</th><th>Sets Default Keybindings</th><th>Sets Terminology Hints</th><th>Sets Tutorial Path</th></tr>
</thead>
<tbody>
<tr><td><strong>New to editing</strong></td><td>IC Default</td><td>IC terms only</td><td>Full guided tour, start with Simple mode</td></tr>
<tr><td><strong>OFP / Eden</strong></td><td>F1–F7 mode switching</td><td>OFP equivalents shown</td><td>Skip basics, focus on RTS differences</td></tr>
<tr><td><strong>AoE2</strong></td><td>AoE2 trigger workflow</td><td>AoE2 equivalents shown</td><td>Skip triggers, focus on Lua + modules</td></tr>
<tr><td><strong>StarCraft / WC3</strong></td><td>WC3 trigger shortcuts</td><td>Location→Region, etc.</td><td>Skip locations, focus on compositions</td></tr>
<tr><td><strong>Other / Skip</strong></td><td>IC Default</td><td>No hints</td><td>Condensed overview</td></tr>
</tbody>
</table>
</div>
<p>This is a <strong>one-time suggestion, not a lock-in.</strong> Profile can be changed anytime in settings. All it does is set initial keybindings and toggle contextual hints.</p>
<p><strong>Customizable keybinding presets:</strong></p>
<p>Full key remapping with shipped presets:</p>
<pre><code>IC Default   — Tab cycles modes, 1-9 entity selection, Space preview
OFP Classic  — F1-F7 modes, Enter properties, Space preview
Eden Modern  — Ctrl+1-7 modes, double-click properties, P preview
AoE2 Style   — T triggers, U units, R resources, Ctrl+C copy trigger
WC3 Style    — Ctrl+T trigger editor, Ctrl+B triggers browser
</code></pre>
<p>Not just hotkeys — mode switching behavior and right-click context menus adapt to the profile. OFP veterans expect right-click on empty ground to deselect; AoE2 veterans expect right-click to open a context menu.</p>
<p><strong>Terminology Rosetta Stone:</strong></p>
<p>A toggleable panel (or contextual tooltips) that maps IC terms to familiar ones:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>IC Term</th><th>OFP / Eden</th><th>AoE2</th><th>StarCraft / WC3</th></tr>
</thead>
<tbody>
<tr><td>Region</td><td>Trigger (area-only)</td><td>Trigger Area</td><td>Location</td></tr>
<tr><td>Module</td><td>Module</td><td>Looping Trigger Pattern</td><td>GUI Trigger Template</td></tr>
<tr><td>Composition</td><td>Composition</td><td>(Copy-paste group)</td><td>Template</td></tr>
<tr><td>Variables Panel</td><td>(setVariable in SQF)</td><td>(Invisible unit on map edge)</td><td>Deaths counter / Switch</td></tr>
<tr><td>Inline Script</td><td>Init field (SQF)</td><td>—</td><td>Custom Script</td></tr>
<tr><td>Connection</td><td>Synchronize</td><td>—</td><td>—</td></tr>
<tr><td>Layer</td><td>Layer</td><td>—</td><td>—</td></tr>
<tr><td>Probability of Presence</td><td>Probability of Presence</td><td>—</td><td>—</td></tr>
<tr><td>Named Character</td><td>Playable unit</td><td>Named hero (scenario)</td><td>Named hero</td></tr>
</tbody>
</table>
</div>
<p>Displayed as <strong>tooltips on hover</strong> — when an AoE2 veteran hovers over “Region” in the UI, a tiny tooltip says “AoE2: Trigger Area.” Not blocking, not patronizing, just a quick orientation aid. Tooltips disappear after the first few uses (configurable).</p>
<p><strong>Interactive migration cheat sheets:</strong></p>
<p>Context-sensitive help that recognizes familiar patterns:</p>
<ul>
<li>Designer opens Variables Panel → tip: “In AoE2, you might have used invisible units placed off-screen as variables. IC has native variables — no workarounds needed.”</li>
<li>Designer creates first trigger → tip: “In OFP, triggers were areas on the map. IC triggers work the same way, but you can also use Regions for reusable areas across multiple triggers.”</li>
<li>Designer writes first Lua line → tip: “Coming from SQF? Here’s a quick Lua comparison: <code>_myVar = 5</code> → <code>local myVar = 5</code>. <code>hint \"hello\"</code> → <code>Game.message(\"hello\")</code>. Full cheat sheet: Help → SQF to Lua.”</li>
</ul>
<p>These only appear once per concept. They’re dismissable and disable-all with one toggle. They’re not tutorials — they’re translation aids.</p>
<p><strong>Scenario import (partial):</strong></p>
<p>Full import of complex scenarios from other engines is unrealistic — but partial import of the most tedious-to-recreate elements saves real time:</p>
<ul>
<li><strong>AoE2 trigger import</strong> — parse AoE2 scenario trigger data, convert condition→effect pairs to IC triggers + modules. Not all triggers translate, but simple ones (timer, area detection, unit death) map cleanly.</li>
<li><strong>StarCraft trigger import</strong> — parse StarCraft triggers, convert locations to IC Regions, convert trigger conditions/actions to IC equivalents.</li>
<li><strong>OFP mission.sqm import</strong> — parse entity placements, trigger positions, and waypoint connections. SQF init scripts flag as “needs Lua conversion” but the spatial layout transfers.</li>
<li><strong>OpenRA .oramap entities</strong> — already supported by the asset pipeline (D025/D026). Editor imports the map and entity placement directly.</li>
</ul>
<p>Import is always <strong>best-effort</strong> with clear reporting: “Imported 47 of 52 triggers. 5 triggers used features without IC equivalents — see import log.” Better to import 90% and fix 10% than to recreate 100% from scratch.</p>
<p><strong>The 30-minute goal:</strong> A veteran editor from ANY background should feel productive within 30 minutes. Not expert — productive. They recognize familiar concepts wearing new names, their muscle memory partially transfers via keybinding presets, and the migration cheat sheet fills the gaps. The learning curve is a gentle slope, not a cliff.</p>
<h3 id="controller--steam-deck-support"><a class="header" href="#controller--steam-deck-support">Controller &amp; Steam Deck Support</a></h3>
<p>Steam Deck is a target platform (Invariant #10), so the editor must be usable without mouse+keyboard — but it doesn’t need to be <em>equally</em> powerful. The approach: full functionality on mouse+keyboard, comfortable core workflows on controller.</p>
<ul>
<li><strong>Controller input mapping:</strong> Left stick for cursor movement (with adjustable acceleration), right stick for camera pan/zoom. D-pad cycles editing modes. Face buttons: place (A), delete (B), properties panel (X), context menu (Y). Triggers: undo (LT), redo (RT). Bumpers: cycle selected entity type</li>
<li><strong>Radial menus</strong> — controller-optimized selection wheels for entity types, trigger types, and module categories (replacing mouse-dependent dropdowns)</li>
<li><strong>Snap-to-grid</strong> — always active on controller (optional on mouse) to compensate for lower cursor precision</li>
<li><strong>Touch input (Steam Deck / mobile):</strong> Tap to place, pinch to zoom, two-finger drag to pan. Long press for properties panel. Touch works as a complement to controller, not a replacement for mouse</li>
<li><strong>Scope:</strong> Core editing (terrain, entity placement, triggers, waypoints, modules, preview) is controller-compatible at launch. Advanced features (inline Lua editing, campaign graph wiring, dialogue tree authoring) require keyboard and are flagged in the UI: “Connect a keyboard for this feature.” This is the same trade-off Eden Editor made — and Steam Deck has a built-in keyboard for occasional text entry</li>
</ul>
<p><strong>Phase:</strong> Controller input for the editor ships with Phase 6a. Touch input is Phase 7.</p>
<h3 id="accessibility"><a class="header" href="#accessibility">Accessibility</a></h3>
<p>The editor’s “accessibility through layered complexity” principle applies to disability access, not just skill tiers. These features ensure the editor is usable by the widest possible audience.</p>
<p><strong>Visual accessibility:</strong></p>
<ul>
<li><strong>Colorblind modes</strong> — all color-coded elements (trigger folders, layer colors, region colors, connection lines, complexity meter) use a palette designed for deuteranopia, protanopia, and tritanopia. In addition to color, elements use distinct <strong>shapes and patterns</strong> (dashed vs solid lines, different node shapes) so color is never the only differentiator</li>
<li><strong>High contrast mode</strong> — editor UI switches to high-contrast theme with stronger borders and larger text. Toggle in editor settings</li>
<li><strong>Scalable UI</strong> — all editor panels respect the game’s global UI scale setting (50%–200%). Editor-specific elements (attribute labels, trigger text, node labels) scale independently if needed</li>
<li><strong>Zoom and magnification</strong> — the isometric viewport supports arbitrary zoom levels. Combined with UI scaling, users with low vision can work at comfortable magnification</li>
</ul>
<p><strong>Motor accessibility:</strong></p>
<ul>
<li><strong>Full keyboard navigation</strong> — every editor operation is reachable via keyboard. Tab cycles panels, arrow keys navigate within panels, Enter confirms, Escape cancels. No operation requires mouse-only gestures</li>
<li><strong>Adjustable click timing</strong> — double-click speed and drag thresholds are configurable for users with reduced dexterity</li>
<li><strong>Sticky modes</strong> — editing modes (terrain, entity, trigger) stay active until explicitly switched, rather than requiring held modifier keys</li>
</ul>
<p><strong>Cognitive accessibility:</strong></p>
<ul>
<li><strong>Simple/Advanced mode</strong> (already designed) is the primary cognitive accessibility feature — it reduces the number of visible options from 30+ to ~10</li>
<li><strong>Consistent layout</strong> — panels don’t rearrange based on context. The attributes panel is always on the right, the mode selector always on the left. Predictable layout reduces cognitive load</li>
<li><strong>Tooltips with examples</strong> — every field in the attributes panel has a tooltip with a concrete example, not just a description. “Probability of Presence: 75” → tooltip: “75% chance this unit exists when the mission starts. Example: set to 50 for a coin-flip ambush.”</li>
</ul>
<p><strong>Phase:</strong> Colorblind modes, UI scaling, and keyboard navigation ship with Phase 6a. High contrast mode and motor accessibility refinements ship in Phase 6b–7.</p>
<blockquote>
<p><strong>Note:</strong> The accessibility features above cover the <strong>editor</strong> UI. <strong>Game-level accessibility</strong> — colorblind faction colors, minimap palettes, resource differentiation, screen reader support for menus, subtitle options for EVA/briefings, and remappable controls — is a separate concern that applies to <code>ic-render</code> and <code>ic-ui</code>, not <code>ic-editor</code>. Game accessibility ships in Phase 7 (see <code>08-ROADMAP.md</code>).</p>
</blockquote>
<h3 id="alternatives-considered"><a class="header" href="#alternatives-considered">Alternatives Considered</a></h3>
<ol>
<li><strong>In-game editor (original design, revised by D040):</strong> The original D038 design embedded the editor inside the game binary. Revised to SDK-separate architecture — players shouldn’t see creator tools. The SDK still reuses the same Bevy rendering and sim crates, so there’s no loss of live preview capability. See D040 § SDK Architecture for the full rationale.</li>
<li><strong>Text-only editing (YAML + Lua):</strong> Already supported for power users and LLM generation. The visual editor is the accessibility layer on top of the same data format.</li>
<li><strong>Node-based visual scripting (like Unreal Blueprints):</strong> Too complex for the casual audience. Modules + triggers cover the sweet spot. Advanced users write Lua directly. A node editor is a potential Phase 7+ community contribution.</li>
</ol>
<p><strong>Phase:</strong> Core scenario editor (terrain + entities + triggers + waypoints + modules + compositions + preview + autosave + controller input + accessibility) ships in <strong>Phase 6a</strong> alongside the modding SDK and full Workshop. Campaign editor (graph, state dashboard, intermissions, dialogue, named characters), game mode templates, multiplayer/co-op scenario tools, and Game Master mode ship in <strong>Phase 6b</strong>. Editor onboarding (“Coming From” profiles, keybinding presets, migration cheat sheets, partial import) and touch input ship in <strong>Phase 7</strong>. The campaign editor’s graph, state dashboard, and intermission screens build on D021’s campaign system (Phase 4) — the sim-side campaign engine must exist before the visual editor can drive it.</p>
<hr>
<hr>
<h2 id="d040-asset-studio--visual-resource-editor--agentic-generation"><a class="header" href="#d040-asset-studio--visual-resource-editor--agentic-generation">D040: Asset Studio — Visual Resource Editor &amp; Agentic Generation</a></h2>
<p><strong>Decision:</strong> Ship an Asset Studio as part of the IC SDK — a visual tool for browsing, viewing, editing, and generating game resources (sprites, palettes, terrain tiles, UI chrome, 3D models). Optionally agentic: modders can describe what they want and an LLM generates or modifies assets, with in-context preview and iterative refinement. The Asset Studio is a tab/mode within the SDK application alongside the scenario editor (D038) — separate from the game binary.</p>
<p><strong>Context:</strong> The current design covers the full lifecycle <em>around</em> assets — parsing (ra-formats), runtime loading (Bevy pipeline), in-game use (ic-render), mission editing (D038), and distribution (D030 Workshop) — but nothing for the creative work of making or modifying assets. A modder who wants to create a new unit sprite, adjust a palette, or redesign menu chrome has zero tooling in our chain. They use external tools (Photoshop, GIMP, Aseprite) and manually convert. The community’s most-used asset tool is XCC Mixer (a 20-year-old Windows utility for browsing .mix archives). We can do better.</p>
<p>Bevy does not fill this gap. Bevy’s asset system handles loading and hot-reloading at runtime. The in-development Bevy Editor is a scene/entity inspector, not an art tool. No Bevy ecosystem crate provides C&amp;C-format-aware asset editing.</p>
<p><strong>What this is NOT:</strong> A Photoshop competitor. The Asset Studio does not provide pixel-level painting or 3D modeling. Artists use professional external tools for that. The Asset Studio handles the last mile: making assets game-ready, previewing them in context, and bridging the gap between “I have a PNG” and “it works as a unit in the game.”</p>
<h3 id="sdk-architecture--editorgame-separation"><a class="header" href="#sdk-architecture--editorgame-separation">SDK Architecture — Editor/Game Separation</a></h3>
<p><strong>The IC SDK is a separate application from the game.</strong> Normal players never see editor UI. Creators download the SDK alongside the game (or as part of the <code>ic</code> CLI toolchain). This follows the industry standard: Bethesda’s Creation Kit, Valve’s Hammer/Source SDK, Epic’s Unreal Editor, Blizzard’s StarEdit/World Editor (bundled but launches separately).</p>
<pre><code>┌──────────────────────────────┐     ┌──────────────────────────────┐
│         IC Game              │     │          IC SDK              │
│  (ic-game binary)            │     │  (ic-sdk binary)             │
│                              │     │                              │
│  • Play skirmish/campaign    │     │  ┌────────────────────────┐  │
│  • Online multiplayer        │     │  │   Scenario Editor      │  │
│  • Browse/install mods       │     │  │   (D038)               │  │
│  • Watch replays             │     │  ├────────────────────────┤  │
│  • Settings &amp; profiles       │     │  │   Asset Studio         │  │
│                              │     │  │   (D040)               │  │
│  No editor UI.               │     │  ├────────────────────────┤  │
│  No asset tools.             │     │  │   Campaign Editor      │  │
│  Clean player experience.    │     │  │   (D038/D021)          │  │
│                              │     │  ├────────────────────────┤  │
│                              │     │  │   Game Master Mode     │  │
│                              │     │  │   (D038)               │  │
│                              │     │  └────────────────────────┘  │
│                              │     │                              │
│                              │     │  Shares: ic-render, ic-sim,  │
│                              │     │  ic-ui, ic-protocol,         │
│                              │     │  ra-formats                  │
└──────────────────────────────┘     └──────────────────────────────┘
         ▲                                      │
         │         ic mod run / Test button      │
         └───────────────────────────────────────┘
</code></pre>
<p><strong>Why separate binaries instead of in-game editor:</strong></p>
<ul>
<li><strong>Players aren’t overwhelmed.</strong> A player launches the game and sees: Play, Multiplayer, Replays, Settings. No “Editor” menu item they’ll never use.</li>
<li><strong>SDK can be complex without apology.</strong> The SDK UI can have dense panels, multi-tab layouts, technical property editors. It’s for creators — they expect professional tools.</li>
<li><strong>Smaller game binary.</strong> All editor systems, asset processing code, LLM integration, and creator UI are excluded from the game build. Players download less.</li>
<li><strong>Industry convention.</strong> Players expect an SDK. “Download the Creation Kit” is understood. “Open the in-game editor” confuses casual players who accidentally click it.</li>
</ul>
<p><strong>Why this still works for fast iteration:</strong></p>
<ul>
<li><strong>“Test” button in SDK</strong> launches <code>ic-game</code> with the current scenario/asset loaded. One click, instant playtest. Same <code>LocalNetwork</code> path as before — the preview is real gameplay.</li>
<li><strong>Hot-reload bridge.</strong> While the game is running from a Test launch, the SDK watches for file changes. Edit a YAML file, save → game hot-reloads. Edit a sprite, save → game picks up the new asset. The iteration loop is seconds, not minutes.</li>
<li><strong>Shared Bevy crates.</strong> The SDK reuses <code>ic-render</code> for its preview viewports, <code>ic-sim</code> for gameplay preview, <code>ic-ui</code> for shared components. It’s the same rendering and simulation — just in a different window with different chrome.</li>
</ul>
<p><strong>Crate boundary:</strong> <code>ic-editor</code> contains all SDK functionality (scenario editor, asset studio, campaign editor, Game Master mode). It depends on <code>ic-render</code>, <code>ic-sim</code>, <code>ic-ui</code>, <code>ic-protocol</code>, <code>ra-formats</code>, and optionally <code>ic-llm</code> (via traits). <code>ic-game</code> does NOT depend on <code>ic-editor</code>. Both <code>ic-game</code> and <code>ic-editor</code> are separate binary targets in the workspace — they share library crates but produce independent executables.</p>
<p><strong>Game Master mode exception:</strong> Game Master mode requires real-time manipulation of a live game session. The SDK connects to a running game as a special client — the Game Master’s SDK sends <code>PlayerOrder</code>s through <code>ic-protocol</code> to the game’s <code>NetworkModel</code>, same as any other player. The game doesn’t know it’s being controlled by an SDK — it receives orders. The Game Master’s SDK renders its own view (top-down strategic overview, budget panel, entity palette) but the game session runs in <code>ic-game</code>. Open questions deferred to Phase 6b design: how matchmaking/lobby handles GM slots (dedicated GM slot vs. spectator-with-controls), whether GM can join mid-match, and how GM presence is communicated to players.</p>
<h3 id="three-layers"><a class="header" href="#three-layers">Three Layers</a></h3>
<h4 id="layer-1--asset-browser--viewer"><a class="header" href="#layer-1--asset-browser--viewer">Layer 1 — Asset Browser &amp; Viewer</a></h4>
<p>Browse, search, and preview every asset the engine can load. This is the XCC Mixer replacement — but integrated into a modern Bevy-based UI with live preview.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Capability</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Archive browser</strong></td><td>Browse .mix archive contents, see file list, extract individual files or bulk export</td></tr>
<tr><td><strong>Sprite viewer</strong></td><td>View .shp sprites with palette applied, animate frame sequences, scrub through frames, zoom</td></tr>
<tr><td><strong>Palette viewer</strong></td><td>View .pal palettes as color grids, compare palettes side-by-side, see palette applied to any sprite</td></tr>
<tr><td><strong>Terrain tile viewer</strong></td><td>Preview .tmp terrain tiles in grid layout, see how tiles connect</td></tr>
<tr><td><strong>Audio player</strong></td><td>Play .aud/.wav/.ogg/.mp3 files directly, waveform visualization, spectral view, loop point markers, sample rate / bit depth / channel info display</td></tr>
<tr><td><strong>Video player</strong></td><td>Play .vqa/.mp4/.webm cutscenes, frame-by-frame scrub, preview in all three display modes (fullscreen, radar_comm, picture_in_picture)</td></tr>
<tr><td><strong>Chrome previewer</strong></td><td>View UI theme sprite sheets (D032) with 9-slice visualization, see button states</td></tr>
<tr><td><strong>3D model viewer</strong></td><td>Preview GLTF/GLB models (and .vxl voxel models for future RA2 module) with rotation, lighting</td></tr>
<tr><td><strong>Asset search</strong></td><td>Full-text search across all loaded assets — by filename, type, archive, tags</td></tr>
<tr><td><strong>In-context preview</strong></td><td>“Preview as unit” — see this sprite on an actual map tile. “Preview as building” — see footprint. “Preview as chrome” — see in actual menu layout.</td></tr>
<tr><td><strong>Dependency graph</strong></td><td>Which assets reference this one? What does this mod override? Visual dependency tree.</td></tr>
</tbody>
</table>
</div>
<p><strong>Format support by game module:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Game</th><th>Archive</th><th>Sprites</th><th>Models</th><th>Palettes</th><th>Audio</th><th>Video</th><th>Source</th></tr>
</thead>
<tbody>
<tr><td>RA1 / TD</td><td>.mix</td><td>.shp</td><td>—</td><td>.pal</td><td>.aud</td><td>.vqa</td><td>EA GPL release — fully open</td></tr>
<tr><td>RA2 / TS</td><td>.mix</td><td>.shp, .vxl (voxels)</td><td>.hva (voxel anim)</td><td>.pal</td><td>.aud</td><td>.bik</td><td>Community-documented (XCC, Ares, Phobos)</td></tr>
<tr><td>Generals / ZH</td><td>.big</td><td>—</td><td>.w3d (3D meshes)</td><td>—</td><td>—</td><td>.bik</td><td>EA GPL release — fully open</td></tr>
<tr><td>OpenRA</td><td>.oramap (ZIP)</td><td>.png</td><td>—</td><td>.pal</td><td>.wav/.ogg</td><td>—</td><td>Open source</td></tr>
<tr><td>IC native</td><td>—</td><td>.png, sprite sheets</td><td>.glb/.gltf</td><td>.pal, .yaml</td><td>.wav/.ogg/.mp3</td><td>.mp4/.webm</td><td>Our format</td></tr>
</tbody>
</table>
</div>
<p><strong>Minimal reverse engineering required.</strong> RA1/TD and Generals/ZH are fully open-sourced by EA (GPL). RA2/TS formats are not open-sourced but have been community-documented for 20+ years — .vxl, .hva, .csf are thoroughly understood by the XCC, Ares, and Phobos projects. The <code>FormatRegistry</code> trait (D018) already anticipates per-module format loaders.</p>
<h4 id="layer-2--asset-editor"><a class="header" href="#layer-2--asset-editor">Layer 2 — Asset Editor</a></h4>
<p>Scoped asset editing operations. Not pixel painting — structured operations on game asset types.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Tool</th><th>What It Does</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><strong>Palette editor</strong></td><td>Remap colors, adjust faction-color ranges, create palette variants, shift hue/saturation/brightness per range</td><td>“Make a winter palette from temperate” — shift greens to whites</td></tr>
<tr><td><strong>Sprite sheet organizer</strong></td><td>Reorder frames, adjust animation timing, add/remove frames, composite sprite layers, set hotpoints/offsets</td><td>Import 8 PNG frames → assemble into .shp-compatible sprite sheet with correct facing rotations</td></tr>
<tr><td><strong>Chrome / theme designer</strong></td><td>Visual editor for D032 UI themes — drag 9-slice panels, position elements, see result live in actual menu mockup</td><td>Design a new sidebar layout: drag resource bar, build queue, minimap into position. Live preview updates.</td></tr>
<tr><td><strong>Terrain tile editor</strong></td><td>Create terrain tile sets — assign connectivity rules, transition tiles, cliff edges. Preview tiling on a test map.</td><td>Paint a new snow terrain set: assign which tiles connect to which edges</td></tr>
<tr><td><strong>Import pipeline</strong></td><td>Convert standard formats to game-ready assets: PNG → palette-quantized .shp, GLTF → game model with LODs, font → bitmap font sheet</td><td>Drag in a 32-bit PNG → auto-quantize to .pal, preview dithering options, export as .shp</td></tr>
<tr><td><strong>Batch operations</strong></td><td>Apply operations across multiple assets: bulk palette remap, bulk resize, bulk re-export</td><td>“Remap all Soviet unit sprites to use the Tiberium Sun palette”</td></tr>
<tr><td><strong>Diff / compare</strong></td><td>Side-by-side comparison of two versions of an asset — sprite diff, palette diff, before/after</td><td>Compare original RA1 sprite with your modified version, pixel-diff highlighted</td></tr>
<tr><td><strong>Video converter</strong></td><td>Convert between C&amp;C video formats (.vqa) and modern formats (.mp4, .webm). Trim, crop, resize. Subtitle overlay. Frame rate control.</td><td>Record a briefing in OBS → import .mp4 → convert to .vqa for classic feel, or keep as .mp4 for modern campaigns. Extract original RA1 briefings to .mp4 for remixing in Premiere/DaVinci.</td></tr>
<tr><td><strong>Audio converter</strong></td><td>Convert between C&amp;C audio format (.aud) and modern formats (.wav, .ogg). Trim, normalize, fade in/out. Sample rate conversion. Batch convert entire sound libraries.</td><td>Extract all RA1 sound effects to .wav for remixing in Audacity/Reaper. Record custom EVA lines → normalize → convert to .aud for classic feel. Batch-convert a voice pack from .wav to .ogg for Workshop publish.</td></tr>
</tbody>
</table>
</div>
<p><strong>Design rule:</strong> Every operation the Asset Studio performs produces standard output formats. Palette edits produce .pal files. Sprite operations produce .shp or sprite sheet PNGs. Chrome editing produces YAML + sprite sheet PNGs. No proprietary intermediate format — the output is always mod-ready.</p>
<h4 id="layer-3--agentic-asset-generation-d016-extension-phase-7"><a class="header" href="#layer-3--agentic-asset-generation-d016-extension-phase-7">Layer 3 — Agentic Asset Generation (D016 Extension, Phase 7)</a></h4>
<p>LLM-powered asset creation for modders who have ideas but not art skills. Same BYOLLM pattern as D016 — user brings their own provider (DALL-E, Stable Diffusion, Midjourney API, local model), <code>ic-llm</code> routes the request.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Capability</th><th>How It Works</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><strong>Sprite generation</strong></td><td>Describe unit → LLM generates sprite sheet → preview on map → iterate</td><td>“Soviet heavy tank, double barrel, darker than the Mammoth Tank” → generates 8-facing sprite sheet → preview as unit on map → “make the turret bigger” → re-generates</td></tr>
<tr><td><strong>Palette generation</strong></td><td>Describe mood/theme → LLM generates palette → preview applied to existing sprites</td><td>“Volcanic wasteland palette — reds, oranges, dark stone” → generates .pal → preview on temperate map sprites</td></tr>
<tr><td><strong>Chrome generation</strong></td><td>Describe UI style → LLM generates theme elements → preview in actual menu</td><td>“Brutalist concrete UI theme, sharp corners, red accents” → generates chrome sprite sheet → preview in sidebar</td></tr>
<tr><td><strong>Terrain generation</strong></td><td>Describe biome → LLM generates tile set → preview tiling</td><td>“Frozen tundra with ice cracks and snow drifts” → generates terrain tiles with connectivity → preview on test map</td></tr>
<tr><td><strong>Asset variation</strong></td><td>Take existing asset + describe change → LLM produces variant</td><td>“Take this Allied Barracks and make a Nod version — darker, angular, with a scorpion emblem”</td></tr>
<tr><td><strong>Style transfer</strong></td><td>Apply visual style across asset set</td><td>“Make all these units look hand-drawn like Advance Wars”</td></tr>
</tbody>
</table>
</div>
<p><strong>Workflow:</strong></p>
<ol>
<li>Describe what you want (text prompt + optional reference image)</li>
<li>LLM generates candidate(s) — multiple options when possible</li>
<li>Preview in-context (on map, in menu, as unit) — not just a floating image, but in the actual game rendering</li>
<li>Iterate: refine prompt, adjust, regenerate</li>
<li>Post-process: palette quantize, frame extract, format convert</li>
<li>Export as mod-ready asset → ready for Workshop publish</li>
</ol>
<p><strong>Crate boundary:</strong> <code>ic-editor</code> defines an <code>AssetGenerator</code> trait (input: text description + format constraints + optional reference → output: generated image data). <code>ic-llm</code> implements it by routing to the configured provider. <code>ic-game</code> wires them at startup in the SDK binary. Same pattern as <code>NarrativeGenerator</code> for the replay-to-scenario pipeline. The SDK works without an LLM — Layers 1 and 2 are fully functional. Layer 3 activates when a provider is configured.</p>
<p><strong>What the LLM does NOT replace:</strong></p>
<ul>
<li>Professional art. LLM-generated sprites are good enough for prototyping, playtesting, and small mods. Professional pixel art for a polished release still benefits from a human artist.</li>
<li>Format knowledge. The LLM generates images. The Asset Studio handles palette quantization, frame extraction, sprite sheet assembly, and format conversion. The LLM doesn’t need to know about .shp internals.</li>
<li>Quality judgment. The modder decides if the result is good enough. The Asset Studio shows it in context so the judgment is informed.</li>
</ul>
<blockquote>
<p><strong>See also:</strong> D016 § “Generative Media Pipeline” extends agentic generation beyond visual assets to audio and video: voice synthesis (<code>VoiceProvider</code>), music generation (<code>MusicProvider</code>), sound FX (<code>SoundFxProvider</code>), and video/cutscene generation (<code>VideoProvider</code>). The SDK integrates these as Tier 3 Asset Studio tools alongside visual generation. All media provider types use the same BYOLLM pattern and D047 task routing.</p>
</blockquote>
<h3 id="menu--chrome-design-workflow"><a class="header" href="#menu--chrome-design-workflow">Menu / Chrome Design Workflow</a></h3>
<p>UI themes (D032) are YAML + sprite sheets. Currently there’s no visual editor — modders hand-edit coordinates and pixel offsets. The Asset Studio’s chrome designer closes this gap:</p>
<ol>
<li><strong>Load a base theme</strong> (Classic, Remastered, Modern, or any workshop theme)</li>
<li><strong>Visual element editor</strong> — see the 9-slice panels, button states, scrollbar tracks as overlays on the sprite sheet. Drag edges to resize. Click to select.</li>
<li><strong>Layout preview</strong> — split view: sprite sheet on left, live menu mockup on right. Every edit updates the mockup instantly.</li>
<li><strong>Element properties</strong> — per-element: padding, margins, color tint, opacity, font assignment, animation (hover/press states)</li>
<li><strong>Full menu preview</strong> — “Preview as: Main Menu / Sidebar / Build Queue / Lobby / Settings” — switch between all game screens to see the theme in each context</li>
<li><strong>Export</strong> — produces <code>theme.yaml</code> + sprite sheet PNG, ready for <code>ic mod publish</code></li>
<li><strong>Agentic mode</strong> — describe desired changes: “make the sidebar narrower with a brushed metal look” → LLM modifies the sprite sheet + adjusts YAML layout → preview → iterate</li>
</ol>
<h3 id="cross-game-asset-bridge"><a class="header" href="#cross-game-asset-bridge">Cross-Game Asset Bridge</a></h3>
<p>The Asset Studio understands multiple C&amp;C format families and can convert between them:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Conversion</th><th>Direction</th><th>Use Case</th><th>Phase</th></tr>
</thead>
<tbody>
<tr><td>.shp (RA1) → .png</td><td>Export</td><td>Extract classic sprites for editing in external tools</td><td>6a</td></tr>
<tr><td>.png → .shp + .pal</td><td>Import</td><td>Turn modern art into classic-compatible format</td><td>6a</td></tr>
<tr><td>.vxl (RA2) → .glb</td><td>Export</td><td>Convert RA2 voxel models to standard 3D format for editing</td><td>Future</td></tr>
<tr><td>.glb → game model</td><td>Import</td><td>Import artist-created 3D models for future 3D game modules</td><td>Future</td></tr>
<tr><td>.w3d (Generals) → .glb</td><td>Export</td><td>Convert Generals models for viewing and editing</td><td>Future</td></tr>
<tr><td>.vqa → .mp4/.webm</td><td>Export</td><td>Extract original RA/TD cutscenes to modern formats for viewing, remixing, or re-editing in standard video tools (Premiere, DaVinci, Kdenlive)</td><td>6a</td></tr>
<tr><td>.mp4/.webm → .vqa</td><td>Import</td><td>Convert custom-recorded campaign briefings/cutscenes to classic VQA format (palette-quantized, VQ-compressed) for authentic retro feel</td><td>6a</td></tr>
<tr><td>.mp4/.webm passthrough</td><td>Native</td><td>Modern video formats play natively — no conversion required. Campaign creators can use .mp4/.webm directly for briefings and radar comms.</td><td>4</td></tr>
<tr><td>.aud → .wav/.ogg</td><td>Export</td><td>Extract original RA/TD sound effects, EVA lines, and music to modern formats for remixing or editing in standard audio tools (Audacity, Reaper, FL Studio)</td><td>6a</td></tr>
<tr><td>.wav/.ogg → .aud</td><td>Import</td><td>Convert custom audio recordings to classic Westwood AUD format (IMA ADPCM compressed) for authentic retro sound or OpenRA mod compatibility</td><td>6a</td></tr>
<tr><td>.wav/.ogg/.mp3 passthrough</td><td>Native</td><td>Modern audio formats play natively — no conversion required. Mod creators can use .wav/.ogg/.mp3 directly for sound effects, music, and EVA lines.</td><td>3</td></tr>
<tr><td>Theme YAML ↔ visual</td><td>Bidirectional</td><td>Edit themes visually or as YAML — changes sync both ways</td><td>6a</td></tr>
</tbody>
</table>
</div>
<p><strong>ra-formats write support:</strong> Currently <code>ra-formats</code> is read-only (parse .mix, .shp, .pal, .vqa, .aud). The Asset Studio requires write support — generating .shp from frames, writing .pal files, encoding .vqa video, encoding .aud audio, optionally packing .mix archives. This is an additive extension to <code>ra-formats</code> (no redesign of existing parsers), but non-trivial engineering: .shp writing requires correct header generation, frame offset tables, and optional LCW/RLE compression; .vqa encoding requires VQ codebook generation and frame differencing; .aud encoding requires IMA ADPCM compression with correct <code>AUDHeaderType</code> generation and <code>IndexTable</code>/<code>DiffTable</code> lookup table application; .mix packing requires building the file index and CRC hash table. All encoders reference the EA GPL source code implementations directly (see <code>05-FORMATS.md</code> § Binary Format Codec Reference). Budget accordingly in Phase 6a.</p>
<p><strong>Video pipeline:</strong> The game engine natively plays .mp4 and .webm via standard media decoders (platform-provided or bundled). Campaign creators can use modern formats directly — no conversion needed. The .vqa ↔ .mp4/.webm conversion in the Asset Studio is for creators who <em>want</em> the classic C&amp;C aesthetic (palette-quantized, low-res FMV look) or who need to extract and remix original EA cutscenes. The conversion pipeline lives in <code>ra-formats</code> (VQA codec) + <code>ic-editor</code> (UI, preview, trim/crop tools). Someone recording a briefing with a webcam or screen recorder imports their .mp4, previews it in the Video Playback module’s display modes (fullscreen, radar_comm, picture_in_picture), optionally converts to .vqa for retro feel, and publishes via Workshop (D030).</p>
<p><strong>Audio pipeline:</strong> The game engine natively plays .wav, .ogg, and .mp3 via standard audio decoders (Bevy audio plugin + platform codecs). Modern formats are the recommended choice for new content — .ogg for music and voice lines (good compression, no licensing issues), .wav for short sound effects (zero decode latency). The .aud ↔ .wav/.ogg conversion in the Asset Studio is for creators who need to extract and remix original EA audio (hundreds of classic sound effects, EVA voice lines, and Hell March variations) or who want to encode custom audio in classic AUD format for OpenRA mod compatibility. The conversion pipeline lives in <code>ra-formats</code> (AUD codec — IMA ADPCM encode/decode using the original Westwood <code>IndexTable</code>/<code>DiffTable</code> from the EA GPL source) + <code>ic-editor</code> (UI, waveform preview, trim/normalize/fade tools). Someone recording custom EVA voice lines imports their .wav files, previews with waveform visualization, normalizes volume, optionally converts to .aud for classic feel or keeps as .ogg for modern mods, and publishes via Workshop (D030). Batch conversion handles entire sound libraries — extract all 200+ RA1 sound effects to .wav in one operation.</p>
<h3 id="alternatives-considered-1"><a class="header" href="#alternatives-considered-1">Alternatives Considered</a></h3>
<ol>
<li><strong>Rely on external tools entirely</strong> (Photoshop, Aseprite, XCC Mixer) — Rejected. Forces modders to learn multiple disconnected tools with no in-context preview. The “last mile” problem (PNG → game-ready .shp with correct palette, offsets, and facing rotations) is where most modders give up.</li>
<li><strong>Build a full art suite</strong> (pixel editor, 3D modeler) — Rejected. Scope explosion. Aseprite and Blender exist. We handle the game-specific parts they can’t.</li>
<li><strong>In-game asset tools</strong> — Rejected. Same reasoning as the overall SDK separation: players shouldn’t see asset editing tools. The SDK is for creators.</li>
<li><strong>Web-based editor</strong> — Deferred. A browser-based asset viewer/editor is a compelling Phase 7+ goal (especially for the WASM target), but the primary tool ships as a native Bevy application in the SDK.</li>
</ol>
<h3 id="phase"><a class="header" href="#phase">Phase</a></h3>
<ul>
<li><strong>Phase 0:</strong> <code>ra-formats</code> delivers CLI asset inspection (dump/inspect/validate) — the text-mode precursor.</li>
<li><strong>Phase 6a:</strong> Asset Studio ships as part of the SDK alongside the scenario editor. Layer 1 (browser/viewer) and Layer 2 (editor) are the deliverables. Chrome designer ships alongside the UI theme system (D032).</li>
<li><strong>Phase 7:</strong> Layer 3 (agentic generation via <code>ic-llm</code>). Same phase as LLM text generation (D016).</li>
<li><strong>Future:</strong> .vxl/.hva write support (for RA2 module), .w3d viewing (for Generals module), browser-based viewer.</li>
</ul>
<hr>
<hr>
<h2 id="d047-llm-configuration-manager--provider-management--community-sharing"><a class="header" href="#d047-llm-configuration-manager--provider-management--community-sharing">D047: LLM Configuration Manager — Provider Management &amp; Community Sharing</a></h2>
<p><strong>Status:</strong> Accepted
<strong>Scope:</strong> <code>ic-ui</code>, <code>ic-llm</code>, <code>ic-game</code>
<strong>Phase:</strong> Phase 7 (ships with LLM features)</p>
<h3 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h3>
<p>D016 established the BYOLLM architecture: users configure an <code>LlmProvider</code> (endpoint, API key, model name) in settings. But as LLM features expand across the engine — mission generation (D016), coaching (D042), AI orchestrator (D044), asset generation (D040) — managing provider configurations becomes non-trivial. Users may want:</p>
<ul>
<li>Multiple providers configured simultaneously (local Ollama for AI orchestrator speed, cloud API for high-quality mission generation)</li>
<li>Task-specific routing (use a cheap model for real-time AI, expensive model for campaign generation)</li>
<li>Sharing working configurations with the community (without sharing API keys)</li>
<li>Discovering which models work well for which IC features</li>
<li>An achievement for configuring and using LLM features (engagement incentive)</li>
</ul>
<h3 id="decision"><a class="header" href="#decision">Decision</a></h3>
<p>Provide a dedicated <strong>LLM Manager</strong> UI screen and a community-shareable configuration format for LLM provider setups.</p>
<h3 id="llm-manager-ui"><a class="header" href="#llm-manager-ui">LLM Manager UI</a></h3>
<p>Accessible from Settings → LLM Providers:</p>
<pre><code>┌─────────────────────────────────────────────────────────┐
│  LLM Providers                                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  [+] Add Provider                                       │
│                                                         │
│  ┌─ Local Ollama (llama3.2) ──────── ✓ Active ───────┐ │
│  │  Endpoint: http://localhost:11434                   │ │
│  │  Model: llama3.2:8b                                │ │
│  │  Assigned to: AI Orchestrator, Quick coaching       │ │
│  │  Avg latency: 340ms  │  Status: ● Connected        │ │
│  │  [Test] [Edit] [Remove]                            │ │
│  └────────────────────────────────────────────────────┘ │
│                                                         │
│  ┌─ OpenAI API (GPT-4o) ───────── ✓ Active ──────────┐ │
│  │  Endpoint: https://api.openai.com/v1               │ │
│  │  Model: gpt-4o                                     │ │
│  │  Assigned to: Mission generation, Campaign briefings│ │
│  │  Avg latency: 1.2s   │  Status: ● Connected        │ │
│  │  [Test] [Edit] [Remove]                            │ │
│  └────────────────────────────────────────────────────┘ │
│                                                         │
│  ┌─ Anthropic API (Claude) ────── ○ Inactive ─────────┐ │
│  │  Endpoint: https://api.anthropic.com/v1            │ │
│  │  Model: claude-sonnet-4-20250514                          │ │
│  │  Assigned to: (none)                               │ │
│  │  [Test] [Edit] [Remove] [Activate]                 │ │
│  └────────────────────────────────────────────────────┘ │
│                                                         │
│  Task Routing:                                          │
│  ┌──────────────────────┬──────────────────────────┐    │
│  │ Task                 │ Provider                 │    │
│  ├──────────────────────┼──────────────────────────┤    │
│  │ AI Orchestrator      │ Local Ollama (fast)      │    │
│  │ Mission Generation   │ OpenAI API (quality)     │    │
│  │ Campaign Briefings   │ OpenAI API (quality)     │    │
│  │ Post-Match Coaching  │ Local Ollama (fast)      │    │
│  │ Asset Generation     │ OpenAI API (quality)     │    │
│  │ Voice Synthesis      │ ElevenLabs (quality)     │    │
│  │ Music Generation     │ Suno API (quality)       │    │
│  └──────────────────────┴──────────────────────────┘    │
│                                                         │
│  [Export Config] [Import Config] [Browse Community]      │
└─────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="community-shareable-configurations"><a class="header" href="#community-shareable-configurations">Community-Shareable Configurations</a></h3>
<p>LLM configurations can be exported (without API keys) and shared via the Workshop (D030):</p>
<pre><code class="language-yaml"># Exported LLM configuration (shareable)
llm_config:
  name: "Budget-Friendly RA Setup"
  author: "PlayerName"
  description: "Ollama for real-time features, free API tier for generation"
  version: 1
  providers:
    - name: "Local Ollama"
      type: ollama
      endpoint: "http://localhost:11434"
      model: "llama3.2:8b"
      # NO api_key — never exported
    - name: "Cloud Provider"
      type: openai-compatible
      # endpoint intentionally omitted — user fills in their own
      model: "gpt-4o-mini"
      notes: "Works well with OpenAI or any compatible API"
  routing:
    ai_orchestrator: "Local Ollama"
    mission_generation: "Cloud Provider"
    coaching: "Local Ollama"
    campaign_briefings: "Cloud Provider"
    asset_generation: "Cloud Provider"
  performance_notes: |
    Tested on RTX 3060 + Ryzen 5600X.
    Ollama latency ~300ms for orchestrator (acceptable).
    GPT-4o-mini at ~$0.02 per mission generation.
  compatibility:
    ic_version: "&gt;=0.5.0"
    tested_models:
      - "llama3.2:8b"
      - "mistral:7b"
      - "gpt-4o-mini"
      - "gpt-4o"
</code></pre>
<p><strong>Security:</strong> API keys are <strong>never</strong> included in exported configurations. The export contains provider types, model names, and routing — the user fills in their own credentials after importing.</p>
<h3 id="workshop-integration"><a class="header" href="#workshop-integration">Workshop Integration</a></h3>
<p>LLM configurations are a Workshop resource type (D030):</p>
<ul>
<li><strong>Category:</strong> “LLM Configurations” in the Workshop browser</li>
<li><strong>Ratings and reviews:</strong> Community rates configurations by reliability, cost, quality</li>
<li><strong>Tagging:</strong> <code>budget</code>, <code>high-quality</code>, <code>local-only</code>, <code>fast</code>, <code>creative</code>, <code>coaching</code></li>
<li><strong>Compatibility tracking:</strong> Configurations specify which IC version and features they’ve been tested with</li>
</ul>
<h3 id="achievement-integration-d036"><a class="header" href="#achievement-integration-d036">Achievement Integration (D036)</a></h3>
<p>LLM configuration is an achievement milestone — encouraging discovery and adoption:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Achievement</th><th>Trigger</th><th>Category</th></tr>
</thead>
<tbody>
<tr><td>“Intelligence Officer”</td><td>Configure your first LLM provider</td><td>Community</td></tr>
<tr><td>“Strategic Command”</td><td>Win a game with LLM Orchestrator AI active</td><td>Exploration</td></tr>
<tr><td>“Artificial Intelligence”</td><td>Play 10 games with any LLM-enhanced AI mode</td><td>Exploration</td></tr>
<tr><td>“The Sharing Protocol”</td><td>Publish an LLM configuration to the Workshop</td><td>Community</td></tr>
<tr><td>“Commanding General”</td><td>Use task routing with 2+ providers simultaneously</td><td>Exploration</td></tr>
</tbody>
</table>
</div>
<h3 id="storage-d034"><a class="header" href="#storage-d034">Storage (D034)</a></h3>
<pre><code class="language-sql">CREATE TABLE llm_providers (
    id          INTEGER PRIMARY KEY,
    name        TEXT NOT NULL,
    type        TEXT NOT NULL,           -- 'ollama', 'openai', 'anthropic', 'custom'
    endpoint    TEXT,
    model       TEXT NOT NULL,
    api_key     TEXT,                    -- encrypted at rest
    is_active   INTEGER NOT NULL DEFAULT 1,
    created_at  TEXT NOT NULL,
    last_tested TEXT
);

CREATE TABLE llm_task_routing (
    task_name   TEXT PRIMARY KEY,        -- 'ai_orchestrator', 'mission_generation', etc.
    provider_id INTEGER REFERENCES llm_providers(id)
);
</code></pre>
<h3 id="relationship-to-existing-decisions"><a class="header" href="#relationship-to-existing-decisions">Relationship to Existing Decisions</a></h3>
<ul>
<li><strong>D016 (BYOLLM):</strong> D047 is the UI and management layer for D016’s <code>LlmProvider</code> trait. D016 defined the trait and provider types; D047 provides the user experience for configuring them.</li>
<li><strong>D036 (Achievements):</strong> LLM-related achievements encourage exploration of optional features without making them required.</li>
<li><strong>D030 (Workshop):</strong> LLM configurations become another shareable resource type.</li>
<li><strong>D034 (SQLite):</strong> Provider configurations stored locally, encrypted API keys.</li>
<li><strong>D044 (LLM AI):</strong> The task routing table directly determines which provider the orchestrator and LLM player use.</li>
</ul>
<h3 id="alternatives-considered-2"><a class="header" href="#alternatives-considered-2">Alternatives Considered</a></h3>
<ul>
<li>Settings-only configuration, no dedicated UI (rejected — multiple providers with task routing is too complex for a settings page)</li>
<li>No community sharing (rejected — LLM configuration is a significant friction point; community knowledge sharing reduces the barrier)</li>
<li>Include API keys in exports (rejected — obvious security risk; never export secrets)</li>
<li>Centralized LLM service run by IC project (rejected — conflicts with BYOLLM principle; users control their own data and costs)</li>
</ul>
<hr>
<hr>
<h2 id="d056-foreign-replay-import-openra--remastered-collection"><a class="header" href="#d056-foreign-replay-import-openra--remastered-collection">D056: Foreign Replay Import (OpenRA &amp; Remastered Collection)</a></h2>
<p><strong>Status:</strong> Settled
<strong>Phase:</strong> Phase 5 (Multiplayer) — decoders in Phase 2 (Simulation) for testing use
<strong>Depends on:</strong> D006 (Pluggable Networking), D011 (Cross-Engine Compatibility), <code>ra-formats</code> crate, <code>ic-protocol</code> (OrderCodec trait)</p>
<h3 id="problem"><a class="header" href="#problem">Problem</a></h3>
<p>The C&amp;C community has accumulated thousands of replay files across two active engines:</p>
<ul>
<li><strong>OpenRA</strong> — <code>.orarep</code> files (ZIP archives containing order streams + metadata YAML)</li>
<li><strong>C&amp;C Remastered Collection</strong> — binary <code>EventClass</code> recordings via <code>Queue_Record()</code> / <code>Queue_Playback()</code> (DoList serialization per frame, with header from <code>Save_Recording_Values()</code>)</li>
</ul>
<p>These replays represent community history, tournament archives, and — critically for IC — a massive corpus of <strong>known-correct gameplay sequences</strong> that can be used as behavioral regression tests. If IC’s simulation handles the same orders and produces visually wrong results (units walking through walls, harvesters ignoring ore, Tesla Coils not firing), that’s a bug we can catch automatically.</p>
<p>Without foreign replay support, this testing corpus is inaccessible. Additionally, players switching to IC lose access to their replay libraries — a real migration friction point.</p>
<h3 id="decision-1"><a class="header" href="#decision-1">Decision</a></h3>
<p><strong>Support direct playback of OpenRA and Remastered Collection replay files, AND provide a converter to IC’s native <code>.icrep</code> format.</strong></p>
<p>Both paths are supported because they serve different needs:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Capability</th><th>Direct Playback</th><th>Convert to <code>.icrep</code></th></tr>
</thead>
<tbody>
<tr><td><strong>Use case</strong></td><td>Quick viewing, casual browsing</td><td>Archival, analysis tooling, regression tests</td></tr>
<tr><td><strong>Requires original engine sim?</strong></td><td>No — runs through IC’s sim</td><td>No — conversion is a format translation</td></tr>
<tr><td><strong>Bit-identical to original?</strong></td><td>No — IC’s sim will diverge (D011)</td><td>N/A — stored as IC orders, replayed by IC sim</td></tr>
<tr><td><strong>Analysis events available?</strong></td><td>Only if IC re-derives them during playback</td><td>Yes — generated during conversion playback</td></tr>
<tr><td><strong>Signature chain?</strong></td><td>Not applicable (foreign replays aren’t relay-signed)</td><td>Unsigned (provenance metadata preserved)</td></tr>
<tr><td><strong>Speed</strong></td><td>Instant (stream-decode on demand)</td><td>One-time batch conversion</td></tr>
</tbody>
</table>
</div>
<h3 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h3>
<h4 id="foreign-replay-decoders-in-ra-formats"><a class="header" href="#foreign-replay-decoders-in-ra-formats">Foreign Replay Decoders (in <code>ra-formats</code>)</a></h4>
<p>Foreign replay file parsing belongs in <code>ra-formats</code> — it reads C&amp;C-family file formats, which is exactly what this crate exists for. The decoders produce a uniform intermediate representation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A decoded foreign replay, normalized to a common structure.
/// Lives in `ra-formats`. No dependency on `ic-sim` or `ic-net`.
pub struct ForeignReplay {
    pub source: ReplaySource,
    pub metadata: ForeignReplayMetadata,
    pub initial_state: ForeignInitialState,
    pub frames: Vec&lt;ForeignFrame&gt;,
}

pub enum ReplaySource {
    OpenRA { mod_id: String, mod_version: String },
    Remastered { game: RemasteredGame, version: String },
}

pub enum RemasteredGame { RedAlert, TiberianDawn }

pub struct ForeignReplayMetadata {
    pub players: Vec&lt;ForeignPlayerInfo&gt;,
    pub map_name: String,
    pub map_hash: Option&lt;String&gt;,
    pub duration_frames: u64,
    pub game_speed: Option&lt;String&gt;,
    pub recorded_at: Option&lt;String&gt;,
}

pub struct ForeignInitialState {
    pub random_seed: u32,
    pub scenario: String,
    pub build_level: Option&lt;u32&gt;,
    pub options: HashMap&lt;String, String&gt;,  // game options (shroud, crates, etc.)
}

/// One frame's worth of decoded orders from a foreign replay.
pub struct ForeignFrame {
    pub frame_number: u64,
    pub orders: Vec&lt;ForeignOrder&gt;,
}

/// A single order decoded from a foreign replay format.
/// Preserves the original order type name for diagnostics.
pub enum ForeignOrder {
    Move { player: u8, unit_ids: Vec&lt;u32&gt;, target_x: i32, target_y: i32 },
    Attack { player: u8, unit_ids: Vec&lt;u32&gt;, target_id: u32 },
    Deploy { player: u8, unit_id: u32 },
    Produce { player: u8, building_type: String, unit_type: String },
    Sell { player: u8, building_id: u32 },
    PlaceBuilding { player: u8, building_type: String, x: i32, y: i32 },
    SetRallyPoint { player: u8, building_id: u32, x: i32, y: i32 },
    // ... other order types common to C&amp;C games
    Unknown { player: u8, raw_type: u32, raw_data: Vec&lt;u8&gt; },
}
<span class="boring">}</span></code></pre>
<p>Two decoder implementations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Decodes OpenRA .orarep files.
/// .orarep = ZIP archive containing:
///   - orders stream (binary, per-tick Order objects)
///   - metadata.yaml (players, map, mod, outcome)
///   - sync.bin (state hashes per tick for desync detection)
pub struct OpenRAReplayDecoder;

impl OpenRAReplayDecoder {
    pub fn decode(reader: impl Read + Seek) -&gt; Result&lt;ForeignReplay&gt; { ... }
}

/// Decodes Remastered Collection replay files.
/// Binary format: Save_Recording_Values() header + per-frame EventClass records.
/// Format documented in research/remastered-collection-netcode-analysis.md § 6.
pub struct RemasteredReplayDecoder;

impl RemasteredReplayDecoder {
    pub fn decode(reader: impl Read) -&gt; Result&lt;ForeignReplay&gt; { ... }
}
<span class="boring">}</span></code></pre>
<h4 id="order-translation-in-ic-protocol"><a class="header" href="#order-translation-in-ic-protocol">Order Translation (in <code>ic-protocol</code>)</a></h4>
<p><code>ForeignOrder</code> → <code>TimestampedOrder</code> translation uses the existing <code>OrderCodec</code> trait architecture (already defined in <code>07-CROSS-ENGINE.md</code>). A <code>ForeignReplayCodec</code> maps foreign order types to IC’s <code>PlayerOrder</code> enum:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Translates ForeignOrder → TimestampedOrder.
/// Lives in ic-protocol alongside OrderCodec.
pub struct ForeignReplayCodec {
    coord_transform: CoordTransform,
    unit_type_map: HashMap&lt;String, UnitTypeId&gt;,   // "1tnk" → IC's UnitTypeId
    building_type_map: HashMap&lt;String, UnitTypeId&gt;,
}

impl ForeignReplayCodec {
    /// Translate a ForeignFrame into IC TickOrders.
    /// Orders that can't be mapped produce warnings, not errors.
    /// Unknown orders are skipped with a diagnostic log entry.
    pub fn translate_frame(
        &amp;self,
        frame: &amp;ForeignFrame,
        tick_rate_ratio: f64,  // e.g., OpenRA 40fps → IC 30tps
    ) -&gt; (TickOrders, Vec&lt;TranslationWarning&gt;) { ... }
}
<span class="boring">}</span></code></pre>
<h4 id="direct-playback-in-ic-net"><a class="header" href="#direct-playback-in-ic-net">Direct Playback (in <code>ic-net</code>)</a></h4>
<p><code>ForeignReplayPlayback</code> wraps the decoder output and implements <code>NetworkModel</code>, feeding translated orders to the sim tick by tick:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Plays back a foreign replay through IC's simulation.
/// Implements NetworkModel — the sim has no idea the orders came from OpenRA.
pub struct ForeignReplayPlayback {
    frames: Vec&lt;TickOrders&gt;,          // pre-translated
    current_tick: usize,
    source_metadata: ForeignReplayMetadata,
    translation_warnings: Vec&lt;TranslationWarning&gt;,
    divergence_tracker: DivergenceTracker,
}

impl NetworkModel for ForeignReplayPlayback {
    fn poll_tick(&amp;mut self) -&gt; Option&lt;TickOrders&gt; {
        let frame = self.frames.get(self.current_tick)?;
        self.current_tick += 1;
        Some(frame.clone())
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Divergence tracking:</strong> Since IC’s sim is not bit-identical to OpenRA’s or the Remastered Collection’s (D011), playback WILL diverge. The <code>DivergenceTracker</code> monitors for visible signs of divergence (units in invalid positions, negative resources, dead units receiving orders) and surfaces them in the UI:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DivergenceTracker {
    pub orders_targeting_dead_units: u64,
    pub orders_targeting_invalid_positions: u64,
    pub first_likely_divergence_tick: Option&lt;u64&gt;,
    pub confidence: DivergenceConfidence,
}

pub enum DivergenceConfidence {
    /// Playback looks plausible — no obvious divergence detected.
    Plausible,
    /// Minor anomalies detected — playback may be slightly off.
    MinorDrift { tick: u64, details: String },
    /// Major divergence — orders no longer make sense for current game state.
    Diverged { tick: u64, details: String },
}
<span class="boring">}</span></code></pre>
<p>The UI shows a subtle indicator: green (plausible) → yellow (minor drift) → red (diverged). Players can keep watching past divergence — they just know the playback is no longer representative of the original game.</p>
<h4 id="conversion-to-icrep-cli-tool"><a class="header" href="#conversion-to-icrep-cli-tool">Conversion to <code>.icrep</code> (CLI tool)</a></h4>
<p>The <code>ic</code> CLI provides a conversion subcommand:</p>
<pre><code>ic replay import game.orarep -o game.icrep
ic replay import recording.bin --format remastered-ra -o game.icrep
ic replay import --batch ./openra-replays/ -o ./converted/
</code></pre>
<p>Conversion process:</p>
<ol>
<li>Decode foreign replay via <code>ra-formats</code> decoder</li>
<li>Translate all orders via <code>ForeignReplayCodec</code></li>
<li>Run translated orders through IC’s sim headlessly (generates analysis events + state hashes)</li>
<li>Write <code>.icrep</code> with <code>Minimal</code> embedding mode + provenance metadata</li>
</ol>
<p>The converted <code>.icrep</code> includes provenance metadata in its JSON metadata block:</p>
<pre><code class="language-json">{
  "replay_id": "...",
  "converted_from": {
    "source": "openra",
    "original_file": "game-20260115-1530.orarep",
    "original_mod": "ra",
    "original_version": "20231010",
    "conversion_date": "2026-02-15T12:00:00Z",
    "translation_warnings": 3,
    "diverged_at_tick": null
  }
}
</code></pre>
<h4 id="automated-regression-testing"><a class="header" href="#automated-regression-testing">Automated Regression Testing</a></h4>
<p>The most valuable use of foreign replay import is <strong>automated behavioral regression testing</strong>:</p>
<pre><code>ic replay test ./test-corpus/openra-replays/ --check visual-sanity
</code></pre>
<p>This runs each foreign replay headlessly through IC’s sim and checks for:</p>
<ul>
<li><strong>Order rejection rate:</strong> What percentage of translated orders does IC’s sim reject as invalid? A high rate means IC’s order validation (D012) disagrees with OpenRA’s — worth investigating.</li>
<li><strong>Unit survival anomalies:</strong> If a unit that survived the entire original game dies in tick 50 in IC, the combat/movement system likely has a significant behavioral difference.</li>
<li><strong>Economy divergence:</strong> Comparing resource trajectories (if OpenRA replay has sync data) against IC’s sim output highlights harvesting/refinery bugs early.</li>
<li><strong>Crash-free completion:</strong> The replay completes without panics, even if the game state diverges.</li>
</ul>
<p>This is NOT about achieving bit-identical results (D011 explicitly rejects that). It’s about detecting <strong>gross behavioral bugs</strong> — the kind where a tank drives into the ocean or a building can’t be placed on flat ground. The foreign replay corpus acts as a “does this look roughly right?” sanity check.</p>
<h3 id="tick-rate-reconciliation"><a class="header" href="#tick-rate-reconciliation">Tick Rate Reconciliation</a></h3>
<p>OpenRA runs at a configurable tick rate (default 40 tps for Normal speed). The Remastered Collection’s original engine runs at approximately 15 fps for game logic. IC targets 30 tps. Foreign replay playback must reconcile these rates:</p>
<ul>
<li><strong>OpenRA 40 tps → IC 30 tps:</strong> Some foreign ticks have no orders and can be merged. Orders are retimed proportionally: foreign tick 120 at 40 tps = 3.0 seconds → IC tick 90 at 30 tps.</li>
<li><strong>Remastered ~15 fps → IC 30 tps:</strong> Each foreign frame maps to ~2 IC ticks. Orders land on the nearest IC tick boundary.</li>
</ul>
<p>The mapping is approximate — sub-tick timing differences mean some orders arrive 1 tick earlier or later than the original. For direct playback this is acceptable (the game will diverge anyway). For regression tests, the tick mapping is deterministic (always the same IC tick for the same foreign tick).</p>
<h3 id="what-this-is-not"><a class="header" href="#what-this-is-not">What This Is NOT</a></h3>
<ul>
<li><strong>NOT cross-engine multiplayer.</strong> Foreign replays are played back through IC’s sim only. No attempt to match the original engine’s behavior tick-for-tick.</li>
<li><strong>NOT a guarantee of visual fidelity.</strong> The game will look “roughly right” for early ticks, then progressively diverge as simulation differences compound. This is expected and documented (D011).</li>
<li><strong>NOT a replacement for IC’s native replay system.</strong> Native <code>.icrep</code> replays are the primary format. Foreign replay support is a compatibility/migration/testing feature.</li>
</ul>
<h3 id="alternatives-considered-3"><a class="header" href="#alternatives-considered-3">Alternatives Considered</a></h3>
<ul>
<li><strong>Convert-only, no direct playback</strong> (rejected — forces a batch step before viewing; users want to double-click an <code>.orarep</code> and watch it immediately)</li>
<li><strong>Direct playback only, no conversion</strong> (rejected — analysis tooling and regression tests need <code>.icrep</code> format; conversion enables the analysis event stream and signature chain)</li>
<li><strong>Embed OpenRA/Remastered sim for accurate playback</strong> (rejected — contradicts D011’s “not a port” principle; massive dependency; licensing complexity; architecture violation of sim purity)</li>
<li><strong>Support only OpenRA, not Remastered</strong> (rejected — Remastered replays are simpler to decode and the community has archives worth preserving; the DoList format is well-documented in EA’s GPL source)</li>
</ul>
<h3 id="integration-with-existing-decisions"><a class="header" href="#integration-with-existing-decisions">Integration with Existing Decisions</a></h3>
<ul>
<li><strong>D006 (Pluggable Networking):</strong> <code>ForeignReplayPlayback</code> is just another <code>NetworkModel</code> implementation — the sim doesn’t know the orders came from a foreign replay.</li>
<li><strong>D011 (Cross-Engine Compatibility):</strong> Foreign replay playback is “Level 1: Replay Compatibility” from <code>07-CROSS-ENGINE.md</code> — now with concrete architecture.</li>
<li><strong>D023 (OpenRA Vocabulary Compatibility):</strong> The <code>ForeignReplayCodec</code> uses the same OpenRA vocabulary mapping (trait names, order names) that D023 established for YAML rules.</li>
<li><strong>D025 (Runtime MiniYAML Loading):</strong> OpenRA <code>.orarep</code> metadata is MiniYAML — parsed by the same <code>ra-formats</code> infrastructure.</li>
<li><strong>D027 (Canonical Enum Compatibility):</strong> Foreign order type names (locomotor types, stance names) use D027’s enum mappings.</li>
</ul>
<hr>
<hr>
<h2 id="d057-llm-skill-library--lifelong-learning-for-ai-and-content-generation"><a class="header" href="#d057-llm-skill-library--lifelong-learning-for-ai-and-content-generation">D057: LLM Skill Library — Lifelong Learning for AI and Content Generation</a></h2>
<p><strong>Status:</strong> Settled
<strong>Scope:</strong> <code>ic-llm</code>, <code>ic-ai</code>, <code>ic-sim</code> (read-only via <code>FogFilteredView</code>)
<strong>Phase:</strong> Phase 7 (LLM Missions + Ecosystem), with AI skill accumulation feasible as soon as D044 ships
<strong>Depends on:</strong> D016 (LLM-Generated Missions), D034 (SQLite Storage), D041 (AiStrategy), D044 (LLM-Enhanced AI), D030 (Workshop)
<strong>Inspired by:</strong> Voyager (NVIDIA/MineDojo, 2023) — LLM-powered lifelong learning agent for Minecraft with an ever-growing skill library of verified, composable, semantically-indexed executable behaviors</p>
<h3 id="problem-1"><a class="header" href="#problem-1">Problem</a></h3>
<p>IC’s LLM features are currently <strong>stateless between sessions</strong>:</p>
<ul>
<li><strong>D044 (<code>LlmOrchestratorAi</code>):</strong> Every strategic consultation starts from scratch. The LLM receives game state + <code>AiEventLog</code> narrative and produces a <code>StrategicPlan</code> with no memory of what strategies worked in previous games. A 100-game-old AI is no smarter than a first-game AI.</li>
<li><strong>D016 (mission generation):</strong> Every mission is generated from raw prompts or template-filling. The LLM has no knowledge of which encounter compositions produced missions that players rated highly, completed at target difficulty, or found genuinely fun.</li>
<li><strong>D044 (<code>LlmPlayerAi</code>):</strong> The experimental full-LLM player repeats the same reasoning mistakes across games because it has no accumulated knowledge of what works in Red Alert.</li>
</ul>
<p>The scene template library (<code>04-MODDING.md</code> § Scene Templates) is a <strong>hand-authored</strong> skill library — pre-built, verified building blocks (ambush, patrol, convoy escort, defend position). But there’s no mechanism for the LLM to <strong>discover, verify, and accumulate</strong> its own proven patterns over time.</p>
<p>Voyager (Wang et al., 2023) demonstrated that an LLM agent with a <strong>skill library</strong> — verified executable behaviors indexed by semantic embedding, retrieved by similarity, and composed for new tasks — dramatically outperforms a stateless LLM agent. Voyager obtained 3.3x more unique items and unlocked tech tree milestones 15.3x faster than agents without skill accumulation. The key insight: storing verified skills eliminates catastrophic forgetting and compounds the agent’s capabilities over time.</p>
<p>IC already has almost every infrastructure piece needed for this pattern. The missing component is the <strong>verification → storage → retrieval → composition</strong> loop that turns individual LLM outputs into a growing library of proven capabilities.</p>
<h3 id="decision-2"><a class="header" href="#decision-2">Decision</a></h3>
<p>Add a <strong>Skill Library</strong> system to <code>ic-llm</code> — a persistent, semantically-indexed store of verified LLM outputs that accumulates knowledge across sessions. The library serves two domains with shared infrastructure:</p>
<ol>
<li><strong>AI Skills</strong> — strategic patterns verified through gameplay outcomes (D044)</li>
<li><strong>Generation Skills</strong> — mission/encounter patterns verified through player ratings and validation (D016)</li>
</ol>
<p>Both domains use the same storage format, retrieval mechanism, verification pipeline, and sharing infrastructure. They differ only in what constitutes a “skill” and how verification works.</p>
<h3 id="architecture-2"><a class="header" href="#architecture-2">Architecture</a></h3>
<h4 id="the-skill"><a class="header" href="#the-skill">The Skill</a></h4>
<p>A skill is a verified, reusable LLM output with provenance and quality metadata:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A verified, reusable LLM output stored in the skill library.
/// Applicable to both AI strategy skills and content generation skills.
pub struct Skill {
    pub id: SkillId,                        // UUID
    pub domain: SkillDomain,
    pub name: String,                       // human-readable, LLM-generated
    pub description: String,                // semantic description for retrieval
    pub description_embedding: Vec&lt;f32&gt;,    // embedding vector for similarity search
    pub body: SkillBody,                    // the actual executable content
    pub provenance: SkillProvenance,
    pub quality: SkillQuality,
    pub tags: Vec&lt;String&gt;,                  // searchable tags (e.g., "anti-air", "early-game", "naval")
    pub composable_with: Vec&lt;SkillId&gt;,      // skills this has been successfully composed with
    pub created_at: String,                 // ISO 8601
    pub last_used: String,
    pub use_count: u32,
}

pub enum SkillDomain {
    /// Strategic AI patterns (D044) — "how to play"
    AiStrategy,
    /// Mission/encounter generation patterns (D016) — "how to build content"
    ContentGeneration,
}

pub enum SkillBody {
    /// A strategic plan template with parameter bindings.
    /// Used by LlmOrchestratorAi to guide inner AI behavior.
    StrategicPattern {
        /// The situation this pattern addresses (serialized game state features).
        situation: SituationSignature,
        /// The StrategicPlan that worked in this situation.
        plan: StrategicPlan,
        /// Parameter adjustments applied to the inner AI.
        parameter_bindings: Vec&lt;(String, i32)&gt;,
    },
    /// A mission encounter composition — scene templates + parameter values.
    /// Used by D016 mission generation to compose proven building blocks.
    EncounterPattern {
        /// Scene template IDs and their parameter values.
        scene_composition: Vec&lt;SceneInstance&gt;,
        /// Overall mission structure metadata.
        mission_structure: MissionStructureHints,
    },
    /// A raw prompt+response pair that produced a verified good result.
    /// Injected as few-shot examples in future LLM consultations.
    VerifiedExample {
        prompt_context: String,
        response: String,
    },
}

pub struct SkillProvenance {
    pub source: SkillSource,
    pub model_id: Option&lt;String&gt;,           // which LLM model generated it
    pub game_module: String,                // "ra1", "td", etc.
    pub engine_version: String,
}

pub enum SkillSource {
    /// Discovered by the LLM during gameplay or generation, then verified.
    LlmDiscovered,
    /// Hand-authored by a human (e.g., built-in scene templates promoted to skills).
    HandAuthored,
    /// Imported from Workshop.
    Workshop { source_id: String, author: String },
    /// Refined from an LLM-discovered skill by a human editor.
    HumanRefined { original_id: SkillId },
}

pub struct SkillQuality {
    pub verification_count: u32,            // how many times verified
    pub success_rate: f64,                  // wins / uses for AI; completion rate for missions
    pub average_rating: Option&lt;f64&gt;,        // player rating (1-5) for generation skills
    pub confidence: SkillConfidence,
    pub last_verified: String,              // ISO 8601
}

pub enum SkillConfidence {
    /// Passed initial validation but low sample size (&lt; 3 verifications).
    Tentative,
    /// Consistently successful across multiple verifications (3-10).
    Established,
    /// Extensively verified with high success rate (10+).
    Proven,
}
<span class="boring">}</span></code></pre>
<h4 id="storage-sqlite-d034"><a class="header" href="#storage-sqlite-d034">Storage: SQLite (D034)</a></h4>
<p>Skills are stored in SQLite — same embedded database as all other IC persistent state. No external vector database required.</p>
<pre><code class="language-sql">CREATE TABLE skills (
    id              TEXT PRIMARY KEY,
    domain          TEXT NOT NULL,       -- 'ai_strategy' | 'content_generation'
    name            TEXT NOT NULL,
    description     TEXT NOT NULL,
    body_json       TEXT NOT NULL,       -- JSON-serialized SkillBody
    tags            TEXT NOT NULL,       -- JSON array of tags
    game_module     TEXT NOT NULL,
    source          TEXT NOT NULL,       -- 'llm_discovered' | 'hand_authored' | 'workshop' | 'human_refined'
    model_id        TEXT,
    verification_count  INTEGER DEFAULT 0,
    success_rate    REAL DEFAULT 0.0,
    average_rating  REAL,
    confidence      TEXT DEFAULT 'tentative',
    use_count       INTEGER DEFAULT 0,
    created_at      TEXT NOT NULL,
    last_used       TEXT,
    last_verified   TEXT
);

-- FTS5 for text-based skill retrieval (fast, no external dependencies)
CREATE VIRTUAL TABLE skills_fts USING fts5(
    name, description, tags,
    content=skills, content_rowid=rowid
);

-- Embedding vectors stored as BLOBs for similarity search
CREATE TABLE skill_embeddings (
    skill_id        TEXT PRIMARY KEY REFERENCES skills(id),
    embedding       BLOB NOT NULL,       -- f32 array, serialized
    model_id        TEXT NOT NULL         -- which embedding model produced this
);

-- Composition history: which skills have been successfully used together
CREATE TABLE skill_compositions (
    skill_a         TEXT REFERENCES skills(id),
    skill_b         TEXT REFERENCES skills(id),
    success_count   INTEGER DEFAULT 0,
    PRIMARY KEY (skill_a, skill_b)
);
</code></pre>
<p><strong>Retrieval strategy (two-tier):</strong></p>
<ol>
<li><strong>FTS5 keyword search</strong> — fast, zero-dependency, works offline. Query: <code>"anti-air defense early-game"</code> matches skills with those terms in name/description/tags. This is the primary retrieval path and works without an embedding model.</li>
<li><strong>Embedding similarity</strong> — optional, higher quality. If the user’s <code>LlmProvider</code> (D016) supports embeddings (most do), skill descriptions are embedded at storage time. Retrieval computes cosine similarity between the query embedding and stored embeddings. This is a SQLite scan with in-process vector math — no external vector database.</li>
</ol>
<p>FTS5 is always available. Embedding similarity is used when an embedding model is configured and falls back to FTS5 otherwise. Both paths return ranked results; the top-K skills are injected into the LLM prompt as few-shot context.</p>
<h4 id="verification-pipeline"><a class="header" href="#verification-pipeline">Verification Pipeline</a></h4>
<p>The critical difference between a skill library and a prompt cache: <strong>skills are verified</strong>. An unverified LLM output is a candidate; a verified output is a skill.</p>
<p><strong>AI Strategy verification (D044):</strong></p>
<pre><code>LlmOrchestratorAi generates StrategicPlan
  → Inner AI executes the plan over the next consultation interval
  → Match outcome observed (win/loss, resource delta, army value delta, territory change)
  → If favorable outcome: candidate skill created
  → Candidate includes: SituationSignature (game state features at plan time)
                        + StrategicPlan + parameter bindings + outcome metrics
  → Same pattern used in 3+ games with &gt;60% success → promoted to Established skill
  → 10+ uses with &gt;70% success → promoted to Proven skill
</code></pre>
<p><code>SituationSignature</code> captures the game state features that made this plan applicable — not the entire state, but the strategically relevant dimensions:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A compressed representation of the game situation when a skill was applied.
/// Used to match current situations against stored skills.
pub struct SituationSignature {
    pub game_phase: GamePhase,              // early / mid / late (derived from tick + tech level)
    pub economy_state: EconomyState,        // ahead / even / behind (relative resource flow)
    pub army_composition: Vec&lt;(String, u8)&gt;, // top unit types by proportion
    pub enemy_composition_estimate: Vec&lt;(String, u8)&gt;,
    pub map_control: f32,                   // 0.0-1.0 estimated map control
    pub threat_level: ThreatLevel,          // none / low / medium / high / critical
    pub active_tech: Vec&lt;String&gt;,           // available tech tiers
}
<span class="boring">}</span></code></pre>
<p><strong>Content Generation verification (D016):</strong></p>
<pre><code>LLM generates mission (from template or raw)
  → Schema validation passes (valid unit types, reachable objectives, balanced resources)
  → Player plays the mission
  → Outcome observed: completion (yes/no), time-to-complete, player rating (if provided)
  → If completed + rated ≥ 3 stars: candidate encounter skill created
  → Candidate includes: scene composition + parameter values + mission structure + rating
  → Aggregated across 3+ players/plays with avg rating ≥ 3.5 → Established
  → Workshop rating data (if published) feeds back into quality scores
</code></pre>
<p><strong>Automated pre-verification (no player required):</strong></p>
<p>For AI skills, headless simulation provides automated verification:</p>
<pre><code>ic skill verify --domain ai --games 20 --opponent "IC Default Hard"
</code></pre>
<p>This runs the AI with each candidate skill against a reference opponent headlessly, measuring win rate. Skills that pass automated verification at a lower threshold (&gt;40% win rate against Hard AI) are promoted to <code>Tentative</code>. Human play promotes them further.</p>
<h4 id="prompt-augmentation--how-skills-reach-the-llm"><a class="header" href="#prompt-augmentation--how-skills-reach-the-llm">Prompt Augmentation — How Skills Reach the LLM</a></h4>
<p>When the <code>LlmOrchestratorAi</code> or mission generator prepares a prompt, the skill library injects relevant context:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Retrieves relevant skills and augments the LLM prompt.
pub struct SkillRetriever {
    db: SqliteConnection,
    embedding_provider: Option&lt;Box&lt;dyn EmbeddingProvider&gt;&gt;,
}

impl SkillRetriever {
    /// Find skills relevant to the current context.
    /// Returns top-K skills ranked by relevance, filtered by domain and game module.
    pub fn retrieve(
        &amp;self,
        query: &amp;str,
        domain: SkillDomain,
        game_module: &amp;str,
        max_results: usize,
    ) -&gt; Vec&lt;Skill&gt; {
        // 1. Try embedding similarity if available
        // 2. Fall back to FTS5 keyword search
        // 3. Filter by confidence &gt;= Tentative
        // 4. Rank by (relevance_score * quality.success_rate)
        // 5. Return top-K
        ...
    }

    /// Format retrieved skills as few-shot context for the LLM prompt.
    pub fn format_as_context(&amp;self, skills: &amp;[Skill]) -&gt; String {
        // Each skill becomes a "Previously successful approach:" block
        // in the prompt, with situation → plan → outcome
        ...
    }
}
<span class="boring">}</span></code></pre>
<p><strong>In the orchestrator prompt flow (D044):</strong></p>
<pre><code>System prompt (from llm/prompts/orchestrator.yaml)
  + "Previously successful strategies in similar situations:"
  + [top 3-5 retrieved AI skills, formatted as situation/plan/outcome examples]
  + "Current game state:"
  + [serialized FogFilteredView]
  + "Recent events:"
  + [event_log.to_narrative(since_tick)]
  → LLM produces StrategicPlan
    (informed by proven patterns, but free to adapt or deviate)
</code></pre>
<p><strong>In the mission generation prompt flow (D016):</strong></p>
<pre><code>System prompt (from llm/prompts/mission_generator.yaml)
  + "Encounter patterns that players enjoyed:"
  + [top 3-5 retrieved generation skills, formatted as composition/rating examples]
  + Campaign context (skeleton, current act, character states)
  + Player preferences
  → LLM produces mission YAML
    (informed by proven encounter patterns, but free to create new ones)
</code></pre>
<p>The LLM is never forced to use retrieved skills — they’re few-shot examples that bias toward proven patterns while preserving creative freedom. If the current situation is genuinely novel (no similar skills found), the retrieval returns nothing and the LLM operates as it does today — statelessly.</p>
<h4 id="skill-composition"><a class="header" href="#skill-composition">Skill Composition</a></h4>
<p>Complex gameplay requires combining multiple skills. Voyager’s key insight: skills compose — “mine iron” + “craft furnace” + “smelt iron ore” compose into “make iron ingots.” IC skills compose similarly:</p>
<p><strong>AI skill composition:</strong></p>
<ul>
<li>“Rush with light vehicles at 5:00” + “transition to heavy armor at 12:00” = an early-aggression-into-late-game strategic arc</li>
<li>The <code>composable_with</code> field and <code>skill_compositions</code> table track which skills have been successfully used in sequence</li>
<li>The orchestrator can retrieve a <em>sequence</em> of skills for different game phases, not just a single skill for the current moment</li>
</ul>
<p><strong>Generation skill composition:</strong></p>
<ul>
<li>“bridge_ambush” + “timed_extraction” + “weather_escalation” = a specific mission pattern</li>
<li>This is exactly the existing scene template hierarchy (<code>04-MODDING.md</code> § Template Hierarchy), but with LLM-discovered compositions alongside hand-authored ones</li>
<li>The <code>EncounterPattern</code> skill body stores the full composition — which scene templates, in what order, with what parameter values</li>
</ul>
<h4 id="workshop-distribution-d030"><a class="header" href="#workshop-distribution-d030">Workshop Distribution (D030)</a></h4>
<p>Skill libraries are Workshop-shareable resources:</p>
<pre><code class="language-yaml"># workshop/my-ai-skill-library/resource.yaml
type: skill_library
display_name: "Competitive RA1 AI Strategies"
description: "150 verified strategic patterns learned over 500 games against Hard AI"
game_module: ra1
domain: ai_strategy
skill_count: 150
average_confidence: proven
license: CC-BY-SA-4.0
ai_usage: Allow
</code></pre>
<p><strong>Sharing model:</strong></p>
<ul>
<li>Players export their skill library (or a curated subset) as a Workshop package</li>
<li>Other players subscribe and merge into their local library</li>
<li>Skill provenance tracks origin — <code>Workshop { source_id, author }</code></li>
<li>Community curation: Workshop ratings on skill libraries indicate quality</li>
<li>AI tournament leaderboards (D043) can require contestants to publish their skill libraries, creating a knowledge commons</li>
</ul>
<p><strong>Privacy:</strong></p>
<ul>
<li>Skill libraries contain <strong>no player data</strong> — only LLM outputs, game state features, and outcome metrics</li>
<li>No replays, no player names, no match IDs in the exported skill data</li>
<li>A skill that says “rush at 5:00 with 3 light tanks against enemy who expanded early” reveals a strategy, not a person</li>
</ul>
<h4 id="skill-lifecycle"><a class="header" href="#skill-lifecycle">Skill Lifecycle</a></h4>
<pre><code>1. DISCOVERY      LLM generates an output (StrategicPlan or mission content)
        ↓
2. EXECUTION      Output is used in gameplay or mission play
        ↓
3. EVALUATION     Outcome measured (win/loss, rating, completion)
        ↓
4. CANDIDACY      If outcome meets threshold → candidate skill created
        ↓
5. VERIFICATION   Same pattern reused 3+ times with consistent success → Established
        ↓
6. PROMOTION      10+ verifications with high success → Proven
        ↓
7. RETRIEVAL      Proven skills injected as few-shot context in future LLM consultations
        ↓
8. COMPOSITION    Skills used together successfully → composition recorded
        ↓
9. SHARING        Player exports library to Workshop; community benefits
</code></pre>
<p><strong>Skill decay:</strong> Skills verified against older engine versions may become less relevant as game balance changes. Skills include <code>engine_version</code> in provenance. A periodic maintenance pass (triggered by engine update) re-validates <code>Proven</code> skills by running them through headless simulation. Skills that fall below threshold are downgraded to <code>Tentative</code> rather than deleted — balance might revert, or the pattern might work in a different context.</p>
<p><strong>Skill pruning:</strong> Libraries grow unboundedly without curation. Automatic pruning removes skills that are: (a) <code>Tentative</code> for &gt;30 days with no additional verifications, (b) <code>use_count == 0</code> for &gt;90 days, or (c) superseded by a strictly-better skill (same situation, higher success rate). Manual pruning via <code>ic skill prune</code> CLI. Users set a max library size; pruning prioritizes keeping <code>Proven</code> skills and removing <code>Tentative</code> duplicates.</p>
<h3 id="embedding-provider"><a class="header" href="#embedding-provider">Embedding Provider</a></h3>
<p>Embeddings require a model. IC does not ship one — same BYOLLM principle as D016:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Produces embedding vectors from text descriptions.
/// Optional — FTS5 provides retrieval without embeddings.
pub trait EmbeddingProvider: Send + Sync {
    fn embed(&amp;self, text: &amp;str) -&gt; Result&lt;Vec&lt;f32&gt;&gt;;
    fn embedding_dimensions(&amp;self) -&gt; usize;
    fn model_id(&amp;self) -&gt; &amp;str;
}
<span class="boring">}</span></code></pre>
<p>Built-in implementations:</p>
<ul>
<li><code>OpenAIEmbeddings</code> — uses OpenAI’s <code>text-embedding-3-small</code> (or compatible API)</li>
<li><code>OllamaEmbeddings</code> — uses any Ollama model with embedding support (local, free)</li>
<li><code>NoEmbeddings</code> — disables embedding similarity; FTS5 keyword search only</li>
</ul>
<p>The embedding model is configured alongside the <code>LlmProvider</code> in D047’s task routing table. If no embedding provider is configured, the skill library works with FTS5 only — slightly lower retrieval quality, but fully functional offline with zero external dependencies.</p>
<h3 id="cli"><a class="header" href="#cli">CLI</a></h3>
<pre><code>ic skill list [--domain ai|content] [--confidence proven|established|tentative] [--game-module ra1]
ic skill show &lt;skill-id&gt;
ic skill verify --domain ai --games 20 --opponent "IC Default Hard"
ic skill export [--domain ai] [--confidence established+] -o skills.icpkg
ic skill import skills.icpkg [--merge|--replace]
ic skill prune [--max-size 500] [--dry-run]
ic skill stats     # library overview: counts by domain/confidence/game module
</code></pre>
<h3 id="what-this-is-not-1"><a class="header" href="#what-this-is-not-1">What This Is NOT</a></h3>
<ul>
<li><strong>NOT fine-tuning.</strong> The LLM model parameters are never modified. Skills are retrieved context (few-shot examples), not gradient updates. Users never need GPU training infrastructure.</li>
<li><strong>NOT a replay database.</strong> Skills store compressed patterns (situation signature + plan + outcome), not full game replays. A skill is ~1-5 KB; a replay is ~2-5 MB.</li>
<li><strong>NOT required for any LLM feature to work.</strong> All LLM features (D016, D044) work without a skill library — they just don’t improve over time. The library is an additive enhancement, not a prerequisite.</li>
<li><strong>NOT a replacement for hand-authored content.</strong> The built-in scene templates, AI behavior presets (D043), and campaign content (D021) are hand-crafted and don’t depend on the skill library. The library augments LLM capabilities; it doesn’t replace authored content.</li>
</ul>
<h3 id="alternatives-considered-4"><a class="header" href="#alternatives-considered-4">Alternatives Considered</a></h3>
<ul>
<li><strong>Full model fine-tuning per user</strong> (rejected — requires GPU infrastructure, violates BYOLLM portability, incompatible with API-based providers, and risks catastrophic forgetting of general capabilities)</li>
<li><strong>Replay-as-skill (store full replays as skills)</strong> (rejected — replays are too large and unstructured for retrieval; skills must be compressed to situation+plan patterns that fit in a prompt context window)</li>
<li><strong>External vector database (Pinecone, Qdrant, Chroma)</strong> (rejected — violates D034’s “no external DB” principle; SQLite + FTS5 + in-process vector math is sufficient for a skill library measured in hundreds-to-thousands of entries, not millions)</li>
<li><strong>Skills stored in the LLM’s context window only (no persistence)</strong> (rejected — context windows are bounded and ephemeral; the whole point is cross-session accumulation)</li>
<li><strong>Shared global skill library</strong> (rejected — violates local-first privacy principle; players opt in to sharing via Workshop, never forced; global aggregation risks homogenizing strategies)</li>
<li><strong>AI training via reinforcement learning instead of skill accumulation</strong> (rejected — RL requires model parameter access, massive compute, and is incompatible with BYOLLM API models; skill retrieval works with any LLM including cloud APIs)</li>
</ul>
<h3 id="integration-with-existing-decisions-1"><a class="header" href="#integration-with-existing-decisions-1">Integration with Existing Decisions</a></h3>
<ul>
<li><strong>D016 (LLM Missions):</strong> Generation skills are accumulated from D016’s mission generation pipeline. The template-first approach (<code>04-MODDING.md</code> § LLM + Templates) benefits most — proven template parameter combinations become generation skills, dramatically improving template-filling reliability.</li>
<li><strong>D034 (SQLite):</strong> Skill storage uses the same embedded SQLite database as replay catalogs, match history, and gameplay events. New tables, same infrastructure. FTS5 is already available for search.</li>
<li><strong>D041 (AiStrategy):</strong> The <code>AiEventLog</code>, <code>FogFilteredView</code>, and <code>set_parameter()</code> infrastructure provide the verification feedback loop. Skill outcomes are measured through the same event pipeline that informs the orchestrator.</li>
<li><strong>D043 (AI Presets):</strong> Built-in AI behavior presets can be promoted to hand-authored skills in the library, giving the retrieval system access to the same proven patterns that the preset system encodes — but indexed for semantic search rather than manual selection.</li>
<li><strong>D044 (LLM AI):</strong> AI strategy skills directly augment the orchestrator’s consultation prompts. The <code>LlmOrchestratorAi</code> becomes the primary skill producer and consumer. The <code>LlmPlayerAi</code> also benefits — its reasoning improves with proven examples in context.</li>
<li><strong>D047 (LLM Configuration Manager):</strong> The embedding provider is configured alongside other LLM providers in D047’s task routing table. Task: <code>embedding</code> → Provider: Ollama/OpenAI.</li>
<li><strong>D030 (Workshop):</strong> Skill libraries are Workshop resources — shareable, versionable, ratable. AI tournament communities can maintain curated skill libraries.</li>
<li><strong>D031 (Observability):</strong> Skill retrieval, verification, and promotion events are logged as telemetry events — observable in Grafana dashboards for debugging skill library behavior.</li>
</ul>
<h3 id="relationship-to-voyager"><a class="header" href="#relationship-to-voyager">Relationship to Voyager</a></h3>
<p>IC’s skill library adapts Voyager’s three core insights to the RTS domain:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Voyager Concept</th><th>IC Adaptation</th></tr>
</thead>
<tbody>
<tr><td><strong>Skill = executable JavaScript function</strong></td><td>Skill = <code>StrategicPlan</code> (AI) or <code>EncounterPattern</code> (generation) — domain-specific executable content</td></tr>
<tr><td><strong>Skill verification via environment feedback</strong></td><td>Verification via match outcome (AI) or player rating + schema validation (generation)</td></tr>
<tr><td><strong>Embedding-indexed retrieval</strong></td><td>Two-tier: FTS5 keyword (always available) + optional embedding similarity</td></tr>
<tr><td><strong>Compositional skills</strong></td><td><code>composable_with</code> + <code>skill_compositions</code> table; scene template hierarchy for generation</td></tr>
<tr><td><strong>Automatic curriculum</strong></td><td>Not directly adopted — IC’s curriculum is human-driven (player picks missions, matchmaking picks opponents). The skill library accumulates passively during normal play.</td></tr>
<tr><td><strong>Iterative prompting with self-verification</strong></td><td>Schema validation + headless sim verification (<code>ic skill verify</code>) replaces Voyager’s in-environment code testing</td></tr>
</tbody>
</table>
</div>
<p>The key architectural difference: Voyager’s agent runs in a single-player sandbox with fast iteration loops (try code → observe → refine → store). IC’s skills accumulate more slowly — each verification requires a full game or mission play. This means IC’s library grows over days/weeks rather than hours, but the skills are verified against real gameplay rather than sandbox experiments, producing higher-quality patterns.</p>
<hr>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../decisions/09e-community.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../decisions/09g-interaction.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../decisions/09e-community.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../decisions/09g-interaction.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-c2a407aa.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
