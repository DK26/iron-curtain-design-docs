<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Decision Log - Iron Curtain — Design Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Design docs for a Rust-native Red Alert RTS engine">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-669b8e99.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-678cb19b.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Iron Curtain — Design Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/DK26/iron-curtain-design-docs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>
                        <a href="https://github.com/DK26/iron-curtain-design-docs/edit/main/src/09-DECISIONS.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <span class=fa-svg id="git-edit-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M421.7 220.3l-11.3 11.3-22.6 22.6-205 205c-6.6 6.6-14.8 11.5-23.8 14.1L30.8 511c-8.4 2.5-17.5 .2-23.7-6.1S-1.5 489.7 1 481.2L38.7 353.1c2.6-9 7.5-17.2 14.1-23.8l205-205 22.6-22.6 11.3-11.3 33.9 33.9 62.1 62.1 33.9 33.9zM96 353.9l-9.3 9.3c-.9 .9-1.6 2.1-2 3.4l-25.3 86 86-25.3c1.3-.4 2.5-1.1 3.4-2l9.3-9.3H112c-8.8 0-16-7.2-16-16V353.9zM453.3 19.3l39.4 39.4c25 25 25 65.5 0 90.5l-14.5 14.5-22.6 22.6-11.3 11.3-33.9-33.9-62.1-62.1L314.3 67.7l11.3-11.3 22.6-22.6 14.5-14.5c25-25 65.5-25 90.5 0z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="09--decision-log"><a class="header" href="#09--decision-log">09 — Decision Log</a></h1>
<p>Every major design decision, with rationale and alternatives considered. Reference this when revisiting or challenging a decision.</p>
<hr>
<h2 id="d001-language--rust"><a class="header" href="#d001-language--rust">D001: Language — Rust</a></h2>
<p><strong>Decision:</strong> Build the engine in Rust.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>No GC pauses (C# / .NET is OpenRA’s known weakness in large battles)</li>
<li>Memory safety without runtime cost</li>
<li>Fearless concurrency for parallel ECS systems</li>
<li>First-class WASM compilation target (browser, modding sandbox)</li>
<li>Modern tooling (cargo, crates.io, clippy, miri)</li>
<li>No competition in Rust RTS space — wide open field</li>
</ul>
<p><strong>Why not a high-level language (C#, Python, Java)?</strong></p>
<p>The goal is to extract maximum performance from the hardware. A game engine is one of the few domains where you genuinely need every cycle — the original Red Alert was written in C and ran close to the metal, and IC should too. High-level languages with garbage collectors, runtime overhead, and opaque memory layouts leave performance on the table. Rust gives the same hardware access as C without the footguns.</p>
<p><strong>Why not C/C++?</strong></p>
<p>Beyond the well-known safety and tooling arguments: <strong>C++ is a liability in the age of LLM-assisted development.</strong> This project is built with agentic LLMs as a core part of the development workflow. With Rust, LLM-generated code that compiles is overwhelmingly <em>correct</em> — the borrow checker, type system, and ownership model catch entire categories of bugs at compile time. The compiler is a safety net that makes LLM output trustworthy. With C++, LLM-generated code that compiles can still contain use-after-free, data races, undefined behavior, and subtle memory corruption — bugs that are dangerous precisely because they’re silent. The errors are cryptic, the debugging is painful, and the risk compounds as the codebase grows. Rust’s compiler turns the LLM from a risk into a superpower: you can develop faster and bolder because the guardrails are structural, not optional.</p>
<p>This isn’t a temporary advantage. LLM-assisted development is the future of programming. Choosing a language where the compiler verifies LLM output — rather than one where you must manually audit every line for memory safety — is a strategic bet that compounds over the lifetime of the project.</p>
<p><strong>Why Rust is the right moment for a C&amp;C engine:</strong></p>
<p>Rust is replacing C and C++ across the industry. It’s in the Linux kernel, Android, Windows, Chromium, and every major cloud provider’s infrastructure. The ecosystem is maturing rapidly — crates.io has 150K+ crates, Bevy is the most actively developed open-source game engine in any language, and the community is growing faster than any systems language since C++ itself. Serious new infrastructure projects increasingly start in Rust rather than C++.</p>
<p>This creates a unique opportunity for a C&amp;C engine renewal. The original games were written in C. OpenRA chose C# — a reasonable choice in 2007, but one that traded hardware performance for developer productivity. Rust didn’t exist as a viable option then. It does now. A Rust-native engine can match C’s performance, exceed C#’s safety, leverage Rust’s excellent concurrency model to use all available CPU cores, and tap into a modern ecosystem (Bevy, wgpu, serde, tokio) that simply has no C++ equivalent at the same quality level. The timing is right: Rust is mature enough to build on, young enough that the RTS space is wide open, and the C&amp;C community deserves an engine built with the best tools available today.</p>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>C++ (manual memory management, no safety guarantees, build system pain, dangerous with LLM-assisted workflows — silent bugs where Rust would catch them at compile time)</li>
<li>C# (would just be another OpenRA — no differentiation, GC pauses in hot paths, gives up hardware-level performance)</li>
<li>Zig (too immature ecosystem for this scope)</li>
</ul>
<hr>
<h2 id="d002-framework--bevy-revised-from-original-no-bevy-decision"><a class="header" href="#d002-framework--bevy-revised-from-original-no-bevy-decision">D002: Framework — Bevy (REVISED from original “No Bevy” decision)</a></h2>
<p><strong>Decision:</strong> Use Bevy as the game framework.</p>
<p><strong>Original decision:</strong> Custom library stack (winit + wgpu + hecs). This was overridden.</p>
<p><strong>Why the reversal:</strong></p>
<ul>
<li>The 2-4 months building engine infrastructure (sprite batching, cameras, audio, input, asset pipeline, hot reload) is time NOT spent on the sim, netcode, and modding — the things that differentiate this project</li>
<li>Bevy’s ECS IS our architecture — no “fighting two systems.” OpenRA traits map directly to Bevy components</li>
<li><code>FixedUpdate</code> + <code>.chain()</code> gives deterministic sim scheduling natively</li>
<li>Bevy’s plugin system makes pluggable networking cleaner than the original trait-based design</li>
<li>Headless mode (<code>MinimalPlugins</code>) for dedicated servers is built in</li>
<li>WASM/browser target is tested by community</li>
<li><code>bevy_reflect</code> enables advanced modding capabilities</li>
<li>Breaking API changes are manageable: pin version per phase, upgrade between phases</li>
</ul>
<p><strong>Risk mitigation:</strong></p>
<ul>
<li>Breaking changes → version pinning per development phase</li>
<li>Not isometric-specific → build isometric layer on Bevy’s 2D (still less work than raw wgpu)</li>
<li>Performance concerns → Bevy uses rayon internally, <code>par_iter()</code> for data parallelism, and allows custom render passes and SIMD where needed</li>
</ul>
<hr>
<h2 id="d003-data-format--real-yaml-not-miniyaml"><a class="header" href="#d003-data-format--real-yaml-not-miniyaml">D003: Data Format — Real YAML, Not MiniYAML</a></h2>
<p><strong>Decision:</strong> Use standard spec-compliant YAML with <code>serde_yaml</code>. Not OpenRA’s MiniYAML.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Standard YAML parsers, linters, formatters, editor support all work</li>
<li><code>serde_yaml</code> → typed Rust struct deserialization for free</li>
<li>JSON-schema validation catches errors before game loads</li>
<li>No custom parser to maintain</li>
<li>Inheritance resolved at load time as a processing pass, not a parser feature</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>MiniYAML as-is (rejected — custom parser, no tooling support, not spec-compliant)</li>
<li>TOML (rejected — awkward for deeply nested game data)</li>
<li>RON (rejected — modders won’t know it, thin editor support)</li>
<li>JSON (rejected — too verbose, no comments)</li>
</ul>
<p><strong>Migration:</strong> <code>miniyaml2yaml</code> converter tool in <code>ra-formats</code> crate.</p>
<hr>
<h2 id="d004-modding--lua-not-python-for-scripting"><a class="header" href="#d004-modding--lua-not-python-for-scripting">D004: Modding — Lua (Not Python) for Scripting</a></h2>
<p><strong>Decision:</strong> Use Lua for Tier 2 scripting. Do NOT use Python.</p>
<p><strong>Rationale against Python:</strong></p>
<ul>
<li>Floating-point non-determinism breaks lockstep multiplayer</li>
<li>GC pauses (reintroduces the problem Rust solves)</li>
<li>50-100x slower than native (hot paths run every tick for every unit)</li>
<li>Embedding CPython is heavy (~15-30MB)</li>
<li>Sandboxing is unsolvable — security disaster for community mods</li>
</ul>
<p><strong>Rationale for Lua:</strong></p>
<ul>
<li>Tiny runtime (~200KB), designed for embedding</li>
<li>Deterministic (provide fixed-point bindings, avoid floats)</li>
<li>Trivially sandboxable (control available functions)</li>
<li>Industry standard: Factorio, WoW, Dota 2, Roblox</li>
<li><code>mlua</code>/<code>rlua</code> crates are mature</li>
<li>Any modder can learn in an afternoon</li>
</ul>
<hr>
<h2 id="d005-modding--wasm-for-power-users-tier-3"><a class="header" href="#d005-modding--wasm-for-power-users-tier-3">D005: Modding — WASM for Power Users (Tier 3)</a></h2>
<p><strong>Decision:</strong> WASM modules via <code>wasmtime</code>/<code>wasmer</code> for advanced mods.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Near-native performance</li>
<li>Perfectly sandboxed by design</li>
<li>Deterministic execution (critical for multiplayer)</li>
<li>Modders can write in Rust, C, Go, AssemblyScript, or Python-to-WASM</li>
<li>Leapfrogs OpenRA (requires C# for deep mods)</li>
</ul>
<hr>
<h2 id="d006-networking--pluggable-via-trait"><a class="header" href="#d006-networking--pluggable-via-trait">D006: Networking — Pluggable via Trait</a></h2>
<p><strong>Decision:</strong> Abstract all networking behind a <code>NetworkModel</code> trait. Game loop is generic over it.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Sim never touches networking concerns (clean boundary)</li>
<li>Full testability (run sim with <code>LocalNetwork</code>)</li>
<li>Community can contribute netcode without understanding game logic</li>
<li>Enables future models: rollback, client-server, cross-engine adapters</li>
<li>Players could choose model in lobby</li>
</ul>
<p><strong>Key invariant:</strong> <code>ic-sim</code> has zero imports from <code>ic-net</code>. They only share <code>ic-protocol</code>.</p>
<hr>
<h2 id="d007-networking--relay-server-as-default"><a class="header" href="#d007-networking--relay-server-as-default">D007: Networking — Relay Server as Default</a></h2>
<p><strong>Decision:</strong> Default multiplayer uses relay server with time authority, not pure P2P.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Blocks lag switches (server owns the clock)</li>
<li>Enables sub-tick chronological ordering (CS2 insight)</li>
<li>Handles NAT traversal (no port forwarding)</li>
<li>Enables order validation before broadcast (anti-cheat)</li>
<li>Signed replays</li>
<li>Cheap to run (doesn’t run sim, just forwards orders)</li>
</ul>
<p><strong>Validated by:</strong> C&amp;C Generals/Zero Hour’s “packet router” — a client-side star topology where one player collected and rebroadcast all commands. Same concept, but our server-hosted version eliminates host advantage and adds neutral time authority. See <code>research/generals-zero-hour-netcode-analysis.md</code>.</p>
<p><strong>Alternatives available:</strong> Pure P2P lockstep, fog-authoritative server, rollback — all implementable as <code>NetworkModel</code> variants.</p>
<hr>
<h2 id="d008-sub-tick-timestamps-on-orders"><a class="header" href="#d008-sub-tick-timestamps-on-orders">D008: Sub-Tick Timestamps on Orders</a></h2>
<p><strong>Decision:</strong> Every order carries a sub-tick timestamp. Orders within a tick are processed in chronological order.</p>
<p><strong>Rationale (inspired by CS2):</strong></p>
<ul>
<li>Fairer results for edge cases (two players competing for same resource/building)</li>
<li>Trivial to implement (just attach timestamp at input layer)</li>
<li>Network model preserves but doesn’t depend on timestamps</li>
<li>If a future model ignores timestamps, no breakage</li>
</ul>
<hr>
<h2 id="d009-simulation--fixed-point-math-no-floats"><a class="header" href="#d009-simulation--fixed-point-math-no-floats">D009: Simulation — Fixed-Point Math, No Floats</a></h2>
<p><strong>Decision:</strong> All sim-layer calculations use integer/fixed-point arithmetic. Floats allowed only for rendering interpolation.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Required for deterministic lockstep (floats can produce different results across platforms)</li>
<li>Original Red Alert used integer math — proven approach</li>
<li>OpenRA uses <code>WDist</code>/<code>WPos</code>/<code>WAngle</code> with 1024 subdivisions — same principle</li>
</ul>
<hr>
<h2 id="d010-simulation--snapshottable-state"><a class="header" href="#d010-simulation--snapshottable-state">D010: Simulation — Snapshottable State</a></h2>
<p><strong>Decision:</strong> Full sim state must be serializable/deserializable at any tick.</p>
<p><strong>Rationale enables:</strong></p>
<ul>
<li>Save games (trivially)</li>
<li>Replay system (initial state + orders)</li>
<li>Desync debugging (diff snapshots between clients at divergence point)</li>
<li>Rollback netcode (restore state N frames back, replay with corrected inputs)</li>
<li>Cross-engine reconciliation (restore from authoritative checkpoint)</li>
<li>Automated testing (load known state, apply inputs, verify result)</li>
</ul>
<hr>
<h2 id="d011-cross-engine-play--community-layer-not-sim-layer"><a class="header" href="#d011-cross-engine-play--community-layer-not-sim-layer">D011: Cross-Engine Play — Community Layer, Not Sim Layer</a></h2>
<p><strong>Decision:</strong> Cross-engine compatibility targets data/community layer. NOT bit-identical simulation.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Bit-identical sim requires bug-for-bug reimplementation (that’s a port, not our engine)</li>
<li>Community interop is valuable and achievable: shared server browser, maps, mod format</li>
<li>Architecture keeps the door open for deeper interop later (OrderCodec, SimReconciler, ProtocolAdapter)</li>
<li>Progressive levels: shared lobby → replay viewing → casual cross-play → competitive cross-play</li>
</ul>
<hr>
<h2 id="d012-security--validate-orders-in-sim"><a class="header" href="#d012-security--validate-orders-in-sim">D012: Security — Validate Orders in Sim</a></h2>
<p><strong>Decision:</strong> Every order is validated inside the simulation before execution. Validation is deterministic.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>All clients run same validation → agree on rejections → no desync</li>
<li>Defense in depth with relay server validation</li>
<li>Repeated rejections indicate cheating (loggable)</li>
<li>No separate “anti-cheat” system — validation IS anti-cheat</li>
</ul>
<hr>
<h2 id="d013-pathfinding--trait-abstracted-multi-layer-hybrid-first"><a class="header" href="#d013-pathfinding--trait-abstracted-multi-layer-hybrid-first">D013: Pathfinding — Trait-Abstracted, Multi-Layer Hybrid First</a></h2>
<p><strong>Decision:</strong> Pathfinding and spatial queries are abstracted behind traits (<code>Pathfinder</code>, <code>SpatialIndex</code>) in the engine core. The RA1 game module implements them with a multi-layer hybrid pathfinder and spatial hash. The engine core never calls algorithm-specific functions directly.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>OpenRA uses hierarchical A* which struggles with large unit groups and lacks local avoidance</li>
<li>A multi-layer approach (hierarchical sectors + JPS/flowfield tiles + local avoidance) handles both small and mass movement well</li>
<li>Grid-based implementations are the right choice for the isometric C&amp;C family</li>
<li>But pathfinding is a <em>game module concern</em>, not an engine-core assumption</li>
<li>Abstracting behind a trait costs near-zero now (one trait, one impl) and prevents a rewrite if a future game module needs navmesh or any other spatial model</li>
<li>Same philosophy as <code>NetworkModel</code> (build <code>LocalNetwork</code> first, but the seam exists), <code>WorldPos.z</code> (costs one <code>i32</code>, saves RA2 rewrite), and <code>InputSource</code> (build mouse/keyboard first, touch slots in later)</li>
</ul>
<p><strong>Concrete design:</strong></p>
<ul>
<li><code>Pathfinder</code> trait: <code>request_path()</code>, <code>get_path()</code>, <code>is_passable()</code>, <code>invalidate_area()</code></li>
<li><code>SpatialIndex</code> trait: <code>query_range()</code>, <code>update_position()</code>, <code>remove()</code></li>
<li>RA1 module registers <code>IcPathfinder</code> (primary) + <code>GridSpatialHash</code>; D045 adds <code>RemastersPathfinder</code> and <code>OpenRaPathfinder</code> as additional <code>Pathfinder</code> implementations for movement feel presets</li>
<li>All sim systems call the traits, never grid-specific data structures</li>
<li>See <code>02-ARCHITECTURE.md</code> § “Pathfinding &amp; Spatial Queries” for trait definitions</li>
</ul>
<p><strong>Modder-selectable and modder-provided:</strong> The <code>Pathfinder</code> trait is open — not locked to first-party implementations. Modders can:</p>
<ol>
<li><strong>Select</strong> any registered <code>Pathfinder</code> for their mod (e.g., a total conversion picks <code>IcPathfinder</code> for its smooth movement, or <code>RemastersPathfinder</code> for its retro feel)</li>
<li><strong>Provide</strong> their own <code>Pathfinder</code> implementation via a Tier 3 WASM module and distribute it through the Workshop (D030)</li>
<li><strong>Use someone else’s</strong> community-created pathfinder — just declare it as a dependency in the mod manifest</li>
</ol>
<p>This follows the same pattern as render modes (D048): the engine ships built-in implementations, mods can add more, and players/modders pick what they want. A Generals-clone mod ships a <code>LayeredGridPathfinder</code>; a tower defense mod ships a waypoint pathfinder; a naval mod ships something flow-based. The trait doesn’t care — <code>request_path()</code> returns waypoints regardless of how they were computed.</p>
<p><strong>Performance:</strong> identical to hardcoding. Rust traits monomorphize — the trait call compiles to a direct function call when there’s one implementation. Zero overhead.</p>
<p><strong>What we build first:</strong> <code>IcPathfinder</code> and <code>GridSpatialHash</code>. The traits exist from day one. <code>RemastersPathfinder</code> and <code>OpenRaPathfinder</code> are Phase 2 deliverables (D045) — ported from their respective GPL codebases. Community pathfinders can be published to the Workshop from Phase 6a.</p>
<hr>
<h2 id="d014-templating--tera-in-phase-6a-nice-to-have"><a class="header" href="#d014-templating--tera-in-phase-6a-nice-to-have">D014: Templating — Tera in Phase 6a (Nice-to-Have)</a></h2>
<p><strong>Decision:</strong> Add Tera template engine for YAML/Lua generation. Phase 6a. Not foundational.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Eliminates copy-paste for faction variants, bulk unit generation</li>
<li>Load-time only (zero runtime cost)</li>
<li>~50 lines to integrate</li>
<li>Optional — no mod depends on it</li>
</ul>
<hr>
<h2 id="d015-performance--efficiency-first-not-thread-first"><a class="header" href="#d015-performance--efficiency-first-not-thread-first">D015: Performance — Efficiency-First, Not Thread-First</a></h2>
<p><strong>Decision:</strong> Performance is achieved through algorithmic efficiency, cache-friendly data layout, adaptive workload, zero allocation, and amortized computation. Multi-core scaling is a bonus layer on top, not the foundation.</p>
<p><strong>Principle:</strong> The engine must run a 500-unit battle smoothly on a 2-core, 4GB machine from 2012. Multi-core machines get higher unit counts as a natural consequence of the work-stealing scheduler.</p>
<p><strong>The Efficiency Pyramid (ordered by impact):</strong></p>
<ol>
<li>Algorithmic efficiency (flowfields, spatial hash, hierarchical pathfinding)</li>
<li>Cache-friendly ECS layout (hot/warm/cold component separation)</li>
<li>Simulation LOD (skip work that doesn’t affect the outcome)</li>
<li>Amortized work (stagger expensive systems across ticks)</li>
<li>Zero-allocation hot paths (pre-allocated scratch buffers)</li>
<li>Work-stealing parallelism (rayon via Bevy — bonus, not foundation)</li>
</ol>
<p><strong>Inspired by:</strong> Datadog Vector’s pipeline efficiency, Tokio’s work-stealing runtime. These systems are fast because they waste nothing, not because they use more hardware.</p>
<p><strong>Anti-pattern rejected:</strong> “Just parallelize it” as the default answer. Parallelism without algorithmic efficiency is adding lanes to a highway with broken traffic lights.</p>
<p>See <code>10-PERFORMANCE.md</code> for full details, targets, and implementation patterns.</p>
<hr>
<h2 id="d016-llm-generated-missions-and-campaigns"><a class="header" href="#d016-llm-generated-missions-and-campaigns">D016: LLM-Generated Missions and Campaigns</a></h2>
<p><strong>Decision:</strong> Provide an optional LLM-powered mission generation system (Phase 7) via the <code>ic-llm</code> crate. Players bring their own LLM provider (BYOLLM) — the engine never ships or requires one. Every game feature works fully without an LLM configured.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Transforms Red Alert from finite content to infinite content — for players who opt in</li>
<li>Generated output is standard YAML + Lua — fully editable, shareable, learnable</li>
<li>No other RTS (Red Alert or otherwise) offers this capability</li>
<li>LLM quality is sufficient for terrain layout, objective design, AI behavior scripting</li>
<li><strong>Strictly optional:</strong> <code>ic-llm</code> crate is optional, game works without it. No feature — campaigns, skirmish, multiplayer, modding, analytics — depends on LLM availability. The LLM enhances the experience; it never gates it</li>
</ul>
<p><strong>Scope:</strong></p>
<ul>
<li>Phase 7: single mission generation (terrain, objectives, enemy composition, triggers, briefing)</li>
<li>Phase 7: player-aware generation — LLM reads local SQLite (D034) for faction history, unit preferences, win rates, campaign roster state; injects player context into prompts for personalized missions, adaptive briefings, post-match commentary, coaching suggestions, and rivalry narratives</li>
<li>Phase 7: replay-to-scenario narrative generation — LLM reads gameplay event logs from replays to generate briefings, objectives, dialogue, and story context for scenarios extracted from real matches (see D038 § Replay-to-Scenario Pipeline)</li>
<li>Future: multi-mission campaigns, adaptive difficulty, cooperative scenario design</li>
</ul>
<blockquote>
<p><strong>Positioning note:</strong> LLM features are a quiet power-user capability, not a project headline. The primary single-player story is the hand-authored branching campaign system (D021), which requires no LLM and is genuinely excellent on its own merits. LLM generation is for players who want more content — it should never appear before D021 in marketing or documentation ordering. The word “AI” in gaming contexts attracts immediate hostility from a significant audience segment regardless of implementation quality. Lead with campaigns, reveal LLM as “also, modders and power users can use AI tools if they want.”</p>
</blockquote>
<p><strong>Implementation approach:</strong></p>
<ul>
<li>LLM generates YAML map definition + Lua trigger scripts</li>
<li>Same format as hand-crafted missions — no special runtime</li>
<li>Validation pass ensures generated content is playable (valid unit types, reachable objectives)</li>
<li>Can use local models or API-based models (user choice)</li>
<li>Player data for personalization comes from local SQLite queries (read-only) — no data leaves the device unless the user’s LLM provider is cloud-based (BYOLLM architecture)</li>
</ul>
<p><strong>Bring-Your-Own-LLM (BYOLLM) architecture:</strong></p>
<ul>
<li><code>ic-llm</code> defines a <code>LlmProvider</code> trait — any backend that accepts a prompt and returns structured text</li>
<li>Built-in providers: OpenAI-compatible API, local Ollama/llama.cpp, Anthropic API</li>
<li>Users configure their provider in settings (API key, endpoint, model name)</li>
<li>The engine never ships or requires a specific model — the user chooses</li>
<li>Provider is a runtime setting, not a compile-time dependency</li>
<li>All prompts and responses are logged (opt-in) for debugging and sharing</li>
<li>Offline mode: pre-generated content works without any LLM connection</li>
</ul>
<hr>
<h2 id="d017-bevy-rendering-pipeline--classic-base-modding-possibilities"><a class="header" href="#d017-bevy-rendering-pipeline--classic-base-modding-possibilities">D017: Bevy Rendering Pipeline — Classic Base, Modding Possibilities</a></h2>
<p><strong>Decision:</strong> Use Bevy’s rendering pipeline (wgpu) to faithfully reproduce the classic Red Alert isometric aesthetic. Bevy’s more advanced rendering capabilities (shaders, post-processing, dynamic lighting, particles, 3D) are available as modding infrastructure — not as base game goals.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>The core rendering goal is a faithful classic Red Alert clone: isometric sprites, palette-aware shading, fog of war</li>
<li>Bevy + wgpu provides this solidly via 2D sprite batching and the isometric layer</li>
<li>Because Bevy includes a full rendering pipeline, advanced visual capabilities (bloom, color grading, GPU particles, dynamic lighting, custom shaders) are <strong>passively available</strong> to modders without extra engine work</li>
<li>This enables community-created visual enhancements: shader effects for chrono-shift, tesla arcs, weather particles, or even full 3D rendering mods (see D018, <code>02-ARCHITECTURE.md</code> § “3D Rendering as a Mod”)</li>
<li>Render quality tiers (Baseline → Ultra) automatically degrade for older hardware — the base classic aesthetic works on all tiers</li>
</ul>
<p><strong>Scope:</strong></p>
<ul>
<li>Phase 1: faithful isometric tile renderer, sprite animation, shroud, camera — showcase optional post-processing prototypes to demonstrate modding potential</li>
<li>Phase 3+: rendering supports whatever the game chrome needs</li>
<li>Phase 7: visual modding infrastructure (particle systems, shader library, weather rendering) — tools for modders, not base game goals</li>
</ul>
<p><strong>Design principle:</strong> The base game looks like Red Alert. Modders can make it look like whatever they want.</p>
<hr>
<h2 id="d018-multi-game-extensibility-game-modules"><a class="header" href="#d018-multi-game-extensibility-game-modules">D018: Multi-Game Extensibility (Game Modules)</a></h2>
<p><strong>Decision:</strong> Design the engine as a game-agnostic RTS framework that ships with multiple built-in game modules. Red Alert is the default module; Tiberian Dawn ships alongside it. RA2, Tiberian Sun, Dune 2000, and original games should be addable as additional modules without modifying core engine code. The engine is also capable of powering non-C&amp;C classic RTS games (see D039).</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>OpenRA already proves multi-game works — runs TD, RA, and D2K on one engine via different trait/component sets</li>
<li>The ECS architecture naturally supports this (composable components, pluggable systems)</li>
<li>Prevents RA1 assumptions from hardening into architectural constraints that require rewrites later</li>
<li>Broadens the project’s audience and contributor base</li>
<li>RA2 is the most-requested extension — community interest is proven (Chrono Divide exists)</li>
<li>Shipping RA + TD from the start (like OpenRA) proves the game-agnostic design is real, not aspirational</li>
</ul>
<p><strong>The <code>GameModule</code> trait:</strong></p>
<p>Every game module implements <code>GameModule</code>, which bundles everything the engine needs to run that game:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait GameModule: Send + Sync + 'static {
    /// Human-readable name ("Red Alert", "Tiberian Dawn")
    fn name(&amp;self) -&gt; &amp;str;

    /// Register ECS components, systems, and system ordering
    fn register_systems(&amp;self, app: &amp;mut App);

    /// Provide the module's Pathfinder implementation
    fn pathfinder(&amp;self) -&gt; Box&lt;dyn Pathfinder&gt;;

    /// Provide the module's SpatialIndex implementation
    fn spatial_index(&amp;self) -&gt; Box&lt;dyn SpatialIndex&gt;;

    /// Provide the module's FogProvider implementation (D041)
    fn fog_provider(&amp;self) -&gt; Box&lt;dyn FogProvider&gt;;

    /// Provide the module's DamageResolver implementation (D041)
    fn damage_resolver(&amp;self) -&gt; Box&lt;dyn DamageResolver&gt;;

    /// Provide the module's OrderValidator implementation (D041)
    fn order_validator(&amp;self) -&gt; Box&lt;dyn OrderValidator&gt;;

    /// Provide the module's render plugin (sprite, voxel, 3D, etc.)
    fn render_plugin(&amp;self) -&gt; Box&lt;dyn RenderPlugin&gt;;

    /// List available render modes — Classic, HD, 3D, etc. (D048)
    fn render_modes(&amp;self) -&gt; Vec&lt;RenderMode&gt;;

    /// Provide the module's UI layout (sidebar style, build queue, etc.)
    fn ui_layout(&amp;self) -&gt; UiLayout;

    /// Provide format loaders for this module's asset types
    fn format_loaders(&amp;self) -&gt; Vec&lt;Box&lt;dyn FormatLoader&gt;&gt;;

    /// List available balance presets (D019)
    fn balance_presets(&amp;self) -&gt; Vec&lt;BalancePreset&gt;;

    /// List available experience profiles (D019 + D032 + D033 + D043 + D045 + D048)
    fn experience_profiles(&amp;self) -&gt; Vec&lt;ExperienceProfile&gt;;

    /// Default experience profile name
    fn default_profile(&amp;self) -&gt; &amp;str;
}
<span class="boring">}</span></code></pre>
<p><strong>Game module capability matrix:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Capability</th><th>RA1 (ships Phase 2)</th><th>TD (ships Phase 3-4)</th><th>Generals-class (future)</th><th>Non-C&amp;C (community)</th></tr>
</thead>
<tbody>
<tr><td>Pathfinding</td><td>Multi-layer hybrid</td><td>Multi-layer hybrid</td><td>Navmesh</td><td>Module-provided</td></tr>
<tr><td>Spatial index</td><td>Spatial hash</td><td>Spatial hash</td><td>BVH/R-tree</td><td>Module-provided</td></tr>
<tr><td>Fog of war</td><td>Radius fog</td><td>Radius fog</td><td>Elevation LOS</td><td>Module-provided</td></tr>
<tr><td>Damage resolution</td><td>Standard pipeline</td><td>Standard pipeline</td><td>Sub-object targeting</td><td>Module-provided</td></tr>
<tr><td>Order validation</td><td>Standard validator</td><td>Standard validator</td><td>Module-specific rules</td><td>Module-provided</td></tr>
<tr><td>Rendering</td><td>Isometric sprites</td><td>Isometric sprites</td><td>3D meshes</td><td>Module-provided</td></tr>
<tr><td>Camera</td><td>Isometric fixed</td><td>Isometric fixed</td><td>Free 3D</td><td>Module-provided</td></tr>
<tr><td>Terrain</td><td>Grid cells</td><td>Grid cells</td><td>Heightmap</td><td>Module-provided</td></tr>
<tr><td>Format loading</td><td>.mix/.shp/.pal</td><td>.mix/.shp/.pal</td><td>.big/.w3d</td><td>Module-provided</td></tr>
<tr><td>AI strategy</td><td>Personality-driven</td><td>Personality-driven</td><td>Module-provided</td><td>Module-provided</td></tr>
<tr><td>Networking</td><td>Shared (ic-net)</td><td>Shared (ic-net)</td><td>Shared (ic-net)</td><td>Shared (ic-net)</td></tr>
<tr><td>Modding (YAML/Lua/WASM)</td><td>Shared (ic-script)</td><td>Shared (ic-script)</td><td>Shared (ic-script)</td><td>Shared (ic-script)</td></tr>
<tr><td>Workshop</td><td>Shared (D030)</td><td>Shared (D030)</td><td>Shared (D030)</td><td>Shared (D030)</td></tr>
<tr><td>Replays &amp; saves</td><td>Shared (ic-sim)</td><td>Shared (ic-sim)</td><td>Shared (ic-sim)</td><td>Shared (ic-sim)</td></tr>
<tr><td>Competitive systems</td><td>Shared</td><td>Shared</td><td>Shared</td><td>Shared</td></tr>
</tbody>
</table>
</div>
<p>The pattern: game-specific rendering, pathfinding, spatial queries, fog, damage resolution, AI strategy, and validation; shared networking, modding, workshop, replays, saves, and competitive infrastructure.</p>
<p><strong>Experience profiles (composing D019 + D032 + D033 + D043 + D045 + D048):</strong></p>
<p>An experience profile bundles a balance preset, UI theme, QoL settings, AI behavior, pathfinding feel, and render mode into a named configuration:</p>
<pre><code class="language-yaml">profiles:
  classic-ra:
    display_name: "Classic Red Alert"
    game_module: red_alert
    balance: classic        # D019 — EA source values
    theme: classic          # D032 — DOS/Win95 aesthetic
    qol: vanilla            # D033 — no QoL additions
    ai_preset: classic-ra   # D043 — original RA AI behavior
    pathfinding: classic-ra # D045 — original RA movement feel
    render_mode: classic    # D048 — original pixel art
    description: "Original Red Alert experience, warts and all"

  openra-ra:
    display_name: "OpenRA Red Alert"
    game_module: red_alert
    balance: openra         # D019 — OpenRA competitive balance
    theme: modern           # D032 — modern UI
    qol: openra             # D033 — OpenRA QoL features
    ai_preset: openra       # D043 — OpenRA skirmish AI behavior
    pathfinding: openra     # D045 — OpenRA movement feel
    render_mode: classic    # D048 — OpenRA uses classic sprites
    description: "OpenRA-style experience on the Iron Curtain engine"

  iron-curtain-ra:
    display_name: "Iron Curtain Red Alert"
    game_module: red_alert
    balance: classic        # D019 — EA source values
    theme: modern           # D032 — modern UI
    qol: iron_curtain       # D033 — IC's recommended QoL
    ai_preset: ic-default   # D043 — research-informed AI
    pathfinding: ic-default # D045 — modern flowfield movement
    render_mode: hd         # D048 — HD sprites if available, else classic
    description: "Recommended — classic balance with modern QoL and enhanced AI"
</code></pre>
<p>Profiles are selectable in the lobby. Players can customize individual settings or pick a preset. Competitive modes lock the profile for fairness.</p>
<p><strong>Concrete changes (baked in from Phase 0):</strong></p>
<ol>
<li><code>WorldPos</code> carries a Z coordinate from day one (RA1 sets z=0). <code>CellPos</code> is a game-module convenience for grid-based games, not an engine-core type.</li>
<li>System execution order is registered per game module, not hardcoded in engine</li>
<li>No game-specific enums in engine core — resource types, unit categories come from YAML / module registration</li>
<li>Renderer uses a <code>Renderable</code> trait — sprite and voxel backends implement it equally</li>
<li>Pathfinding uses a <code>Pathfinder</code> trait — <code>IcPathfinder</code> (multi-layer hybrid) is the RA1 impl; navmesh could slot in without touching sim</li>
<li>Spatial queries use a <code>SpatialIndex</code> trait — spatial hash is the RA1 impl; BVH/R-tree could slot in without touching combat/targeting</li>
<li><code>GameModule</code> trait bundles component registration, system pipeline, pathfinder, spatial index, fog provider, damage resolver, order validator, format loaders, render backends, and experience profiles (see D041 for the 5 additional trait abstractions)</li>
<li><code>PlayerOrder</code> is extensible to game-specific commands</li>
<li>Engine crates use <code>ic-*</code> naming (not <code>ra-*</code>) to reflect game-agnostic identity (see D039). Exception: <code>ra-formats</code> stays because it reads C&amp;C-family file formats specifically.</li>
</ol>
<p><strong>What this does NOT mean:</strong></p>
<ul>
<li>We don’t build RA2 support now. Red Alert + Tiberian Dawn are the focus through Phase 3-4.</li>
<li>We don’t add speculative abstractions. Only the nine concrete changes above.</li>
<li>Non-C&amp;C game modules are an architectural capability, not a deliverable (see D039).</li>
</ul>
<p><strong>Scope boundary — current targets vs. architectural openness:</strong>
First-party game module development targets the C&amp;C family: Red Alert (default, ships Phase 2), Tiberian Dawn (ships Phase 3-4 stretch goal). RA2, Tiberian Sun, and Dune 2000 are future community goals sharing the isometric camera, grid-based terrain, sprite/voxel rendering, and <code>.mix</code> format lineage.</p>
<p><strong>3D titles (Generals, C&amp;C3, RA3) are not current targets</strong> but the architecture deliberately avoids closing doors. With pathfinding (<code>Pathfinder</code> trait), spatial queries (<code>SpatialIndex</code> trait), rendering (<code>Renderable</code> trait), camera (<code>ScreenToWorld</code> trait), format loading (<code>FormatRegistry</code>), fog of war (<code>FogProvider</code> trait), damage resolution (<code>DamageResolver</code> trait), AI (<code>AiStrategy</code> trait), and order validation (<code>OrderValidator</code> trait) all behind pluggable abstractions, a Generals-class game module would provide its own implementations of these traits while reusing the sim core, networking, modding infrastructure, workshop, competitive systems, replays, and save games. The traits exist from day one — the cost is near-zero, and the benefit is that neither we nor the community need to fork the engine to explore continuous-space games in the future. See D041 for the full trait-abstraction strategy and rationale.</p>
<p>See <code>02-ARCHITECTURE.md</code> § “Architectural Openness: Beyond Isometric” for the full trait-by-trait breakdown.</p>
<p>However, <strong>3D rendering mods for isometric-family games are explicitly supported.</strong> A “3D Red Alert” Tier 3 mod can replace sprites with GLTF meshes and the isometric camera with a free 3D camera — without changing the sim, networking, or pathfinding. Bevy’s built-in 3D pipeline makes this feasible. Cross-view multiplayer (2D vs 3D players in the same game) works because the sim is view-agnostic. See <code>02-ARCHITECTURE.md</code> § “3D Rendering as a Mod”.</p>
<p><strong>Phase:</strong> Architecture baked in from Phase 0. RA1 module ships Phase 2. TD module targets Phase 3-4 as a stretch goal. RA2 module is a potential Phase 8+ community project.</p>
<blockquote>
<p><strong>Expectation management:</strong> The community’s most-requested feature is RA2 support. The architecture deliberately supports it (game-agnostic traits, extensible ECS, pluggable pathfinding), but <strong>RA2 is a future community goal, not a scheduled deliverable.</strong> No timeline, staffing, or exit criteria exist for any game module beyond RA1 and TD. When the community reads “game-agnostic,” they should understand: the architecture won’t block RA2, but nobody is building it yet. TD ships alongside RA1 to prove the multi-game design works — not because two games are twice as fun, but because an engine that only runs one game hasn’t proven it’s game-agnostic.</p>
</blockquote>
<hr>
<h2 id="d019-switchable-balance-presets-classic-ra-vs-openra"><a class="header" href="#d019-switchable-balance-presets-classic-ra-vs-openra">D019: Switchable Balance Presets (Classic RA vs OpenRA)</a></h2>
<p><strong>Decision:</strong> Ship multiple balance presets as first-class YAML rule sets. Default to classic Red Alert values from the EA source code. OpenRA balance available as an alternative preset. Selectable per-game in lobby.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Original Red Alert’s balance makes units feel <strong>powerful and iconic</strong> — Tanya, MiGs, Tesla Coils, V2 rockets are devastating. This is what made the game memorable.</li>
<li>OpenRA rebalances toward competitive fairness, which can dilute the personality of iconic units. Valid for tournaments, wrong as a default.</li>
<li>The community is split on this. Rather than picking a side, expose it as a choice.</li>
<li>Presets are just alternate YAML files loaded at game start — zero engine complexity. The modding system already supports this via inheritance and overrides.</li>
<li>The Remastered Collection made its own subtle balance tweaks — worth capturing as a third preset.</li>
</ul>
<p><strong>Implementation:</strong></p>
<ul>
<li><code>rules/presets/classic/</code> — unit/weapon/structure values from EA source code (default)</li>
<li><code>rules/presets/openra/</code> — values matching OpenRA’s current balance</li>
<li><code>rules/presets/remastered/</code> — values matching the Remastered Collection</li>
<li>Preset selection exposed in lobby UI and stored in game settings</li>
<li>Presets use YAML inheritance: only override fields that differ from <code>classic</code></li>
<li>Multiplayer: all players must use the same preset (enforced by lobby, validated by sim)</li>
<li>Custom presets: modders can create new presets as additional YAML directories</li>
</ul>
<p><strong>What this is NOT:</strong></p>
<ul>
<li>Not a “difficulty setting” — both presets play at normal difficulty</li>
<li>Not a mod — it’s a first-class game option, no workshop download required</li>
<li>Not just multiplayer — applies to skirmish and campaign too</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Only ship classic values (rejected — alienates OpenRA competitive community)</li>
<li>Only ship OpenRA values (rejected — loses the original game’s personality)</li>
<li>Let mods handle it (rejected — too important to bury in the modding system; should be one click in settings)</li>
</ul>
<p><strong>Phase:</strong> Phase 2 (balance values extracted during simulation implementation).</p>
<hr>
<h3 id="d020--mod-sdk--creative-toolchain"><a class="header" href="#d020--mod-sdk--creative-toolchain">D020 — Mod SDK &amp; Creative Toolchain</a></h3>
<p><strong>Decision:</strong> Ship a Mod SDK comprising two components: (1) the <code>ic</code> CLI tool for headless mod workflow (init, check, test, build, publish), and (2) the <strong>IC SDK application</strong> — a visual creative toolchain with the scenario editor (D038), asset studio (D040), campaign editor, and Game Master mode. The SDK is a separate application from the game — players never see it (see D040 § SDK Architecture).</p>
<p><strong>Context:</strong> The OpenRA Mod SDK is a template repository modders fork. It bundles shell scripts (<code>fetch-engine.sh</code>, <code>launch-game.sh</code>, <code>utility.sh</code>), a <code>Makefile</code>/<code>make.cmd</code> build system, and a <code>packaging/</code> directory with per-platform installer scripts. The approach works — it’s the standard way to create OpenRA mods. But it has significant friction: requires .NET SDK, custom C# DLLs for anything beyond data changes, MiniYAML with no validation tooling, GPL contamination on mod code, and no distribution system beyond manual file sharing.</p>
<p><strong>What we adapt:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concept</th><th>OpenRA SDK</th><th>Iron Curtain</th></tr>
</thead>
<tbody>
<tr><td>Starting point</td><td>Fork a template repo</td><td><code>ic mod init [template]</code> via <code>cargo-generate</code></td></tr>
<tr><td>Engine version pin</td><td><code>ENGINE_VERSION</code> in <code>mod.config</code></td><td><code>engine.version</code> in <code>mod.yaml</code> with semver</td></tr>
<tr><td>Engine management</td><td><code>fetch-engine.sh</code> downloads + compiles from source</td><td>Engine ships as binary crate, auto-resolved</td></tr>
<tr><td>Build/run</td><td><code>Makefile</code> + shell scripts (requires Python, .NET)</td><td><code>ic</code> CLI — single Rust binary, zero dependencies</td></tr>
<tr><td>Mod manifest</td><td><code>mod.yaml</code> in MiniYAML</td><td><code>mod.yaml</code> in real YAML with typed serde schema</td></tr>
<tr><td>Validation</td><td><code>utility.sh --check-yaml</code></td><td><code>ic mod check</code> — YAML + Lua + WASM validation</td></tr>
<tr><td>Packaging</td><td><code>packaging/</code> shell scripts → .exe/.app/.AppImage</td><td><code>ic mod package</code> + workshop publish</td></tr>
<tr><td>Dedicated server</td><td><code>launch-dedicated.sh</code></td><td><code>ic mod server</code></td></tr>
<tr><td>Directory layout</td><td>Convention-based (chrome/, rules/, maps/, etc.)</td><td>Adapted for three-tier model</td></tr>
<tr><td>IDE support</td><td><code>.vscode/</code> in repo</td><td>VS Code extension with YAML schema + Lua LSP</td></tr>
</tbody>
</table>
</div>
<p><strong>What we don’t adapt (pain points we solve differently):</strong></p>
<ul>
<li>C# DLLs for custom traits → our Lua + WASM tiers are strictly better (no compilation, sandboxed, polyglot)</li>
<li>GPL license contamination → WASM sandbox means mod code is isolated; engine license doesn’t infect mods</li>
<li>MiniYAML → real YAML with <code>serde_yaml</code>, JSON Schema, standard linters</li>
<li>No hot-reload → Lua and YAML hot-reload during <code>ic mod watch</code></li>
<li>No workshop → built-in workshop with <code>ic mod publish</code></li>
</ul>
<p><strong>The <code>ic</code> CLI tool:</strong>
A single Rust binary replacing OpenRA’s shell scripts + Makefile + Python dependencies:</p>
<pre><code>ic mod init [template]     # scaffold from template
ic mod check               # validate all mod content
ic mod test                # headless smoke test
ic mod run                 # launch game with mod
ic mod server              # dedicated server
ic mod package             # build distributables
ic mod publish             # workshop upload
ic mod watch               # hot-reload dev mode
ic mod lint                # convention + llm: metadata checks
ic mod update-engine       # bump engine version
ic sdk                     # launch the visual SDK application (scenario editor, asset studio, campaign editor)
ic sdk open [project]      # launch SDK with a specific mod/scenario
</code></pre>
<p><strong>Mod templates (built-in):</strong></p>
<ul>
<li><code>data-mod</code> — YAML-only balance/cosmetic mods</li>
<li><code>scripted-mod</code> — missions and custom game modes (YAML + Lua)</li>
<li><code>total-conversion</code> — full layout with WASM scaffolding</li>
<li><code>map-pack</code> — map collections</li>
<li><code>asset-pack</code> — sprites, sounds, video packs</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li>OpenRA’s SDK validates the template-project approach — modders want a turnkey starting point</li>
<li>Engine version pinning is essential — mods break when engine updates; semver solves this cleanly</li>
<li>A CLI tool is more portable, discoverable, and maintainable than shell scripts + Makefiles</li>
<li>Workshop integration from the CLI closes the “last mile” — OpenRA modders must manually distribute their work</li>
<li>The three-tier modding system means most modders never compile anything — <code>ic mod init data-mod</code> gives you a working mod instantly</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Shell scripts like OpenRA (rejected — cross-platform pain, Python/shell dependencies, fragile)</li>
<li>Cargo workspace (rejected — mods aren’t Rust crates; YAML/Lua mods have nothing to compile)</li>
<li>In-engine mod editor only (rejected — power users want filesystem access and version control)</li>
<li>No SDK, just documentation (rejected — OpenRA proves that a template project dramatically lowers the barrier)</li>
</ul>
<p><strong>Phase:</strong> Phase 6a (Core Modding + Scenario Editor). CLI prototype in Phase 4 (for Lua scripting development).</p>
<hr>
<h3 id="d021--branching-campaign-system-with-persistent-state"><a class="header" href="#d021--branching-campaign-system-with-persistent-state">D021 — Branching Campaign System with Persistent State</a></h3>
<p><strong>Decision:</strong> Campaigns are directed graphs of missions with named outcomes, branching paths, persistent unit rosters, and continuous flow — not linear sequences with binary win/lose. Failure doesn’t end the campaign; it branches to a different path. Unit state, equipment, and story flags persist across missions.</p>
<p><strong>Context:</strong> OpenRA’s campaigns are disconnected — each mission is standalone, you exit to menu after completion, there’s no sense of flow or consequence. The original Red Alert had linear progression with FMV briefings but no branching or state persistence. Games like Operation Flashpoint: Cold War Crisis showed that branching outcomes create dramatically more engaging campaigns, and OFP: Resistance proved that persistent unit rosters (surviving soldiers, captured equipment, accumulated experience) create deep emotional investment.</p>
<p><strong>Key design points:</strong></p>
<ol>
<li>
<p><strong>Campaign graph:</strong> Missions are nodes in a directed graph. Each mission has named outcomes (not just win/lose). Each outcome maps to a next-mission node, forming branches and convergences. The graph is defined in YAML and validated at load time.</p>
</li>
<li>
<p><strong>Named outcomes:</strong> Lua scripts signal completion with a named key: <code>Campaign.complete("victory_bridge_intact")</code>. The campaign YAML maps each outcome to the next mission. This enables rich branching: “Won cleanly” → easy path, “Won with heavy losses” → harder path, “Failed” → fallback mission.</p>
</li>
<li>
<p><strong>Failure continues the game:</strong> A <code>defeat</code> outcome is just another edge in the graph. The campaign designer decides what happens: retry with fewer resources, branch to a retreating mission, skip ahead with consequences, or even “no game over” campaigns where the story always continues.</p>
</li>
<li>
<p><strong>Persistent unit roster (OFP: Resistance model):</strong></p>
<ul>
<li>Surviving units carry forward between missions (configurable per transition)</li>
<li>Units accumulate veterancy across missions — a veteran tank from mission 1 stays veteran in mission 5</li>
<li>Dead units are gone permanently — losing veterans hurts</li>
<li>Captured enemy equipment joins a persistent equipment pool</li>
<li>Five carryover modes: <code>none</code>, <code>surviving</code>, <code>extracted</code> (only units in evac zone), <code>selected</code> (Lua picks), <code>custom</code> (full Lua control)</li>
</ul>
</li>
<li>
<p><strong>Story flags:</strong> Arbitrary key-value state writable from Lua, readable in subsequent missions. Enables conditional content: “If the radar was captured in mission 2, it provides intel in mission 4.”</p>
</li>
<li>
<p><strong>Campaign state is serializable:</strong> Fits D010 (snapshottable sim state). Save games capture full campaign progress including roster, flags, and path taken. Replays can replay entire campaign runs.</p>
</li>
<li>
<p><strong>Continuous flow:</strong> Briefing → mission → debrief → next mission. No exit to menu between levels unless the player explicitly quits.</p>
</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>OpenRA’s disconnected missions are its single biggest single-player UX failure — universally cited in community feedback</li>
<li>OFP proved persistent rosters create investment: players restart missions to save a veteran soldier</li>
<li>Branching eliminates the frustration of replaying the same mission on failure — the campaign adapts</li>
<li>YAML graph definition is accessible to modders (Tier 1) and LLM-generable</li>
<li>Lua campaign API enables complex state logic while staying sandboxed</li>
<li>The same system works for hand-crafted campaigns, modded campaigns, and LLM-generated campaigns</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Linear mission sequence like RA1 (rejected — primitive, no replayability, failure is frustrating)</li>
<li>Disconnected missions like OpenRA (rejected — the specific problem we’re solving)</li>
<li>Full open-world (rejected — scope too large, not appropriate for RTS)</li>
<li>Only branching on win/lose (rejected — named outcomes are trivially more expressive with no added complexity)</li>
<li>No unit persistence (rejected — OFP: Resistance proves this is the feature that creates campaign investment)</li>
</ul>
<p><strong>Phase:</strong> Phase 4 (AI &amp; Single Player). Campaign graph engine and Lua Campaign API are core Phase 4 deliverables. The visual Campaign Editor in D038 (Phase 6b) builds on this system — D021 provides the sim-side engine, D038 provides the visual authoring tools.</p>
<hr>
<h3 id="d022--dynamic-weather-with-terrain-surface-effects"><a class="header" href="#d022--dynamic-weather-with-terrain-surface-effects">D022 — Dynamic Weather with Terrain Surface Effects</a></h3>
<p><strong>Decision:</strong> Weather transitions dynamically during gameplay via a deterministic state machine, and terrain textures visually respond to weather — snow accumulates on the ground, rain darkens/wets surfaces, sunshine dries them out. Terrain surface state optionally affects gameplay (movement penalties on snow/ice/mud).</p>
<p><strong>Context:</strong> The base weather system (static per-mission, GPU particles + sim modifiers) provides atmosphere but doesn’t evolve. Real-world weather changes. A mission that starts sunny and ends in a blizzard is vastly more dramatic — and strategically different — than one where weather is set-and-forget.</p>
<p><strong>Key design points:</strong></p>
<ol>
<li>
<p><strong>Weather state machine (sim-side):</strong> <code>WeatherState</code> resource tracks current type, intensity (fixed-point <code>0..1024</code>), and transition progress. Three schedule modes: <code>cycle</code> (deterministic round-robin), <code>random</code> (seeded from match, deterministic), <code>scripted</code> (Lua-driven only). State machine graph and transition weights defined in map YAML.</p>
</li>
<li>
<p><strong>Terrain surface state (sim-side):</strong> <code>TerrainSurfaceGrid</code> — a per-cell grid of <code>SurfaceCondition { snow_depth, wetness }</code>. Updated every tick by <code>weather_surface_system</code>. Fully deterministic, derives <code>Serialize, Deserialize</code> for snapshots. When <code>sim_effects: true</code>, surface state modifies movement: deep snow slows infantry/vehicles, ice makes water passable, mud bogs wheeled units.</p>
</li>
<li>
<p><strong>Terrain texture effects (render-side):</strong> Three quality tiers — palette tinting (free, no assets needed), overlay sprites (moderate, one extra pass), shader blending (GPU blend between base + weather variant textures). Selectable via <code>RenderSettings</code>. Accumulation is gradual and spatially non-uniform (snow appears on edges/roofs first, puddles in low cells first).</p>
</li>
<li>
<p><strong>Composes with day/night and seasons:</strong> Overcast days are darker, rain at night is near-black with lightning flashes. Map <code>temperature.base</code> controls whether precipitation is rain or snow. Arctic/desert/tropical maps set different defaults.</p>
</li>
<li>
<p><strong>Fully moddable:</strong> YAML defines schedules and surface rates (Tier 1). Lua triggers transitions and queries surface state (Tier 2). WASM adds custom weather types like ion storms (Tier 3).</p>
</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>No other C&amp;C engine has dynamic weather that affects terrain visuals — unique differentiator</li>
<li>Deterministic state machine preserves lockstep (same seed = same weather progression on all clients)</li>
<li>Sim/render split respected: surface state is sim (deterministic), visual blending is render (cosmetic)</li>
<li>Palette tinting tier ensures even low-end devices and WASM can show weather effects</li>
<li>Gameplay effects are optional per-map — purely cosmetic weather is valid</li>
<li>Surface state fits the snapshot system (D010) for save games and replays</li>
<li>Weather schedules are LLM-generable — “generate a mission where weather gets progressively worse”</li>
</ul>
<p><strong>Performance:</strong></p>
<ul>
<li>Palette tinting: zero extra draw calls, negligible GPU cost</li>
<li>Surface state grid: ~2 bytes per cell (compact fixed-point) — a 128×128 map is 32KB</li>
<li><code>weather_surface_system</code> is O(cells) but amortizable (update every 4 ticks for non-visible cells)</li>
<li>Follows efficiency pyramid: algorithmic (grid lookup) → cache-friendly (contiguous array) → amortized</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Static weather only (rejected — misses dramatic potential, no terrain response)</li>
<li>Client-side random weather (rejected — breaks deterministic sim, desync risk)</li>
<li>Full volumetric weather simulation (rejected — overkill, performance cost, not needed for isometric RTS)</li>
<li>Always-on sim effects (rejected — weather-as-decoration is valid for casual/modded games)</li>
</ul>
<p><strong>Phase:</strong> Phase 3 (visual effects) for render-side; Phase 2 (sim implementation) for weather state machine and surface grid.</p>
<hr>
<h3 id="d023--openra-vocabulary-compatibility-layer"><a class="header" href="#d023--openra-vocabulary-compatibility-layer">D023 — OpenRA Vocabulary Compatibility Layer</a></h3>
<p><strong>Decision:</strong> Accept OpenRA trait names and YAML keys as aliases in our YAML parser. Both OpenRA-style names (e.g., <code>Armament</code>, <code>Valued</code>, <code>Buildable</code>) and IC-native names (e.g., <code>combat</code>, <code>buildable.cost</code>) resolve to the same ECS components. Unconverted OpenRA YAML loads with a deprecation warning.</p>
<p><strong>Context:</strong> The biggest migration barrier for the 80% YAML tier isn’t missing features — it’s naming divergence. Every renamed concept multiplies across thousands of mod files. OpenRA modders have years of muscle memory with trait names and YAML keys. Forcing renames creates friction that discourages adoption.</p>
<p><strong>Key design points:</strong></p>
<ol>
<li><strong>Alias registry:</strong> <code>ra-formats</code> maintains a compile-time map of OpenRA trait names to IC component names. <code>Armament</code> → <code>combat</code>, <code>Valued</code> → <code>buildable.cost</code>, <code>AttackOmni</code> → <code>combat.mode: omni</code>, etc.</li>
<li><strong>Bi-directional:</strong> The alias registry is used during YAML parsing (OpenRA names accepted) and by the <code>miniyaml2yaml</code> converter (produces IC-native names). Both representations are valid.</li>
<li><strong>Deprecation warnings:</strong> When an OpenRA alias is used, the parser emits a warning: <code>"Armament" is accepted but deprecated; prefer "combat"</code>. Warnings can be suppressed per-mod via <code>mod.yaml</code> setting.</li>
<li><strong>No runtime cost:</strong> Aliases resolve during YAML deserialization (load time only). The ECS never sees alias names — only canonical IC component types.</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>Reduces the YAML migration from “convert everything” to “drop in and play, clean up later”</li>
<li>Respects invariant #8 (“the community’s existing work is sacred”) at the data vocabulary layer, not just binary formats</li>
<li>Zero runtime cost — purely a deserialization convenience</li>
<li>Makes <code>miniyaml2yaml</code> output immediately usable even without manual cleanup</li>
<li>Modders can learn IC-native names gradually as they edit files</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>IC-native names only (rejected — unnecessary migration barrier for thousands of existing mod files)</li>
<li>Adopt OpenRA’s names wholesale (rejected — some OpenRA names are poorly chosen or C#-specific; IC benefits from cleaner naming)</li>
<li>Converter handles everything (rejected — modders still need to re-learn names for new content; aliases let them use familiar names forever)</li>
</ul>
<p><strong>Phase:</strong> Phase 0 (alias registry built alongside <code>ra-formats</code> YAML parser). Phase 6a (deprecation warnings configurable in <code>mod.yaml</code>).</p>
<hr>
<h3 id="d024--lua-api-superset-of-openra"><a class="header" href="#d024--lua-api-superset-of-openra">D024 — Lua API Superset of OpenRA</a></h3>
<p><strong>Decision:</strong> Iron Curtain’s Lua scripting API is a strict superset of OpenRA’s 16 global objects. Same function names, same parameter signatures, same return types. OpenRA Lua missions run unmodified. IC then extends with additional functionality.</p>
<p><strong>Context:</strong> OpenRA has a mature Lua API used in hundreds of campaign missions across all C&amp;C game mods. Combined Arms alone has 34 Lua-scripted missions. The mod migration doc (12-MOD-MIGRATION.md) identified “API compatibility shim” as a migration requirement — this decision elevates it from “nice to have” to “hard requirement.”</p>
<p><strong>OpenRA’s 16 globals (all must work identically in IC):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Global</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Actor</code></td><td>Create, query, manipulate actors</td></tr>
<tr><td><code>Map</code></td><td>Terrain, bounds, spatial queries</td></tr>
<tr><td><code>Trigger</code></td><td>Event hooks (OnKilled, AfterDelay)</td></tr>
<tr><td><code>Media</code></td><td>Audio, video, text display</td></tr>
<tr><td><code>Player</code></td><td>Player state, resources, diplomacy</td></tr>
<tr><td><code>Reinforcements</code></td><td>Spawn units at edges/drops</td></tr>
<tr><td><code>Camera</code></td><td>Pan, position, shake</td></tr>
<tr><td><code>DateTime</code></td><td>Game time queries</td></tr>
<tr><td><code>Objectives</code></td><td>Mission objective management</td></tr>
<tr><td><code>Lighting</code></td><td>Global lighting control</td></tr>
<tr><td><code>UserInterface</code></td><td>UI text, notifications</td></tr>
<tr><td><code>Utils</code></td><td>Math, random, table utilities</td></tr>
<tr><td><code>Beacon</code></td><td>Map beacon management</td></tr>
<tr><td><code>Radar</code></td><td>Radar ping control</td></tr>
<tr><td><code>HSLColor</code></td><td>Color construction</td></tr>
<tr><td><code>WDist</code></td><td>Distance unit conversion</td></tr>
</tbody>
</table>
</div>
<p><strong>IC extensions (additions, not replacements):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Global</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Campaign</code></td><td>Branching campaign state (D021)</td></tr>
<tr><td><code>Weather</code></td><td>Dynamic weather control (D022)</td></tr>
<tr><td><code>Layer</code></td><td>Runtime layer activation/deaction</td></tr>
<tr><td><code>Region</code></td><td>Named region queries</td></tr>
<tr><td><code>Var</code></td><td>Mission/campaign variable access</td></tr>
<tr><td><code>Workshop</code></td><td>Mod metadata queries</td></tr>
<tr><td><code>LLM</code></td><td>LLM integration hooks (Phase 7)</td></tr>
</tbody>
</table>
</div>
<p><strong>Actor properties also match:</strong> Each actor reference exposes properties matching OpenRA’s property groups (<code>.Health</code>, <code>.Location</code>, <code>.Owner</code>, <code>.Move()</code>, <code>.Attack()</code>, <code>.Stop()</code>, <code>.Guard()</code>, <code>.Deploy()</code>, etc.) with identical semantics.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>CA’s 34 missions + hundreds of community missions work on day one — no porting effort</li>
<li>Reduces Lua migration from “moderate effort” to “zero effort” for standard missions</li>
<li>IC’s extensions are additive — no conflicts, no breaking changes</li>
<li>Modders who know OpenRA Lua immediately know IC Lua</li>
<li>Future OpenRA missions created by the community are automatically IC-compatible</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Design our own API, provide shim (rejected — shim is always leaky, creates two mental models)</li>
<li>Partial compatibility (rejected — partial breaks are worse than full breaks; either missions work or they don’t)</li>
<li>No Lua compatibility (rejected — throws away hundreds of community missions for no gain)</li>
</ul>
<p><strong>Phase:</strong> Phase 4 (Lua scripting implementation). API surface documented during Phase 2 planning.</p>
<hr>
<h3 id="d025--runtime-miniyaml-loading"><a class="header" href="#d025--runtime-miniyaml-loading">D025 — Runtime MiniYAML Loading</a></h3>
<p><strong>Decision:</strong> Support loading MiniYAML directly at runtime as a fallback format in <code>ra-formats</code>. When the engine encounters tab-indented files with <code>^</code> inheritance or <code>@</code> suffixes, it auto-converts in memory. The <code>miniyaml2yaml</code> CLI converter still exists for permanent migration, but is no longer a prerequisite for loading mods.</p>
<p><strong>Revision of D003:</strong> D003 (“Real YAML, not MiniYAML”) remains the canonical format. All IC-native content uses standard YAML. D025 adds a compatibility loader — it does not change what IC produces, only what it accepts.</p>
<p><strong>Key design points:</strong></p>
<ol>
<li><strong>Format detection:</strong> <code>ra-formats</code> checks the first few lines of each file. Tab-indented content with no YAML indicators triggers the MiniYAML parser path.</li>
<li><strong>In-memory conversion:</strong> MiniYAML is parsed to an intermediate tree, then resolved to standard YAML structs. The result is identical to what <code>miniyaml2yaml</code> would produce.</li>
<li><strong>Combined with D023:</strong> OpenRA trait name aliases (D023) apply after MiniYAML parsing — so the full chain is: MiniYAML → intermediate tree → alias resolution → typed Rust structs.</li>
<li><strong>Performance:</strong> Conversion adds ~10-50ms per mod at load time (one-time cost). Cached after first load.</li>
<li><strong>Warning output:</strong> Console logs <code>"Loaded MiniYAML file rules.yaml — consider converting to standard YAML with 'ic mod convert'"</code>.</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>Turns “migrate then play” into “play immediately, migrate when ready”</li>
<li>Existing OpenRA mods become testable on IC within minutes, not hours</li>
<li>Respects invariant #8 — the community’s existing work is sacred, including their file formats</li>
<li>The converter CLI still exists for modders who want clean IC-native files</li>
<li>No performance impact after initial load (conversion result is cached)</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Require pre-conversion (original plan — rejected as unnecessary friction; the converter runs in memory just as well as on disk)</li>
<li>Support MiniYAML as a first-class format permanently (rejected — standard YAML is strictly better for tooling, validation, and editor support)</li>
<li>Only support converted files (rejected — blocks quick experimentation and casual mod testing)</li>
</ul>
<p><strong>Phase:</strong> Phase 0 (MiniYAML parser already needed for <code>miniyaml2yaml</code>; making it a runtime loader is minimal additional work).</p>
<hr>
<h3 id="d026--openra-mod-manifest-compatibility"><a class="header" href="#d026--openra-mod-manifest-compatibility">D026 — OpenRA Mod Manifest Compatibility</a></h3>
<p><strong>Decision:</strong> <code>ra-formats</code> can parse OpenRA’s <code>mod.yaml</code> manifest format and auto-map it to IC’s mod structure at load time. Combined with D023 (aliases), D024 (Lua API), and D025 (MiniYAML loading), this means a modder can point IC at an existing OpenRA mod directory and it loads — no restructuring needed.</p>
<p><strong>Key design points:</strong></p>
<ol>
<li><strong>Manifest parsing:</strong> OpenRA’s <code>mod.yaml</code> declares <code>Packages</code>, <code>Rules</code>, <code>Sequences</code>, <code>Cursors</code>, <code>Chrome</code>, <code>Assemblies</code>, <code>ChromeLayout</code>, <code>Weapons</code>, <code>Voices</code>, <code>Notifications</code>, <code>Music</code>, <code>Translations</code>, <code>MapFolders</code>, <code>SoundFormats</code>, <code>SpriteFormats</code>. IC maps each section to its equivalent concept.</li>
<li><strong>Directory convention mapping:</strong> OpenRA mods use <code>rules/</code>, <code>maps/</code>, <code>sequences/</code> etc. IC maps these to its own layout at load time without copying files.</li>
<li><strong>Unsupported sections flagged:</strong> <code>Assemblies</code> (C# DLLs) cannot load — these are flagged as warnings listing which custom traits are unavailable and what WASM alternatives exist.</li>
<li><strong>Partial loading:</strong> A mod with unsupported C# traits still loads — units using those traits get a visual placeholder and a “missing trait” debug overlay. The mod is playable with reduced functionality.</li>
<li><strong><code>ic mod import</code>:</strong> CLI command that reads an OpenRA mod directory and generates an IC-native <code>mod.yaml</code> with proper structure, converting files to standard YAML and flagging C# dependencies for WASM migration.</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>Combined with D023/D024/D025, this completes the “zero-friction import” pipeline</li>
<li>Modders can evaluate IC as a target without committing to migration</li>
<li>Partial loading means even mods with C# dependencies are partially testable</li>
<li>The <code>ic mod import</code> command provides a clean migration path when the modder is ready</li>
<li>Validates our claim that “the community’s existing work is sacred”</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Require manual mod restructuring (rejected — unnecessary friction, blocks adoption)</li>
<li>Only support IC mod format (rejected — makes evaluation impossible without migration effort)</li>
<li>Full C# trait loading via .NET interop (rejected — violates D001/D002, reintroduces the problems Rust solves)</li>
</ul>
<p><strong>Phase:</strong> Phase 0 (manifest parsing) + Phase 6a (full <code>ic mod import</code> workflow).</p>
<hr>
<h3 id="d027--canonical-enum-compatibility-with-openra"><a class="header" href="#d027--canonical-enum-compatibility-with-openra">D027 — Canonical Enum Compatibility with OpenRA</a></h3>
<p><strong>Decision:</strong> Use OpenRA’s canonical enum names for locomotor types, armor types, target types, damage states, and other enumerated values — or accept both OpenRA and IC-native names via the alias system (D023).</p>
<p><strong>Specific enums aligned:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Enum Type</th><th>OpenRA Names</th><th>IC Accepts</th></tr>
</thead>
<tbody>
<tr><td>Locomotor</td><td><code>Foot</code>, <code>Wheeled</code>, <code>Tracked</code>, <code>Float</code>, <code>Fly</code></td><td>Same (canonical)</td></tr>
<tr><td>Armor</td><td><code>None</code>, <code>Light</code>, <code>Medium</code>, <code>Heavy</code>, <code>Wood</code>, <code>Concrete</code></td><td>Same (canonical)</td></tr>
<tr><td>Target Type</td><td><code>Ground</code>, <code>Air</code>, <code>Water</code>, <code>Underground</code></td><td>Same (canonical)</td></tr>
<tr><td>Damage State</td><td><code>Undamaged</code>, <code>Light</code>, <code>Medium</code>, <code>Heavy</code>, <code>Critical</code>, <code>Dead</code></td><td>Same (canonical)</td></tr>
<tr><td>Stance</td><td><code>AttackAnything</code>, <code>Defend</code>, <code>ReturnFire</code>, <code>HoldFire</code></td><td>Same (canonical)</td></tr>
<tr><td>UnitType</td><td><code>Building</code>, <code>Infantry</code>, <code>Vehicle</code>, <code>Aircraft</code>, <code>Ship</code></td><td>Same (canonical)</td></tr>
</tbody>
</table>
</div>
<p><strong>Why this matters:</strong> The <code>Versus</code> damage table — which modders spend 80% of their balance time tuning — uses armor type names as keys. Locomotor types determine pathfinding behavior. Target types control weapon targeting. If these don’t match, every single weapon definition, armor table, and locomotor reference needs translation. By matching names, these definitions copy-paste directly.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Eliminates an entire category of conversion mapping</li>
<li>Versus tables, weapon definitions, locomotor configs — all transfer without renaming</li>
<li>OpenRA’s names are reasonable and well-known in the community</li>
<li>No technical reason to rename these — they describe the same concepts</li>
<li>Where IC needs additional values (e.g., <code>Hover</code>, <code>Amphibious</code>), they extend the enum without conflicting</li>
</ul>
<p><strong>Phase:</strong> Phase 2 (when enum types are formally defined in <code>ic-sim</code>).</p>
<hr>
<h3 id="d028--condition-and-multiplier-systems-as-phase-2-requirements"><a class="header" href="#d028--condition-and-multiplier-systems-as-phase-2-requirements">D028 — Condition and Multiplier Systems as Phase 2 Requirements</a></h3>
<p><strong>Decision:</strong> The condition system and multiplier system identified as P0 critical gaps in <code>11-OPENRA-FEATURES.md</code> are promoted to hard Phase 2 exit criteria. Phase 2 cannot ship without both systems implemented and tested.</p>
<p><strong>What this adds to Phase 2:</strong></p>
<ol>
<li>
<p><strong>Condition system:</strong></p>
<ul>
<li><code>Conditions</code> component: <code>HashMap&lt;ConditionId, u32&gt;</code> (ref-counted named conditions per entity)</li>
<li>Condition sources: <code>GrantConditionOnMovement</code>, <code>GrantConditionOnDamageState</code>, <code>GrantConditionOnDeploy</code>, <code>GrantConditionOnAttack</code>, <code>GrantConditionOnTerrain</code>, <code>GrantConditionOnVeterancy</code> — exposed in YAML</li>
<li>Condition consumers: any component field can declare <code>requires:</code> or <code>disabled_by:</code> conditions</li>
<li>Runtime: systems check <code>conditions.is_active("deployed")</code> via fast bitset or hash lookup</li>
</ul>
</li>
<li>
<p><strong>Multiplier system:</strong></p>
<ul>
<li><code>StatModifiers</code> component: per-entity stack of <code>(source, stat, modifier_value, condition)</code></li>
<li>Every numeric stat (speed, damage, range, reload, build time, build cost, sight range, etc.) resolves through the modifier stack</li>
<li>Modifiers from: veterancy, terrain, crates, conditions, player handicaps</li>
<li>Fixed-point multiplication (no floats)</li>
<li>YAML-configurable: modders add multipliers without code</li>
</ul>
</li>
<li>
<p><strong>Full damage pipeline:</strong></p>
<ul>
<li>Armament → Projectile entity → travel → impact → Warhead(s) → armor-versus-weapon table → DamageMultiplier resolution → Health reduction</li>
<li>Composable warheads: each weapon can trigger multiple warheads (damage + condition + terrain effect)</li>
</ul>
</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>Without conditions, 80% of OpenRA YAML mods cannot express their behavior at all — conditions are the fundamental modding primitive</li>
<li>Without multipliers, veterancy/crates/terrain bonuses don’t work — critical gameplay systems are broken</li>
<li>Without the full damage pipeline, weapons are simplistic and balance modding is impossible</li>
<li>These three systems are the foundation that P1–P3 features build on (stealth, veterancy, transport, support powers all use conditions and multipliers)</li>
<li>Promoting from “identified gap” to “exit criteria” ensures they’re not deferred</li>
</ul>
<p><strong>Phase:</strong> Phase 2 (hard exit criteria — no Phase 3 starts without these).</p>
<hr>
<h3 id="d029--cross-game-component-library-phase-2-targets"><a class="header" href="#d029--cross-game-component-library-phase-2-targets">D029 — Cross-Game Component Library (Phase 2 Targets)</a></h3>
<p><strong>Decision:</strong> The seven first-party component systems identified in <code>12-MOD-MIGRATION.md</code> (from Combined Arms and Remastered case studies) are Phase 2 targets. They are high priority and independently scoped — any that don’t land by Phase 2 exit are early Phase 3 work, not deferred indefinitely. (The D028 systems — conditions, multipliers, damage pipeline — are the hard Phase 2 gate; see <code>08-ROADMAP.md</code> § Phase 2 exit criteria.)</p>
<p><strong>The seven systems:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>System</th><th>Needed For</th><th>Phase 2 Scope</th></tr>
</thead>
<tbody>
<tr><td><strong>Mind Control</strong></td><td>CA (Yuri), RA2 game module, Scrin</td><td>Controller/controllable components, capacity limits, override</td></tr>
<tr><td><strong>Carrier/Spawner</strong></td><td>CA, RA2 (Aircraft Carrier, Kirov drones)</td><td>Master/slave with respawn, recall, autonomous attack</td></tr>
<tr><td><strong>Teleport Networks</strong></td><td>CA, Nod tunnels (TD/TS), Chronosphere</td><td>Multi-node network with primary exit designation</td></tr>
<tr><td><strong>Shield System</strong></td><td>CA, RA2 force shields, Scrin</td><td>Absorb-before-health, recharge timer, depletion</td></tr>
<tr><td><strong>Upgrade System</strong></td><td>CA, C&amp;C3 game module</td><td>Per-unit tech research via building, condition grants</td></tr>
<tr><td><strong>Delayed Weapons</strong></td><td>CA (radiation, poison), RA2 (terror drones)</td><td>Timer-attached effects on targets</td></tr>
<tr><td><strong>Dual Asset Rendering</strong></td><td>Remastered recreation, HD mod packs</td><td>Superseded by the Resource Pack system (<code>04-MODDING.md</code> § “Resource Packs”) which generalizes this to N asset tiers, not just two. Phase 2 scope: <code>ic-render</code> supports runtime-switchable asset source per entity; Resource Pack manifests resolve at load time.</td></tr>
</tbody>
</table>
</div>
<p><strong>Rationale:</strong></p>
<ul>
<li>These aren’t CA-specific — they’re needed for RA2 (the likely second game module). Building them in Phase 2 means they’re available when RA2 development starts.</li>
<li>CA can migrate to IC the moment the engine is playable, rather than waiting for Phase 6a</li>
<li>Without these as built-in components, CA modders would need to write WASM for basic mechanics like mind control — unacceptable for adoption</li>
<li>The seven systems cover ~60% of CA’s custom C# code — collapsing the WASM tier from ~15% to ~5% of migration effort</li>
<li>Each system is independently useful and well-scoped (2-5 days engineering each)</li>
</ul>
<p><strong>Impact on migration estimates:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Migration Tier</th><th>Before D029</th><th>After D029</th></tr>
</thead>
<tbody>
<tr><td>Tier 1 (YAML)</td><td>~40%</td><td>~45%</td></tr>
<tr><td>Built-in</td><td>~30%</td><td>~40%</td></tr>
<tr><td>Tier 2 (Lua)</td><td>~15%</td><td>~10%</td></tr>
<tr><td>Tier 3 (WASM)</td><td>~15%</td><td>~5%</td></tr>
</tbody>
</table>
</div>
<p><strong>Phase:</strong> Phase 2 (sim-side components and dual asset rendering in <code>ic-render</code>).</p>
<hr>
<h2 id="d030-workshop-resource-registry--dependency-system"><a class="header" href="#d030-workshop-resource-registry--dependency-system">D030: Workshop Resource Registry &amp; Dependency System</a></h2>
<p><strong>Decision:</strong> The Workshop operates as a crates.io-style resource registry where any game asset — music, sprites, textures, cutscenes, maps, sound effects, palettes, voice lines, UI themes, templates — is publishable as an independent, versioned, licensable resource that others (including LLM agents, with author consent) can discover, depend on, and pull automatically. Authors control AI access to their resources separately from the license via <code>ai_usage</code> permissions.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>OpenRA has no resource sharing infrastructure — modders copy-paste files, share on forums, lose attribution</li>
<li>Individual resources (a single music track, one sprite sheet) should be as easy to publish and consume as full mods</li>
<li>A dependency system eliminates duplication: five mods that need the same HD sprite pack declare it as a dependency instead of each bundling 200MB of sprites</li>
<li>License metadata protects community creators and enables automated compatibility checking</li>
<li>LLM agents generating missions need a way to discover and pull community assets without human intervention</li>
<li>The mod ecosystem grows faster when building blocks are reusable — this is why npm/crates.io/pip changed their respective ecosystems</li>
<li>CI/CD-friendly publishing (headless CLI, scoped API tokens) lets serious mod teams automate their release pipeline — no manual uploads</li>
</ul>
<p><strong>Key Design Elements:</strong></p>
<h3 id="phased-delivery-strategy"><a class="header" href="#phased-delivery-strategy">Phased Delivery Strategy</a></h3>
<p>The Workshop design below is comprehensive, but it ships incrementally:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Phase</th><th>Scope</th><th>Complexity</th></tr>
</thead>
<tbody>
<tr><td>Phase 0–3</td><td><strong>Git-hosted index:</strong> <code>workshop-index</code> GitHub repo as package registry (<code>index.yaml</code> + per-package manifests). <code>.icpkg</code> files stored on GitHub Releases (free CDN). Community contributes via PR. <code>git-index</code> source type in Workshop client. Zero infrastructure cost</td><td>Minimal</td></tr>
<tr><td>Phase 3–4</td><td><strong>Add P2P:</strong> BitTorrent tracker ($5-10/month VPS). Package manifests gain <code>torrent</code> source entries. P2P delivery for large packages. Git index remains discovery layer. Format recommendations published</td><td>Low–Medium</td></tr>
<tr><td>Phase 4–5</td><td><strong>Minimal viable Workshop:</strong> Full Workshop server (search, ratings, deps) + integrated P2P tracker + <code>ic mod publish</code> + <code>ic mod install</code> + in-game browser + auto-download on lobby join</td><td>Medium</td></tr>
<tr><td>Phase 6a</td><td><strong>Full Workshop:</strong> Federation, community servers join P2P swarm, replication, promotion channels, CI/CD token scoping, creator reputation, DMCA process, Steam Workshop as optional source</td><td>High</td></tr>
<tr><td>Phase 7+</td><td><strong>Advanced:</strong> LLM-driven discovery, premium hosting tiers</td><td>Low priority</td></tr>
</tbody>
</table>
</div>
<p>The Artifactory-level federation design is the end state, not the MVP. Ship simple, iterate toward complex. P2P delivery (D049) is integrated from Phase 3–4 because centralized hosting costs are a sustainability risk — better to solve early than retrofit. Workshop packages use the <code>.icpkg</code> format (ZIP with <code>manifest.yaml</code>) — see D049 for full specification.</p>
<h3 id="resource-identity--versioning"><a class="header" href="#resource-identity--versioning">Resource Identity &amp; Versioning</a></h3>
<p>Every Workshop resource gets a globally unique identifier: <code>publisher/name@version</code>.</p>
<ul>
<li><strong>Publisher</strong> = author username or organization (e.g., <code>alice</code>, <code>community-hd-project</code>)</li>
<li><strong>Name</strong> = resource name, lowercase with hyphens (e.g., <code>soviet-march-music</code>, <code>allied-infantry-hd</code>)</li>
<li><strong>Version</strong> = semver (e.g., <code>1.2.0</code>)</li>
<li>Full ID example: <code>alice/soviet-march-music@1.2.0</code></li>
</ul>
<h3 id="resource-categories-expanded"><a class="header" href="#resource-categories-expanded">Resource Categories (Expanded)</a></h3>
<p>Resources aren’t limited to mod-sized packages. Granularity is flexible:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Granularity Examples</th></tr>
</thead>
<tbody>
<tr><td>Music</td><td>Single track, album, soundtrack</td></tr>
<tr><td>Sound Effects</td><td>Weapon sound pack, ambient loops, UI sounds</td></tr>
<tr><td>Voice Lines</td><td>EVA pack, unit response set, faction voice pack</td></tr>
<tr><td>Sprites</td><td>Single unit sheet, building sprites, effects pack</td></tr>
<tr><td>Textures</td><td>Terrain tileset, UI skin, palette-indexed sprites</td></tr>
<tr><td>Palettes</td><td>Theater palette, faction palette, seasonal palette</td></tr>
<tr><td>Maps</td><td>Single map, map pack, tournament map pool</td></tr>
<tr><td>Missions</td><td>Single mission, mission chain</td></tr>
<tr><td>Campaign Chapters</td><td>Story arc with persistent state</td></tr>
<tr><td>Scene Templates</td><td>Tera scene template for LLM composition</td></tr>
<tr><td>Mission Templates</td><td>Tera mission template for LLM composition</td></tr>
<tr><td>Cutscenes / Video</td><td>Briefing video, in-game cinematic, tutorial clip</td></tr>
<tr><td>UI Themes</td><td>Sidebar layout, font pack, cursor set</td></tr>
<tr><td>Balance Presets</td><td>Tuned unit/weapon stats as a selectable preset</td></tr>
<tr><td>QoL Presets</td><td>Gameplay behavior toggle set (D033) — sim-affecting + client-only toggles</td></tr>
<tr><td>Experience Profile</td><td>Combined balance + theme + QoL + AI + pathfinding + render mode (D019+D032+D033+D043+D045+D048)</td></tr>
<tr><td>Resource Packs</td><td>Switchable asset layer for any category — see <code>04-MODDING.md</code> § “Resource Packs”</td></tr>
<tr><td>Script Libraries</td><td>Reusable Lua modules, utility functions, AI behavior scripts, trigger templates</td></tr>
<tr><td>Full Mods</td><td>Traditional mod (may depend on individual resources)</td></tr>
</tbody>
</table>
</div>
<p>A published resource is just a <code>ResourcePackage</code> with the appropriate <code>ResourceCategory</code>. The existing <code>asset-pack</code> template and <code>ic mod publish</code> flow handle this natively — no separate command needed.</p>
<h3 id="dependency-declaration"><a class="header" href="#dependency-declaration">Dependency Declaration</a></h3>
<p><code>mod.yaml</code> already has a <code>dependencies:</code> section. D030 formalizes the resolution semantics:</p>
<pre><code class="language-yaml"># mod.yaml
dependencies:
  - id: "community-project/hd-infantry-sprites"
    version: "^2.0"                    # semver range (cargo-style)
    source: workshop                   # workshop | local | url
  - id: "alice/soviet-march-music"
    version: "&gt;=1.0, &lt;3.0"
    source: workshop
    optional: true                     # soft dependency — mod works without it
  - id: "bob/desert-terrain-textures"
    version: "~1.4"                    # compatible with 1.4.x
    source: workshop
</code></pre>
<p>Resource packages can also declare dependencies on other resources (transitive):</p>
<pre><code class="language-yaml"># A mission pack depends on a sprite pack and a music track
dependencies:
  - id: "community-project/hd-sprites"
    version: "^2.0"
    source: workshop
  - id: "alice/briefing-videos"
    version: "^1.0"
    source: workshop
</code></pre>
<h3 id="repository-types"><a class="header" href="#repository-types">Repository Types</a></h3>
<p>The Workshop uses three repository types (architecture inspired by Artifactory’s local/remote/virtual model):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Source Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Local</strong></td><td>A directory on disk following Workshop structure. Stores resources you create. Used for development, LAN parties, offline play, pre-publish testing.</td></tr>
<tr><td><strong>Remote</strong></td><td>A Workshop server (official or community-hosted). Resources are downloaded and cached locally on first access. Cache is used for subsequent requests — works offline after first pull.</td></tr>
<tr><td><strong>Virtual</strong></td><td>The aggregated view across all configured sources. The <code>ic</code> CLI and in-game browser query the virtual view — it merges listings from all local + remote + git-index sources, deduplicates by resource ID, and resolves version conflicts using priority ordering.</td></tr>
</tbody>
</table>
</div>
<p>The <code>settings.yaml</code> <code>sources:</code> list defines which local and remote sources compose the virtual view. This is the federation model — the client never queries raw servers directly, it queries the merged Workshop view.</p>
<h3 id="package-integrity"><a class="header" href="#package-integrity">Package Integrity</a></h3>
<p>Every published resource includes cryptographic checksums for integrity verification:</p>
<ul>
<li><strong>SHA-256 checksum</strong> stored in the package manifest and on the Workshop server</li>
<li><code>ic mod install</code> verifies checksums after download — mismatch → abort + warning</li>
<li><code>ic.lock</code> records both version AND checksum for each dependency — guarantees byte-identical installs across machines</li>
<li>Protects against: corrupted downloads, CDN tampering, mirror drift</li>
<li>Workshop server computes checksums on upload; clients verify on download. Trust but verify.</li>
</ul>
<h3 id="manifest-integrity--confusion-prevention"><a class="header" href="#manifest-integrity--confusion-prevention">Manifest Integrity &amp; Confusion Prevention</a></h3>
<p>The canonical package manifest is <strong>inside the <code>.icpkg</code> archive</strong> (<code>manifest.yaml</code>). The git-index entry and Workshop server metadata are derived summaries — never independent sources of truth. See <code>06-SECURITY.md</code> § Vulnerability 20 for the full threat analysis (inspired by the 2023 npm manifest confusion affecting 800+ packages).</p>
<ul>
<li><strong><code>manifest_hash</code> field:</strong> Every index entry includes <code>manifest_hash: SHA-256(manifest.yaml)</code> — the hash of the manifest file itself, separate from the full-package hash. Clients verify this independently.</li>
<li><strong>CI validation (git-index phase):</strong> PR validation CI downloads the <code>.icpkg</code>, extracts <code>manifest.yaml</code>, computes its hash, and verifies against the declared <code>manifest_hash</code>. Mismatch → PR rejected.</li>
<li><strong>Client verification:</strong> <code>ic mod install</code> verifies the extracted <code>manifest.yaml</code> matches the index’s <code>manifest_hash</code> before processing mod content. Mismatch → abort.</li>
</ul>
<h3 id="version-immutability"><a class="header" href="#version-immutability">Version Immutability</a></h3>
<p>Once version X.Y.Z is published, its content <strong>cannot</strong> be modified or overwritten. The SHA-256 hash recorded at publish time is permanent.</p>
<ul>
<li><strong>Yanking ≠ deletion:</strong> Yanked versions are hidden from new <code>ic mod install</code> searches but remain downloadable for existing <code>ic.lock</code> files that reference them.</li>
<li><strong>Git-index enforcement:</strong> CI rejects PRs that modify fields in existing version manifest files. Only additions of new version files are accepted.</li>
<li><strong>Registry enforcement (Phase 4+):</strong> Workshop server API rejects publish requests for existing version numbers with HTTP 409 Conflict. No override flag.</li>
</ul>
<h3 id="typosquat--name-confusion-prevention"><a class="header" href="#typosquat--name-confusion-prevention">Typosquat &amp; Name Confusion Prevention</a></h3>
<p>Publisher-scoped naming (<code>publisher/package</code>) is the structural defense — see <code>06-SECURITY.md</code> § Vulnerability 19. Additional measures:</p>
<ul>
<li><strong>Name similarity checking at publish time:</strong> Levenshtein distance + common substitution patterns checked against existing packages. Edit distance ≤ 2 from an existing popular package → flagged for manual review.</li>
<li><strong>Disambiguation in mod manager:</strong> When multiple similar names exist, the search UI shows a notice with download counts and publisher reputation.</li>
</ul>
<h3 id="reputation-system-integrity"><a class="header" href="#reputation-system-integrity">Reputation System Integrity</a></h3>
<p>The Workshop reputation system (download count, average rating, dependency count, publish consistency, community reports) includes anti-gaming measures:</p>
<ul>
<li><strong>Rate-limited reviews:</strong> One review per account per package. Accounts must be &gt;7 days old with at least one game session to leave reviews.</li>
<li><strong>Download deduplication:</strong> Counts unique authenticated users, not raw download events. Anonymous downloads deduplicated by IP with a time window.</li>
<li><strong>Sockpuppet detection:</strong> Burst of positive reviews from newly created accounts → flagged for moderator review. Review weight is proportional to reviewer account age and activity.</li>
<li><strong>Source repo verification (optional):</strong> If a package links to a source repository, the publisher can verify push access to earn a “verified source” badge.</li>
</ul>
<h3 id="abandoned-package-policy"><a class="header" href="#abandoned-package-policy">Abandoned Package Policy</a></h3>
<p>A published package is considered <strong>abandoned</strong> after 18+ months of inactivity AND no response to 3 maintainer contact attempts over 90 days.</p>
<ul>
<li><strong>Archive-first default:</strong> Abandoned packages are archived (still installable, marked “unmaintained” with a banner) rather than transferred.</li>
<li><strong>Transfer process:</strong> Community can nominate a new maintainer. Requires moderator approval + 30-day public notice period. Original author can reclaim within 6 months.</li>
<li><strong>Published version immutability survives transfer.</strong> New maintainer can publish new versions but cannot modify existing ones.</li>
</ul>
<h3 id="promotion--maturity-channels"><a class="header" href="#promotion--maturity-channels">Promotion &amp; Maturity Channels</a></h3>
<p>Resources can be published to maturity channels, allowing staged releases:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Channel</th><th>Purpose</th><th>Visibility</th></tr>
</thead>
<tbody>
<tr><td><code>dev</code></td><td>Work-in-progress, local testing</td><td>Author only (local repos only)</td></tr>
<tr><td><code>beta</code></td><td>Pre-release, community testing</td><td>Opt-in (users enable beta flag)</td></tr>
<tr><td><code>release</code></td><td>Stable, production-ready</td><td>Default (everyone sees these)</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-yaml"># mod.yaml
mod:
  version: "1.3.0-beta.1"            # semver pre-release tag
  channel: beta                       # publish to beta channel
</code></pre>
<ul>
<li><code>ic mod publish --channel beta</code> → visible only to users who opt in to beta resources</li>
<li><code>ic mod publish</code> (no flag) → release channel by default</li>
<li><code>ic mod install</code> pulls from release channel unless <code>--include-beta</code> is specified</li>
<li>Promotion: <code>ic mod promote 1.3.0-beta.1 release</code> → moves resource to release channel without re-upload</li>
</ul>
<h3 id="replication--mirroring"><a class="header" href="#replication--mirroring">Replication &amp; Mirroring</a></h3>
<p>Community Workshop servers can replicate from the official server (pull replication, Artifactory-style):</p>
<ul>
<li><strong>Pull replication:</strong> Community server periodically syncs popular resources from official. Reduces latency for regional players, provides redundancy.</li>
<li><strong>Selective sync:</strong> Community servers choose which categories/publishers to replicate (e.g., replicate all Maps but not Mods)</li>
<li><strong>Offline bundles:</strong> <code>ic workshop export-bundle</code> creates a portable archive of selected resources for LAN parties or airgapped environments. <code>ic workshop import-bundle</code> loads them into a local repository.</li>
</ul>
<h3 id="dependency-resolution"><a class="header" href="#dependency-resolution">Dependency Resolution</a></h3>
<p>Cargo-inspired version solving:</p>
<ul>
<li><strong>Semver ranges:</strong> <code>^1.2</code> (&gt;=1.2.0, &lt;2.0.0), <code>~1.2</code> (&gt;=1.2.0, &lt;1.3.0), <code>&gt;=1.0, &lt;3.0</code>, exact <code>=1.2.3</code></li>
<li><strong>Lockfile:</strong> <code>ic.lock</code> records exact resolved versions + SHA-256 checksums for reproducible installs. In multi-source configurations, also records the <strong>source identifier</strong> per dependency (<code>source:publisher/package@version</code>) to prevent dependency confusion across federated sources (see <code>06-SECURITY.md</code> § Vulnerability 22).</li>
<li><strong>Transitive resolution:</strong> If mod A depends on resource B which depends on resource C, all three are resolved</li>
<li><strong>Conflict detection:</strong> Two dependencies requiring incompatible versions of the same resource → error with resolution suggestions</li>
<li><strong>Deduplication:</strong> Same resource pulled by multiple dependents is stored once in local cache</li>
<li><strong>Offline resolution:</strong> Once cached, all dependencies resolve from local cache — no network required</li>
</ul>
<h3 id="cli-extensions"><a class="header" href="#cli-extensions">CLI Extensions</a></h3>
<pre><code>ic mod resolve         # compute dependency graph, report conflicts
ic mod install         # download all dependencies to local cache
ic mod update          # update deps to latest compatible versions (respects semver)
ic mod tree            # display dependency tree (like `cargo tree`)
ic mod lock            # regenerate ic.lock from current mod.yaml
ic mod audit           # check dependency licenses for compatibility + source confusion detection
ic mod list             # list all local resources (state, size, last used, source)
ic mod remove &lt;pkg&gt;     # remove resource from disk (dependency-aware, prompts for cascade)
ic mod deactivate &lt;pkg&gt; # keep on disk but don't load (quick toggle without re-download)
ic mod activate &lt;pkg&gt;   # re-enable a deactivated resource
ic mod pin &lt;pkg&gt;        # mark as "keep" — exempt from auto-cleanup
ic mod unpin &lt;pkg&gt;      # allow auto-cleanup (returns to transient state)
ic mod clean            # remove all expired transient resources
ic mod clean --dry-run  # show what would be cleaned without removing anything
ic mod status           # disk usage summary: total, by category, by state, largest resources
</code></pre>
<p>These extend the existing <code>ic</code> CLI (D020), not replace it. <code>ic mod publish</code> already exists — it now also uploads dependency metadata and validates license presence.</p>
<h3 id="local-resource-management"><a class="header" href="#local-resource-management">Local Resource Management</a></h3>
<p>Without active management, a player’s disk fills with resources from lobby auto-downloads, one-off map packs, and abandoned mods. IC treats this as a first-class design problem — not an afterthought.</p>
<p><strong>Resource lifecycle states:</strong></p>
<p>Every local resource is in exactly one of these states:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>State</th><th>On disk?</th><th>Loaded by game?</th><th>Auto-cleanup eligible?</th><th>How to enter</th></tr>
</thead>
<tbody>
<tr><td><strong>Pinned</strong></td><td>Yes</td><td>Yes</td><td>No — stays until explicitly removed</td><td><code>ic mod install</code>, “Install” in Workshop UI, <code>ic mod pin</code>, or auto-promotion</td></tr>
<tr><td><strong>Transient</strong></td><td>Yes</td><td>Yes</td><td>Yes — after TTL expires</td><td>Lobby auto-download, transitive dependency of a transient resource</td></tr>
<tr><td><strong>Deactivated</strong></td><td>Yes</td><td>No</td><td>No — explicit state, player decides</td><td><code>ic mod deactivate</code> or toggle in UI</td></tr>
<tr><td><strong>Expiring</strong></td><td>Yes</td><td>Yes</td><td>Yes — in grace period, deletion pending</td><td>Transient resource unused for <code>transient_ttl_days</code></td></tr>
<tr><td><strong>Removed</strong></td><td>No</td><td>No</td><td>N/A</td><td><code>ic mod remove</code>, auto-cleanup, or player confirmation</td></tr>
</tbody>
</table>
</div>
<p><strong>Pinned vs. Transient — the core distinction:</strong></p>
<ul>
<li><strong>Pinned</strong> resources are things the player explicitly chose: they clicked “Install,” ran <code>ic mod install</code>, or marked a resource as “Keep.” Pinned resources stay on disk forever until the player explicitly removes them. This is the default state for deliberate installations.</li>
<li><strong>Transient</strong> resources arrived automatically — lobby auto-downloads, dependencies pulled transitively by other transient resources. They’re fully functional (loaded, playable, seedable) but have a time-to-live. After <code>transient_ttl_days</code> without being used in a game session (default: 30 days), they enter the <strong>Expiring</strong> state.</li>
</ul>
<p>This distinction means a player who joins a modded lobby once doesn’t accumulate permanent disk debt. The resources work for that session and stick around for a month in case the player returns to similar lobbies — then quietly clean up.</p>
<p><strong>Auto-promotion:</strong> If a transient resource is used in 3+ separate game sessions, it’s automatically promoted to Pinned. A non-intrusive notification tells the player: “Kept alice/hd-sprites — you’ve used it in 5 matches.” This preserves content the player clearly enjoys without requiring manual action.</p>
<p><strong>Deactivation:</strong></p>
<p>Deactivated resources stay on disk but aren’t loaded by the game. Use cases:</p>
<ul>
<li>Temporarily disable a heavy mod without losing it (and having to re-download 500 MB later)</li>
<li>Keep content available for quick re-activation (one click, no network)</li>
<li>Deactivated resources are still available as P2P seeds (configurable via <code>seed_deactivated</code> setting) since they’re already integrity-verified</li>
</ul>
<p>Dependency-aware: deactivating a resource that others depend on offers: “bob/tank-skins depends on this. Deactivate both? [Both / Just this one / Cancel]”. Deactivating “just this one” means dependents that reference it will show a missing-dependency warning in the mod manager.</p>
<p><strong>Dependency-aware removal:</strong></p>
<p><code>ic mod remove alice/hd-sprites</code> checks the reverse dependency graph:</p>
<ul>
<li>If nothing depends on it → remove immediately.</li>
<li>If bob/tank-skins depends on it → prompt: “bob/tank-skins depends on alice/hd-sprites. Remove both? [Yes / No / Remove only alice/hd-sprites and deactivate bob/tank-skins]”</li>
<li><code>ic mod remove alice/hd-sprites --cascade</code> → removes the resource and all resources that become orphaned as a result (no explicit dependents left).</li>
<li>Orphan detection: after any removal, scan for resources with zero dependents and zero explicit install (not pinned by the player). These are cleanup candidates.</li>
</ul>
<p><strong>Storage budget and auto-cleanup:</strong></p>
<pre><code class="language-yaml"># settings.yaml
workshop:
  cache_dir: "~/.ic/cache"
  storage:
    budget_gb: 10                   # max transient cache before auto-cleanup (0 = unlimited)
    transient_ttl_days: 30          # days of non-use before transient resources expire
    cleanup_prompt: "weekly"        # never | after-session | weekly | monthly
    low_disk_warning_gb: 5          # warn when OS free space drops below this
    seed_deactivated: false         # P2P seed deactivated (but verified) resources
</code></pre>
<ul>
<li><code>budget_gb</code> applies to <strong>transient</strong> resources only. Pinned and deactivated resources don’t count against the auto-cleanup budget (but are shown in disk usage summaries).</li>
<li>When transient cache exceeds <code>budget_gb</code>, the oldest (by last-used timestamp) transient resources are cleaned first — LRU eviction.</li>
<li>At 80% of budget, the content manager shows a gentle notice: “Workshop cache is 8.1 / 10 GB. [Clean up now] [Adjust budget]”</li>
<li>On low system disk space (below <code>low_disk_warning_gb</code>), cleanup suggestions become more prominent and include deactivated resources as candidates.</li>
</ul>
<p><strong>Post-session cleanup prompt:</strong></p>
<p>After a game session that auto-downloaded resources, a non-intrusive toast appears:</p>
<pre><code> Downloaded 2 new resources for this match (47 MB).
  alice/hd-sprites@2.0    38 MB
  bob/desert-map@1.1       9 MB
 [Pin (keep forever)]  [They'll auto-clean in 30 days]  [Remove now]
</code></pre>
<p>The default (clicking away or ignoring the toast) is “transient” — resources stay for 30 days then auto-clean. The player only needs to act if they want to explicitly keep or immediately remove. This is the low-friction path: do nothing = reasonable default.</p>
<p><strong>Periodic cleanup prompt (configurable):</strong></p>
<p>Based on <code>cleanup_prompt</code> setting:</p>
<ul>
<li><code>after-session</code>: prompt after every session that used transient resources</li>
<li><code>weekly</code> (default): once per week if there are expiring transient resources</li>
<li><code>monthly</code>: once per month</li>
<li><code>never</code>: fully manual — player uses <code>ic mod clean</code> or the content manager</li>
</ul>
<p>The prompt shows total reclaimable space and a one-click “Clean all expired” button:</p>
<pre><code> Workshop cleanup: 3 resources unused for 30+ days (1.2 GB)
  [Clean all]  [Review individually]  [Remind me later]
</code></pre>
<p><strong>In-game Local Content Manager:</strong></p>
<p>Accessible from the Workshop tab → “My Content” (or a dedicated top-level menu item). This is the player’s disk management dashboard:</p>
<pre><code>┌──────────────────────────────────────────────────────────────────┐
│  My Content                                        Storage: 6.2 GB │
│  ┌──────────────────────────────────────────────────────────────┐ │
│  │ Pinned: 4.1 GB (12 resources)                               │ │
│  │ Transient: 1.8 GB (23 resources, 5 expiring soon)           │ │
│  │ Deactivated: 0.3 GB (2 resources)                           │ │
│  │ Budget: 1.8 / 10 GB transient    [Clean expired: 340 MB]    │ │
│  └──────────────────────────────────────────────────────────────┘ │
├──────────────────────────────────────────────────────────────────┤
│  Filter: [All ▾]  [Any category ▾]  Sort: [Size ▾]  [Search…]  │
├────────────────────┬──────┬───────┬───────────┬────────┬────────┤
│ Resource           │ Size │ State │ Last Used │ Source │ Action │
├────────────────────┼──────┼───────┼───────────┼────────┼────────┤
│ alice/hd-sprites   │ 38MB │ 📌    │ 2 days ago│ Manual │ [···]  │
│ bob/desert-map     │  9MB │ ⏳    │ 28 days   │ Lobby  │ [···]  │
│ core/ra-balance    │  1MB │ 📌    │ today     │ Manual │ [···]  │
│ dave/retro-sounds  │ 52MB │ 💤    │ 3 months  │ Manual │ [···]  │
│ eve/snow-map       │  4MB │ ⏳⚠   │ 32 days   │ Lobby  │ [···]  │
└────────────────────┴──────┴───────┴───────────┴────────┴────────┘
│  📌 = Pinned  ⏳ = Transient  💤 = Deactivated  ⚠ = Expiring    │
│  [Select all]  [Bulk: Pin | Deactivate | Remove]                │
└──────────────────────────────────────────────────────────────────┘
</code></pre>
<p>The <code>[···]</code> action menu per resource:</p>
<ul>
<li><strong>Pin / Unpin</strong> — toggle between pinned and transient</li>
<li><strong>Deactivate / Activate</strong> — toggle loading without removing</li>
<li><strong>Remove</strong> — delete from disk (dependency-aware prompt)</li>
<li><strong>View in Workshop</strong> — open the Workshop page for this resource</li>
<li><strong>Show dependents</strong> — what local resources depend on this one</li>
<li><strong>Show dependencies</strong> — what this resource requires</li>
<li><strong>Open folder</strong> — reveal the resource’s cache directory in the file manager</li>
</ul>
<p><strong>Bulk operations:</strong> Select multiple resources → Pin all, Deactivate all, Remove all. “Select all transient” and “Select all expiring” shortcuts for quick cleanup.</p>
<p><strong>“What’s using my disk?” view:</strong> A treemap or bar chart showing disk usage by category (Maps, Mods, Resource Packs, Script Libraries) with the largest individual resources highlighted. Helps players identify space hogs quickly. Accessible from the storage summary at the top of the content manager.</p>
<p><strong>Group operations:</strong></p>
<ul>
<li><strong>Pin with dependencies:</strong> <code>ic mod pin alice/total-conversion --with-deps</code> pins the resource AND all its transitive dependencies. Ensures the entire dependency tree is protected from auto-cleanup.</li>
<li><strong>Remove with orphans:</strong> <code>ic mod remove alice/total-conversion --cascade</code> removes the resource and any dependencies that become orphaned (no other pinned or transient resource needs them).</li>
<li><strong>Modpack-aware:</strong> Pinning a modpack (D030 § Modpacks) pins all resources in the modpack. Removing a modpack removes all resources that were only needed by that modpack.</li>
</ul>
<p><strong>How resources from different sources interact:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Source</th><th>Default state</th><th>Auto-cleanup?</th></tr>
</thead>
<tbody>
<tr><td><code>ic mod install</code> (explicit)</td><td>Pinned</td><td>No</td></tr>
<tr><td>Workshop UI “Install” button</td><td>Pinned</td><td>No</td></tr>
<tr><td>Lobby auto-download</td><td>Transient</td><td>Yes (after TTL)</td></tr>
<tr><td>Dependency of a pinned resource</td><td>Pinned (inherited)</td><td>No</td></tr>
<tr><td>Dependency of a transient resource</td><td>Transient (inherited)</td><td>Yes</td></tr>
<tr><td><code>ic workshop import-bundle</code></td><td>Pinned</td><td>No</td></tr>
<tr><td>Steam Workshop subscription</td><td>Pinned (managed by Steam)</td><td>Steam handles</td></tr>
</tbody>
</table>
</div>
<p><strong>Edge case — mixed dependency state:</strong> If resource C is a dependency of both pinned resource A and transient resource B: C is treated as pinned (strongest state wins). If A is later removed, C reverts to transient (inheriting from B). The state is always computed from the dependency graph, not stored independently for shared deps.</p>
<p><strong>Phase:</strong> Resource states (pinned/transient) and <code>ic mod remove/deactivate/clean/status</code> ship in Phase 4–5 with the Workshop. Storage budget and auto-cleanup prompts in Phase 5. In-game content manager UI in Phase 5–6a.</p>
<h3 id="continuous-deployment"><a class="header" href="#continuous-deployment">Continuous Deployment</a></h3>
<p>The <code>ic</code> CLI is designed for CI/CD pipelines — every command works headless (no interactive prompts). Authors authenticate via scoped API tokens (<code>IC_WORKSHOP_TOKEN</code> environment variable or <code>--token</code> flag). Tokens are scoped to specific operations (<code>publish</code>, <code>promote</code>, <code>admin</code>) and expire after a configurable duration. This enables:</p>
<ul>
<li><strong>Tag-triggered publish:</strong> Push a <code>v1.2.0</code> git tag → CI validates, tests headless, publishes to Workshop automatically</li>
<li><strong>Beta channel CI:</strong> Every merge to <code>main</code> publishes to <code>beta</code>; explicit tag promotes to <code>release</code></li>
<li><strong>Multi-resource monorepos:</strong> Matrix builds publish multiple resource packs from a single repo</li>
<li><strong>Automated quality gates:</strong> <code>ic mod check</code> + <code>ic mod test</code> + <code>ic mod audit</code> run before every publish</li>
<li><strong>Scheduled compatibility checks:</strong> Cron-triggered CI re-publishes against latest engine version to catch regressions</li>
</ul>
<p>Works with GitHub Actions, GitLab CI, Gitea Actions, or any CI system — the CLI is a single static binary. See <code>04-MODDING.md</code> § “Continuous Deployment for Workshop Authors” for the full workflow including a GitHub Actions example.</p>
<h3 id="script-libraries--sharing"><a class="header" href="#script-libraries--sharing">Script Libraries &amp; Sharing</a></h3>
<p><strong>Lesson from ArmA/OFP:</strong> ArmA’s modding ecosystem thrives partly because the community developed shared script libraries (CBA — Community Base Addons, ACE3’s interaction framework, ACRE radio system) that became foundational infrastructure. Mods built on shared libraries instead of reimplementing common patterns. IC makes this a first-class Workshop category.</p>
<p>A Script Library is a Workshop resource containing reusable Lua modules that other mods can depend on:</p>
<pre><code class="language-yaml"># mod.yaml for a script library resource
mod:
  name: "rts-ai-behaviors"
  category: script-library
  version: "1.0.0"
  license: "MIT"
  description: "Reusable AI behavior patterns for mission scripting"
  exports:
    - "patrol_routes"        # Lua module names available to dependents
    - "guard_behaviors"
    - "retreat_logic"
</code></pre>
<p>Dependent mods declare the library as a dependency and import its modules:</p>
<pre><code class="language-lua">-- In a mission script that depends on rts-ai-behaviors
local patrol = require("rts-ai-behaviors.patrol_routes")
local guard  = require("rts-ai-behaviors.guard_behaviors")

patrol.create_route(unit, waypoints, { loop = true, pause_time = 30 })
guard.assign_area(squad, Region.Get("base_perimeter"))
</code></pre>
<p><strong>Key design points:</strong></p>
<ul>
<li>Script libraries are Workshop resources with the <code>script-library</code> category — they use the same dependency, versioning (semver), and resolution system as any other resource (see Dependency Declaration above)</li>
<li><code>require()</code> in the Lua sandbox resolves to installed Workshop dependencies, not filesystem paths — maintaining sandbox security</li>
<li>Libraries are versioned independently — a library author can release 2.0 without breaking mods pinned to <code>^1.0</code></li>
<li><code>ic mod check</code> validates that all <code>require()</code> calls in a mod resolve to declared dependencies</li>
<li>Script libraries encourage specialization: AI behavior experts publish behavior libraries, UI specialists publish UI helper libraries, campaign designers share narrative utilities</li>
</ul>
<p>This turns the Lua tier from “every mod reimplements common patterns” into a composable ecosystem — the same shift that made npm/crates.io transformative for their respective communities.</p>
<h3 id="license-system"><a class="header" href="#license-system">License System</a></h3>
<p><strong>Every published Workshop resource MUST have a <code>license</code> field.</strong> Publishing without one is rejected.</p>
<pre><code class="language-yaml"># In mod.yaml or resource manifest
mod:
  license: "CC-BY-SA-4.0"             # SPDX identifier (required for publishing)
</code></pre>
<ul>
<li>Uses <a href="https://spdx.org/licenses/">SPDX identifiers</a> for machine-readable license classification</li>
<li>Workshop UI displays license prominently on every resource listing</li>
<li><code>ic mod audit</code> checks the full dependency tree for license compatibility (e.g., CC-BY-NC dep in a CC-BY mod → warning)</li>
<li>Common licenses for game assets: <code>CC-BY-4.0</code>, <code>CC-BY-SA-4.0</code>, <code>CC-BY-NC-4.0</code>, <code>CC0-1.0</code>, <code>MIT</code>, <code>GPL-3.0-only</code>, <code>LicenseRef-Custom</code> (with link to full text)</li>
<li>Resources with incompatible licenses can coexist in the Workshop but <code>ic mod audit</code> warns when combining them</li>
<li><strong>Optional EULA</strong> for authors who need additional terms beyond SPDX (e.g., “no use in commercial products without written permission”). EULA cannot contradict the SPDX license. See <code>04-MODDING.md</code> § “Optional EULA”</li>
<li><strong>Workshop Terms of Service (platform license):</strong> By publishing, authors grant the platform minimum rights to host, cache, replicate, index, generate previews, serve as dependency, and auto-download in multiplayer — regardless of the resource’s declared license. Same model as GitHub/npm/Steam Workshop. The ToS does not expand what <em>recipients</em> can do (that’s the license) — it ensures the platform can mechanically operate. See <code>04-MODDING.md</code> § “Workshop Terms of Service”</li>
<li><strong>Minimum age (COPPA):</strong> Workshop accounts require users to be 13+. See <code>04-MODDING.md</code> § “Minimum Age Requirement”</li>
<li><strong>Third-party content disclaimer:</strong> IC is not liable for Workshop content. See <code>04-MODDING.md</code> § “Third-Party Content Disclaimer”</li>
<li><strong>Privacy Policy:</strong> Required before Workshop server deployment. Covers data collection, retention, GDPR rights. See <code>04-MODDING.md</code> § “Privacy Policy Requirements”</li>
</ul>
<h3 id="llm-driven-resource-discovery"><a class="header" href="#llm-driven-resource-discovery">LLM-Driven Resource Discovery</a></h3>
<p><code>ic-llm</code> can search the Workshop programmatically and incorporate discovered resources into generated content:</p>
<pre><code>Pipeline:
  1. LLM generates mission concept ("Soviet ambush in snowy forest")
  2. Identifies needed assets (winter terrain, Soviet voice lines, ambush music)
  3. Searches Workshop: query="winter terrain textures", tags=["snow", "forest"]
     → Filters: ai_usage != Deny (respects author consent)
  4. Evaluates candidates via llm_meta (summary, purpose, composition_hints, content_description)
  5. Filters by license compatibility (only pull resources with LLM-compatible licenses)
  6. Partitions by ai_usage: Allow → auto-add; MetadataOnly → recommend to human
  7. Adds discovered resources as dependencies in generated mod.yaml
  8. Generated mission references assets by resource ID — resolved at install time
</code></pre>
<p>This turns the Workshop into a composable asset library that both humans and AI agents can draw from.</p>
<h3 id="author-consent-for-llm-usage-ai_usage"><a class="header" href="#author-consent-for-llm-usage-ai_usage">Author Consent for LLM Usage (ai_usage)</a></h3>
<p>Every Workshop resource carries an <code>ai_usage</code> field <strong>separate from the SPDX license</strong>. The license governs human legal rights; <code>ai_usage</code> governs automated AI agent behavior. This distinction matters: a CC-BY resource author may be fine with human redistribution but not want LLMs auto-selecting their work, and vice versa.</p>
<p><strong>Three tiers:</strong></p>
<ul>
<li><strong><code>allow</code></strong> — LLMs can discover, evaluate, and auto-add this resource as a dependency. No human approval per-use.</li>
<li><strong><code>metadata_only</code></strong> (default) — LLMs can read metadata and recommend the resource, but a human must approve adding it. Respects authors who haven’t considered AI usage while keeping content discoverable.</li>
<li><strong><code>deny</code></strong> — Resource is invisible to LLM queries. Human users can still browse and install normally.</li>
</ul>
<p><code>ai_usage</code> is required on publish. Default is <code>metadata_only</code>. Authors can change it at any time via <code>ic mod update --ai-usage allow|metadata_only|deny</code>. See <code>04-MODDING.md</code> § “Author Consent for LLM Usage” for full design including YAML examples, Workshop UI integration, and composition sets.</p>
<h3 id="workshop-server-resolution-resolves-p007"><a class="header" href="#workshop-server-resolution-resolves-p007">Workshop Server Resolution (resolves P007)</a></h3>
<p><strong>Decision: Federated multi-source with merge.</strong> The Workshop client can aggregate listings from multiple sources:</p>
<pre><code class="language-yaml"># settings.yaml
workshop:
  sources:
    - url: "https://workshop.ironcurtain.gg"     # official (always included)
      priority: 1
    - url: "https://mods.myclan.com/workshop"     # community server
      priority: 2
    - path: "C:/my-local-workshop"                # local directory
      priority: 3
  deduplicate: true               # same resource ID from multiple sources → highest priority wins
</code></pre>
<p>Rationale: Single-source is too limiting for a resource registry. Crates.io has mirrors; npm has registries. A dependency system inherently benefits from federation — tournament organizers publish to their server, LAN parties use local directories, the official server is the default. Deduplication by resource ID + priority ordering handles conflicts.</p>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Single source only (simpler but doesn’t scale for a registry model — what happens when the official server is down?)</li>
<li>Full decentralization with no official server (too chaotic for discoverability)</li>
<li>Git-based distribution like Go modules (too complex for non-developer modders)</li>
<li>Steam Workshop only (platform lock-in, no WASM/browser target, no self-hosting)</li>
</ul>
<h3 id="steam-workshop-integration"><a class="header" href="#steam-workshop-integration">Steam Workshop Integration</a></h3>
<p>The federated model includes <strong>Steam Workshop as a source type</strong> alongside IC-native Workshop servers and local directories. For Steam builds, the Workshop browser can query Steam Workshop in addition to IC sources:</p>
<pre><code class="language-yaml"># settings.yaml (Steam build)
workshop:
  sources:
    - url: "https://workshop.ironcurtain.gg"     # IC official
      priority: 1
    - type: steam-workshop                        # Steam Workshop (Steam builds only)
      app_id: &lt;steam_app_id&gt;
      priority: 2
    - path: "C:/my-local-workshop"
      priority: 3
</code></pre>
<ul>
<li><strong>Publish to both:</strong> <code>ic mod publish</code> uploads to IC Workshop; Steam builds additionally push to Steam Workshop via Steamworks API. One command, dual publish.</li>
<li><strong>Subscribe from either:</strong> IC resources and Steam Workshop items appear in the same in-game browser (virtual view merges them).</li>
<li><strong>Non-Steam builds are not disadvantaged.</strong> IC’s own Workshop is the primary registry. Steam Workshop is an optional distribution channel that broadens reach for creators on Steam.</li>
<li><strong>Maps are the primary Steam Workshop content type</strong> (matching Remastered’s pattern). Full mods are better served by the IC Workshop due to richer metadata, dependency resolution, and federation.</li>
</ul>
<h3 id="in-game-workshop-browser"><a class="header" href="#in-game-workshop-browser">In-Game Workshop Browser</a></h3>
<p>The Workshop is accessible from the main menu, not only via the <code>ic</code> CLI. The in-game browser provides:</p>
<ul>
<li><strong>Search</strong> with full-text search (FTS5 via D034), category filters, tag filters, and sorting (popular, recent, trending, most-depended-on)</li>
<li><strong>Resource detail pages</strong> with description, screenshots/preview, license, author, download count, rating, dependency tree, changelog</li>
<li><strong>One-click install</strong> with automatic dependency resolution — same as <code>ic mod install</code> but from the game UI</li>
<li><strong>Ratings and reviews</strong> — 1-5 star rating plus optional text review per user per resource</li>
<li><strong>Creator profiles</strong> — browse all resources by a specific author, see their total downloads, reputation badges</li>
<li><strong>Collections</strong> — user-curated lists of resources (“My Competitive Setup”, “Best Soviet Music”), shareable via link</li>
<li><strong>Trending and featured</strong> — algorithmically surfaced (time-weighted download velocity) plus editorially curated featured lists</li>
</ul>
<h3 id="auto-download-on-lobby-join"><a class="header" href="#auto-download-on-lobby-join">Auto-Download on Lobby Join</a></h3>
<p>When a player joins a multiplayer lobby, the game automatically resolves and downloads any required mods, maps, or resource packs that the player doesn’t have locally:</p>
<ol>
<li><strong>Lobby advertises requirements:</strong> The <code>GameListing</code> (see <code>03-NETCODE.md</code>) includes mod ID, version, and Workshop source for all required resources</li>
<li><strong>Client checks local cache:</strong> Already have the exact version? Skip download.</li>
<li><strong>Missing resources auto-resolve:</strong> Client queries the virtual Workshop repository, downloads missing resources via P2P (BitTorrent/WebTorrent — D049) with HTTP fallback. Lobby peers are prioritized as download sources (they already have the required content).</li>
<li><strong>Progress UI:</strong> Download progress bar shown in lobby with source indicator (P2P/HTTP). Game start blocked until all players have all required resources.</li>
<li><strong>Rejection option:</strong> Player can decline to download and leave the lobby instead.</li>
<li><strong>Size warning:</strong> Downloads exceeding a configurable threshold (default 100MB) prompt confirmation before proceeding.</li>
</ol>
<p>This matches CS:GO/CS2’s pattern where community maps download automatically when joining a server — zero friction for players. It also solves ArmA Reforger’s most-cited community complaint about mod management friction. P2P delivery means lobby auto-download is fast (peers in the same lobby are direct seeds) and free (no CDN cost per join). See D052 § “In-Lobby P2P Resource Sharing” for the full lobby protocol: room discovery, host-as-tracker, security model, and verification flow.</p>
<p><strong>Local resource lifecycle:</strong> Resources downloaded this way are tagged as <strong>transient</strong> (not pinned). They remain fully functional but are subject to auto-cleanup after <code>transient_ttl_days</code> (default 30 days) of non-use. After the session, a non-intrusive toast offers: “[Pin (keep forever)] [They’ll auto-clean in 30 days] [Remove now]”. Frequently-used transient resources (3+ sessions) are automatically promoted to pinned. See D030 § “Local Resource Management” for the full lifecycle, storage budget, and cleanup UX.</p>
<h3 id="creator-reputation-system"><a class="header" href="#creator-reputation-system">Creator Reputation System</a></h3>
<p>Creators accumulate reputation through their Workshop activity. Reputation is displayed on resource listings and creator profiles:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Signal</th><th>Weight</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Total downloads</td><td>Medium</td><td>Cumulative downloads across all published resources</td></tr>
<tr><td>Average rating</td><td>High</td><td>Mean star rating across published resources (minimum 10 ratings to display)</td></tr>
<tr><td>Dependency count</td><td>High</td><td>How many other resources/mods depend on this creator’s work</td></tr>
<tr><td>Publish consistency</td><td>Low</td><td>Regular updates and new content over time</td></tr>
<tr><td>Community reports</td><td>Negative</td><td>DMCA strikes, policy violations reduce reputation</td></tr>
</tbody>
</table>
</div>
<p><strong>Badges:</strong></p>
<ul>
<li><strong>Verified</strong> — identity confirmed (e.g., linked GitHub account)</li>
<li><strong>Prolific</strong> — 10+ published resources with ≥4.0 average rating</li>
<li><strong>Foundation</strong> — resources depended on by 50+ other resources</li>
<li><strong>Curator</strong> — maintains high-quality curated collections</li>
</ul>
<p>Reputation is displayed but not gatekeeping — any registered user can publish. Reputation helps players discover trustworthy content in a growing registry.</p>
<h3 id="content-moderation--dmcatakedown-policy"><a class="header" href="#content-moderation--dmcatakedown-policy">Content Moderation &amp; DMCA/Takedown Policy</a></h3>
<p>The Workshop requires a clear content policy and takedown process:</p>
<p><strong>Prohibited content:</strong></p>
<ul>
<li>Assets ripped from commercial games without permission (the ArmA community’s perennial problem)</li>
<li>Malicious content (WASM modules with harmful behavior — mitigated by capability sandbox)</li>
<li>Content violating the license declared in its manifest</li>
<li>Hate speech, illegal content (standard platform policy)</li>
</ul>
<p><strong>Takedown process:</strong></p>
<ol>
<li><strong>Reporter files takedown request</strong> via Workshop UI or email, specifying the resource and the claim (DMCA, license violation, policy violation)</li>
<li><strong>Resource is flagged</strong> — not immediately removed — and the author is notified with a 72-hour response window</li>
<li><strong>Author can counter-claim</strong> (e.g., they hold the rights, the reporter is mistaken)</li>
<li><strong>Workshop moderators review</strong> — if the claim is valid, the resource is delisted (not deleted — remains in local caches of existing users)</li>
<li><strong>Repeat offenders</strong> accumulate strikes. Three strikes → account publishing privileges suspended. Appeals process available.</li>
<li><strong>DMCA safe harbor:</strong> The Workshop server operator (official or community-hosted) follows standard DMCA safe harbor procedures. Community-hosted servers set their own moderation policies.</li>
</ol>
<p><strong>License enforcement integration:</strong></p>
<ul>
<li><code>ic mod audit</code> already checks dependency tree license compatibility</li>
<li>Workshop server rejects publish if declared license conflicts with dependency licenses</li>
<li>Resources with <code>LicenseRef-Custom</code> must provide a URL to full license text</li>
</ul>
<p><strong>Rationale (from ArmA research):</strong> ArmA’s private mod ecosystem exists specifically because the Workshop can’t protect creators or manage IP claims. Disney, EA, and others actively DMCA ArmA Workshop content. Bohemia established an IP ban list but the community found it heavy-handed. IC’s approach: clear rules, due process, creator notification first — not immediate removal.</p>
<p><strong>Phase:</strong> Minimal Workshop in Phase 4–5 (central server + publish + browse + auto-download); full Workshop (federation, Steam source, reputation, DMCA) in Phase 6a; preparatory work in Phase 3 (manifest format finalized).</p>
<hr>
<h2 id="d035-creator-recognition--attribution"><a class="header" href="#d035-creator-recognition--attribution">D035: Creator Recognition &amp; Attribution</a></h2>
<p><strong>Decision:</strong> The Workshop supports <strong>voluntary creator recognition</strong> through tipping/sponsorship links and reputation badges. Monetization is never mandatory — all Workshop resources are freely downloadable. Creators can optionally accept tips and link sponsorship profiles.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>The C&amp;C modding community has a 30-year culture of free modding. Mandatory paid content would generate massive resistance and fragment multiplayer (can’t join a game if you don’t own a required paid map — ArmA DLC demonstrated this problem).</li>
<li>Valve’s Steam Workshop paid mods experiment (Skyrim, 2015) was reversed within days due to community backlash. The 75/25 revenue split (Valve/creator) was seen as exploitative.</li>
<li>Nexus Mods’ Donation Points system is well-received as a voluntary model — creators earn money without gating access.</li>
<li>CS:GO/CS2’s creator economy ($57M+ paid to creators by 2015) works because it’s cosmetic-only items curated by Valve — a fundamentally different model than gating gameplay content.</li>
<li>ArmA’s commissioned mod ecosystem exists in a legal/ethical gray zone with no official framework — creators deserve better.</li>
<li>Backend infrastructure (relay servers, Workshop servers, tracking servers) has real hosting costs. Sustainability requires some revenue model.</li>
</ul>
<p><strong>Key Design Elements:</strong></p>
<h3 id="creator-tipping"><a class="header" href="#creator-tipping">Creator Tipping</a></h3>
<ul>
<li><strong>Tip jar on resource pages:</strong> Every Workshop resource page has an optional “Support this creator” button. Clicking shows the creator’s configured payment links.</li>
<li><strong>Payment links, not payment processing.</strong> IC does not process payments directly. Creators link their own payment platforms:</li>
</ul>
<pre><code class="language-yaml"># In mod.yaml or creator profile
creator:
  name: "Alice"
  tip_links:
    - platform: "ko-fi"
      url: "https://ko-fi.com/alice"
    - platform: "github-sponsors"
      url: "https://github.com/sponsors/alice"
    - platform: "patreon"
      url: "https://patreon.com/alice"
    - platform: "paypal"
      url: "https://paypal.me/alice"
</code></pre>
<ul>
<li><strong>No IC platform fee on tips.</strong> Tips go directly to creators via their chosen platform. IC takes zero cut.</li>
<li><strong>Aggregate tip link on creator profile:</strong> Creator’s profile page shows a single “Support Alice” button linking to their preferred platform.</li>
</ul>
<h3 id="infrastructure-sustainability"><a class="header" href="#infrastructure-sustainability">Infrastructure Sustainability</a></h3>
<p>The Workshop and backend servers have hosting costs. Sustainability options (not mutually exclusive):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Model</th><th>Description</th><th>Precedent</th></tr>
</thead>
<tbody>
<tr><td><strong>Community donations</strong></td><td>Open Collective / GitHub Sponsors for the project itself</td><td>Godot, Blender, Bevy</td></tr>
<tr><td><strong>Premium hosting tier</strong></td><td>Optional paid tier: priority matchmaking queue, larger replay archive, custom clan pages</td><td>Discord Nitro, private game servers</td></tr>
<tr><td><strong>Sponsored featured slots</strong></td><td>Creators or communities pay to feature resources in the Workshop’s “Featured” section</td><td>App Store featured placements</td></tr>
<tr><td><strong>White-label licensing</strong></td><td>Tournament organizers or game communities license the engine+infrastructure for their own branded deployments</td><td>Many open-source projects</td></tr>
</tbody>
</table>
</div>
<p><strong>No mandatory paywalls.</strong> The free tier is fully functional — all gameplay features, all maps, all mods, all multiplayer. Premium tiers offer convenience and visibility, never exclusive gameplay content.</p>
<p><strong>No loot boxes, no skin gambling, no speculative economy.</strong> CS:GO’s skin economy generated massive revenue but also attracted gambling sites, scams, and regulatory scrutiny. IC’s creator recognition model is direct and transparent.</p>
<h3 id="future-expansion-path"><a class="header" href="#future-expansion-path">Future Expansion Path</a></h3>
<p>The Workshop schema supports monetization metadata from day one, but launches with tips-only:</p>
<pre><code class="language-yaml"># Future schema (not implemented at launch)
mod:
  pricing:
    model: "free"                    # free | tip | paid (paid = future)
    tip_links: [...]                 # voluntary compensation
    # price: "2.99"                  # future: optional price for premium content
    # revenue_split: "70/30"         # future: creator/platform split
</code></pre>
<p>If the community evolves toward wanting paid content (e.g., professional-quality campaign packs), the schema is ready. But this is a community decision, not a launch feature.</p>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Mandatory marketplace (Skyrim paid mods disaster — community backlash guaranteed)</li>
<li>Revenue share on all downloads (creates perverse incentives, fragments multiplayer)</li>
<li>No monetization at all (unsustainable for infrastructure; undervalues creators)</li>
<li>EA premium content pathway (licensing conflicts with open-source, gives EA control the community should own)</li>
</ul>
<p><strong>Phase:</strong> Phase 6a (integrated with Workshop infrastructure), with creator profile schema defined in Phase 3.</p>
<hr>
<h2 id="d036-achievement-system"><a class="header" href="#d036-achievement-system">D036: Achievement System</a></h2>
<p><strong>Decision:</strong> IC includes a <strong>per-game-module achievement system</strong> with built-in and mod-defined achievements, stored locally in SQLite (D034), with optional Workshop sync for community-created achievement packs.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Achievements provide progression and engagement outside competitive ranking — important for casual players who are the majority of the C&amp;C community</li>
<li>Modern RTS players expect achievement systems (Remastered, SC2, AoE4 all have them)</li>
<li>Mod-defined achievements drive Workshop adoption: a total conversion mod can define its own achievement set, incentivizing players to explore community content</li>
<li>SQLite storage (D034) already handles all persistent client state — achievements are another table</li>
</ul>
<p><strong>Key Design Elements:</strong></p>
<h3 id="achievement-categories"><a class="header" href="#achievement-categories">Achievement Categories</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Examples</th><th>Scope</th></tr>
</thead>
<tbody>
<tr><td><strong>Campaign</strong></td><td>“Complete Allied Campaign on Hard”, “Zero casualties in mission 3”</td><td>Per-game-module, per-campaign</td></tr>
<tr><td><strong>Skirmish</strong></td><td>“Win with only infantry”, “Defeat 3 brutal AIs simultaneously”</td><td>Per-game-module</td></tr>
<tr><td><strong>Multiplayer</strong></td><td>“Win 10 ranked matches”, “Achieve 200 APM in a match”</td><td>Per-game-module, per-mode</td></tr>
<tr><td><strong>Exploration</strong></td><td>“Play every official map”, “Try all factions”</td><td>Per-game-module</td></tr>
<tr><td><strong>Community</strong></td><td>“Install 5 Workshop mods”, “Rate 10 Workshop resources”, “Publish a resource”</td><td>Cross-module</td></tr>
<tr><td><strong>Mod-defined</strong></td><td>Defined by mod authors in YAML, registered via Workshop</td><td>Per-mod</td></tr>
</tbody>
</table>
</div>
<h3 id="storage-schema-d034"><a class="header" href="#storage-schema-d034">Storage Schema (D034)</a></h3>
<pre><code class="language-sql">CREATE TABLE achievements (
    id              TEXT PRIMARY KEY,     -- "ra1.campaign.allied_hard_complete"
    game_module     TEXT NOT NULL,        -- "ra1", "td", "ra2"
    category        TEXT NOT NULL,        -- "campaign", "skirmish", "multiplayer", "community"
    title           TEXT NOT NULL,
    description     TEXT NOT NULL,
    icon            TEXT,                 -- path to achievement icon asset
    hidden          BOOLEAN DEFAULT 0,    -- hidden until unlocked (surprise achievements)
    source          TEXT NOT NULL         -- "builtin" or workshop resource ID
);

CREATE TABLE achievement_progress (
    achievement_id  TEXT REFERENCES achievements(id),
    unlocked_at     TEXT,                 -- ISO 8601 timestamp, NULL if locked
    progress        INTEGER DEFAULT 0,    -- for multi-step achievements (e.g., "win 10 matches": progress=7)
    target          INTEGER DEFAULT 1,    -- total required for unlock
    PRIMARY KEY (achievement_id)
);
</code></pre>
<h3 id="mod-defined-achievements"><a class="header" href="#mod-defined-achievements">Mod-Defined Achievements</a></h3>
<p>Mod authors define achievements in their <code>mod.yaml</code>, which register when the mod is installed:</p>
<pre><code class="language-yaml"># mod.yaml (achievement definition in a mod)
achievements:
  - id: "my_mod.survive_the_storm"
    title: "Eye of the Storm"
    description: "Survive a blizzard event without losing any buildings"
    category: skirmish
    icon: "assets/achievements/storm.png"
    hidden: false
    trigger: "lua"                     # unlock logic in Lua script
  - id: "my_mod.build_all_units"
    title: "Full Arsenal"
    description: "Build every unit type in a single match"
    category: skirmish
    icon: "assets/achievements/arsenal.png"
    trigger: "lua"
</code></pre>
<p>Lua scripts call <code>Achievement.unlock("my_mod.survive_the_storm")</code> when conditions are met. The achievement API is part of the Lua globals (alongside <code>Actor</code>, <code>Trigger</code>, <code>Map</code>, etc.).</p>
<h3 id="design-constraints"><a class="header" href="#design-constraints">Design Constraints</a></h3>
<ul>
<li><strong>No multiplayer achievements that incentivize griefing.</strong> “Kill 100 allied units” → no. “Win 10 team games” → yes.</li>
<li><strong>Campaign achievements are deterministic</strong> — same inputs, same achievement unlock. Replays can verify achievement legitimacy.</li>
<li><strong>Achievement packs are Workshop resources</strong> — community can create themed achievement collections (e.g., “Speedrun Challenges”, “Pacifist Run”).</li>
<li><strong>Mod achievements are sandboxed to their mod.</strong> Uninstalling a mod hides its achievements (progress preserved, shown as “mod not installed”).</li>
<li><strong>Steam achievements sync</strong> (Steam builds only) — built-in achievements map to Steam achievement API. Mod-defined achievements are IC-only.</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Steam achievements only (excludes non-Steam players, can’t support mod-defined achievements)</li>
<li>No achievement system (misses engagement opportunity, feels incomplete vs modern RTS competitors)</li>
<li>Blockchain-verified achievements (needless complexity, community hostility toward crypto/blockchain in games)</li>
</ul>
<p><strong>Phase:</strong> Phase 3 (built-in achievement infrastructure + campaign achievements), Phase 6b (mod-defined achievements via Workshop).</p>
<hr>
<h2 id="d037-community-governance--platform-stewardship"><a class="header" href="#d037-community-governance--platform-stewardship">D037: Community Governance &amp; Platform Stewardship</a></h2>
<p><strong>Decision:</strong> IC’s community infrastructure (Workshop, tracking servers, competitive systems) operates under a <strong>transparent governance model</strong> with community representation, clear policies, and distributed authority.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>OpenRA’s community fragmented partly because governance was opaque — balance changes and feature decisions were made by a small core team without structured community input, leading to the “OpenRA isn’t RA1” sentiment</li>
<li>ArmA’s Workshop moderation is perceived as inconsistent — some IP holders get mods removed, others don’t, with no clear published policy</li>
<li>CNCnet succeeds partly because it’s community-run with clear ownership</li>
<li>The Workshop (D030) and competitive systems create platform responsibilities: content moderation, balance curation, server uptime, dispute resolution. These need defined ownership.</li>
<li>Self-hosting is a first-class use case (D030 federation) — governance must work even when the official infrastructure is one of many</li>
</ul>
<p><strong>Key Design Elements:</strong></p>
<h3 id="governance-structure"><a class="header" href="#governance-structure">Governance Structure</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Role</th><th>Responsibility</th><th>Selection</th></tr>
</thead>
<tbody>
<tr><td><strong>Project maintainer(s)</strong></td><td>Engine code, architecture decisions, release schedule</td><td>Existing (repository owners)</td></tr>
<tr><td><strong>Workshop moderators</strong></td><td>Content moderation, DMCA processing, policy enforcement</td><td>Appointed by maintainers, community nominations</td></tr>
<tr><td><strong>Competitive committee</strong></td><td>Ranked map pool, balance preset curation, tournament rules</td><td>Elected by active ranked players (annual)</td></tr>
<tr><td><strong>Game module stewards</strong></td><td>Per-module balance/content decisions (RA1 steward, TD steward, etc.)</td><td>Appointed by maintainers based on community contributions</td></tr>
<tr><td><strong>Community representatives</strong></td><td>Advocate for community needs, surface pain points, vote on pending decisions</td><td>Elected by community (annual), at least one per major region</td></tr>
</tbody>
</table>
</div>
<h3 id="transparency-commitments"><a class="header" href="#transparency-commitments">Transparency Commitments</a></h3>
<ul>
<li><strong>Public decision log</strong> (this document) for all architectural and policy decisions</li>
<li><strong>Monthly community reports</strong> for Workshop statistics (uploads, downloads, moderation actions, takedowns)</li>
<li><strong>Open moderation log</strong> for Workshop takedown actions (stripped of personal details) — the community can see what was removed and why</li>
<li><strong>RFC process for major changes:</strong> Balance preset modifications, Workshop policy changes, and competitive rule changes go through a public comment period before adoption</li>
<li><strong>Community surveys</strong> before major decisions that affect gameplay experience (annually at minimum)</li>
</ul>
<h3 id="self-hosting-independence"><a class="header" href="#self-hosting-independence">Self-Hosting Independence</a></h3>
<p>The governance model explicitly supports community independence:</p>
<ul>
<li>Any community can host their own Workshop server, tracking server, and relay server</li>
<li>Federation (D030) means community servers are peers, not subordinates to the official infrastructure</li>
<li>If the official project becomes inactive, the community has all the tools, source code, and infrastructure to continue independently</li>
<li>Community-hosted servers set their own moderation policies (within the framework of clear minimum standards for federated discovery)</li>
</ul>
<h3 id="community-groups"><a class="header" href="#community-groups">Community Groups</a></h3>
<p><strong>Lesson from ArmA/OFP:</strong> The ArmA community’s longevity (25+ years) owes much to its clan/unit culture — persistent groups with shared mod lists, server configurations, and identity. IC supports this natively rather than leaving it to Discord servers and spreadsheets.</p>
<p>Community groups are lightweight persistent entities in the Workshop/tracking infrastructure:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Group identity</strong></td><td>Name, tag, icon, description — displayed in lobby and in-game alongside player names</td></tr>
<tr><td><strong>Shared mod list</strong></td><td>Group-curated list of Workshop resources. Members click “Sync” to install the group’s mod configuration.</td></tr>
<tr><td><strong>Shared server list</strong></td><td>Preferred relay/tracking servers. Members auto-connect to the group’s servers.</td></tr>
<tr><td><strong>Group achievements</strong></td><td>Community achievements (D036) scoped to group activities — “Play 50 matches with your group”</td></tr>
<tr><td><strong>Private lobbies</strong></td><td>Group members can create password-free lobbies visible only to other members</td></tr>
</tbody>
</table>
</div>
<p>Groups are <strong>not</strong> competitive clans (no group rankings, no group matchmaking). They are social infrastructure — a way for communities of players to share configurations and find each other. Competitive team features (team ratings, team matchmaking) are separate and independent.</p>
<p><strong>Storage:</strong> Group metadata stored in SQLite (D034) on the tracking/Workshop server. Groups are federated — a group created on a community tracking server is visible to members who have that server in their <code>settings.yaml</code> sources list. No central authority over group creation.</p>
<p><strong>Phase:</strong> Phase 5 (alongside multiplayer infrastructure). Minimal viable implementation: group identity + shared mod list + private lobbies. Group achievements and server lists in Phase 6a.</p>
<h3 id="community-knowledge-base"><a class="header" href="#community-knowledge-base">Community Knowledge Base</a></h3>
<p><strong>Lesson from ArmA/OFP:</strong> ArmA’s community wiki (Community Wiki — formerly BI Wiki) is one of the most comprehensive game modding references ever assembled, entirely community-maintained. OpenRA has scattered documentation across GitHub wiki pages, the OpenRA book, mod docs, and third-party tutorials — no single authoritative reference.</p>
<p>IC ships a structured knowledge base alongside the Workshop:</p>
<ul>
<li><strong>Engine wiki</strong> — community-editable documentation for engine features, YAML schema reference, Lua API reference, WASM host functions. Seeded with auto-generated content from the typed schema (every YAML field and Lua global gets a stub page).</li>
<li><strong>Modding tutorials</strong> — structured guides from “first YAML change” through “WASM total conversion.” Community members can submit and edit tutorials.</li>
<li><strong>Map-making guides</strong> — scenario editor documentation with annotated examples.</li>
<li><strong>Community cookbook</strong> — recipe-style pages: “How to add a new unit type,” “How to create a branching campaign,” “How to publish a resource pack.” Short, copy-pasteable, maintained by the community.</li>
</ul>
<p><strong>Implementation:</strong> The knowledge base is a static site (mdbook or similar) with source in a public git repository. Community contributions via pull requests — same workflow as code contributions. Auto-generated API reference pages are rebuilt on each engine release. The in-game help system links to knowledge base pages contextually (e.g., the scenario editor’s trigger panel links to the triggers documentation).</p>
<p><strong>Not a forum.</strong> The knowledge base is reference documentation, not discussion. Community discussion happens on whatever platforms the community chooses (Discord, forums, etc.). IC provides infrastructure for shared knowledge, not social interaction beyond Community Groups.</p>
<p><strong>Phase:</strong> Phase 4 (auto-generated API reference from Lua/YAML schema). Phase 6a (community-editable tutorials, cookbook). Seeded by the project maintainer during development — the design docs themselves are the initial knowledge base.</p>
<h3 id="creator-content-program"><a class="header" href="#creator-content-program">Creator Content Program</a></h3>
<p><strong>Lesson from ArmA/OFP:</strong> Bohemia Interactive’s Creator DLC program (launched 2019) showed that a structured quality ladder — from hobbyist to featured to commercially published — works when the criteria are transparent and the community governs curation. The program produced professional-quality content (Global Mobilization, S.O.G. Prairie Fire, CSLA Iron Curtain) while keeping the free modding ecosystem healthy.</p>
<p>IC adapts this concept within D035’s voluntary framework (no mandatory paywalls, no IC platform fee):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Tier</th><th>Criteria</th><th>Recognition</th></tr>
</thead>
<tbody>
<tr><td><strong>Published</strong></td><td>Meets Workshop minimum standards (valid metadata, license declared, no malware)</td><td>Listed in Workshop, available for search and dependency</td></tr>
<tr><td><strong>Reviewed</strong></td><td>Passes community review (2+ moderator approvals for quality, completeness, documentation)</td><td>“Reviewed” badge on Workshop page, eligible for “Staff Picks” featured section</td></tr>
<tr><td><strong>Featured</strong></td><td>Selected by Workshop moderators or competitive committee for exceptional quality</td><td>Promoted in Workshop “Featured” section, highlighted in in-game browser, included in starter packs</td></tr>
<tr><td><strong>Spotlighted</strong></td><td>Seasonal showcase — community-voted “best of” for maps, mods, campaigns, and assets</td><td>Front-page placement, social media promotion, creator interview/spotlight</td></tr>
</tbody>
</table>
</div>
<p><strong>Key differences from Bohemia’s Creator DLC:</strong></p>
<ul>
<li><strong>No paid tier at launch.</strong> All tiers are free. D035’s future <code>paid</code> pricing model is available if the community evolves toward it, but the quality ladder operates independently of monetization.</li>
<li><strong>Community curation, not publisher curation.</strong> Workshop moderators and the competitive committee (both community roles) make tier decisions, not the project maintainer.</li>
<li><strong>Transparent criteria.</strong> Published criteria for each tier — creators know exactly what’s needed to reach “Reviewed” or “Featured” status.</li>
<li><strong>No exclusive distribution.</strong> Featured content is Workshop content — it can be forked, depended on, and mirrored. No lock-in.</li>
</ul>
<p>The Creator Content Program is a recognition and quality signal system, not a gatekeeping mechanism. The Workshop remains open to all — tiers help players find high-quality content, not restrict who can publish.</p>
<p><strong>Phase:</strong> Phase 6a (integrated with Workshop moderator role from D037 governance structure). “Published” tier is automatic from Workshop launch (Phase 4–5). “Reviewed” and “Featured” require active moderators.</p>
<h3 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h3>
<p>Standard open-source code of conduct (Contributor Covenant or similar) applies to:</p>
<ul>
<li>Workshop resource descriptions and reviews</li>
<li>In-game chat (client-side filtering, not server enforcement for non-ranked games)</li>
<li>Competitive play (ranked games: stricter enforcement, report system, temporary bans for verified toxicity)</li>
<li>Community forums and communication channels</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>BDFL (Benevolent Dictator for Life) model with no community input (faster decisions but risks OpenRA’s fate — community alienation)</li>
<li>Full democracy (too slow for a game project; bikeshedding on every decision)</li>
<li>Corporate governance (inappropriate for an open-source community project)</li>
<li>No formal governance (works early, creates problems at scale — better to define structure before it’s needed)</li>
</ul>
<p><strong>Phase:</strong> Phase 0 (code of conduct, contribution guidelines), Phase 5 (competitive committee), Phase 7 (Workshop moderators, community representatives).</p>
<blockquote>
<p><strong>Phasing note:</strong> This governance model is aspirational — it describes where the project aims to be at scale, not what launches on day one. At project start, governance is BDFL (maintainer) + trusted contributors, which is appropriate for a project with zero users. Formal elections, committees, and community representatives should not be implemented until there is an active community of 50+ regular contributors. The governance structure documented here is a roadmap, not a launch requirement. Premature formalization risks creating bureaucracy before there are people to govern.</p>
</blockquote>
<hr>
<h2 id="d031-observability--telemetry--otel-across-engine-servers-and-ai-pipeline"><a class="header" href="#d031-observability--telemetry--otel-across-engine-servers-and-ai-pipeline">D031: Observability &amp; Telemetry — OTEL Across Engine, Servers, and AI Pipeline</a></h2>
<p><strong>Decision:</strong> All backend servers (relay, tracking, workshop) and the game engine itself emit structured telemetry via OpenTelemetry (OTEL), enabling operational monitoring, gameplay debugging, state inspection, and AI/LLM training data collection — all from a single, unified instrumentation layer.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Backend servers (relay, tracking, workshop) are production infrastructure — they need health metrics, latency histograms, error rates, and distributed traces, just like any microservice</li>
<li>The game engine already has rich internal state (per-tick <code>state_hash()</code>, snapshots, system execution times) but no structured way to export it for analysis</li>
<li>Replay files capture <em>what happened</em> but not <em>why</em> — telemetry captures the engine’s decision-making process (pathfinding time, order validation outcomes, combat resolution details) that replays miss</li>
<li>Behavioral analysis (V12 anti-cheat) already collects APM, reaction times, and input entropy on the relay — OTEL is the natural export format for this data</li>
<li>AI/LLM development needs training data: game telemetry (unit movements, build orders, engagement outcomes) is exactly the training corpus for <code>ic-ai</code> and <code>ic-llm</code></li>
<li>Bevy already integrates with Rust’s <code>tracing</code> crate — OTEL export is a natural extension, not a foreign addition</li>
<li>Desync debugging needs cross-client correlation — distributed tracing (trace IDs) lets you follow an order from input → network → sim → render across multiple clients and the relay server</li>
<li>A single instrumentation approach (OTEL) avoids the mess of ad-hoc logging, custom metrics files, separate debug protocols, and incompatible formats</li>
</ul>
<p><strong>Key Design Elements:</strong></p>
<h3 id="three-telemetry-signals-otel-standard"><a class="header" href="#three-telemetry-signals-otel-standard">Three Telemetry Signals (OTEL Standard)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Signal</th><th>What It Captures</th><th>Export Format</th></tr>
</thead>
<tbody>
<tr><td>Metrics</td><td>Counters, histograms, gauges — numeric time series</td><td>OTLP → Prometheus</td></tr>
<tr><td>Traces</td><td>Distributed request flows — an order’s journey through the system</td><td>OTLP → Jaeger/Zipkin</td></tr>
<tr><td>Logs</td><td>Structured events with severity, context, correlation IDs</td><td>OTLP → Loki/stdout</td></tr>
</tbody>
</table>
</div>
<h3 id="backend-server-telemetry-relay-tracking-workshop"><a class="header" href="#backend-server-telemetry-relay-tracking-workshop">Backend Server Telemetry (Relay, Tracking, Workshop)</a></h3>
<p>Standard operational observability — same patterns used by any production Rust service:</p>
<p><strong>Relay server metrics:</strong></p>
<pre><code>relay.games.active                    # gauge: concurrent games
relay.games.total                     # counter: total games hosted
relay.orders.received                 # counter: orders received per tick
relay.orders.forwarded                # counter: orders broadcast
relay.orders.dropped                  # counter: orders missed (lag switch)
relay.tick.latency_ms                 # histogram: tick processing time
relay.player.rtt_ms                   # histogram: per-player round-trip time
relay.player.suspicion_score          # gauge: behavioral analysis score (V12)
relay.desync.detected                 # counter: desync events
relay.match.completed                 # counter: matches finished
relay.match.duration_s                # histogram: match duration
</code></pre>
<p><strong>Tracking server metrics:</strong></p>
<pre><code>tracking.listings.active              # gauge: current game listings
tracking.heartbeats.received          # counter: heartbeats processed
tracking.heartbeats.expired           # counter: listings expired (TTL)
tracking.queries.total                # counter: browse/search requests
tracking.queries.latency_ms           # histogram: query latency
</code></pre>
<p><strong>Workshop server metrics:</strong></p>
<pre><code>workshop.resources.total              # gauge: total published resources
workshop.resources.downloads          # counter: download events
workshop.resources.publishes          # counter: publish events
workshop.resolve.latency_ms           # histogram: dependency resolution time
workshop.resolve.conflicts            # counter: version conflicts detected
workshop.search.latency_ms            # histogram: search query time
</code></pre>
<p><strong>Distributed traces:</strong> A multiplayer game session gets a trace ID. Every order, tick, and desync event references this trace ID. Debug a desync by searching for the game’s trace ID in Jaeger and seeing the exact sequence of events across all participants.</p>
<p><strong>Health endpoints:</strong> Every server exposes <code>/healthz</code> (already designed) and <code>/readyz</code>. Prometheus scrape endpoint at <code>/metrics</code>. These are standard and compose with existing k8s deployment (Helm charts already designed in <code>03-NETCODE.md</code>).</p>
<h3 id="game-engine-telemetry-client-side"><a class="header" href="#game-engine-telemetry-client-side">Game Engine Telemetry (Client-Side)</a></h3>
<p>The engine emits structured telemetry for debugging, profiling, and AI training — but only when enabled. <strong>Hot paths remain zero-cost when telemetry is disabled</strong> (compile-time feature flag <code>telemetry</code>).</p>
<h4 id="performance-instrumentation"><a class="header" href="#performance-instrumentation">Performance Instrumentation</a></h4>
<p>Per-tick system timing, already needed for the benchmark suite (<code>10-PERFORMANCE.md</code>), exported as OTEL metrics when enabled:</p>
<pre><code>sim.tick.duration_us                  # histogram: total tick time
sim.system.apply_orders_us            # histogram: per-system time
sim.system.production_us
sim.system.harvesting_us
sim.system.movement_us
sim.system.combat_us
sim.system.death_us
sim.system.triggers_us
sim.system.fog_us
sim.entities.total                    # gauge: entity count
sim.entities.by_type                  # gauge: per-component-type count
sim.memory.scratch_bytes              # gauge: TickScratch buffer usage
sim.pathfinding.requests              # counter: pathfinding queries per tick
sim.pathfinding.cache_hits            # counter: flowfield cache reuse
sim.pathfinding.duration_us           # histogram: pathfinding computation time
</code></pre>
<h4 id="gameplay-event-stream"><a class="header" href="#gameplay-event-stream">Gameplay Event Stream</a></h4>
<p>Structured events emitted during simulation — the raw material for AI training and replay enrichment:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Gameplay events emitted by the sim when telemetry is enabled.
/// These are structured, not printf-style — each field is queryable.
pub enum GameplayEvent {
    UnitCreated { tick: u64, entity: EntityId, unit_type: String, owner: PlayerId },
    UnitDestroyed { tick: u64, entity: EntityId, killer: Option&lt;EntityId&gt;, cause: DeathCause },
    CombatEngagement { tick: u64, attacker: EntityId, target: EntityId, weapon: String, damage: i32, remaining_hp: i32 },
    BuildingPlaced { tick: u64, entity: EntityId, structure_type: String, owner: PlayerId, position: WorldPos },
    HarvestDelivered { tick: u64, harvester: EntityId, resource_type: String, amount: i32, total_credits: i32 },
    OrderIssued { tick: u64, player: PlayerId, order: PlayerOrder, validated: bool, rejection_reason: Option&lt;String&gt; },
    PathfindingCompleted { tick: u64, entity: EntityId, from: WorldPos, to: WorldPos, path_length: u32, compute_time_us: u32 },
    DesyncDetected { tick: u64, expected_hash: u64, actual_hash: u64, player: PlayerId },
    StateSnapshot { tick: u64, state_hash: u64, entity_count: u32 },
}
<span class="boring">}</span></code></pre>
<p>These events are:</p>
<ul>
<li><strong>Emitted as OTEL log records</strong> with structured attributes (not free-text — every field is filterable)</li>
<li><strong>Collected locally</strong> into a SQLite gameplay event log alongside replays (D034) — queryable with ad-hoc SQL without an OTEL stack</li>
<li><strong>Optionally exported</strong> to a collector for batch analysis (tournament servers, AI training pipelines)</li>
</ul>
<h4 id="state-inspection-development--debugging"><a class="header" href="#state-inspection-development--debugging">State Inspection (Development &amp; Debugging)</a></h4>
<p>A debug overlay (via <code>bevy_egui</code>, already in the architecture) that reads live telemetry:</p>
<ul>
<li>Per-system tick time breakdown (bar chart)</li>
<li>Entity count by type</li>
<li>Network: RTT, order latency, jitter</li>
<li>Memory: scratch buffer usage, component storage</li>
<li>Pathfinding: active flowfields, cache hit rate</li>
<li>Fog: cells updated this tick, stagger bucket</li>
<li>Sim state hash (for manual desync comparison)</li>
</ul>
<p>This is the “game engine equivalent of a Kubernetes dashboard” — operators of tournament servers or mod developers can inspect the engine’s internal state in real-time.</p>
<h3 id="ai--llm-training-data-pipeline"><a class="header" href="#ai--llm-training-data-pipeline">AI / LLM Training Data Pipeline</a></h3>
<p>The gameplay event stream is the foundation for AI development:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Consumer</th><th>Data Source</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>ic-ai</code> (skirmish AI)</td><td>Gameplay events from human games</td><td>Learn build orders, engagement timing, micro patterns</td></tr>
<tr><td><code>ic-llm</code> (missions)</td><td>Gameplay events + enriched replays</td><td>Learn what makes missions fun (engagement density, pacing, flow)</td></tr>
<tr><td><code>ic-editor</code> (replay→scenario)</td><td>Replay event log (SQLite)</td><td>Direct extraction of waypoints, combat zones, build timelines into editor</td></tr>
<tr><td><code>ic-llm</code> (replay→scenario)</td><td>Replay event log + context</td><td>Generate narrative, briefings, dialogue for replay-to-scenario pipeline</td></tr>
<tr><td>Behavioral analysis</td><td>Relay-side player profiles</td><td>APM, reaction time, input entropy → suspicion scoring (V12)</td></tr>
<tr><td>Balance analysis</td><td>Aggregated match outcomes</td><td>Win rates by faction/map/preset → balance tuning</td></tr>
<tr><td>Adaptive difficulty</td><td>Per-player gameplay patterns</td><td>Build speed, APM, unit composition → difficulty calibration</td></tr>
<tr><td>Community analytics</td><td>Workshop + match metadata</td><td>Popular resources, play patterns, mod adoption → recommendations</td></tr>
</tbody>
</table>
</div>
<p><strong>Privacy:</strong> Gameplay events are associated with anonymized player IDs (hashed). No PII in telemetry. Players opt in to telemetry export (default: local-only for debugging). Tournament/ranked play may require telemetry for anti-cheat and certified results. See <code>06-SECURITY.md</code>.</p>
<p><strong>Data format:</strong> Gameplay events export as structured OTEL log records → can be collected into Parquet/Arrow columnar format for batch ML training. The LLM training pipeline reads events, not raw replay bytes.</p>
<h3 id="architecture-where-telemetry-lives"><a class="header" href="#architecture-where-telemetry-lives">Architecture: Where Telemetry Lives</a></h3>
<pre><code>                  ┌──────────────────────────────────────────┐
                  │              OTEL Collector               │
                  │  (receives all signals, routes to sinks)  │
                  └──┬──────────┬──────────┬─────────────────┘
                     │          │          │
              ┌──────▼──┐ ┌────▼────┐ ┌───▼─────────────┐
              │Prometheus│ │ Jaeger  │ │ Loki / Storage  │
              │(metrics) │ │(traces) │ │(logs / events)  │
              └──────────┘ └─────────┘ └───────┬─────────┘
                                               │
                                        ┌──────▼──────┐
                                        │ AI Training  │
                                        │ Pipeline     │
                                        │ (Parquet→ML) │
                                        └─────────────┘

  Emitters:
  ┌─────────┐  ┌─────────┐  ┌──────────┐  ┌──────────┐
  │  Relay  │  │Tracking │  │ Workshop │  │  Game    │
  │ Server  │  │ Server  │  │  Server  │  │ Engine   │
  └─────────┘  └─────────┘  └──────────┘  └──────────┘
</code></pre>
<p>No emitter talks directly to Prometheus/Jaeger/Loki — everything goes through the OTEL Collector. This means:</p>
<ul>
<li>Emitters don’t know or care about the backend storage</li>
<li>Self-hosters can route to whatever they want (Grafana Cloud, Datadog, or just stdout)</li>
<li>The collector handles sampling, batching, and export — emitters stay lightweight</li>
</ul>
<h3 id="implementation-approach"><a class="header" href="#implementation-approach">Implementation Approach</a></h3>
<p><strong>Rust ecosystem:</strong></p>
<ul>
<li><code>tracing</code> crate — Bevy already uses this; add structured fields and span instrumentation</li>
<li><code>opentelemetry</code> + <code>opentelemetry-otlp</code> crates — OTEL SDK for Rust</li>
<li><code>tracing-opentelemetry</code> — bridges <code>tracing</code> spans to OTEL traces</li>
<li><code>metrics</code> crate — lightweight counters/histograms, exported via OTEL</li>
</ul>
<p><strong>Zero-cost when disabled:</strong> The <code>telemetry</code> feature flag gates all instrumentation behind <code>#[cfg(feature = "telemetry")]</code>. When disabled (default for release builds), all telemetry calls compile to no-ops. No runtime cost, no allocations, no branches. This respects invariant #5 (efficiency-first performance).</p>
<p><strong>Build configurations:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Build</th><th>Telemetry</th><th>Use case</th></tr>
</thead>
<tbody>
<tr><td><code>release</code></td><td>Off</td><td>Player-facing builds — zero overhead</td></tr>
<tr><td><code>release-telemetry</code></td><td>On</td><td>Tournament servers, AI training, debugging</td></tr>
<tr><td><code>debug</code></td><td>On</td><td>Development — full instrumentation</td></tr>
</tbody>
</table>
</div>
<h3 id="self-hosting-observability"><a class="header" href="#self-hosting-observability">Self-Hosting Observability</a></h3>
<p>Community server operators get observability for free. The docker-compose.yaml (already designed in <code>03-NETCODE.md</code>) can optionally include a Grafana + Prometheus + Loki stack:</p>
<pre><code class="language-yaml"># docker-compose.observability.yaml (optional overlay)
services:
  otel-collector:
    image: otel/opentelemetry-collector:latest
    ports:
      - "4317:4317"    # OTLP gRPC
  prometheus:
    image: prom/prometheus:latest
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"    # dashboards
  loki:
    image: grafana/loki:latest
</code></pre>
<p>Pre-built Grafana dashboards ship with the project:</p>
<ul>
<li><strong>Relay Dashboard:</strong> active games, player RTT, orders/sec, desync events, suspicion scores</li>
<li><strong>Tracking Dashboard:</strong> listings, heartbeats, query rates</li>
<li><strong>Workshop Dashboard:</strong> downloads, publishes, dependency resolution times</li>
<li><strong>Engine Dashboard:</strong> tick times, entity counts, system breakdown, pathfinding stats</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Custom metrics format (less work initially, but no ecosystem — no Grafana, no alerting, no community tooling)</li>
<li>StatsD (simpler but metrics-only — no traces, no structured logs, no distributed correlation)</li>
<li>No telemetry (leaves operators blind and AI training without data)</li>
<li>Always-on telemetry (violates performance invariant — must be zero-cost when disabled)</li>
</ul>
<p><strong>Phase:</strong> Backend server telemetry in Phase 5 (multiplayer). Engine telemetry in Phase 2 (sim) and Phase 3 (chrome/debug overlay). AI training pipeline in Phase 7 (LLM).</p>
<hr>
<h2 id="d032-switchable-ui-themes-main-menu-chrome-lobby"><a class="header" href="#d032-switchable-ui-themes-main-menu-chrome-lobby">D032: Switchable UI Themes (Main Menu, Chrome, Lobby)</a></h2>
<p><strong>Decision:</strong> Ship a YAML-driven UI theme system with multiple built-in presets. Players pick their preferred visual style for the main menu, in-game chrome (sidebar, minimap, build queue), and lobby. Mods and community can create and publish custom themes.</p>
<p><strong>Motivation:</strong></p>
<p>The Remastered Collection nailed its main menu — it respects the original Red Alert’s military aesthetic while modernizing the presentation. OpenRA went a completely different direction: functional, data-driven, but with a generic feel that doesn’t evoke the same nostalgia. Both approaches have merit for different audiences. Rather than pick one style, let the player choose.</p>
<p>This also mirrors D019 (switchable balance presets) and D048 (switchable render modes). Just as players choose between Classic, OpenRA, and Remastered balance rules in the lobby, and toggle between classic and HD graphics with F1, they should be able to choose their UI chrome the same way. All three compose into experience profiles.</p>
<p><strong>Built-in themes (original art, not copied assets):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Theme</th><th>Inspired By</th><th>Aesthetic</th><th>Default For</th></tr>
</thead>
<tbody>
<tr><td>Classic</td><td>Original RA1 (1996)</td><td>Military minimalism — bare buttons over a static title screen, Soviet-era propaganda palette, utilitarian layout, Hell March on startup</td><td>RA1 game module</td></tr>
<tr><td>Remastered</td><td>Remastered Collection (2020)</td><td>Clean modern military — HD polish, sleek panels, reverent to the original but refined, jukebox integration</td><td>—</td></tr>
<tr><td>Modern</td><td>Iron Curtain’s own design</td><td>Full Bevy UI capabilities — dynamic panels, animated transitions, modern game launcher feel</td><td>New game modules</td></tr>
</tbody>
</table>
</div>
<p><strong>Important legal note:</strong> All theme art assets are <strong>original creations</strong> inspired by these design languages — no assets are copied from EA’s Remastered Collection (those are proprietary) or from OpenRA. The themes capture the <em>aesthetic philosophy</em> (palette, layout structure, design mood) but use entirely IC-created sprite sheets, fonts, and layouts. This is standard “inspired by” in game development — layout and color choices are not copyrightable, only specific artistic expression is.</p>
<p><strong>Theme structure (YAML-defined):</strong></p>
<pre><code class="language-yaml"># themes/classic.yaml
theme:
  name: Classic
  description: "Inspired by the original Red Alert — military minimalism"

  # Chrome sprite sheet — 9-slice panels, button states, scrollbars
  chrome:
    sprite_sheet: themes/classic/chrome.png
    panel: { top_left: [0, 0, 8, 8], ... }  # 9-slice regions
    button:
      normal: [0, 32, 118, 9]
      hover: [0, 41, 118, 9]
      pressed: [0, 50, 118, 9]
      disabled: [0, 59, 118, 9]

  # Color palette
  colors:
    primary: "#c62828"       # Soviet red
    secondary: "#1a1a2e"     # Dark navy
    text: "#e0e0e0"
    text_highlight: "#ffd600"
    panel_bg: "#0d0d1a"
    panel_border: "#4a4a5a"

  # Typography
  fonts:
    menu: { family: "military-stencil", size: 14 }
    body: { family: "default", size: 12 }
    hud: { family: "monospace", size: 11 }

  # Main menu layout
  main_menu:
    background: themes/classic/title.png     # static image
    shellmap: null                            # no live battle (faithfully minimal)
    music: THEME_INTRO                       # Hell March intro
    button_layout: vertical_center           # stacked buttons, centered
    show_version: true

  # In-game chrome
  ingame:
    sidebar: right                           # classic RA sidebar position
    minimap: top_right
    build_queue: sidebar_tabs
    resource_bar: top_center

  # Lobby
  lobby:
    style: compact                           # minimal chrome, functional
</code></pre>
<p><strong>Shellmap system (live menu backgrounds):</strong></p>
<p>Like OpenRA’s signature feature — a real game map with scripted AI battles running behind the main menu. But better:</p>
<ul>
<li><strong>Per-theme shellmaps.</strong> Each theme can specify its own shellmap, or none (Classic theme faithfully uses a static image).</li>
<li><strong>Multiple shellmaps with random selection.</strong> The Remastered and Modern themes can ship with several shellmaps — a random one plays each launch.</li>
<li><strong>Shellmaps are regular maps</strong> tagged with <code>visibility: shellmap</code> in YAML. The engine loads them with a scripted AI that stages dramatic battles. Mods automatically get their own shellmaps.</li>
<li><strong>Orbiting/panning camera.</strong> Shellmaps can define camera paths — slow pan across a battlefield, orbiting around a base, or fixed view.</li>
</ul>
<p><strong>Shellmap AI design:</strong> Shellmaps use a dedicated AI profile (<code>shellmap_ai</code> in <code>ic-ai</code>) optimized for visual drama, not competitive play:</p>
<pre><code class="language-yaml"># ai/shellmap.yaml
shellmap_ai:
  personality:
    name: "Shellmap Director"
    aggression: 40               # builds up before attacking
    attack_threshold: 5000       # large armies before engaging
    micro_level: basic
    tech_preference: balanced    # diverse unit mix for visual variety
    dramatic_mode: true          # avoids cheese, prefers spectacle
    max_tick_budget_us: 2000     # 2ms max — shellmap is background
    unit_variety_bonus: 0.5      # AI prefers building different unit types
    no_early_rush: true          # let both sides build up
</code></pre>
<p>The <code>dramatic_mode</code> flag tells the AI to prioritize visually interesting behavior: large mixed-army clashes over efficient rush strategies, diverse unit compositions over optimal builds, and sustained back-and-forth engagements over quick victories. The AI’s tick budget is capped at 2ms to avoid impacting menu UI responsiveness. Shellmap AI is the same <code>ic-ai</code> system used for skirmish — just a different personality profile.</p>
<p><strong>Per-game-module default themes:</strong></p>
<p>Each game module registers its own default theme that matches its aesthetic:</p>
<ul>
<li><strong>RA1 module:</strong> Classic theme (red/black Soviet palette)</li>
<li><strong>TD module:</strong> GDI theme (green/black Nod palette) — community or first-party</li>
<li><strong>RA2 module:</strong> Remastered-style with RA2 color palette — community or first-party</li>
</ul>
<p>The game module provides a <code>default_theme()</code> in its <code>GameModule</code> trait implementation. Players override this in settings.</p>
<p><strong>Integration with existing UI architecture:</strong></p>
<p>The theme system layers on top of <code>ic-ui</code>’s existing responsive layout profiles (D002, <code>02-ARCHITECTURE.md</code>):</p>
<ul>
<li><strong>Layout profiles</strong> handle <em>where</em> UI elements go (sidebar vs bottom bar, phone vs desktop) — driven by <code>ScreenClass</code></li>
<li><strong>Themes</strong> handle <em>how</em> UI elements look (colors, chrome sprites, fonts, animations) — driven by player preference</li>
<li>Orthogonal concerns. A player on mobile gets the Phone layout profile + their chosen theme. A player on desktop gets the Desktop layout profile + their chosen theme.</li>
</ul>
<p><strong>Community themes:</strong></p>
<ul>
<li>Themes are Tier 1 mods (YAML + sprite sheets) — no code required</li>
<li>Publishable to the workshop (D030) as a standalone resource</li>
<li>Players subscribe to themes independently of gameplay mods — themes and gameplay mods stack</li>
<li>An “OpenRA-inspired” theme would be a natural community contribution</li>
<li>Total conversion mod developers create matching themes for their mods</li>
</ul>
<p><strong>What this enables:</strong></p>
<ol>
<li><strong>Day-one nostalgia choice.</strong> First launch asks: do you want Classic, Remastered, or Modern? Sets the mood immediately.</li>
<li><strong>Mod-matched chrome.</strong> A WWII mod ships its own olive-drab theme. A sci-fi mod ships neon blue chrome. The theme changes with the mod.</li>
<li><strong>Cross-view consistency with D019.</strong> Classic balance + Classic theme = feels like 1996. Remastered balance + Remastered theme = feels like 2020. Players configure the full experience.</li>
<li><strong>Live backgrounds without code.</strong> Shellmaps are regular maps — anyone can create one with the map editor.</li>
</ol>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Hardcoded single theme (OpenRA approach) — forces one aesthetic on everyone; misses the emotional connection different players have to different eras of C&amp;C</li>
<li>Copy Remastered Collection assets — illegal; proprietary EA art</li>
<li>CSS-style theming (web-engine approach) — overengineered for a game; YAML is simpler and Bevy-native</li>
<li>Theme as a full WASM mod — overkill; theming is data, not behavior; Tier 1 YAML is sufficient</li>
</ul>
<p><strong>Phase:</strong> Phase 3 (Game Chrome). Theme system is part of the <code>ic-ui</code> crate. Built-in themes ship with the engine. Community themes available in Phase 6a (Workshop).</p>
<hr>
<h2 id="d033-toggleable-qol--gameplay-behavior-presets"><a class="header" href="#d033-toggleable-qol--gameplay-behavior-presets">D033: Toggleable QoL &amp; Gameplay Behavior Presets</a></h2>
<p><strong>Decision:</strong> Every UX and gameplay behavior improvement added by OpenRA or the Remastered Collection over vanilla Red Alert is individually toggleable. Built-in presets group these toggles into coherent experience profiles. Players can pick a preset and then customize any individual toggle. In multiplayer lobbies, sim-affecting toggles are shared settings; client-only toggles are per-player.</p>
<p><strong>The problem this solves:</strong></p>
<p>OpenRA and the Remastered Collection each introduced dozens of quality-of-life improvements over the original 1996 Red Alert. Many are genuinely excellent (attack-move, waypoint queuing, multi-queue production). But some players want the authentic vanilla experience. Others want the full OpenRA feature set. Others want the Remastered Collection’s specific subset. And some want to cherry-pick: “Give me OpenRA’s attack-move but not its build radius circles.”</p>
<p>Currently, no Red Alert implementation lets you do this. OpenRA’s QoL features are hardcoded. The Remastered Collection’s are hardcoded. Vanilla’s limitations are hardcoded. Every version forces you into one developer’s opinion of what the game “should” feel like.</p>
<p><strong>Our approach:</strong> Every QoL feature is a YAML-configurable toggle. Presets set all toggles at once. Individual toggles override the preset. The player owns their experience.</p>
<h3 id="qol-feature-catalog"><a class="header" href="#qol-feature-catalog">QoL Feature Catalog</a></h3>
<p>Every toggle is categorized as <strong>sim-affecting</strong> (changes game logic — must be identical for all players in multiplayer) or <strong>client-only</strong> (visual/UX — each player can set independently).</p>
<h4 id="production--economy-sim-affecting"><a class="header" href="#production--economy-sim-affecting">Production &amp; Economy (Sim-Affecting)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Toggle</th><th>Vanilla</th><th>OpenRA</th><th>Remastered</th><th>IC Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>multi_queue</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Queue multiple units of the same type</td></tr>
<tr><td><code>parallel_factories</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Multiple factories of same type produce simultaneously</td></tr>
<tr><td><code>build_radius_rule</code></td><td>None</td><td>ConYard+buildings</td><td>ConYard only</td><td>ConYard+buildings</td><td>Where you can place new buildings</td></tr>
<tr><td><code>sell_buildings</code></td><td>Partial</td><td>✅ Full</td><td>✅ Full</td><td>✅ Full</td><td>Sell any own building for partial refund</td></tr>
<tr><td><code>repair_buildings</code></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>Repair buildings for credits</td></tr>
</tbody>
</table>
</div>
<h4 id="unit-commands-sim-affecting"><a class="header" href="#unit-commands-sim-affecting">Unit Commands (Sim-Affecting)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Toggle</th><th>Vanilla</th><th>OpenRA</th><th>Remastered</th><th>IC Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>attack_move</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Move to location, engaging enemies en route</td></tr>
<tr><td><code>waypoint_queue</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Shift-click to queue movement waypoints</td></tr>
<tr><td><code>guard_command</code></td><td>❌</td><td>✅</td><td>❌</td><td>✅</td><td>Guard a unit or position, engage nearby threats</td></tr>
<tr><td><code>scatter_command</code></td><td>❌</td><td>✅</td><td>❌</td><td>✅</td><td>Units scatter from current position</td></tr>
<tr><td><code>force_fire_ground</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Force-fire on empty ground (area denial)</td></tr>
<tr><td><code>force_move</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Force move through crushable targets</td></tr>
<tr><td><code>rally_points</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Set rally point for production buildings</td></tr>
<tr><td><code>stance_system</code></td><td>None</td><td>Full</td><td>Basic</td><td>Full</td><td>Unit stance: aggressive / defensive / hold / return fire</td></tr>
</tbody>
</table>
</div>
<h4 id="ui--visual-feedback-client-only"><a class="header" href="#ui--visual-feedback-client-only">UI &amp; Visual Feedback (Client-Only)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Toggle</th><th>Vanilla</th><th>OpenRA</th><th>Remastered</th><th>IC Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>health_bars</code></td><td><code>never</code></td><td><code>always</code></td><td><code>on_selection</code></td><td><code>on_selection</code></td><td>Unit health bar visibility: <code>never</code> / <code>on_selection</code> / <code>always</code> / <code>damaged_or_selected</code></td></tr>
<tr><td><code>range_circles</code></td><td>❌</td><td>✅</td><td>❌</td><td>✅</td><td>Show weapon range circle when selecting defense buildings</td></tr>
<tr><td><code>build_radius_display</code></td><td>❌</td><td>✅</td><td>❌</td><td>✅</td><td>Show buildable area around construction yard / buildings</td></tr>
<tr><td><code>power_indicators</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Visual indicator on buildings affected by low power</td></tr>
<tr><td><code>support_power_timer</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Countdown timer bar for superweapons</td></tr>
<tr><td><code>production_progress</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Progress bar on sidebar build icons</td></tr>
<tr><td><code>target_lines</code></td><td>❌</td><td>✅</td><td>❌</td><td>✅</td><td>Lines showing order targets (move, attack)</td></tr>
<tr><td><code>rally_point_display</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Visual line from factory to rally point</td></tr>
</tbody>
</table>
</div>
<h4 id="selection--input-client-only"><a class="header" href="#selection--input-client-only">Selection &amp; Input (Client-Only)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Toggle</th><th>Vanilla</th><th>OpenRA</th><th>Remastered</th><th>IC Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>double_click_select_type</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Double-click a unit to select all of that type on screen</td></tr>
<tr><td><code>ctrl_click_select_type</code></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>Ctrl+click to add all of type to selection</td></tr>
<tr><td><code>tab_cycle_types</code></td><td>❌</td><td>✅</td><td>❌</td><td>✅</td><td>Tab through unit types in multi-type selection</td></tr>
<tr><td><code>control_group_limit</code></td><td>10</td><td>Unlimited</td><td>Unlimited</td><td>Unlimited</td><td>Max units per control group (0 = unlimited)</td></tr>
<tr><td><code>smart_select_priority</code></td><td>❌</td><td>✅</td><td>❌</td><td>✅</td><td>Prefer combat units over harvesters in box select</td></tr>
</tbody>
</table>
</div>
<h4 id="gameplay-rules-sim-affecting-lobby-setting"><a class="header" href="#gameplay-rules-sim-affecting-lobby-setting">Gameplay Rules (Sim-Affecting, Lobby Setting)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Toggle</th><th>Vanilla</th><th>OpenRA</th><th>Remastered</th><th>IC Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>fog_of_war</code></td><td>❌</td><td>Optional</td><td>❌</td><td>Optional</td><td>Fog of war (explored but not visible = greyed out)</td></tr>
<tr><td><code>shroud_regrow</code></td><td>❌</td><td>Optional</td><td>❌</td><td>❌</td><td>Explored shroud grows back after units leave</td></tr>
<tr><td><code>short_game</code></td><td>❌</td><td>Optional</td><td>❌</td><td>Optional</td><td>Destroying all production buildings = defeat</td></tr>
<tr><td><code>crate_system</code></td><td>Basic</td><td>Enhanced</td><td>Basic</td><td>Enhanced</td><td>Bonus crates type and behavior</td></tr>
<tr><td><code>ore_regrowth</code></td><td>✅</td><td>✅ Configurable</td><td>✅</td><td>✅ Configurable</td><td>Ore regeneration rate</td></tr>
</tbody>
</table>
</div>
<h3 id="experience-presets"><a class="header" href="#experience-presets">Experience Presets</a></h3>
<p>Presets set all toggles at once. The player selects a preset, then overrides individual toggles if they want.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Preset</th><th>Balance (D019)</th><th>Theme (D032)</th><th>QoL (D033)</th><th>Feel</th></tr>
</thead>
<tbody>
<tr><td><strong>Vanilla RA</strong></td><td><code>classic</code></td><td><code>classic</code></td><td><code>vanilla</code></td><td>Authentic 1996 experience — warts and all</td></tr>
<tr><td><strong>OpenRA</strong></td><td><code>openra</code></td><td><code>modern</code></td><td><code>openra</code></td><td>Full OpenRA experience</td></tr>
<tr><td><strong>Remastered</strong></td><td><code>remastered</code></td><td><code>remastered</code></td><td><code>remastered</code></td><td>Remastered Collection feel</td></tr>
<tr><td><strong>Iron Curtain</strong> (default)</td><td><code>classic</code></td><td><code>modern</code></td><td><code>iron_curtain</code></td><td>Classic balance + best QoL from all eras</td></tr>
<tr><td><strong>Custom</strong></td><td>any</td><td>any</td><td>any</td><td>Player picks everything</td></tr>
</tbody>
</table>
</div>
<p>The “Iron Curtain” default cherry-picks: classic balance (units feel iconic), modern theme (polished UI), and the best QoL features from both OpenRA and Remastered (attack-move, multi-queue, health bars, range circles — everything that makes the game more playable without changing game feel).</p>
<h3 id="yaml-structure"><a class="header" href="#yaml-structure">YAML Structure</a></h3>
<pre><code class="language-yaml"># presets/qol/iron_curtain.yaml
qol:
  name: "Iron Curtain"
  description: "Best quality-of-life features from all eras"
  
  production:
    multi_queue: true
    parallel_factories: true
    build_radius_rule: conyard_and_buildings
    sell_buildings: full
    repair_buildings: true
  
  commands:
    attack_move: true
    waypoint_queue: true
    guard_command: true
    scatter_command: true
    force_fire_ground: true
    force_move: true
    rally_points: true
    stance_system: full    # none | basic | full
  
  ui_feedback:
    health_bars: on_selection  # never | on_selection | always | damaged_or_selected
    range_circles: true
    build_radius_display: true
    power_indicators: true
    support_power_timer: true
    production_progress: true
    target_lines: true
    rally_point_display: true
  
  selection:
    double_click_select_type: true
    ctrl_click_select_type: true
    tab_cycle_types: true
    control_group_limit: 0    # 0 = unlimited
    smart_select_priority: true
  
  gameplay:
    fog_of_war: optional      # on | off | optional (lobby choice)
    shroud_regrow: false
    short_game: optional
    crate_system: enhanced    # none | basic | enhanced
    ore_regrowth: true
</code></pre>
<pre><code class="language-yaml"># presets/qol/vanilla.yaml
qol:
  name: "Vanilla Red Alert"
  description: "Authentic 1996 experience"
  
  production:
    multi_queue: false
    parallel_factories: false
    build_radius_rule: none
    sell_buildings: partial
    repair_buildings: true
  
  commands:
    attack_move: false
    waypoint_queue: false
    guard_command: false
    scatter_command: false
    force_fire_ground: false
    force_move: false
    rally_points: false
    stance_system: none
  
  ui_feedback:
    health_bars: never
    range_circles: false
    build_radius_display: false
    power_indicators: false
    support_power_timer: false
    production_progress: false
    target_lines: false
    rally_point_display: false
  
  selection:
    double_click_select_type: false
    ctrl_click_select_type: false
    tab_cycle_types: false
    control_group_limit: 10
    smart_select_priority: false
  
  gameplay:
    fog_of_war: off
    shroud_regrow: false
    short_game: off
    crate_system: basic
    ore_regrowth: true
</code></pre>
<h3 id="sim-vs-client-split"><a class="header" href="#sim-vs-client-split">Sim vs Client Split</a></h3>
<p>Critical for multiplayer: some toggles change game rules, others are purely cosmetic.</p>
<p><strong>Sim-affecting toggles</strong> (lobby settings — all players must agree):</p>
<ul>
<li>Everything in <code>production</code>, <code>commands</code>, and <code>gameplay</code> sections</li>
<li>These are validated deterministically by the sim (invariant #1)</li>
<li>Multiplayer lobby: host sets the QoL preset; displayed to all players before match start</li>
<li>Mismatch = connection refused (enforced by sim hash, same as balance presets)</li>
</ul>
<p><strong>Client-only toggles</strong> (per-player preferences — each player sets their own):</p>
<ul>
<li>Everything in <code>ui_feedback</code> and <code>selection</code> sections</li>
<li>One player can play with always-visible health bars while their opponent plays with none</li>
<li>Stored in player settings, not in the lobby configuration</li>
<li>No sim impact — purely visual/UX</li>
</ul>
<h3 id="interaction-with-other-systems"><a class="header" href="#interaction-with-other-systems">Interaction with Other Systems</a></h3>
<p><strong>D019 (Balance Presets):</strong> QoL presets and balance presets are independent axes. You can play with <code>classic</code> balance + <code>openra</code> QoL, or <code>openra</code> balance + <code>vanilla</code> QoL. The lobby UI shows both selections.</p>
<p><strong>D032 (UI Themes):</strong> QoL and themes are also independent. The “Classic” theme changes chrome appearance; the “Vanilla” QoL preset changes gameplay behavior. They’re separate settings that happen to compose well.</p>
<p><strong>Experience Profiles:</strong> The meta-layer above all of these. Selecting “Vanilla RA” experience profile sets D019=classic, D032=classic, D033=vanilla, D043=classic-ra, D045=classic-ra, D048=classic in one click. Selecting “Iron Curtain” sets D019=classic, D032=modern, D033=iron_curtain, D043=ic-default, D045=ic-default, D048=hd. After selecting a profile, any individual setting can still be overridden.</p>
<p><strong>Modding (Tier 1):</strong> QoL presets are just YAML files in <code>presets/qol/</code>. Modders can create custom QoL presets — a total conversion mod ships its own preset tuned for its gameplay. The <code>mod.yaml</code> manifest can specify a default QoL preset.</p>
<h3 id="rationale"><a class="header" href="#rationale">Rationale</a></h3>
<ul>
<li><strong>Respect for all eras.</strong> Each version of Red Alert — original, OpenRA, Remastered — has a community that loves it. Forcing one set of behaviors on everyone loses part of the audience.</li>
<li><strong>Player agency.</strong> “Good defaults with full customization” is the guiding principle. The IC default enables the best QoL features; purists can turn them off; power users can cherry-pick.</li>
<li><strong>Zero engine complexity.</strong> QoL toggles are just config flags read by systems that already exist. Attack-move is either registered as a command or not. Health bars are either rendered or not. No complex runtime switching — the config is read once at game start.</li>
<li><strong>Multiplayer safety.</strong> The sim/client split ensures determinism. Sim-affecting toggles are lobby settings (like game speed or starting cash). Client-only toggles are personal preferences (like enabling subtitles in any other game).</li>
<li><strong>Natural extension of D019 + D032.</strong> Balance, theme, and behavior are three independent axes of experience customization. Together they let a player fully configure what “Red Alert” feels like to them.</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Hardcode one set of behaviors (rejected — this is what every other implementation does; we can do better)</li>
<li>Make QoL features mod-only (rejected — too important to bury behind modding; should be one click in settings, same as D019)</li>
<li>Only offer presets without individual toggles (rejected — power users need granular control; presets are starting points, not cages)</li>
<li>Bundle QoL into balance presets (rejected — “I want OpenRA’s attack-move but classic unit values” is a legitimate preference; conflating balance with UX is a design mistake)</li>
</ul>
<p><strong>Phase:</strong> Phase 3 (alongside D032 UI themes and sidebar work). QoL toggles are implemented as system-level config flags — each system checks its toggle on initialization. Preset YAML files are authored during Phase 2 (simulation) as features are built.</p>
<hr>
<hr>
<h2 id="d034-sqlite-as-embedded-storage-for-services-and-client"><a class="header" href="#d034-sqlite-as-embedded-storage-for-services-and-client">D034: SQLite as Embedded Storage for Services and Client</a></h2>
<p><strong>Decision:</strong> Use SQLite (via <code>rusqlite</code>) as the embedded database for all backend services that need persistent state and for the game client’s local metadata indices. No external database dependency required for any deployment.</p>
<p><strong>What this means:</strong> Every service that persists data beyond a single process lifetime uses an embedded SQLite database file. The “just a binary” philosophy (see <code>03-NETCODE.md</code> § Backend Infrastructure) is preserved — an operator downloads a binary, runs it, and persistence is a <code>.db</code> file next to the executable. No PostgreSQL, no MySQL, no managed database service.</p>
<p><strong>Where SQLite is used:</strong></p>
<h3 id="backend-services"><a class="header" href="#backend-services">Backend Services</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Service</th><th>What it stores</th><th>Why not in-memory</th></tr>
</thead>
<tbody>
<tr><td><strong>Relay server</strong></td><td><code>CertifiedMatchResult</code> records, <code>DesyncReport</code> events, <code>PlayerBehaviorProfile</code> history, replay archive metadata</td><td>Match results and behavioral data are valuable beyond the game session — operators need to query desync patterns, review suspicion scores, link replays to match records. A relay restart shouldn’t erase match history.</td></tr>
<tr><td><strong>Workshop server</strong></td><td>Resource metadata, versions, dependencies, download counts, ratings, search index (FTS5), license data, replication cursors</td><td>This is a package registry — functionally equivalent to crates.io’s data layer. Search, dependency resolution, and version queries are relational workloads.</td></tr>
<tr><td><strong>Matchmaking server</strong></td><td>Player ratings (Glicko-2), match history, seasonal league data, leaderboards</td><td>Ratings and match history must survive restarts. Leaderboard queries (<code>top N</code>, per-faction, per-map) are natural SQL.</td></tr>
<tr><td><strong>Tournament server</strong></td><td>Brackets, match results, map pool votes, community reports</td><td>Tournament state spans hours/days; must survive restarts. Bracket queries and result reporting are relational.</td></tr>
</tbody>
</table>
</div>
<h3 id="game-client-local"><a class="header" href="#game-client-local">Game Client (local)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Data</th><th>What it stores</th><th>Benefit</th></tr>
</thead>
<tbody>
<tr><td><strong>Replay catalog</strong></td><td>Player names, map, factions, date, duration, result, file path, signature status</td><td>Browse and search local replays without scanning files on disk. Filter by map, opponent, date range.</td></tr>
<tr><td><strong>Save game index</strong></td><td>Save name, campaign, mission, timestamp, playtime, thumbnail path</td><td>Fast save browser without deserializing every save file on launch.</td></tr>
<tr><td><strong>Workshop cache</strong></td><td>Downloaded resource metadata, versions, checksums, dependency graph</td><td>Offline dependency resolution. Know what’s installed without scanning the filesystem.</td></tr>
<tr><td><strong>Map catalog</strong></td><td>Map name, player count, size, author, source (local/workshop/OpenRA), tags</td><td>Browse local maps from all sources with a single query.</td></tr>
<tr><td><strong>Gameplay event log</strong></td><td>Structured <code>GameplayEvent</code> records (D031) per game session</td><td>Queryable post-game analysis without an OTEL stack: <code>SELECT json_extract(data_json, '$.weapon'), AVG(json_extract(data_json, '$.damage')) FROM gameplay_events WHERE event_type = 'combat' AND session_id = ?</code>. Mod developers debug balance with SQL, not Grafana.</td></tr>
<tr><td><strong>Asset index</strong></td><td><code>.mix</code> archive contents, MiniYAML conversion cache (keyed by file hash)</td><td>Skip re-parsing on startup. Know which <code>.mix</code> contains which file without opening every archive.</td></tr>
</tbody>
</table>
</div>
<h3 id="where-sqlite-is-not-used"><a class="header" href="#where-sqlite-is-not-used">Where SQLite is NOT used</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Area</th><th>Why not</th></tr>
</thead>
<tbody>
<tr><td><strong><code>ic-sim</code></strong></td><td>No I/O in the sim. Ever. Invariant #1.</td></tr>
<tr><td><strong>Tracking server</strong></td><td>Truly ephemeral data — game listings with TTL. In-memory is correct.</td></tr>
<tr><td><strong>Hot paths</strong></td><td>No DB queries per tick. All SQLite access is at load time, between games, or on UI/background threads.</td></tr>
<tr><td><strong>Save game data</strong></td><td>Save files are serde-serialized sim snapshots loaded as a whole unit. No partial queries needed. SQLite indexes their <em>metadata</em>, not their <em>content</em>.</td></tr>
<tr><td><strong>Campaign state</strong></td><td>Loaded/saved as a unit inside save games. Fits in memory. No relational queries.</td></tr>
</tbody>
</table>
</div>
<h3 id="why-sqlite-specifically"><a class="header" href="#why-sqlite-specifically">Why SQLite specifically</a></h3>
<ul>
<li><strong><code>rusqlite</code></strong> is a mature, well-maintained Rust crate with no unsafe surprises</li>
<li><strong>Single-file database</strong> — fits the “just a binary” deployment model. No connection strings, no separate database process, no credentials to manage</li>
<li><strong>Self-hosting alignment</strong> — a community relay operator on a €5 VPS gets persistent match history without installing or operating a database server</li>
<li><strong>FTS5 full-text search</strong> — covers workshop resource search and replay text search without Elasticsearch or a separate search service</li>
<li><strong>WAL mode</strong> — handles concurrent reads from web endpoints while a single writer persists new records. Sufficient for community-scale deployments (hundreds of concurrent users, not millions)</li>
<li><strong>WASM-compatible</strong> — <code>sql.js</code> (Emscripten build of SQLite) or <code>sqlite-wasm</code> for the browser target. The client-side replay catalog and gameplay event log work in the browser build.</li>
<li><strong>Ad-hoc investigation</strong> — any operator can open the <code>.db</code> file in DB Browser for SQLite, DBeaver, or the <code>sqlite3</code> CLI and run queries immediately. No Grafana dashboards required. This fills the gap between “just stdout logs” and “full OTEL stack” for community self-hosters.</li>
</ul>
<h3 id="relationship-to-d031-otel-telemetry"><a class="header" href="#relationship-to-d031-otel-telemetry">Relationship to D031 (OTEL Telemetry)</a></h3>
<p>D031 (OTEL) and D034 (SQLite) are complementary, not competing:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>D031 (OTEL)</th><th>D034 (SQLite)</th></tr>
</thead>
<tbody>
<tr><td><strong>Real-time monitoring</strong></td><td>Yes — Prometheus metrics, Grafana dashboards</td><td>No</td></tr>
<tr><td><strong>Distributed tracing</strong></td><td>Yes — Jaeger traces across clients and relay</td><td>No</td></tr>
<tr><td><strong>Persistent records</strong></td><td>No — metrics are time-windowed, logs rotate</td><td>Yes — match history, ratings, replays are permanent</td></tr>
<tr><td><strong>Ad-hoc investigation</strong></td><td>Requires OTEL stack running</td><td>Just open the <code>.db</code> file</td></tr>
<tr><td><strong>Offline operation</strong></td><td>No — needs collector + backends</td><td>Yes — works standalone</td></tr>
<tr><td><strong>Client-side debugging</strong></td><td>Requires exporting to a collector</td><td>Local <code>.db</code> file, queryable immediately</td></tr>
<tr><td><strong>AI training pipeline</strong></td><td>Yes — Parquet/Arrow export for ML</td><td>Source data — gameplay events could be exported from SQLite to Parquet</td></tr>
</tbody>
</table>
</div>
<p>OTEL is for operational monitoring and distributed debugging. SQLite is for persistent records, metadata indices, and standalone investigation. Tournament servers and relay servers use both — OTEL for dashboards, SQLite for match history.</p>
<h3 id="consumers-of-player-data"><a class="header" href="#consumers-of-player-data">Consumers of Player Data</a></h3>
<p>SQLite isn’t just infrastructure — it’s a UX pillar. Multiple crates read the client-side database to deliver features no other RTS offers:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Consumer</th><th>Crate</th><th>What it reads</th><th>What it produces</th><th>Required?</th></tr>
</thead>
<tbody>
<tr><td><strong>Player-facing analytics</strong></td><td><code>ic-ui</code></td><td><code>gameplay_events</code>, <code>matches</code>, <code>match_players</code>, <code>campaign_missions</code>, <code>roster_snapshots</code></td><td>Post-game stats screen, career stats page, campaign dashboard with roster/veterancy graphs, mod balance dashboard</td><td>Always on</td></tr>
<tr><td><strong>Adaptive AI</strong></td><td><code>ic-ai</code></td><td><code>matches</code>, <code>match_players</code>, <code>gameplay_events</code></td><td>Difficulty adjustment, build order variety, counter-strategy selection based on player tendencies</td><td>Always on</td></tr>
<tr><td><strong>LLM personalization</strong></td><td><code>ic-llm</code></td><td><code>matches</code>, <code>gameplay_events</code>, <code>campaign_missions</code>, <code>roster_snapshots</code></td><td>Personalized missions, adaptive briefings, post-match commentary, coaching suggestions, rivalry narratives</td><td><strong>Optional</strong> — requires BYOLLM provider configured (D016)</td></tr>
<tr><td><strong>Player style profiles</strong> (D042)</td><td><code>ic-ai</code></td><td><code>gameplay_events</code>, <code>match_players</code>, <code>matches</code></td><td><code>player_profiles</code> table — aggregated behavioral models for local player + opponents</td><td>Always on (profile building)</td></tr>
<tr><td><strong>Training system</strong> (D042)</td><td><code>ic-ai</code> + <code>ic-ui</code></td><td><code>player_profiles</code>, <code>training_sessions</code>, <code>gameplay_events</code></td><td>Quick training scenarios, weakness analysis, progress tracking</td><td>Always on (training UI)</td></tr>
</tbody>
</table>
</div>
<p>Player analytics, adaptive AI, player style profiles, and the training system are always available. LLM personalization and coaching activate only when the player has configured an LLM provider — the game is fully functional without it.</p>
<p>All consumers are read-only. The sim writes nothing (invariant #1) — <code>gameplay_events</code> are recorded by a Bevy observer system outside <code>ic-sim</code>, and <code>matches</code>/<code>campaign_missions</code> are written at session boundaries.</p>
<h3 id="player-facing-analytics-ic-ui"><a class="header" href="#player-facing-analytics-ic-ui">Player-Facing Analytics (<code>ic-ui</code>)</a></h3>
<p>No other RTS surfaces your own match data this way. SQLite makes it trivial — queries run on a background thread, results drive a lightweight chart component in <code>ic-ui</code> (Bevy 2D: line, bar, pie, heatmap, stacked area).</p>
<p><strong>Post-game stats screen</strong> (after every match):</p>
<ul>
<li>Unit production timeline (stacked area: units built per minute by type)</li>
<li>Resource income/expenditure curves</li>
<li>Combat engagement heatmap (where fights happened on the map)</li>
<li>APM over time, army value graph, tech tree timing</li>
<li>Head-to-head comparison table vs opponent</li>
<li>All data: <code>SELECT ... FROM gameplay_events WHERE session_id = ?</code></li>
</ul>
<p><strong>Career stats page</strong> (main menu):</p>
<ul>
<li>Win rate by faction, map, opponent, game mode — over time and lifetime</li>
<li>Rating history graph (Glicko-2 from matchmaking, synced to local DB)</li>
<li>Most-used units, highest kill-count units, signature strategies</li>
<li>Session history: date, map, opponent, result, duration — clickable → replay</li>
<li>All data: <code>SELECT ... FROM matches JOIN match_players ...</code></li>
</ul>
<p><strong>Campaign dashboard</strong> (D021 integration):</p>
<ul>
<li>Roster composition graph per mission (how your army evolves across the campaign)</li>
<li>Veterancy progression: track named units across missions (the tank that survived from mission 1)</li>
<li>Campaign path visualization: which branches you took, which missions you replayed</li>
<li>Performance trends: completion time, casualties, resource efficiency per mission</li>
<li>All data: <code>SELECT ... FROM campaign_missions JOIN roster_snapshots ...</code></li>
</ul>
<p><strong>Mod balance dashboard</strong> (Phase 7, for mod developers):</p>
<ul>
<li>Unit win-rate contribution, cost-efficiency scatter plots, engagement outcome distributions</li>
<li>Compare across balance presets (D019) or mod versions</li>
<li><code>ic mod stats</code> CLI command reads the same SQLite database</li>
<li>All data: <code>SELECT ... FROM gameplay_events WHERE mod_id = ?</code></li>
</ul>
<h3 id="llm-personalization-ic-llm--optional-byollm"><a class="header" href="#llm-personalization-ic-llm--optional-byollm">LLM Personalization (<code>ic-llm</code>) — Optional, BYOLLM</a></h3>
<p>When a player has configured an LLM provider (see BYOLLM in D016), <code>ic-llm</code> reads the local SQLite database (read-only) and injects player context into generation prompts. This is entirely optional — every game feature works without it. No data leaves the device unless the user’s chosen LLM provider is cloud-based.</p>
<p><strong>Personalized mission generation:</strong></p>
<ul>
<li>“You’ve been playing Soviet heavy armor for 12 games. Here’s a mission that forces infantry-first tactics.”</li>
<li>“Your win rate drops against Allied naval. This coastal defense mission trains that weakness.”</li>
<li>Prompt includes: faction preferences, unit usage patterns, win/loss streaks, map size preferences — all from SQLite aggregates.</li>
</ul>
<p><strong>Adaptive briefings:</strong></p>
<ul>
<li>Campaign briefings reference your actual roster: “Commander, your veteran Tesla Tank squad from Vladivostok is available for this operation.”</li>
<li>Difficulty framing adapts to performance: struggling player gets “intel reports suggest light resistance”; dominant player gets “expect fierce opposition.”</li>
<li>Queries <code>roster_snapshots</code> and <code>campaign_missions</code> tables.</li>
</ul>
<p><strong>Post-match commentary:</strong></p>
<ul>
<li>LLM generates a narrative summary of the match from <code>gameplay_events</code>: “The turning point was at 8:42 when your MiG strike destroyed the Allied War Factory, halting tank production for 3 minutes.”</li>
<li>Highlights unusual events: first-ever use of a unit type, personal records, close calls.</li>
<li>Optional — disabled by default, requires LLM provider configured.</li>
</ul>
<p><strong>Coaching suggestions:</strong></p>
<ul>
<li>“You built 40 Rifle Infantry across 5 games but they had a 12% survival rate. Consider mixing in APCs for transport.”</li>
<li>“Your average expansion timing is 6:30. Top players expand at 4:00-5:00.”</li>
<li>Queries aggregate statistics from <code>gameplay_events</code> across multiple sessions.</li>
</ul>
<p><strong>Rivalry narratives:</strong></p>
<ul>
<li>Track frequent opponents from <code>matches</code> table: “You’re 3-7 against PlayerX. They favor Allied air rushes — here’s a counter-strategy mission.”</li>
<li>Generate rivalry-themed campaign missions featuring opponent tendencies.</li>
</ul>
<h3 id="adaptive-ai-ic-ai"><a class="header" href="#adaptive-ai-ic-ai">Adaptive AI (<code>ic-ai</code>)</a></h3>
<p><code>ic-ai</code> reads the player’s match history to calibrate skirmish and campaign AI behavior. No learning during the match — all adaptation happens between games by querying SQLite.</p>
<ul>
<li><strong>Difficulty scaling:</strong> AI selects from difficulty presets based on player win rate over recent N games. Avoids both stomps and frustration.</li>
<li><strong>Build order variety:</strong> AI avoids repeating the same strategy the player has already beaten. Queries <code>gameplay_events</code> for AI build patterns the player countered successfully.</li>
<li><strong>Counter-strategy selection:</strong> If the player’s last 5 games show heavy tank play, AI is more likely to choose anti-armor compositions.</li>
<li><strong>Campaign-specific:</strong> In branching campaigns (D021), AI reads the player’s roster strength from <code>roster_snapshots</code> and adjusts reinforcement timing accordingly.</li>
</ul>
<p>This is designer-authored adaptation (the AI author sets the rules for how history influences behavior), not machine learning. The SQLite queries are simple aggregates run at mission load time.</p>
<p><strong>Fallback:</strong> When no match history is available (first launch, empty database, WASM/headless builds without SQLite), <code>ic-ai</code> falls back to default difficulty presets and random strategy selection. All SQLite reads are behind an <code>Option&lt;impl AiHistorySource&gt;</code> — the AI is fully functional without it, just not personalized.</p>
<h3 id="client-side-schema-key-tables"><a class="header" href="#client-side-schema-key-tables">Client-Side Schema (Key Tables)</a></h3>
<pre><code class="language-sql">-- Match history (synced from matchmaking server when online, always written locally)
CREATE TABLE matches (
    id              INTEGER PRIMARY KEY,
    session_id      TEXT NOT NULL UNIQUE,
    map_name        TEXT NOT NULL,
    game_mode       TEXT NOT NULL,
    balance_preset  TEXT NOT NULL,
    mod_id          TEXT,
    duration_ticks  INTEGER NOT NULL,
    started_at      TEXT NOT NULL,
    replay_path     TEXT,
    replay_hash     BLOB
);

CREATE TABLE match_players (
    match_id    INTEGER REFERENCES matches(id),
    player_name TEXT NOT NULL,
    faction     TEXT NOT NULL,
    team        INTEGER,
    result      TEXT NOT NULL,  -- 'victory', 'defeat', 'disconnect', 'draw'
    is_local    INTEGER NOT NULL DEFAULT 0,
    PRIMARY KEY (match_id, player_name)
);

-- Gameplay events (D031 structured events, written per session)
CREATE TABLE gameplay_events (
    id          INTEGER PRIMARY KEY,
    session_id  TEXT NOT NULL,
    tick        INTEGER NOT NULL,
    event_type  TEXT NOT NULL,   -- 'unit_built', 'unit_killed', 'building_placed', ...
    player      TEXT,
    data_json   TEXT NOT NULL    -- event-specific payload
);

-- Campaign state (D021 branching campaigns)
CREATE TABLE campaign_missions (
    id              INTEGER PRIMARY KEY,
    campaign_id     TEXT NOT NULL,
    mission_id      TEXT NOT NULL,
    outcome         TEXT NOT NULL,
    duration_ticks  INTEGER NOT NULL,
    completed_at    TEXT NOT NULL,
    casualties      INTEGER,
    resources_spent INTEGER
);

CREATE TABLE roster_snapshots (
    id          INTEGER PRIMARY KEY,
    mission_id  INTEGER REFERENCES campaign_missions(id),
    snapshot_at TEXT NOT NULL,   -- 'mission_start' or 'mission_end'
    roster_json TEXT NOT NULL    -- serialized unit list with veterancy, equipment
);

-- FTS5 for replay and map search (contentless — populated via triggers on matches + match_players)
CREATE VIRTUAL TABLE replay_search USING fts5(
    player_names, map_name, factions, content=''
);
-- Triggers on INSERT into matches/match_players aggregate player_names and factions
-- into the FTS index. Contentless means FTS stores its own copy — no content= source mismatch.
</code></pre>
<h3 id="schema-migration"><a class="header" href="#schema-migration">Schema Migration</a></h3>
<p>Each service manages its own schema using embedded SQL migrations (numbered, applied on startup). The <code>rusqlite</code> <code>user_version</code> pragma tracks the current schema version. Forward-only migrations — the binary upgrades the database file automatically on first launch after an update.</p>
<h3 id="scaling-path"><a class="header" href="#scaling-path">Scaling Path</a></h3>
<p>SQLite is the default and the right choice for 95% of deployments. For the official infrastructure at high scale, individual services can optionally be configured to use PostgreSQL by swapping the storage backend trait implementation. The schema is designed to be portable (standard SQL, no SQLite-specific syntax). FTS5 is used for full-text search on Workshop and replay catalogs — a PostgreSQL backend would substitute <code>tsvector</code>/<code>tsquery</code> for the same queries. This is a future optimization, not a launch requirement.</p>
<p>Each service defines its own storage trait — no god-trait mixing unrelated concerns:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Relay server storage — match results, desync reports, behavioral profiles.
pub trait RelayStorage: Send + Sync {
    fn store_match_result(&amp;self, result: &amp;CertifiedMatchResult) -&gt; Result&lt;()&gt;;
    fn query_matches(&amp;self, filter: &amp;MatchFilter) -&gt; Result&lt;Vec&lt;MatchRecord&gt;&gt;;
    fn store_desync_report(&amp;self, report: &amp;DesyncReport) -&gt; Result&lt;()&gt;;
    fn update_behavior_profile(&amp;self, player: PlayerId, profile: &amp;BehaviorProfile) -&gt; Result&lt;()&gt;;
}

/// Matchmaking server storage — ratings, match history, leaderboards.
pub trait MatchmakingStorage: Send + Sync {
    fn update_rating(&amp;self, player: PlayerId, rating: &amp;Glicko2Rating) -&gt; Result&lt;()&gt;;
    fn leaderboard(&amp;self, scope: &amp;LeaderboardScope, limit: u32) -&gt; Result&lt;Vec&lt;LeaderboardEntry&gt;&gt;;
    fn match_history(&amp;self, player: PlayerId, limit: u32) -&gt; Result&lt;Vec&lt;MatchRecord&gt;&gt;;
}

/// Workshop server storage — resource metadata, versions, dependencies, search.
pub trait WorkshopStorage: Send + Sync {
    fn publish_resource(&amp;self, meta: &amp;ResourceMetadata) -&gt; Result&lt;()&gt;;
    fn search(&amp;self, query: &amp;str, filter: &amp;ResourceFilter) -&gt; Result&lt;Vec&lt;ResourceListing&gt;&gt;;
    fn resolve_deps(&amp;self, root: &amp;ResourceId, range: &amp;VersionRange) -&gt; Result&lt;DependencyGraph&gt;;
}

/// SQLite implementation — each service gets its own SqliteXxxStorage struct
/// wrapping a rusqlite::Connection (WAL mode, foreign keys on, journal_size_limit set).
/// PostgreSQL implementations are optional, behind `#[cfg(feature = "postgres")]`.
<span class="boring">}</span></code></pre>
<p><strong>Phase:</strong> SQLite storage for relay and client lands in Phase 2 (replay catalog, save game index, gameplay event log). Workshop server storage lands in Phase 6a (D030). Matchmaking and tournament storage land in Phase 5 (competitive infrastructure). The <code>StorageBackend</code> trait is defined early but PostgreSQL implementation is deferred until scale requires it.</p>
<hr>
<h2 id="d038--scenario-editor-ofpeden-inspired-sdk"><a class="header" href="#d038--scenario-editor-ofpeden-inspired-sdk">D038 — Scenario Editor (OFP/Eden-Inspired, SDK)</a></h2>
<p><strong>Resolves:</strong> P005 (Map editor architecture)</p>
<p><strong>Decision:</strong> Visual scenario editor — not just a map/terrain painter, but a full mission authoring tool inspired by Operation Flashpoint’s mission editor (2001) and Arma 3’s Eden Editor (2016). Ships as part of the <strong>IC SDK</strong> (separate application from the game — see D040 § SDK Architecture). Live isometric preview via shared Bevy crates. Combines terrain editing (tiles, resources, cliffs) with scenario logic editing (unit placement, triggers, waypoints, modules). Two complexity tiers: Simple mode (accessible) and Advanced mode (full power).</p>
<p><strong>Rationale:</strong></p>
<p>The OFP mission editor is one of the most successful content creation tools in gaming history. It shipped with a $40 game in 2001 and generated thousands of community missions across 15 years — despite having no undo button. Its success came from three principles:</p>
<ol>
<li><strong>Accessibility through layered complexity.</strong> Easy mode hides advanced fields. A beginner places units and waypoints in minutes. An advanced user adds triggers, conditions, probability of presence, and scripting. Same data, different UI.</li>
<li><strong>Emergent behavior from simple building blocks.</strong> Guard + Guarded By creates dynamic multi-group defense behavior from pure placement — zero scripting. Synchronization lines coordinate multi-group operations. Triggers with countdown/timeout timers and min/mid/max randomization create unpredictable encounters.</li>
<li><strong>Instant preview collapses the edit→test loop.</strong> Place things on the actual map, hit “Test” to launch the game with your scenario loaded. Hot-reload keeps the loop tight — edit in the SDK, changes appear in the running game within seconds.</li>
</ol>
<p>Eden Editor (2016) evolved these principles: 3D placement, undo/redo, 154 pre-built modules (complex logic as drag-and-drop nodes), compositions (reusable prefabs), layers (organizational folders), and Steam Workshop publishing directly from the editor. Arma Reforger (2022) added budget systems, behavior trees for waypoints, controller support, and a real-time Game Master mode.</p>
<p><strong>Iron Curtain applies these lessons to the RTS genre.</strong> An RTS scenario editor has different needs than a military sim — isometric view instead of first-person, base-building and resource placement instead of terrain sculpting, wave-based encounters instead of patrol routes. But the underlying principles are identical: layered complexity, emergent behavior from simple rules, and zero barrier between editing and playing.</p>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<p>The scenario editor lives in the <code>ic-editor</code> crate and ships as part of the <strong>IC SDK</strong> — a separate Bevy application from the game (see D040 § SDK Architecture for the full separation rationale). It reuses the game’s rendering and simulation crates: <code>ic-render</code> (isometric viewport), <code>ic-sim</code> (preview playback), <code>ic-ui</code> (shared UI components like panels and attribute editors), and <code>ic-protocol</code> (order types for preview). <code>ic-game</code> does NOT depend on <code>ic-editor</code> — the game binary has zero editor code. The SDK binary (<code>ic-sdk</code>) bundles the scenario editor, asset studio (D040), campaign editor, and Game Master mode in a single application with a tab-based workspace.</p>
<p><strong>Test/preview communication:</strong> When the user hits “Test,” the SDK serializes the current scenario and launches <code>ic-game</code> with it loaded, using a <code>LocalNetwork</code> (from <code>ic-net</code>). The game runs the scenario identically to normal gameplay — the sim never knows it was launched from the SDK. For quick in-SDK preview (without launching the full game), the SDK can also run <code>ic-sim</code> internally with a lightweight preview viewport. Editor-generated inputs (e.g., placing a debug unit mid-preview) are submitted as <code>PlayerOrder</code>s through <code>ic-protocol</code>. The hot-reload bridge watches for file changes and pushes updates to the running game test session.</p>
<pre><code>┌─────────────────────────────────────────────────┐
│                 Scenario Editor                  │
│                                                  │
│  ┌──────────┐  ┌──────────┐  ┌───────────────┐ │
│  │  Terrain  │  │  Entity   │  │   Logic       │ │
│  │  Painter  │  │  Placer   │  │   Editor      │ │
│  │           │  │           │  │               │ │
│  │ tiles     │  │ units     │  │ triggers      │ │
│  │ resources │  │ buildings │  │ waypoints     │ │
│  │ cliffs    │  │ props     │  │ modules       │ │
│  │ water     │  │ markers   │  │ regions       │ │
│  └──────────┘  └──────────┘  └───────────────┘ │
│                                                  │
│  ┌──────────────────────────────────────────┐   │
│  │            Attributes Panel               │   │
│  │  Per-entity properties (GUI, not code)    │   │
│  └──────────────────────────────────────────┘   │
│                                                  │
│  ┌─────────┐  ┌──────────┐  ┌──────────────┐   │
│  │ Layers  │  │ Comps    │  │ Preview/Test │   │
│  │ Panel   │  │ Library  │  │ Button       │   │
│  └─────────┘  └──────────┘  └──────────────┘   │
│                                                  │
│  ┌─────────┐  ┌──────────┐  ┌──────────────┐   │
│  │ Script  │  │ Vars     │  │ Complexity   │   │
│  │ Editor  │  │ Panel    │  │ Meter        │   │
│  └─────────┘  └──────────┘  └──────────────┘   │
│                                                  │
│  ┌──────────────────────────────────────────┐   │
│  │           Campaign Editor                 │   │
│  │  Graph · State · Intermissions · Dialogue │   │
│  └──────────────────────────────────────────┘   │
│                                                  │
│  Crate: ic-editor                                │
│  Uses:  ic-render (isometric view)               │
│         ic-sim   (preview playback)              │
│         ic-ui    (shared panels, attributes)     │
└─────────────────────────────────────────────────┘
</code></pre>
<h3 id="editing-modes"><a class="header" href="#editing-modes">Editing Modes</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Purpose</th><th>OFP Equivalent</th></tr>
</thead>
<tbody>
<tr><td><strong>Terrain</strong></td><td>Paint tiles, place resources (ore/gems), sculpt cliffs, water</td><td>N/A (OFP had fixed terrains)</td></tr>
<tr><td><strong>Entities</strong></td><td>Place units, buildings, props, markers</td><td>F1 (Units) + F6 (Markers)</td></tr>
<tr><td><strong>Groups</strong></td><td>Organize units into squads/formations, set group behavior</td><td>F2 (Groups)</td></tr>
<tr><td><strong>Triggers</strong></td><td>Place area-based conditional logic (win/lose, events, spawns)</td><td>F3 (Triggers)</td></tr>
<tr><td><strong>Waypoints</strong></td><td>Assign movement/behavior orders to groups</td><td>F4 (Waypoints)</td></tr>
<tr><td><strong>Connections</strong></td><td>Link triggers ↔ waypoints ↔ modules visually</td><td>F5 (Synchronization)</td></tr>
<tr><td><strong>Modules</strong></td><td>Pre-packaged game logic nodes</td><td>F7 (Modules)</td></tr>
<tr><td><strong>Regions</strong></td><td>Draw named spatial zones reusable across triggers and scripts</td><td>N/A (AoE2/StarCraft concept)</td></tr>
<tr><td><strong>Scripts</strong></td><td>Browse and edit external <code>.lua</code> files referenced by inline scripts</td><td>OFP mission folder <code>.sqs</code>/<code>.sqf</code> files</td></tr>
<tr><td><strong>Campaign</strong></td><td>Visual campaign graph — mission ordering, branching, persistent state</td><td>N/A (no RTS editor has this)</td></tr>
</tbody>
</table>
</div>
<h3 id="entity-palette-ux"><a class="header" href="#entity-palette-ux">Entity Palette UX</a></h3>
<p>The Entities mode panel provides the primary browse/select interface for all placeable objects. Inspired by Garry’s Mod’s spawn menu (<code>Q</code> menu) — the gold standard for navigating massive asset libraries — the palette includes:</p>
<ul>
<li><strong>Search-as-you-type</strong> across all entities (units, structures, props, modules, compositions) — filters the tree in real time</li>
<li><strong>Favorites list</strong> — star frequently-used items; persisted per-user in SQLite (D034). A dedicated Favorites tab at the top of the palette</li>
<li><strong>Recently placed</strong> — shows the last 20 entities placed this session, most recent first. One click to re-select</li>
<li><strong>Per-category browsing</strong> with collapsible subcategories (faction → unit type → specific unit). Categories are game-module-defined via YAML</li>
<li><strong>Thumbnail previews</strong> — small sprite/icon preview next to each entry. Hovering shows a larger preview with stats summary</li>
</ul>
<p>The same palette UX applies to the Compositions Library panel, the Module selector, and the Trigger type picker — search/favorites/recents are universal navigation patterns across all editor panels.</p>
<h3 id="entity-attributes-panel"><a class="header" href="#entity-attributes-panel">Entity Attributes Panel</a></h3>
<p>Every placed entity has a GUI properties panel (no code required). This replaces OFP’s “Init” field for most use cases while keeping advanced scripting available.</p>
<p><strong>Unit attributes (example):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Type</strong></td><td>dropdown</td><td>Unit class (filtered by faction)</td></tr>
<tr><td><strong>Name</strong></td><td>text</td><td>Variable name for Lua scripting</td></tr>
<tr><td><strong>Faction</strong></td><td>dropdown</td><td>Owner: Player 1–8, Neutral, Creeps</td></tr>
<tr><td><strong>Facing</strong></td><td>slider 0–360</td><td>Starting direction</td></tr>
<tr><td><strong>Stance</strong></td><td>enum</td><td>Guard / Patrol / Hold / Aggressive</td></tr>
<tr><td><strong>Health</strong></td><td>slider 0–100%</td><td>Starting hit points</td></tr>
<tr><td><strong>Veterancy</strong></td><td>enum</td><td>None / Rookie / Veteran / Elite</td></tr>
<tr><td><strong>Probability of Presence</strong></td><td>slider 0–100%</td><td>Random chance to exist at mission start</td></tr>
<tr><td><strong>Condition of Presence</strong></td><td>expression</td><td>Lua boolean (e.g., <code>difficulty &gt;= "hard"</code>)</td></tr>
<tr><td><strong>Placement Radius</strong></td><td>slider 0–10 cells</td><td>Random starting position within radius</td></tr>
<tr><td><strong>Init Script</strong></td><td>text (multi-line)</td><td>Inline Lua — the primary scripting surface</td></tr>
</tbody>
</table>
</div>
<p><strong>Probability of Presence</strong> is the single most important replayability feature from OFP. Every entity — units, buildings, resource patches, props — can have a percentage chance of existing when the mission loads. Combined with Condition of Presence, this creates two-factor randomization: “50% chance this tank platoon spawns, but only on Hard difficulty.” A player replaying the same mission encounters different enemy compositions each time. This is trivially deterministic — the mission seed determines all rolls.</p>
<h3 id="named-regions"><a class="header" href="#named-regions">Named Regions</a></h3>
<p>Inspired by Age of Empires II’s trigger areas and StarCraft’s “locations” — both independently proved that named spatial zones are how non-programmers think about RTS mission logic. A <strong>region</strong> is a named area on the map (rectangle or ellipse) that can be referenced by name across multiple triggers, modules, and scripts.</p>
<p>Regions are NOT triggers — they have no logic of their own. They are spatial labels. A region named <code>bridge_crossing</code> can be referenced by:</p>
<ul>
<li>Trigger 1: “IF Player 1 faction present in <code>bridge_crossing</code> → activate reinforcements”</li>
<li>Trigger 2: “IF <code>bridge_crossing</code> has no enemies → play victory audio”</li>
<li>Lua script: <code>Region.unit_count("bridge_crossing", faction.allied) &gt;= 5</code></li>
<li>Module: Wave Spawner configured to spawn at <code>bridge_crossing</code></li>
</ul>
<p>This separation prevents the common RTS editor mistake of coupling spatial areas to individual triggers. In AoE2, if three triggers need to reference the same map area, you create three identical areas. In IC, you create one region and reference it three times.</p>
<p><strong>Region attributes:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Name</strong></td><td>text</td><td>Unique identifier (e.g., <code>enemy_base</code>, <code>ambush_zone</code>)</td></tr>
<tr><td><strong>Shape</strong></td><td>rect / ellipse</td><td>Cell-aligned or free-form</td></tr>
<tr><td><strong>Color</strong></td><td>color picker</td><td>Editor visualization color (not visible in-game)</td></tr>
<tr><td><strong>Tags</strong></td><td>text[]</td><td>Optional categorization for search/filter</td></tr>
<tr><td><strong>Z-layer</strong></td><td>ground / air / any</td><td>Which unit layers the region applies to</td></tr>
</tbody>
</table>
</div>
<h3 id="inline-scripting-ofp-style"><a class="header" href="#inline-scripting-ofp-style">Inline Scripting (OFP-Style)</a></h3>
<p>OFP’s most powerful feature was also its simplest: double-click a unit, type a line of SQF in the Init field, done. No separate IDE, no file management, no project setup. The scripting lived <em>on the entity</em>. For anything complex, the Init field called an external script file — one line bridges the gap between visual editing and full programming.</p>
<p>IC follows the same model with Lua. The <strong>Init Script</strong> field on every entity is the primary scripting surface — not a secondary afterthought.</p>
<p><strong>Inline scripting examples:</strong></p>
<pre><code class="language-lua">-- Simple: one-liner directly on the entity
this:set_stance("hold")

-- Medium: a few lines of inline behavior
this:set_patrol_route("north_road")
this:on_damaged(function() Var.set("alarm_triggered", true) end)

-- Complex: inline calls an external script file
dofile("scripts/elite_guard.lua")(this)

-- OFP equivalent of `nul = [this] execVM "patrol.sqf"`
run_script("scripts/convoy_escort.lua", { unit = this, route = "highway" })
</code></pre>
<p>This is exactly how OFP worked: most units have no Init script at all (pure visual placement). Some have one-liners. A few call external files for complex behavior. The progression is organic — a designer starts with visual placement, realizes they need a small tweak, types a line, and naturally graduates to scripting when they’re ready. No mode switch, no separate tool.</p>
<p><strong>Inline scripts run at entity spawn time</strong> — when the mission loads (or when the entity is dynamically spawned by a trigger/module). The <code>this</code> variable refers to the entity the script is attached to.</p>
<p><strong>Triggers and modules also have inline script fields:</strong></p>
<ul>
<li>Trigger <strong>On Activation</strong>: inline Lua that runs when the trigger fires</li>
<li>Trigger <strong>On Deactivation</strong>: inline Lua for repeatable triggers</li>
<li>Module <strong>Custom Logic</strong>: override or extend a module’s default behavior</li>
</ul>
<p>Every inline script field has:</p>
<ul>
<li><strong>Syntax highlighting</strong> for Lua with IC API keywords</li>
<li><strong>Autocompletion</strong> for entity names, region names, variables, and the IC Lua API (D024)</li>
<li><strong>Error markers</strong> shown inline before preview (not in a crash log)</li>
<li><strong>Expand button</strong> — opens the field in a larger editing pane for multi-line scripts without leaving the entity’s properties panel</li>
</ul>
<h3 id="script-files-panel"><a class="header" href="#script-files-panel">Script Files Panel</a></h3>
<p>When inline scripts call external files (<code>dofile("scripts/ambush.lua")</code>), those files need to live somewhere. The <strong>Script Files Panel</strong> manages them — it’s the editor for the external script files that inline scripts reference.</p>
<p>This is the same progression OFP used: Init field → <code>execVM "script.sqf"</code> → the .sqf file lives in the mission folder. IC keeps the external files <em>inside the editor</em> rather than requiring alt-tab to a text editor.</p>
<p><strong>Script Files Panel features:</strong></p>
<ul>
<li><strong>File browser</strong> — lists all <code>.lua</code> files in the mission</li>
<li><strong>New file</strong> — create a script file, it’s immediately available to inline <code>dofile()</code> calls</li>
<li><strong>Syntax highlighting</strong> and <strong>autocompletion</strong> (same as inline fields)</li>
<li><strong>Live reload</strong> — edit a script file during preview, save, changes take effect next tick</li>
<li><strong>API reference sidebar</strong> — searchable IC Lua API docs without leaving the editor</li>
<li><strong>Breakpoints and watch</strong> (Advanced mode) — pause the sim on a breakpoint, inspect variables</li>
</ul>
<p><strong>Script scope hierarchy (mirrors the natural progression):</strong></p>
<pre><code>Inline init scripts  — on entities, run at spawn (the starting point)
Inline trigger scripts — on triggers, run on activation/deactivation
External script files  — called by inline scripts for complex logic
Mission init script    — special file that runs once at mission start
</code></pre>
<p>The tiered model: most users never write a script. Some write one-liners on entities. A few create external files. The progression is seamless — there’s no cliff between “visual editing” and “programming,” just a gentle slope that starts with <code>this:set_stance("hold")</code>.</p>
<h3 id="variables-panel"><a class="header" href="#variables-panel">Variables Panel</a></h3>
<p>AoE2 scenario designers used invisible units placed off-screen as makeshift variables. StarCraft modders abused the “deaths” counter as integer storage. Both are hacks because the editors lacked native state management.</p>
<p>IC provides a <strong>Variables Panel</strong> — mission-wide state visible and editable in the GUI. Triggers and modules can read/write variables without Lua.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variable Type</th><th>Example</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><strong>Switch</strong></td><td><code>bridge_destroyed</code> (on/off)</td><td>Boolean flags for trigger conditions</td></tr>
<tr><td><strong>Counter</strong></td><td><code>waves_survived</code> (integer)</td><td>Counting events, tracking progress</td></tr>
<tr><td><strong>Timer</strong></td><td><code>mission_clock</code> (ticks)</td><td>Elapsed time tracking</td></tr>
<tr><td><strong>Text</strong></td><td><code>player_callsign</code> (string)</td><td>Dynamic text for briefings/dialogue</td></tr>
</tbody>
</table>
</div>
<p><strong>Variable operations in triggers (no Lua required):</strong></p>
<ul>
<li>Set variable, increment/decrement counter, toggle switch</li>
<li>Condition: “IF <code>waves_survived</code> &gt;= 5 → trigger victory”</li>
<li>Module connection: Wave Spawner increments <code>waves_survived</code> after each wave</li>
</ul>
<p>Variables are visible in the Variables Panel, named by the designer, and referenced by name everywhere. Lua scripts access them via <code>Var.get("waves_survived")</code> / <code>Var.set("waves_survived", 5)</code>. All variables are deterministic sim state (included in snapshots and replays).</p>
<h3 id="scenario-complexity-meter"><a class="header" href="#scenario-complexity-meter">Scenario Complexity Meter</a></h3>
<p>Inspired by TimeSplitters’ memory bar — a persistent, always-visible indicator of scenario complexity and estimated performance impact.</p>
<pre><code>┌──────────────────────────────────────────────┐
│  Complexity: ████████████░░░░░░░░  58%       │
│  Entities: 247/500  Triggers: 34/200         │
│  Scripts: 3 files   Regions: 12              │
└──────────────────────────────────────────────┘
</code></pre>
<p>The meter reflects:</p>
<ul>
<li><strong>Entity count</strong> vs recommended maximum (per target platform)</li>
<li><strong>Trigger count</strong> and nesting depth</li>
<li><strong>Script complexity</strong> (line count, hook count)</li>
<li><strong>Estimated tick cost</strong> — based on entity types and AI behaviors</li>
</ul>
<p>The meter is a <strong>guideline, not a hard limit</strong>. Exceeding 100% shows a warning (“This scenario may perform poorly on lower-end hardware”) but doesn’t prevent saving or publishing. Power users can push past it; casual creators stay within safe bounds without thinking about performance.</p>
<h3 id="trigger-organization"><a class="header" href="#trigger-organization">Trigger Organization</a></h3>
<p>The AoE2 Scenario Editor’s trigger list collapses into an unmanageable wall at 200+ triggers — no folders, no search, no visual overview. IC prevents this from day one:</p>
<ul>
<li><strong>Folders</strong> — group triggers by purpose (“Phase 1”, “Enemy AI”, “Cinematics”, “Victory Conditions”)</li>
<li><strong>Search / Filter</strong> — find triggers by name, condition type, connected entity, or variable reference</li>
<li><strong>Color coding</strong> — triggers inherit their folder’s color for visual scanning</li>
<li><strong>Flow graph view</strong> — toggle between list view and a visual node graph showing trigger chains, connections to modules, and variable flow. Read-only visualization, not a node-based editor (that’s the “Alternatives Considered” item). Lets designers see the big picture of complex mission logic without reading every trigger.</li>
<li><strong>Collapse / expand</strong> — folders collapse to single lines; individual triggers collapse to show only name + condition summary</li>
</ul>
<h3 id="undo--redo"><a class="header" href="#undo--redo">Undo / Redo</a></h3>
<p>OFP’s editor shipped without undo. Eden added it 15 years later. IC ships with full undo/redo from day one.</p>
<ul>
<li><strong>Unlimited undo stack</strong> (bounded by memory, not count)</li>
<li>Covers all operations: entity placement/deletion/move, trigger edits, terrain painting, variable changes, layer operations</li>
<li><strong>Redo</strong> restores undone actions until a new action branches the history</li>
<li>Undo history survives save/load within a session</li>
<li><strong>Ctrl+Z / Ctrl+Y</strong> (desktop), equivalent bindings on controller</li>
</ul>
<h3 id="autosave--crash-recovery"><a class="header" href="#autosave--crash-recovery">Autosave &amp; Crash Recovery</a></h3>
<p>OFP’s editor had no undo and no autosave — one misclick or crash could destroy hours of work. IC ships with both from day one.</p>
<ul>
<li><strong>Autosave</strong> — configurable interval (default: every 5 minutes). Writes to a rotating set of 3 autosave slots so a corrupted save doesn’t overwrite the only backup</li>
<li><strong>Pre-preview save</strong> — the editor automatically saves a snapshot before entering preview mode. If the game crashes during preview, the editor state is preserved</li>
<li><strong>Recovery on launch</strong> — if the editor detects an unclean shutdown (crash), it offers to restore from the most recent autosave: “The editor was not closed properly. Restore from autosave (2 minutes ago)? [Restore] [Discard]”</li>
<li><strong>Undo history persistence</strong> — the undo stack is included in autosaves. Restoring from autosave also restores the ability to undo recent changes</li>
<li><strong>Manual save is always available</strong> — Ctrl+S saves to the scenario file. Autosave supplements manual save, never replaces it</li>
</ul>
<h3 id="trigger-system-rts-adapted"><a class="header" href="#trigger-system-rts-adapted">Trigger System (RTS-Adapted)</a></h3>
<p>OFP’s trigger system adapted for RTS gameplay:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Area</strong></td><td>Rectangle or ellipse on the isometric map (cell-aligned or free-form)</td></tr>
<tr><td><strong>Activation</strong></td><td>Who triggers it: Any Player / Specific Player / Any Unit / Faction Units / No Unit (condition-only)</td></tr>
<tr><td><strong>Condition Type</strong></td><td>Present / Not Present / Destroyed / Built / Captured / Harvested</td></tr>
<tr><td><strong>Custom Condition</strong></td><td>Lua expression (e.g., <code>Player.cash(1) &gt;= 5000</code>)</td></tr>
<tr><td><strong>Repeatable</strong></td><td>Once or Repeatedly (with re-arm)</td></tr>
<tr><td><strong>Timer</strong></td><td>Countdown (fires after delay, condition can lapse) or Timeout (condition must persist for full duration)</td></tr>
<tr><td><strong>Timer Values</strong></td><td>Min / Mid / Max — randomized, gravitating toward Mid. Prevents predictable timing.</td></tr>
<tr><td><strong>Trigger Type</strong></td><td>None / Victory / Defeat / Reveal Area / Spawn Wave / Play Audio / Weather Change / Reinforcements / Objective Update</td></tr>
<tr><td><strong>On Activation</strong></td><td>Advanced: Lua script</td></tr>
<tr><td><strong>On Deactivation</strong></td><td>Advanced: Lua script (repeatable triggers only)</td></tr>
<tr><td><strong>Effects</strong></td><td>Play music / Play sound / Play video / Show message / Camera flash / Screen shake / Enter cinematic mode</td></tr>
</tbody>
</table>
</div>
<p><strong>RTS-specific trigger conditions:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Condition</th><th>Description</th><th>OFP Equivalent</th></tr>
</thead>
<tbody>
<tr><td><code>faction_present</code></td><td>Any unit of faction X is alive inside the trigger area</td><td>Side Present</td></tr>
<tr><td><code>faction_not_present</code></td><td>No units of faction X inside trigger area</td><td>Side Not Present</td></tr>
<tr><td><code>building_destroyed</code></td><td>Specific building is destroyed</td><td>N/A</td></tr>
<tr><td><code>building_captured</code></td><td>Specific building changed ownership</td><td>N/A</td></tr>
<tr><td><code>building_built</code></td><td>Player has constructed building type X</td><td>N/A</td></tr>
<tr><td><code>unit_count</code></td><td>Faction has ≥ N units of type X alive</td><td>N/A</td></tr>
<tr><td><code>resources_collected</code></td><td>Player has harvested ≥ N resources</td><td>N/A</td></tr>
<tr><td><code>timer_elapsed</code></td><td>N ticks since mission start (or since trigger activation)</td><td>N/A</td></tr>
<tr><td><code>area_seized</code></td><td>Faction dominates the trigger area (adapted from OFP’s “Seized by”)</td><td>Seized by Side</td></tr>
<tr><td><code>all_destroyed_in_area</code></td><td>Every enemy unit/building inside the area is destroyed</td><td>N/A</td></tr>
<tr><td><code>custom_lua</code></td><td>Arbitrary Lua expression</td><td>Custom Condition</td></tr>
</tbody>
</table>
</div>
<p><strong>Countdown vs Timeout with Min/Mid/Max</strong> is crucial for RTS missions. Example: “Reinforcements arrive 3–7 minutes after the player captures the bridge” (Countdown, Min=3m, Mid=5m, Max=7m). The player can’t memorize the exact timing. In OFP, this was the key to making missions feel alive rather than scripted.</p>
<h3 id="module-system-pre-packaged-logic-nodes"><a class="header" href="#module-system-pre-packaged-logic-nodes">Module System (Pre-Packaged Logic Nodes)</a></h3>
<p>Modules are IC’s equivalent of Eden Editor’s 154 built-in modules — complex game logic packaged as drag-and-drop nodes with a properties panel. Non-programmers get 80% of the power without writing Lua.</p>
<p><strong>Built-in module library (initial set):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Module</th><th>Parameters</th><th>Logic</th></tr>
</thead>
<tbody>
<tr><td><strong>Spawning</strong></td><td>Wave Spawner</td><td>waves[], interval, escalation, entry_points[]</td><td>Spawns enemy units in configurable waves</td></tr>
<tr><td><strong>Spawning</strong></td><td>Reinforcements</td><td>units[], entry_point, trigger, delay</td><td>Sends units from map edge on trigger</td></tr>
<tr><td><strong>Spawning</strong></td><td>Probability Group</td><td>units[], probability 0–100%</td><td>Group exists only if random roll passes (visual wrapper around Probability of Presence)</td></tr>
<tr><td><strong>AI Behavior</strong></td><td>Patrol Route</td><td>waypoints[], alert_radius, response</td><td>Units cycle waypoints, engage if threat detected</td></tr>
<tr><td><strong>AI Behavior</strong></td><td>Guard Position</td><td>position, radius, priority</td><td>Units defend location; peel to attack nearby threats (OFP Guard/Guarded By pattern)</td></tr>
<tr><td><strong>AI Behavior</strong></td><td>Hunt and Destroy</td><td>area, unit_types[], aggression</td><td>AI actively searches for and engages enemies in area</td></tr>
<tr><td><strong>AI Behavior</strong></td><td>Harvest Zone</td><td>area, harvesters, refinery</td><td>AI harvests resources in designated zone</td></tr>
<tr><td><strong>Objectives</strong></td><td>Destroy Target</td><td>target, description, optional</td><td>Player must destroy specific building/unit</td></tr>
<tr><td><strong>Objectives</strong></td><td>Capture Building</td><td>building, description, optional</td><td>Player must engineer-capture building</td></tr>
<tr><td><strong>Objectives</strong></td><td>Defend Position</td><td>area, duration, description</td><td>Player must keep faction presence in area for N ticks</td></tr>
<tr><td><strong>Objectives</strong></td><td>Timed Objective</td><td>target, time_limit, failure_consequence</td><td>Objective with countdown timer</td></tr>
<tr><td><strong>Objectives</strong></td><td>Escort Convoy</td><td>convoy_units[], route, description</td><td>Protect moving units along a path</td></tr>
<tr><td><strong>Events</strong></td><td>Reveal Map Area</td><td>area, trigger, delay</td><td>Removes shroud from an area</td></tr>
<tr><td><strong>Events</strong></td><td>Play Briefing</td><td>text, audio_ref, portrait</td><td>Shows briefing panel with text and audio</td></tr>
<tr><td><strong>Events</strong></td><td>Camera Pan</td><td>from, to, duration, trigger</td><td>Cinematic camera movement on trigger</td></tr>
<tr><td><strong>Events</strong></td><td>Weather Change</td><td>type, intensity, transition_time, trigger</td><td>Changes weather on trigger activation</td></tr>
<tr><td><strong>Events</strong></td><td>Dialogue</td><td>lines[], trigger</td><td>In-game dialogue sequence</td></tr>
<tr><td><strong>Flow</strong></td><td>Mission Timer</td><td>duration, visible, warning_threshold</td><td>Global countdown affecting mission end</td></tr>
<tr><td><strong>Flow</strong></td><td>Checkpoint</td><td>trigger, save_state</td><td>Auto-save when trigger fires</td></tr>
<tr><td><strong>Flow</strong></td><td>Branch</td><td>condition, true_path, false_path</td><td>Campaign branching point (D021)</td></tr>
<tr><td><strong>Flow</strong></td><td>Difficulty Gate</td><td>min_difficulty, entities[]</td><td>Entities only exist above threshold difficulty</td></tr>
<tr><td><strong>Effects</strong></td><td>Explosion</td><td>position, size, trigger</td><td>Cosmetic explosion on trigger</td></tr>
<tr><td><strong>Effects</strong></td><td>Sound Emitter</td><td>sound_ref, trigger, loop, 3d</td><td>Play sound effect — positional (3D) or global</td></tr>
<tr><td><strong>Effects</strong></td><td>Music Trigger</td><td>track, trigger, fade_time</td><td>Change music track on trigger activation</td></tr>
<tr><td><strong>Media</strong></td><td>Video Playback</td><td>video_ref, trigger, display_mode, skippable</td><td>Play video — fullscreen, radar_comm, or picture_in_picture (see 04-MODDING.md)</td></tr>
<tr><td><strong>Media</strong></td><td>Cinematic Sequence</td><td>steps[], trigger, skippable</td><td>Chain camera pans + dialogue + music + video + letterbox into a scripted sequence</td></tr>
<tr><td><strong>Media</strong></td><td>Ambient Sound Zone</td><td>region, sound_ref, volume, falloff</td><td>Looping positional audio tied to a named region (forest, river, factory hum)</td></tr>
<tr><td><strong>Media</strong></td><td>Music Playlist</td><td>tracks[], mode, trigger</td><td>Set active playlist — sequential, shuffle, or dynamic (combat/ambient/tension)</td></tr>
<tr><td><strong>Media</strong></td><td>Radar Comm</td><td>portrait, audio_ref, text, duration, trigger</td><td>RA2-style comm overlay in radar panel — portrait + voice + subtitle (no video required)</td></tr>
<tr><td><strong>Media</strong></td><td>EVA Notification</td><td>event_type, text, audio_ref, trigger</td><td>Play EVA-style notification with audio + text banner</td></tr>
<tr><td><strong>Media</strong></td><td>Letterbox Mode</td><td>trigger, duration, enter_time, exit_time</td><td>Toggle cinematic letterbox bars — hides HUD, enters cinematic aspect ratio</td></tr>
<tr><td><strong>Multiplayer</strong></td><td>Spawn Point</td><td>faction, position</td><td>Player starting location in MP scenarios</td></tr>
<tr><td><strong>Multiplayer</strong></td><td>Crate Drop</td><td>position, trigger, contents</td><td>Random powerup/crate on trigger</td></tr>
</tbody>
</table>
</div>
<p>Modules connect to triggers and other entities via <strong>visual connection lines</strong> — same as OFP’s synchronization system. A “Reinforcements” module connected to a trigger means the reinforcements arrive when the trigger fires. No scripting required.</p>
<p><strong>Custom modules</strong> can be created by modders — a YAML definition + Lua implementation, publishable via Workshop (D030). The community can extend the module library indefinitely.</p>
<h3 id="compositions-reusable-building-blocks"><a class="header" href="#compositions-reusable-building-blocks">Compositions (Reusable Building Blocks)</a></h3>
<p>Compositions are saved groups of entities, triggers, modules, and connections — like Eden Editor’s custom compositions. They bridge the gap between individual entity placement and full scene templates (04-MODDING.md).</p>
<p><strong>Hierarchy:</strong></p>
<pre><code>Entity           — single unit, building, trigger, or module
  ↓ grouped into
Composition      — reusable cluster (base layout, defensive formation, scripted encounter)
  ↓ assembled into
Scenario         — complete mission with objectives, terrain, all compositions placed
  ↓ sequenced into (via Campaign Editor)
Campaign         — branching multi-mission graph with persistent state, intermissions, and dialogue (D021)
</code></pre>
<p><strong>Built-in compositions:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Composition</th><th>Contents</th></tr>
</thead>
<tbody>
<tr><td>Soviet Base (Small)</td><td>Construction Yard, Power Plant, Barracks, Ore Refinery, 3 harvesters, guard units</td></tr>
<tr><td>Allied Outpost</td><td>Pillbox ×2, AA Gun, Power Plant, guard units with patrol waypoints</td></tr>
<tr><td>Ore Field (Rich)</td><td>Ore cells + ore truck spawn trigger</td></tr>
<tr><td>Ambush Point</td><td>Hidden units + area trigger + attack waypoints (Probability of Presence per unit)</td></tr>
<tr><td>Bridge Checkpoint</td><td>Bridge + guarding units + trigger for crossing detection</td></tr>
<tr><td>Air Patrol</td><td>Aircraft with looping patrol waypoints + scramble trigger</td></tr>
<tr><td>Coastal Defense</td><td>Naval turrets + submarine patrol + radar</td></tr>
</tbody>
</table>
</div>
<p><strong>Workflow:</strong></p>
<ol>
<li>Place entities, arrange them, connect triggers/modules</li>
<li>Select all → “Save as Composition” → name, category, description, tags, thumbnail</li>
<li>Composition appears in the Compositions Library panel (searchable, with favorites — same palette UX as the entity panel)</li>
<li>Drag composition onto any map to place a pre-built cluster</li>
<li>Publish to Workshop (D030) — community compositions become shared building blocks</li>
</ol>
<p><strong>Compositions are individually publishable.</strong> Unlike scenarios (which are complete missions), a single composition can be published as a standalone Workshop resource — a “Soviet Base (Large)” layout, a “Scripted Ambush” encounter template, a “Tournament Start” formation. Other designers browse and install individual compositions, just as Garry’s Mod’s Advanced Duplicator lets players share and browse individual contraptions independently of full maps. Composition metadata (name, description, thumbnail, tags, author, dependencies) enables a browsable composition library within the Workshop, not just a flat file list.</p>
<p>This completes the content creation pipeline: compositions are the visual-editor equivalent of scene templates (04-MODDING.md). Scene templates are YAML/Lua for programmatic use and LLM generation. Compositions are the same concept for visual editing. They share the same underlying data format — a composition saved in the editor can be loaded as a scene template by Lua/LLM, and vice versa.</p>
<h3 id="layers"><a class="header" href="#layers">Layers</a></h3>
<p>Organizational folders for managing complex scenarios:</p>
<ul>
<li>Group entities by purpose: “Phase 1 — Base Defense”, “Phase 2 — Counterattack”, “Enemy Patrols”, “Civilian Traffic”</li>
<li><strong>Visibility toggle</strong> — hide layers in the editor without affecting runtime (essential when a mission has 500+ entities)</li>
<li><strong>Lock toggle</strong> — prevent accidental edits to finalized layers</li>
<li><strong>Runtime show/hide</strong> — Lua can show/hide entire layers at runtime: <code>Layer.activate("Phase2_Reinforcements")</code> / <code>Layer.deactivate(...)</code>. Activating a layer spawns all entities in it as a batch; deactivating despawns them. These are <strong>sim operations</strong> (deterministic, included in snapshots and replays), not editor operations — the Lua API name uses <code>Layer</code>, not <code>Editor</code>, to make the boundary clear. Internally, each entity has a <code>layer: Option&lt;String&gt;</code> field; activation toggles a per-layer <code>active</code> flag that the spawn system reads. Entities in inactive layers do not exist in the sim — they are serialized in the scenario file but not instantiated until activation. <strong>Deactivation is destructive:</strong> calling <code>Layer.deactivate()</code> despawns all entities in the layer — any runtime state (damage taken, position changes, veterancy gained) is lost. Re-activating the layer spawns fresh copies from the scenario template. This is intentional: layers model “reinforcement waves” and “phase transitions,” not pausable unit groups. For scenarios that need to preserve unit state across activation cycles, use Lua variables or campaign state (D021) to snapshot and restore specific values</li>
</ul>
<h3 id="media--cinematics"><a class="header" href="#media--cinematics">Media &amp; Cinematics</a></h3>
<p>Original Red Alert’s campaign identity was defined as much by its media as its gameplay — FMV briefings before missions, the radar panel switching to a video feed during gameplay, Hell March driving the combat tempo, EVA voice lines as constant tactical feedback. A campaign editor that can’t orchestrate media is a campaign editor that can’t recreate what made C&amp;C campaigns feel like C&amp;C campaigns.</p>
<p>The modding layer (<code>04-MODDING.md</code>) defines the primitives: <code>video_playback</code> scene templates with display modes (<code>fullscreen</code>, <code>radar_comm</code>, <code>picture_in_picture</code>), <code>scripted_scene</code> templates, and the <code>Media</code> Lua global. The scenario editor surfaces all of these as <strong>visual modules</strong> — no Lua required for standard use, Lua available for advanced control.</p>
<h4 id="video-playback"><a class="header" href="#video-playback">Video Playback</a></h4>
<p>The <strong>Video Playback</strong> module plays video files (<code>.vqa</code>, <code>.mp4</code>, <code>.webm</code>) at a designer-specified trigger point. Three display modes (from <code>04-MODDING.md</code>):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Display Mode</th><th>Behavior</th><th>Inspiration</th></tr>
</thead>
<tbody>
<tr><td><code>fullscreen</code></td><td>Pauses gameplay, fills screen, letterboxed. Classic FMV briefing.</td><td>RA1 mission briefings</td></tr>
<tr><td><code>radar_comm</code></td><td>Video replaces the radar/minimap panel. Game continues. Sidebar stays functional.</td><td>RA2 EVA / commander video calls</td></tr>
<tr><td><code>picture_in_picture</code></td><td>Small floating video overlay in a corner. Game continues. Dismissible.</td><td>Modern RTS cinematics</td></tr>
</tbody>
</table>
</div>
<p><strong>Module properties in the editor:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Video</strong></td><td>file picker</td><td>Video file reference (from mission assets or Workshop dependency)</td></tr>
<tr><td><strong>Display mode</strong></td><td>dropdown</td><td><code>fullscreen</code> / <code>radar_comm</code> / <code>picture_in_picture</code></td></tr>
<tr><td><strong>Trigger</strong></td><td>connection</td><td>When to play — connected to a trigger, module, or “mission start”</td></tr>
<tr><td><strong>Skippable</strong></td><td>checkbox</td><td>Whether the player can press Escape to skip</td></tr>
<tr><td><strong>Subtitle</strong></td><td>text (optional)</td><td>Subtitle text shown during playback (accessibility)</td></tr>
<tr><td><strong>On Complete</strong></td><td>connection (optional)</td><td>Trigger or module to activate when the video finishes</td></tr>
</tbody>
</table>
</div>
<p><strong>Radar Comm</strong> deserves special emphasis — it’s the feature that makes in-mission storytelling possible without interrupting gameplay. A commander calls in during a battle, their face appears in the radar panel, they deliver a line, and the radar returns. The designer connects a Video Playback (mode: <code>radar_comm</code>) to a trigger, and that’s it. No scripting, no timeline editor, no separate cinematic tool.</p>
<p>For missions without custom video, the <strong>Radar Comm</strong> module (separate from Video Playback) provides the same radar-panel takeover using a static portrait + audio + subtitle text — the RA2 communication experience without requiring video production.</p>
<h4 id="cinematic-sequences"><a class="header" href="#cinematic-sequences">Cinematic Sequences</a></h4>
<p>Individual modules (Camera Pan, Video Playback, Dialogue, Music Trigger) handle single media events. A <strong>Cinematic Sequence</strong> chains them into a scripted multi-step sequence — the editor equivalent of a cutscene director.</p>
<p><strong>Sequence step types:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Step Type</th><th>Parameters</th><th>What It Does</th></tr>
</thead>
<tbody>
<tr><td><code>camera_pan</code></td><td>from, to, duration, easing</td><td>Smooth camera movement between positions</td></tr>
<tr><td><code>camera_shake</code></td><td>intensity, duration</td><td>Screen shake (explosion, impact)</td></tr>
<tr><td><code>dialogue</code></td><td>speaker, portrait, text, audio_ref, duration</td><td>Character speech bubble / subtitle overlay</td></tr>
<tr><td><code>play_video</code></td><td>video_ref, display_mode</td><td>Video playback (any display mode)</td></tr>
<tr><td><code>play_music</code></td><td>track, fade_in</td><td>Music change with crossfade</td></tr>
<tr><td><code>play_sound</code></td><td>sound_ref, position (optional)</td><td>Sound effect — positional or global</td></tr>
<tr><td><code>wait</code></td><td>duration</td><td>Pause between steps (in game ticks or seconds)</td></tr>
<tr><td><code>spawn_units</code></td><td>units[], position, faction</td><td>Dramatic unit reveal (reinforcements arriving on-camera)</td></tr>
<tr><td><code>destroy</code></td><td>target</td><td>Scripted destruction (building collapses, bridge blows)</td></tr>
<tr><td><code>weather</code></td><td>type, intensity, transition_time</td><td>Weather change synchronized with the sequence</td></tr>
<tr><td><code>letterbox</code></td><td>enable/disable, transition_time</td><td>Toggle cinematic letterbox bars</td></tr>
<tr><td><code>set_variable</code></td><td>name, value</td><td>Set a mission or campaign variable during the sequence</td></tr>
<tr><td><code>lua</code></td><td>script</td><td>Advanced: arbitrary Lua for anything not covered above</td></tr>
</tbody>
</table>
</div>
<p><strong>Cinematic Sequence module properties:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Steps</strong></td><td>ordered list</td><td>Sequence of steps (drag-to-reorder in the editor)</td></tr>
<tr><td><strong>Trigger</strong></td><td>connection</td><td>When to start the sequence</td></tr>
<tr><td><strong>Skippable</strong></td><td>checkbox</td><td>Whether the player can skip the entire sequence</td></tr>
<tr><td><strong>Pause sim</strong></td><td>checkbox</td><td>Whether gameplay pauses during the sequence (default: yes)</td></tr>
<tr><td><strong>Letterbox</strong></td><td>checkbox</td><td>Auto-enter letterbox mode when sequence starts (default: yes)</td></tr>
<tr><td><strong>On Complete</strong></td><td>connection (optional)</td><td>What fires when the sequence finishes</td></tr>
</tbody>
</table>
</div>
<p><strong>Visual editing:</strong> Steps are shown as a vertical timeline in the module’s expanded properties panel. Each step has a colored icon by type. Drag steps to reorder. Click a camera_pan step to see from/to positions highlighted on the map. Click “Preview from step” to test a subsequence without playing the whole thing.</p>
<p><strong>Example — mission intro cinematic:</strong></p>
<pre><code>Cinematic Sequence: "Mission 3 Intro"
  Trigger: mission_start
  Skippable: yes
  Pause sim: yes

  Steps:
  1. [letterbox]   enable, 0.5s transition
  2. [camera_pan]  from: player_base → to: enemy_fortress, 3s, ease_in_out
  3. [dialogue]    Stavros: "The enemy has fortified the river crossing."
  4. [play_sound]  artillery_distant.wav (global)
  5. [camera_shake] intensity: 0.3, duration: 0.5s
  6. [camera_pan]  to: bridge_crossing, 2s
  7. [dialogue]    Tanya: "I see a weak point in their eastern wall."
  8. [play_music]  "hell_march_v2", fade_in: 2s
  9. [letterbox]   disable, 0.5s transition
</code></pre>
<p>This replaces what would be 40+ lines of Lua with a visual drag-and-drop sequence. The designer sees the whole flow, reorders steps, previews specific moments, and never touches code.</p>
<h4 id="dynamic-music"><a class="header" href="#dynamic-music">Dynamic Music</a></h4>
<p><code>ic-audio</code> supports dynamic music states (combat/ambient/tension) that respond to game state (see <code>13-PHILOSOPHY.md</code> — Klepacki’s game-tempo philosophy). The editor exposes this through two mechanisms:</p>
<p><strong>1. Music Trigger module</strong> — simple track swap on trigger activation. Already in the module table. Good for scripted moments (“play Hell March when the tanks roll out”).</p>
<p><strong>2. Music Playlist module</strong> — manages an active playlist with playback modes:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>sequential</code></td><td>Play tracks in order, loop</td></tr>
<tr><td><code>shuffle</code></td><td>Random order, no immediate repeats</td></tr>
<tr><td><code>dynamic</code></td><td>Engine selects track based on game state — <code>combat</code> / <code>ambient</code> / <code>tension</code> / <code>victory</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Dynamic mode</strong> is the key feature. The designer tags tracks by mood:</p>
<pre><code class="language-yaml">music_playlist:
  combat:
    - hell_march
    - grinder
    - drill
  ambient:
    - fogger
    - trenches
    - mud
  tension:
    - radio_2
    - face_the_enemy
  victory:
    - credits
</code></pre>
<p>The engine monitors game state (active combat, unit losses, base threat, objective progress) and crossfades between mood categories automatically. No triggers required — the music responds to what’s happening. The designer curates the playlist; the engine handles transitions.</p>
<p><strong>Crossfade control:</strong> Music Trigger and Music Playlist modules both support <code>fade_time</code> — the duration of the crossfade between the current track and the new one. Default: 2 seconds. Set to 0 for a hard cut (dramatic moments).</p>
<h4 id="ambient-sound-zones"><a class="header" href="#ambient-sound-zones">Ambient Sound Zones</a></h4>
<p><strong>Ambient Sound Zone</strong> modules tie looping environmental audio to named regions. Walk units near a river — hear water. Move through a forest — hear birds and wind. Approach a factory — hear industrial machinery.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Region</strong></td><td>region picker</td><td>Named region this sound zone covers</td></tr>
<tr><td><strong>Sound</strong></td><td>file picker</td><td>Looping audio file</td></tr>
<tr><td><strong>Volume</strong></td><td>slider 0–100%</td><td>Base volume at the center of the region</td></tr>
<tr><td><strong>Falloff</strong></td><td>slider</td><td>How quickly sound fades at region edges (sharp → gradual)</td></tr>
<tr><td><strong>Active</strong></td><td>checkbox</td><td>Whether the zone starts active (can be toggled by triggers/Lua)</td></tr>
<tr><td><strong>Layer</strong></td><td>text</td><td>Optional layer assignment — zone activates/deactivates with its layer</td></tr>
</tbody>
</table>
</div>
<p>Ambient Sound Zones are <strong>render-side only</strong> (<code>ic-audio</code>) — they have zero sim impact and are not deterministic. They exist purely for atmosphere. The sound is spatialized: the camera’s position determines what the player hears and at what volume.</p>
<p>Multiple overlapping zones blend naturally. A bridge over a river in a forest plays water + birds + wind, with each source fading based on camera proximity to its region.</p>
<h4 id="eva-notification-system"><a class="header" href="#eva-notification-system">EVA Notification System</a></h4>
<p>EVA voice lines are how C&amp;C communicates game events to the player — “Construction complete,” “Unit lost,” “Enemy approaching.” The editor exposes EVA as a module for custom notifications:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Event type</strong></td><td>dropdown</td><td><code>custom</code> / <code>warning</code> / <code>info</code> / <code>critical</code></td></tr>
<tr><td><strong>Text</strong></td><td>text</td><td>Notification text shown in the message area</td></tr>
<tr><td><strong>Audio</strong></td><td>file picker</td><td>Voice line audio file</td></tr>
<tr><td><strong>Trigger</strong></td><td>connection</td><td>When to fire the notification</td></tr>
<tr><td><strong>Cooldown</strong></td><td>slider</td><td>Minimum time before this notification can fire again</td></tr>
<tr><td><strong>Priority</strong></td><td>dropdown</td><td><code>low</code> / <code>normal</code> / <code>high</code> / <code>critical</code></td></tr>
</tbody>
</table>
</div>
<p>Priority determines queuing behavior — critical notifications interrupt lower-priority ones; low-priority notifications wait. This prevents EVA spam during intense battles while ensuring critical alerts always play.</p>
<p><strong>Built-in EVA events</strong> (game module provides defaults for standard events: unit lost, building destroyed, harvester under attack, insufficient funds, etc.). Custom EVA modules are for mission-specific notifications — “The bridge has been rigged with explosives,” “Reinforcements are en route.”</p>
<h4 id="letterbox--cinematic-mode"><a class="header" href="#letterbox--cinematic-mode">Letterbox / Cinematic Mode</a></h4>
<p>The <strong>Letterbox Mode</strong> module toggles cinematic presentation:</p>
<ul>
<li><strong>Letterbox bars</strong> — black bars at top and bottom of screen, creating a widescreen aspect ratio</li>
<li><strong>HUD hidden</strong> — sidebar, minimap, resource bar, unit selection all hidden</li>
<li><strong>Input restricted</strong> — player cannot issue orders (optional — some sequences allow camera panning)</li>
<li><strong>Transition time</strong> — bars slide in/out smoothly (configurable)</li>
</ul>
<p>Letterbox mode is automatically entered by Cinematic Sequences when <code>letterbox: true</code> (the default). It can also be triggered independently — a Letterbox Mode module connected to a trigger enters cinematic mode for dramatic moments without a full sequence (e.g., a dramatic camera pan to a nuclear explosion, then back to gameplay).</p>
<h4 id="media-in-campaigns"><a class="header" href="#media-in-campaigns">Media in Campaigns</a></h4>
<p>All media modules work within the campaign editor’s intermission system:</p>
<ul>
<li><strong>Fullscreen video</strong> before missions (briefing FMVs)</li>
<li><strong>Music Playlist</strong> per campaign node (each mission can have its own playlist, or inherit from the campaign default)</li>
<li><strong>Dialogue with audio</strong> in intermission screens — character portraits with voice-over</li>
<li><strong>Ambient sound</strong> in intermission screens (command tent ambiance, war room hum)</li>
</ul>
<p>The campaign node properties (briefing, debriefing) support media references:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Briefing video</strong></td><td>file picker</td><td>Optional FMV played before the mission (fullscreen)</td></tr>
<tr><td><strong>Briefing audio</strong></td><td>file picker</td><td>Voice-over for text briefing (if no video)</td></tr>
<tr><td><strong>Briefing music</strong></td><td>track picker</td><td>Music playing during the briefing screen</td></tr>
<tr><td><strong>Debrief audio</strong></td><td>file picker (×N)</td><td>Per-outcome voice-over for debrief screens</td></tr>
<tr><td><strong>Debrief video</strong></td><td>file picker (×N)</td><td>Per-outcome FMV (optional)</td></tr>
</tbody>
</table>
</div>
<p>This means a campaign creator can build the full original RA experience — FMV briefing → mission with in-game radar comms → debrief with per-outcome results — entirely through the visual editor.</p>
<h4 id="lua-media-api-advanced"><a class="header" href="#lua-media-api-advanced">Lua Media API (Advanced)</a></h4>
<p>All media modules map to Lua functions for advanced scripting. The <code>Media</code> global (OpenRA-compatible, D024) provides the baseline; IC extensions add richer control:</p>
<pre><code class="language-lua">-- OpenRA-compatible (work identically)
Media.PlaySpeech("eva_building_captured")    -- EVA notification
Media.PlaySound("explosion_large")           -- Sound effect
Media.PlayMusic("hell_march")                -- Music track
Media.DisplayMessage("Bridge destroyed!", "warning")  -- Text message

-- IC extensions (additive)
Media.PlayVideo("briefing_03.vqa", "fullscreen", { skippable = true })
Media.PlayVideo("commander_call.mp4", "radar_comm")
Media.PlayVideo("heli_arrives.webm", "picture_in_picture")

Media.SetMusicPlaylist({ "hell_march", "grinder" }, "shuffle")
Media.SetMusicMode("dynamic")    -- switch to dynamic mood-based selection
Media.CrossfadeTo("fogger", 3.0) -- manual crossfade with duration

Media.SetAmbientZone("forest_region", "birds_wind.ogg", { volume = 0.7 })
Media.SetAmbientZone("river_region", "water_flow.ogg", { volume = 0.5 })

-- Cinematic sequence from Lua (for procedural cutscenes)
local seq = Media.CreateSequence({ skippable = true, pause_sim = true })
seq:AddStep("letterbox", { enable = true, transition = 0.5 })
seq:AddStep("camera_pan", { to = bridge_pos, duration = 3.0 })
seq:AddStep("dialogue", { speaker = "Tanya", text = "I see them.", audio = "tanya_03.wav" })
seq:AddStep("play_sound", { ref = "artillery.wav" })
seq:AddStep("camera_shake", { intensity = 0.4, duration = 0.5 })
seq:AddStep("letterbox", { enable = false, transition = 0.5 })
seq:Play()
</code></pre>
<p>The visual modules and Lua API are interchangeable — a Cinematic Sequence created in the editor generates the same data as one built in Lua. Advanced users can start with the visual editor and extend with Lua; Lua-first users get the same capabilities without the GUI.</p>
<h3 id="preview--test"><a class="header" href="#preview--test">Preview / Test</a></h3>
<ul>
<li><strong>Preview button</strong> — starts the sim from current editor state. Play the mission, then return to editor. No compilation, no export, no separate process.</li>
<li><strong>Play from cursor</strong> — start the preview with the camera at the current editor position (Eden Editor’s “play from here”)</li>
<li><strong>Speed controls</strong> — preview at 2x/4x/8x to quickly reach later mission stages</li>
<li><strong>Instant restart</strong> — reset to editor state without re-entering the editor</li>
</ul>
<h3 id="simple-vs-advanced-mode"><a class="header" href="#simple-vs-advanced-mode">Simple vs Advanced Mode</a></h3>
<p>Inspired by OFP’s Easy/Advanced toggle:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Simple Mode</th><th>Advanced Mode</th></tr>
</thead>
<tbody>
<tr><td>Entity placement</td><td>✓</td><td>✓</td></tr>
<tr><td>Faction/facing/health</td><td>✓</td><td>✓</td></tr>
<tr><td>Basic triggers (win/lose/timer)</td><td>✓</td><td>✓</td></tr>
<tr><td>Waypoints (move/patrol/guard)</td><td>✓</td><td>✓</td></tr>
<tr><td>Modules</td><td>✓</td><td>✓</td></tr>
<tr><td>Probability of Presence</td><td>—</td><td>✓</td></tr>
<tr><td>Condition of Presence</td><td>—</td><td>✓</td></tr>
<tr><td>Custom Lua conditions</td><td>—</td><td>✓</td></tr>
<tr><td>Init scripts per entity</td><td>—</td><td>✓</td></tr>
<tr><td>Countdown/Timeout timers</td><td>—</td><td>✓</td></tr>
<tr><td>Min/Mid/Max randomization</td><td>—</td><td>✓</td></tr>
<tr><td>Connection lines</td><td>—</td><td>✓</td></tr>
<tr><td>Layer management</td><td>—</td><td>✓</td></tr>
<tr><td>Campaign editor</td><td>—</td><td>✓</td></tr>
<tr><td>Named regions</td><td>—</td><td>✓</td></tr>
<tr><td>Variables panel</td><td>—</td><td>✓</td></tr>
<tr><td>Inline Lua scripts on entities</td><td>—</td><td>✓</td></tr>
<tr><td>External script files panel</td><td>—</td><td>✓</td></tr>
<tr><td>Trigger folders &amp; flow graph</td><td>—</td><td>✓</td></tr>
<tr><td>Media modules (basic)</td><td>✓</td><td>✓</td></tr>
<tr><td>Video playback</td><td>✓</td><td>✓</td></tr>
<tr><td>Music trigger / playlist</td><td>✓</td><td>✓</td></tr>
<tr><td>Cinematic sequences</td><td>—</td><td>✓</td></tr>
<tr><td>Ambient sound zones</td><td>—</td><td>✓</td></tr>
<tr><td>Letterbox / cinematic mode</td><td>—</td><td>✓</td></tr>
<tr><td>Lua Media API</td><td>—</td><td>✓</td></tr>
<tr><td>Intermission screens</td><td>—</td><td>✓</td></tr>
<tr><td>Dialogue editor</td><td>—</td><td>✓</td></tr>
<tr><td>Campaign state dashboard</td><td>—</td><td>✓</td></tr>
<tr><td>Multiplayer / co-op properties</td><td>—</td><td>✓</td></tr>
<tr><td>Game mode templates</td><td>✓</td><td>✓</td></tr>
</tbody>
</table>
</div>
<p>Simple mode covers 80% of what a casual scenario creator needs. Advanced mode exposes the full power. Same data format — a mission created in Simple mode can be opened in Advanced mode and extended.</p>
<h3 id="campaign-editor"><a class="header" href="#campaign-editor">Campaign Editor</a></h3>
<p>D021 defines the campaign <em>system</em> — branching mission graphs, persistent rosters, story flags. But a system without an editor means campaigns are hand-authored YAML, which limits who can create them. The Campaign Editor makes D021’s full power visual.</p>
<p>Every RTS editor ever shipped treats missions as isolated units. Warcraft III’s World Editor came closest — it had a campaign screen with mission ordering and global variables — but even that was a flat list with linear flow. No visual branching, no state flow visualization, no intermission screens, no dialogue trees. The result: almost nobody creates custom RTS campaigns, because the tooling makes it miserable.</p>
<p>The Campaign Editor operates at a level above the Scenario Editor. Where the Scenario Editor zooms into one mission, the Campaign Editor zooms out to see the entire campaign structure. Double-click a mission node → the Scenario Editor opens for that mission. Back out → you’re at the campaign graph again.</p>
<h4 id="visual-campaign-graph"><a class="header" href="#visual-campaign-graph">Visual Campaign Graph</a></h4>
<p>The core view: missions as nodes, outcomes as directed edges.</p>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                    Campaign: Red Tide Rising                     │
│                                                                  │
│    ┌─────────┐   victory    ┌──────────┐   bridge_held           │
│    │ Mission │─────────────→│ Mission  │───────────────→ ...     │
│    │   1     │              │   2      │                         │
│    │ Beach   │   defeat     │ Bridge   │   bridge_lost           │
│    │ Landing │──────┐       │ Assault  │──────┐                  │
│    └─────────┘      │       └──────────┘      │                  │
│                     │                         │                  │
│                     ▼                         ▼                  │
│               ┌──────────┐             ┌──────────┐             │
│               │ Mission  │             │ Mission  │             │
│               │   1B     │             │   3B     │             │
│               │ Retreat  │             │ Fallback │             │
│               └──────────┘             └──────────┘             │
│                                                                  │
│   [+ Add Mission]  [+ Add Transition]  [Validate Graph]         │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>Node (mission) properties:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Mission file</strong></td><td>Link to the scenario (created in Scenario Editor)</td></tr>
<tr><td><strong>Display name</strong></td><td>Shown in campaign graph and briefing</td></tr>
<tr><td><strong>Outcomes</strong></td><td>Named results this mission can produce (e.g., <code>victory</code>, <code>defeat</code>, <code>bridge_intact</code>)</td></tr>
<tr><td><strong>Briefing</strong></td><td>Text/audio/portrait shown before the mission</td></tr>
<tr><td><strong>Debriefing</strong></td><td>Text/audio shown after the mission, per outcome</td></tr>
<tr><td><strong>Intermission</strong></td><td>Optional between-mission screen (see Intermission Screens below)</td></tr>
<tr><td><strong>Roster in</strong></td><td>What units the player receives: <code>none</code>, <code>carry_forward</code>, <code>preset</code>, <code>merge</code></td></tr>
<tr><td><strong>Roster out</strong></td><td>Carryover mode for surviving units: <code>none</code>, <code>surviving</code>, <code>extracted</code>, <code>selected</code>, <code>custom</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Edge (transition) properties:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>From outcome</strong></td><td>Which named outcome triggers this transition</td></tr>
<tr><td><strong>To mission</strong></td><td>Destination mission node</td></tr>
<tr><td><strong>Condition</strong></td><td>Optional Lua expression or story flag check (e.g., <code>Flag.get("scientist_rescued")</code>)</td></tr>
<tr><td><strong>Weight</strong></td><td>Probability weight when multiple edges share the same outcome (see below)</td></tr>
<tr><td><strong>Roster filter</strong></td><td>Override roster carryover for this specific path</td></tr>
</tbody>
</table>
</div>
<h4 id="randomized-and-conditional-paths"><a class="header" href="#randomized-and-conditional-paths">Randomized and Conditional Paths</a></h4>
<p>D021 defines deterministic branching — outcome X always leads to mission Y. The Campaign Editor extends this with weighted and conditional edges, enabling randomized campaign structures.</p>
<p><strong>Weighted random:</strong> When multiple edges share the same outcome, weights determine probability. The roll is seeded from the campaign save (deterministic for replays).</p>
<pre><code class="language-yaml"># Mission 3 outcome "victory" → random next mission
transitions:
  - from_outcome: victory
    to: mission_4a_snow      # weight 40%
    weight: 40
  - from_outcome: victory
    to: mission_4b_desert    # weight 60%
    weight: 60
</code></pre>
<p>Visually in the graph editor, weighted edges show their probability and use varying line thickness.</p>
<p><strong>Conditional edges:</strong> An edge with a condition is only eligible if the condition passes. Conditions are evaluated before weights. This enables “if you rescued the scientist, always go to the lab mission; otherwise, random between two alternatives.”</p>
<p><strong>Mission pools:</strong> A pool node represents “pick N missions from this set” — the campaign equivalent of side quests. The player gets a random subset, plays them in any order, then proceeds. Enables roguelike campaign structures.</p>
<pre><code>┌──────────┐         ┌─────────────────┐         ┌──────────┐
│ Mission  │────────→│   Side Mission   │────────→│ Mission  │
│    3     │         │   Pool (2 of 5)  │         │    4     │
└──────────┘         │                  │         └──────────┘
                     │ ☐ Raid Supply    │
                     │ ☐ Rescue POWs    │
                     │ ☐ Sabotage Rail  │
                     │ ☐ Defend Village │
                     │ ☐ Naval Strike   │
                     └─────────────────┘
</code></pre>
<p>Mission pools are a natural fit for the persistent roster system — side missions that strengthen (or deplete) the player’s forces before a major battle.</p>
<h4 id="persistent-state-dashboard"><a class="header" href="#persistent-state-dashboard">Persistent State Dashboard</a></h4>
<p>The biggest reason campaign creation is painful in every RTS editor: you can’t see what state flows between missions. Story flags are set in Lua buried inside mission scripts. Roster carryover is configured in YAML you never visualize. Variables disappear between missions unless you manually manage them.</p>
<p>The <strong>Persistent State Dashboard</strong> makes campaign state visible and editable in the GUI.</p>
<p><strong>Roster view:</strong></p>
<pre><code>┌──────────────────────────────────────────────────────┐
│  Campaign Roster                                      │
│                                                       │
│  Mission 1 → Mission 2:  Carryover: surviving         │
│  ├── Tanya (named hero)     ★ Must survive            │
│  ├── Medium Tanks ×4        ↝ Survivors carry forward  │
│  └── Engineers ×2           ↝ Survivors carry forward  │
│                                                       │
│  Mission 2 → Mission 3:  Carryover: extracted          │
│  ├── Extraction zone: bridge_south                    │
│  └── Only units in zone at mission end carry forward  │
│                                                       │
│  Named Characters: Tanya, Volkov, Stavros              │
│  Equipment Pool: Captured MiG, Prototype Chrono        │
└──────────────────────────────────────────────────────┘
</code></pre>
<p><strong>Story flags view:</strong> A table of every flag across the entire campaign — where it’s set, where it’s read, current value in test runs. See at a glance: “The flag <code>bridge_destroyed</code> is set in Mission 2’s trigger #14, read in Mission 4’s Condition of Presence on the bridge entity and Mission 5’s briefing text.”</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Flag</th><th>Set in</th><th>Read in</th><th>Type</th></tr>
</thead>
<tbody>
<tr><td><code>bridge_destroyed</code></td><td>Mission 2, trigger 14</td><td>Mission 4 (CoP), Mission 5 (briefing)</td><td>switch</td></tr>
<tr><td><code>scientist_rescued</code></td><td>Mission 3, Lua script</td><td>Mission 4 (edge condition)</td><td>switch</td></tr>
<tr><td><code>tanks_captured</code></td><td>Mission 2, debrief</td><td>Mission 3 (roster merge)</td><td>counter</td></tr>
<tr><td><code>player_reputation</code></td><td>Multiple missions</td><td>Mission 6 (dialogue branches)</td><td>counter</td></tr>
</tbody>
</table>
</div>
<p><strong>Campaign variables:</strong> Separate from per-mission variables (Variables Panel). Campaign variables persist across ALL missions. Per-mission variables reset. The dashboard shows which scope each variable belongs to and highlights conflicts (same name in both scopes).</p>
<h4 id="intermission-screens"><a class="header" href="#intermission-screens">Intermission Screens</a></h4>
<p>Between missions, the player sees an intermission — not just a text briefing, but a customizable screen layout. This is where campaigns become more than “mission list” and start feeling like a <em>game within the game</em>.</p>
<p><strong>Built-in intermission templates:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Template</th><th>Layout</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><strong>Briefing Only</strong></td><td>Portrait + text + “Begin Mission” button</td><td>Simple campaigns, classic RA style</td></tr>
<tr><td><strong>Roster Management</strong></td><td>Unit list with keep/dismiss, equipment assignment, formation arrangement</td><td>OFP: Resistance style unit management</td></tr>
<tr><td><strong>Base Screen</strong></td><td>Persistent base view — spend resources on upgrades that carry forward</td><td>Between-mission base building (C&amp;C3 style)</td></tr>
<tr><td><strong>Shop / Armory</strong></td><td>Campaign inventory + purchase panel + currency</td><td>RPG-style equipment management</td></tr>
<tr><td><strong>Dialogue</strong></td><td>Portrait + branching text choices (see Dialogue Editor below)</td><td>Story-driven campaigns, RPG conversations</td></tr>
<tr><td><strong>World Map</strong></td><td>Map with mission locations — player chooses next mission from available nodes</td><td>Non-linear campaigns, Total War style</td></tr>
<tr><td><strong>Debrief + Stats</strong></td><td>Mission results, casualties, performance grade, story flag changes</td><td>Post-mission feedback</td></tr>
<tr><td><strong>Custom</strong></td><td>Empty canvas — arrange any combination of panels via the layout editor</td><td>Total creative freedom</td></tr>
</tbody>
</table>
</div>
<p>Intermissions are defined per campaign node (between “finish Mission 2” and “start Mission 3”). They can chain: debrief → roster management → briefing → begin mission.</p>
<p><strong>Intermission panels (building blocks):</strong></p>
<ul>
<li><strong>Text panel</strong> — rich text with variable substitution (<code>"Commander, we lost {Var.get('casualties')} soldiers."</code>).</li>
<li><strong>Portrait panel</strong> — character portrait + name. Links to Named Characters.</li>
<li><strong>Roster panel</strong> — surviving units from previous mission. Player can dismiss, reorganize, assign equipment.</li>
<li><strong>Inventory panel</strong> — campaign-wide items. Drag onto units to equip. Purchase from shop with campaign currency.</li>
<li><strong>Choice panel</strong> — buttons that set story flags or campaign variables. “Execute the prisoner? [Yes] [No]” → sets <code>prisoner_executed</code> flag.</li>
<li><strong>Map panel</strong> — shows campaign geography. Highlights available next missions if using mission pools.</li>
<li><strong>Stats panel</strong> — mission performance: time, casualties, objectives completed, units destroyed.</li>
<li><strong>Custom Lua panel</strong> — advanced panel that runs arbitrary Lua to generate content dynamically.</li>
</ul>
<p>These panels compose freely. A “Base Screen” template is just a preset arrangement: roster panel on the left, inventory panel center, stats panel right, briefing text bottom. The Custom template starts empty and lets the designer arrange any combination.</p>
<h4 id="dialogue-editor"><a class="header" href="#dialogue-editor">Dialogue Editor</a></h4>
<p>Branching dialogue isn’t RPG-exclusive — it’s what separates a campaign with a story from a campaign that’s just a mission list. “Commander, we’ve intercepted enemy communications. Do we attack now or wait for reinforcements?” That’s a dialogue tree. The choice sets a story flag that changes the next mission’s layout.</p>
<p>The Dialogue Editor is a visual branching tree editor, similar to tools like Twine or Ink but built into the scenario editor.</p>
<pre><code>┌──────────────────────────────────────────────────────┐
│  Dialogue: Mission 3 Briefing                         │
│                                                       │
│  ┌────────────────────┐                               │
│  │ STAVROS:            │                               │
│  │ "The bridge is       │                               │
│  │  heavily defended." │                               │
│  └────────┬───────────┘                               │
│           │                                            │
│     ┌─────┴─────┐                                      │
│     │           │                                      │
│  ┌──▼───┐  ┌───▼────┐                                  │
│  │Attack│  │Flank   │                                  │
│  │Now   │  │Through │                                  │
│  │      │  │Forest  │                                  │
│  └──┬───┘  └───┬────┘                                  │
│     │          │                                       │
│  sets:       sets:                                     │
│  approach=   approach=                                 │
│  "direct"    "flank"                                   │
│     │          │                                       │
│  ┌──▼──────────▼──┐                                    │
│  │ TANYA:          │                                    │
│  │ "I'll take       │                                    │
│  │  point."         │                                    │
│  └─────────────────┘                                    │
└──────────────────────────────────────────────────────┘
</code></pre>
<p><strong>Dialogue node properties:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Speaker</strong></td><td>Character name + portrait reference</td></tr>
<tr><td><strong>Text</strong></td><td>Dialogue line (supports variable substitution)</td></tr>
<tr><td><strong>Audio</strong></td><td>Optional voice-over reference</td></tr>
<tr><td><strong>Choices</strong></td><td>Player responses — each is an outgoing edge</td></tr>
<tr><td><strong>Condition</strong></td><td>Node only appears if condition is true (enables adaptive dialogue)</td></tr>
<tr><td><strong>Effects</strong></td><td>On reaching this node: set flags, adjust variables, give items</td></tr>
</tbody>
</table>
</div>
<p><strong>Conditional dialogue:</strong> Nodes can have conditions — “Only show this line if <code>scientist_rescued</code> is true.” This means the same dialogue tree adapts to campaign state. A character references events from earlier missions without the designer creating separate trees per path.</p>
<p><strong>Dialogue in missions:</strong> Dialogue trees aren’t limited to intermissions. They can trigger during a mission — an NPC unit triggers a dialogue when approached or when a trigger fires. The dialogue pauses the game (or runs alongside it, designer’s choice) and the player’s choice sets flags that affect the mission in real-time.</p>
<h4 id="named-characters"><a class="header" href="#named-characters">Named Characters</a></h4>
<p>A <strong>named character</strong> is a persistent entity identity that survives across missions. Not a specific unit instance (those die) — a character definition that can have multiple appearances.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Name</strong></td><td>Display name (“Tanya”, “Commander Volkov”)</td></tr>
<tr><td><strong>Portrait</strong></td><td>Image reference for dialogue and intermission screens</td></tr>
<tr><td><strong>Unit type</strong></td><td>Default unit type when spawned (can change per mission)</td></tr>
<tr><td><strong>Traits</strong></td><td>Arbitrary key-value pairs (strength, charisma, rank — designer-defined)</td></tr>
<tr><td><strong>Inventory</strong></td><td>Items this character carries (from campaign inventory system)</td></tr>
<tr><td><strong>Biography</strong></td><td>Text shown in roster screen, updated by Lua as the campaign progresses</td></tr>
<tr><td><strong>Must survive</strong></td><td>If true, character death → mission failure (or specific outcome)</td></tr>
<tr><td><strong>Death outcome</strong></td><td>Named outcome triggered if this character dies (e.g., <code>tanya_killed</code>)</td></tr>
</tbody>
</table>
</div>
<p>Named characters bridge scenarios and intermissions. Tanya in Mission 1 is the same Tanya in Mission 5 — same veterancy, same kill count, same equipment. If she dies in Mission 3 and doesn’t have “must survive,” the campaign continues without her — and future dialogue trees skip her lines via conditions.</p>
<p>This is the primitive that makes RPG campaigns possible. A designer creates 6 named characters, gives them traits and portraits, writes dialogue between them, and lets the player manage their roster between missions. That’s an RPG party in an RTS shell — no engine changes required, just creative use of the campaign editor’s building blocks.</p>
<h4 id="campaign-inventory"><a class="header" href="#campaign-inventory">Campaign Inventory</a></h4>
<p>Persistent items that exist at the campaign level, not within any specific mission.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Name</strong></td><td>Item identifier (<code>prototype_chrono</code>, <code>captured_mig</code>)</td></tr>
<tr><td><strong>Display</strong></td><td>Name, icon, description shown in intermission screens</td></tr>
<tr><td><strong>Quantity</strong></td><td>Stack count (1 for unique items, N for consumables)</td></tr>
<tr><td><strong>Category</strong></td><td>Grouping for inventory panel (equipment, intel, resources)</td></tr>
<tr><td><strong>Effects</strong></td><td>Optional Lua — what happens when used/equipped</td></tr>
<tr><td><strong>Assignable</strong></td><td>Can be assigned to named characters in roster screen</td></tr>
</tbody>
</table>
</div>
<p>Items are added via Lua (<code>Campaign.add_item("captured_mig", 1)</code>) or via debrief/intermission choices. They’re spent, equipped, or consumed in later missions or intermissions.</p>
<p>Combined with named characters and the roster screen: a player captures enemy equipment in Mission 2, assigns it to a character in the intermission, and that character spawns with it in Mission 3. The system is general-purpose — “items” can be weapons, vehicles, intel documents, key cards, magical artifacts, or anything the designer defines.</p>
<h4 id="campaign-testing"><a class="header" href="#campaign-testing">Campaign Testing</a></h4>
<p>The Campaign Editor includes tools for testing campaign flow without playing every mission to completion:</p>
<ul>
<li><strong>Graph validation</strong> — checks for dead ends (outcomes with no outgoing edge), unreachable missions, circular paths (unless intentional), and missing mission files</li>
<li><strong>Jump to mission</strong> — start any mission with simulated campaign state (set flags, roster, and inventory to test a specific path)</li>
<li><strong>Fast-forward state</strong> — manually set campaign variables and flags to simulate having played earlier missions</li>
<li><strong>Path coverage</strong> — highlights which campaign paths have been test-played and which haven’t. Color-coded: green (tested), yellow (partially tested), red (untested)</li>
<li><strong>Campaign playthrough</strong> — play the entire campaign with accelerated sim (or auto-resolve missions) to verify flow and state propagation</li>
<li><strong>State inspector</strong> — during preview, shows live campaign state: current flags, roster, inventory, variables, which path was taken</li>
</ul>
<h4 id="reference-material-campaign-editors"><a class="header" href="#reference-material-campaign-editors">Reference Material (Campaign Editors)</a></h4>
<p>The campaign editor design draws from these (in addition to the scenario editor references above):</p>
<ul>
<li><strong>Warcraft III World Editor (2002):</strong> The closest any RTS came to campaign editing — campaign screen with mission ordering, cinematic editor, global variables persistent across maps. Still linear and limited: no visual branching, no roster management, no intermission screen customization. IC takes WC3’s foundation and adds the graph, state, and intermission layers.</li>
<li><strong>RPG Maker (1992–present):</strong> Campaign-level persistent variables, party management, item/equipment systems, branching dialogue. Proves these systems work for non-programmers. IC adapts the persistence model for RTS context.</li>
<li><strong>Twine / Ink (interactive fiction tools):</strong> Visual branching narrative editors. Twine’s node-and-edge graph directly inspired IC’s campaign graph view. Ink’s conditional text (“You remember the bridge{bridge_destroyed: ’s destruction| still standing}”) inspired IC’s variable substitution in dialogue.</li>
<li><strong>Heroes of Might and Magic III (1999):</strong> Campaign with carryover — hero stats, army, artifacts persist between maps. Proved that persistent state between RTS-adjacent missions creates investment. Limited to linear ordering.</li>
<li><strong>FTL / Slay the Spire (roguelikes):</strong> Randomized mission path selection, persistent resources, risk/reward side missions. Inspired IC’s mission pools and weighted random paths.</li>
<li><strong>OFP: Resistance (2002):</strong> The gold standard for persistent campaigns — surviving soldiers, captured equipment, emotional investment. Every feature in IC’s campaign editor exists because OFP: Resistance proved persistent campaigns are transformative.</li>
</ul>
<h3 id="game-master-mode-zeus-inspired"><a class="header" href="#game-master-mode-zeus-inspired">Game Master Mode (Zeus-Inspired)</a></h3>
<p>A real-time scenario manipulation mode where one player (the Game Master) controls the scenario while others play. Derived from the scenario editor’s UI but operates on a live game.</p>
<p><strong>Use cases:</strong></p>
<ul>
<li><strong>Cooperative campaigns</strong> — a human GM controls the enemy faction, placing reinforcements, directing attacks, adjusting difficulty in real-time based on how players are doing</li>
<li><strong>Training</strong> — a GM creates escalating challenges for new players</li>
<li><strong>Events</strong> — community game nights with a live GM creating surprises</li>
<li><strong>Content testing</strong> — mission designers test their scenarios with real players while making live adjustments</li>
</ul>
<p><strong>Game Master controls:</strong></p>
<ul>
<li>Place/remove units and buildings (from a budget — prevents flooding)</li>
<li>Direct AI unit groups (attack here, retreat, patrol)</li>
<li>Change weather, time of day</li>
<li>Trigger scripted events (reinforcements, briefings, explosions)</li>
<li>Reveal/hide map areas</li>
<li>Adjust resource levels</li>
<li>Pause sim for dramatic reveals (if all players agree)</li>
</ul>
<p><strong>Not included at launch:</strong> Player control of individual units (RTS is about armies, not individual soldiers). The GM operates at the strategic level — directing groups, managing resources, triggering events.</p>
<p><strong>Per-player undo:</strong> In multiplayer editing contexts (and Game Master mode specifically), undo is scoped per-actor. The GM’s undo reverts only GM actions, not player orders or other players’ actions. This follows Garry’s Mod’s per-player undo model — in a shared session, pressing undo reverts YOUR last action, not the last global action. For the single-player editor, undo is global (only one actor).</p>
<p><strong>Phase:</strong> Game Master mode is a Phase 6b deliverable. It reuses 90% of the scenario editor’s systems — the main new work is the real-time overlay UI and budget/permission system.</p>
<h3 id="publishing"><a class="header" href="#publishing">Publishing</a></h3>
<p>Scenarios created in the editor export as standard IC mission format (YAML map + Lua scripts + assets). They can be:</p>
<ul>
<li>Saved locally</li>
<li>Published to Workshop (D030) with one click</li>
<li>Shared as files</li>
<li>Used in campaigns (D021) — or created directly in the Campaign Editor</li>
<li>Assembled into full campaigns and published as campaign packs</li>
<li>Loaded by the LLM for remixing (D016)</li>
</ul>
<h3 id="replay-to-scenario-pipeline"><a class="header" href="#replay-to-scenario-pipeline">Replay-to-Scenario Pipeline</a></h3>
<p>Replays are the richest source of gameplay data in any RTS — every order, every battle, every building placement, every dramatic moment. IC already stores replays as deterministic order streams and enriches them with structured gameplay events (D031) in SQLite (D034). The Replay-to-Scenario pipeline turns that data into editable scenarios.</p>
<p>Replays already contain what’s hardest to design from scratch: pacing, escalation, and dramatic turning points. The pipeline extracts that structure into an editable scenario skeleton — a designer adds narrative and polish on top.</p>
<h4 id="two-modes-direct-extraction-and-llm-generation"><a class="header" href="#two-modes-direct-extraction-and-llm-generation">Two Modes: Direct Extraction and LLM Generation</a></h4>
<p><strong>Direct extraction (no LLM required):</strong> Deterministic, mechanical conversion of replay data into editor entities. This always works, even without an LLM configured.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Extracted Element</th><th>Source Data</th><th>Editor Result</th></tr>
</thead>
<tbody>
<tr><td><strong>Map &amp; terrain</strong></td><td>Replay’s initial map state</td><td>Full terrain imported — tiles, resources, cliffs, water</td></tr>
<tr><td><strong>Starting positions</strong></td><td>Initial unit/building placements per player</td><td>Entities placed with correct faction, position, facing</td></tr>
<tr><td><strong>Movement paths</strong></td><td><code>OrderIssued</code> (move orders) over time</td><td>Waypoints along actual routes taken — patrol paths, attack routes, retreat lines</td></tr>
<tr><td><strong>Build order timeline</strong></td><td><code>BuildingPlaced</code> events with tick timestamps</td><td>Building entities with <code>timer_elapsed</code> triggers matching the original timing</td></tr>
<tr><td><strong>Combat hotspots</strong></td><td>Clusters of <code>CombatEngagement</code> events in spatial proximity</td><td>Named regions at cluster centroids — “Combat Zone 1 (2400, 1800),” “Combat Zone 2 (800, 3200).” The LLM path (below) upgrades these to human-readable names like “Bridge Assault” using map feature context.</td></tr>
<tr><td><strong>Unit composition</strong></td><td><code>UnitCreated</code> events per faction per time window</td><td>Wave Spawner modules mimicking the original army buildup timing</td></tr>
<tr><td><strong>Key moments</strong></td><td>Spikes in event density (kills/sec, orders/sec)</td><td>Trigger markers at dramatic moments — editor highlights them in the timeline</td></tr>
<tr><td><strong>Resource flow</strong></td><td><code>HarvestDelivered</code> events</td><td>Resource deposits and harvester assignments matching the original economy</td></tr>
</tbody>
</table>
</div>
<p>The result: a scenario skeleton with correct terrain, unit placements, waypoints tracing the actual battle flow, and trigger points at dramatic moments. It’s mechanically accurate but has no story — no briefing, no objectives, no dialogue. A designer opens it in the editor and adds narrative on top.</p>
<p><strong>LLM-powered generation (D016, requires LLM configured):</strong> The LLM reads the gameplay event log and generates the narrative layer that direct extraction can’t provide.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Generated Element</th><th>LLM Input</th><th>LLM Output</th></tr>
</thead>
<tbody>
<tr><td><strong>Mission briefing</strong></td><td>Event timeline summary, factions, map name, outcome</td><td>“Commander, intelligence reports enemy armor massing at the river crossing…”</td></tr>
<tr><td><strong>Objectives</strong></td><td>Key events + outcome</td><td>Primary: “Destroy the enemy base.” Secondary: “Capture the tech center before it’s razed.”</td></tr>
<tr><td><strong>Dialogue</strong></td><td>Combat events, faction interactions, dramatic moments</td><td>In-mission dialogue triggered at key moments — characters react to what originally happened</td></tr>
<tr><td><strong>Difficulty curve</strong></td><td>Event density over time, casualty rates</td><td>Wave timing and composition tuned to recreate the original difficulty arc</td></tr>
<tr><td><strong>Story context</strong></td><td>Faction composition, map geography, battle outcome</td><td>Narrative framing that makes the mechanical events feel like a story</td></tr>
<tr><td><strong>Named characters</strong></td><td>High-performing units (most kills, longest survival)</td><td>Surviving units promoted to named characters with generated backstories</td></tr>
<tr><td><strong>Alternative paths</strong></td><td>What-if analysis of critical moments</td><td>Branch points: “What if the bridge assault failed?” → generates alternate mission variant</td></tr>
</tbody>
</table>
</div>
<p>The LLM output is standard YAML + Lua — the same format as hand-crafted missions. Everything is editable in the editor. The LLM is a starting point, not a black box.</p>
<h4 id="workflow"><a class="header" href="#workflow">Workflow</a></h4>
<pre><code>┌─────────────┐     ┌──────────────────┐     ┌────────────────────┐     ┌──────────────┐
│   Replay    │────→│  Event Log       │────→│  Replay-to-Scenario │────→│   Scenario   │
│   Browser   │     │  (SQLite, D034)  │     │  Pipeline           │     │   Editor     │
└─────────────┘     └──────────────────┘     │                     │     └──────────────┘
                                             │  Direct extraction  │
                                             │  + LLM (optional)   │
                                             └────────────────────┘
</code></pre>
<ol>
<li><strong>Browse replays</strong> — open the replay browser, select a replay (or multiple — a tournament series, a campaign run)</li>
<li><strong>“Create Scenario from Replay”</strong> — button in the replay browser context menu</li>
<li><strong>Import settings dialog:</strong></li>
</ol>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Setting</th><th>Options</th><th>Default</th></tr>
</thead>
<tbody>
<tr><td><strong>Perspective</strong></td><td>Player 1’s view / Player 2’s view / Observer (full map)</td><td>Player 1</td></tr>
<tr><td><strong>Time range</strong></td><td>Full replay / Custom range (tick start – tick end)</td><td>Full replay</td></tr>
<tr><td><strong>Extract waypoints</strong></td><td>All movement / Combat movement only / Key maneuvers only</td><td>Key maneuvers only</td></tr>
<tr><td><strong>Combat zones</strong></td><td>Mark all engagements / Major battles only (threshold)</td><td>Major battles only</td></tr>
<tr><td><strong>Generate narrative</strong></td><td>Yes (requires LLM) / No (direct extraction only)</td><td>Yes if LLM available</td></tr>
<tr><td><strong>Difficulty</strong></td><td>Match original / Easier / Harder / Let LLM tune</td><td>Match original</td></tr>
<tr><td><strong>Playable as</strong></td><td>Player 1’s faction / Player 2’s faction / New player vs AI</td><td>New player vs AI</td></tr>
</tbody>
</table>
</div>
<ol start="4">
<li><strong>Pipeline runs</strong> — extraction is instant (SQL queries on the event log); LLM generation takes seconds to minutes depending on the provider</li>
<li><strong>Open in editor</strong> — the scenario opens with all extracted/generated content. Everything is editable. The designer adds, removes, or modifies anything before publishing.</li>
</ol>
<h4 id="perspective-conversion"><a class="header" href="#perspective-conversion">Perspective Conversion</a></h4>
<p>The key design challenge: a replay is a symmetric record (both sides played). A scenario is asymmetric (the player is one side, the AI is the other). The pipeline handles this conversion:</p>
<ul>
<li><strong>“Playable as Player 1”</strong> — Player 1’s units become the player’s starting forces. Player 2’s units, movements, and build order become AI-controlled entities with waypoints and triggers mimicking the replay behavior.</li>
<li><strong>“Playable as Player 2”</strong> — reversed.</li>
<li><strong>“New player vs AI”</strong> — the player starts fresh. The AI follows a behavior pattern extracted from the better-performing replay side. The LLM (if available) adjusts difficulty so the mission is winnable but challenging.</li>
<li><strong>“Observer (full map)”</strong> — both sides are AI-controlled, recreating the entire battle as a spectacle. Useful for “historical battle” recreations of famous tournament matches.</li>
</ul>
<p>Initial implementation targets 1v1 replays — perspective conversion maps cleanly to “one player side, one AI side.” 2v2 team games work by merging each team’s orders into a single AI side. FFA and larger multiplayer replays require per-faction AI assignment and are deferred to a future iteration. Observer mode is player-count-agnostic (all sides are AI-controlled regardless of player count).</p>
<h4 id="ai-behavior-extraction"><a class="header" href="#ai-behavior-extraction">AI Behavior Extraction</a></h4>
<p>The pipeline converts a player’s replay orders into AI modules that approximate the original behavior at the strategic level. The mapping is deterministic — no LLM required.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Replay Order Type</th><th>AI Module Generated</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>Move orders</td><td>Patrol waypoints</td><td>Unit moved A→B→C → patrol route with 3 waypoints</td></tr>
<tr><td>Attack-move orders</td><td>Attack-move zones</td><td>Attack-move toward (2400, 1800) → attack-move zone centered on that area</td></tr>
<tr><td>Build orders (structures)</td><td>Timed build queue</td><td>Barracks at tick 300, War Factory at tick 600 → build triggers at those offsets</td></tr>
<tr><td>Unit production orders</td><td>Wave Spawner timing</td><td>5 tanks produced ticks 800–1000 → Wave Spawner with matching composition</td></tr>
<tr><td>Harvest orders</td><td>Harvester assignment</td><td>3 harvesters assigned to ore field → harvester waypoints to that resource</td></tr>
</tbody>
</table>
</div>
<p>This isn’t “perfectly replicate a human player” — it’s “create an AI that does roughly the same thing in roughly the same order.” The Probability of Presence system (per-entity randomization) can be applied on top, so replaying the scenario doesn’t produce an identical experience every time.</p>
<p><strong>Crate boundary:</strong> The extraction logic lives in <code>ic-ai</code> behind a <code>ReplayBehaviorExtractor</code> trait. <code>ic-editor</code> calls this trait to generate AI modules from replay data. <code>ic-game</code> wires the concrete implementation. This keeps <code>ic-editor</code> decoupled from AI internals — the same pattern as sim/net separation.</p>
<h4 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h4>
<ul>
<li><strong>“That was an incredible game — let others experience it”</strong> — import your best multiplayer match, add briefing and objectives, publish as a community mission</li>
<li><strong>Tournament highlight missions</strong> — import famous tournament replays, let players play from either side. “Can you do better than the champion?”</li>
<li><strong>Training scenarios</strong> — import a skilled player’s replay, the new player faces an AI that follows the skilled player’s build order and attack patterns</li>
<li><strong>Campaign from history</strong> — import a series of replays from a ladder season or clan war, LLM generates connecting narrative → instant campaign</li>
<li><strong>Modder stress test</strong> — import a replay with 1000+ units to create a performance benchmark scenario</li>
<li><strong>Content creation</strong> — streamers import viewer-submitted replays and remix them into challenge missions live</li>
</ul>
<h4 id="batch-import-replay-series--campaign"><a class="header" href="#batch-import-replay-series--campaign">Batch Import: Replay Series → Campaign</a></h4>
<p>Multiple replays can be imported as a connected campaign:</p>
<ol>
<li>Select multiple replays (e.g., a best-of-5 tournament series)</li>
<li>Pipeline extracts each as a separate mission</li>
<li>LLM (if available) generates connecting narrative: briefings that reference previous missions, persistent characters who survive across matches, escalating stakes</li>
<li>Campaign graph auto-generated: linear (match order) or branching (win/loss → different next mission)</li>
<li>Open in Campaign Editor for refinement</li>
</ol>
<p>This is the fastest path from “cool replays” to “playable campaign” — and it’s entirely powered by existing systems (D016 + D021 + D031 + D034 + D038).</p>
<h4 id="what-this-does-not-do"><a class="header" href="#what-this-does-not-do">What This Does NOT Do</a></h4>
<ul>
<li><strong>Perfectly reproduce a human player’s micro</strong> — AI modules approximate human behavior at the strategic level. Precise micro (target switching, spell timing, retreat feints) is not captured. The goal is “similar army, similar timing, similar aggression,” not “frame-perfect recreation.”</li>
<li><strong>Work on corrupted or truncated replays</strong> — the pipeline requires a complete event log. Partial replays produce partial scenarios (with warnings).</li>
<li><strong>Replace mission design</strong> — direct extraction produces a mechanical skeleton, not a polished mission. The LLM adds narrative, but a human designer’s touch is what makes it feel crafted. The pipeline reduces the work from “start from scratch” to “edit and polish.”</li>
</ul>
<p><strong>Crate boundary for LLM integration:</strong> <code>ic-editor</code> defines a <code>NarrativeGenerator</code> trait (input: replay event summary → output: briefing, objectives, dialogue YAML). <code>ic-llm</code> implements it. <code>ic-game</code> wires the implementation at startup — if no LLM provider is configured, the trait is backed by a no-op that skips narrative generation. <code>ic-editor</code> never imports <code>ic-llm</code> directly. This mirrors the sim/net separation: the editor knows it <em>can</em> request narrative, but has zero knowledge of how it’s generated.</p>
<p><strong>Phase:</strong> Direct extraction ships with the scenario editor in <strong>Phase 6a</strong> (it’s just SQL queries + editor import — no new system needed). LLM-powered narrative generation ships in <strong>Phase 7</strong> (requires <code>ic-llm</code>). Batch campaign import is a <strong>Phase 7</strong> feature built on D021’s campaign graph.</p>
<h3 id="reference-material"><a class="header" href="#reference-material">Reference Material</a></h3>
<p>The scenario editor design draws from:</p>
<ul>
<li><strong>OFP mission editor (2001):</strong> Probability of Presence, triggers with countdown/timeout, Guard/Guarded By, synchronization, Easy/Advanced toggle. The gold standard for “simple, not bloated, not limiting.”</li>
<li><strong>OFP: Resistance (2002):</strong> Persistent campaign — surviving soldiers, captured equipment, emotional investment. The campaign editor exists because Resistance proved persistent campaigns are transformative.</li>
<li><strong>Arma 3 Eden Editor (2016):</strong> 3D placement, modules (154 built-in), compositions, layers, Workshop integration, undo/redo</li>
<li><strong>Arma Reforger Game Master (2022):</strong> Budget system, real-time manipulation, controller support, simplified objectives</li>
<li><strong>Age of Empires II Scenario Editor (1999):</strong> Condition-effect trigger system (the RTS gold standard — 25+ years of community use), trigger areas as spatial logic. Cautionary lesson: flat trigger list collapses at scale — IC adds folders, search, and flow graph to prevent this.</li>
<li><strong>StarCraft Campaign Editor / SCMDraft (1998+):</strong> Named locations (spatial regions referenced by name across triggers). The “location” concept directly inspired IC’s Named Regions. Also: open file format enabled community editors — validates IC’s YAML approach.</li>
<li><strong>Warcraft III World Editor:</strong> GUI-based triggers with conditions, actions, and variables. IC’s module system and Variables Panel serve the same role.</li>
<li><strong>TimeSplitters 2/3 MapMaker (2002/2005):</strong> Visible memory/complexity budget bar — always know what you can afford. Inspired IC’s Scenario Complexity Meter.</li>
<li><strong>Super Mario Maker (2015/2019):</strong> Element interactions create depth without parameter bloat. Behaviors emerge from spatial arrangement. Instant build-test loop measured in seconds.</li>
<li><strong>LittleBigPlanet 2 (2011):</strong> Pre-packaged logic modules (drop-in game patterns). Directly inspired IC’s module system. Cautionary lesson: server shutdown destroyed 10M+ creations — content survival is non-negotiable (IC uses local-first storage + Workshop export).</li>
<li><strong>RPG Maker (1992–present):</strong> Tiered complexity architecture (visual events → scripting). Validates IC’s Simple → Advanced → Lua progression.</li>
<li><strong>Halo Forge (2007–present):</strong> In-game real-time editing with instant playtesting. Evolution from minimal (Halo 3) to powerful (Infinite) proves: ship simple, grow over iterations. Also: game mode prefabs (Strongholds, CTF) that designers customize — directly inspired IC’s Game Mode Templates.</li>
<li><strong>Far Cry 2 Map Editor (2008):</strong> Terrain sculpting separated from mission logic. Proves environment creation and scenario scripting can be independent workflows.</li>
<li><strong>Divinity: Original Sin 2 (2017):</strong> Co-op campaign with persistent state, per-player dialogue choices that affect the shared story. Game Master mode with real-time scenario manipulation. Proved co-op campaign RPG works — and that the tooling for CREATING co-op content matters as much as the runtime support.</li>
<li><strong>Doom community editors (1994–present):</strong> Open data formats enable 30+ years of community tools. The WAD format’s openness is why Doom modding exists — validates IC’s YAML-based scenario format.</li>
<li><strong>OpenRA map editor:</strong> Terrain painting, resource placement, actor placement — standalone tool. IC improves by integrating a full creative toolchain in the SDK (scenario editor + asset studio + campaign editor)</li>
<li><strong>Garry’s Mod (2006–present):</strong> Spawn menu UX (search/favorites/recents for large asset libraries) directly inspired IC’s Entity Palette. Duplication system (save/share/browse entity groups) validates IC’s Compositions. Per-player undo in multiplayer sessions informed IC’s Game Master undo scoping. Community-built tools (Wire Mod, Expression 2) that became indistinguishable from first-party tools proved that a clean tool API matters more than shipping every tool yourself — directly inspired IC’s Workshop-distributed editor plugins. Sandbox mode as the default creative environment validated IC’s Sandbox template as the editor’s default preview mode. Cautionary lesson: unrestricted Lua access enabled the Glue Library incident (malicious addon update) — reinforces IC’s sandboxed Lua model (D004) and Workshop supply chain defenses (D030, <code>06-SECURITY.md</code> § Vulnerability 18)</li>
</ul>
<h3 id="multiplayer--co-op-scenario-tools"><a class="header" href="#multiplayer--co-op-scenario-tools">Multiplayer &amp; Co-op Scenario Tools</a></h3>
<p>Most RTS editors treat multiplayer as an afterthought — place some spawn points, done. Creating a proper co-op mission, a team scenario with split objectives, or a campaign playable by two friends requires hacking around the editor’s single-player assumptions. IC’s editor treats multiplayer and co-op as first-class authoring targets.</p>
<h4 id="player-slot-configuration"><a class="header" href="#player-slot-configuration">Player Slot Configuration</a></h4>
<p>Every scenario has a <strong>Player Slots panel</strong> — the central hub for multiplayer setup.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Slot count</strong></td><td>Number of human player slots (1–8). Solo missions = 1. Co-op = 2+.</td></tr>
<tr><td><strong>Faction</strong></td><td>Which faction each slot controls (or “any” for lobby selection)</td></tr>
<tr><td><strong>Team</strong></td><td>Team assignment (Team 1, Team 2, FFA, Configurable in lobby)</td></tr>
<tr><td><strong>Spawn area</strong></td><td>Starting position/area per slot</td></tr>
<tr><td><strong>Starting units</strong></td><td>Pre-placed entities assigned to this slot</td></tr>
<tr><td><strong>Color</strong></td><td>Default color (overridable in lobby)</td></tr>
<tr><td><strong>AI fallback</strong></td><td>What happens if this slot is unfilled: AI takes over, slot disabled, or required</td></tr>
</tbody>
</table>
</div>
<p>The designer places entities and assigns them to player slots via the Attributes Panel — a dropdown says “belongs to Player 1 / Player 2 / Player 3 / Any.” Triggers and objectives can be scoped to specific slots or shared.</p>
<h4 id="co-op-mission-modes"><a class="header" href="#co-op-mission-modes">Co-op Mission Modes</a></h4>
<p>The editor supports several co-op configurations. These are set per-mission in the scenario properties:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><strong>Allied Factions</strong></td><td>Each player controls a separate allied faction with their own base, army, and economy</td><td>Player 1: Allies infantry push. Player 2: Soviet armor support.</td></tr>
<tr><td><strong>Shared Command</strong></td><td>Players share a single faction. Units can be assigned to specific players or freely controlled by anyone.</td><td>One player manages economy/production, the other commands the army.</td></tr>
<tr><td><strong>Commander + Ops</strong></td><td>One player has the base and production (Commander), the other controls field units only (Operations).</td><td>Commander builds and sends reinforcements. Ops does all the fighting.</td></tr>
<tr><td><strong>Asymmetric</strong></td><td>Players have fundamentally different gameplay. One does RTS, the other does Game Master or support roles.</td><td>Player 1 plays the mission. Player 2 controls enemy as GM.</td></tr>
<tr><td><strong>Split Objectives</strong></td><td>Players have different objectives on the same map. Both must succeed for mission victory.</td><td>Player 1: capture the bridge. Player 2: defend the base.</td></tr>
</tbody>
</table>
</div>
<h4 id="per-player-objectives--triggers"><a class="header" href="#per-player-objectives--triggers">Per-Player Objectives &amp; Triggers</a></h4>
<p>The key to good co-op missions: players need their own goals, not just shared ones.</p>
<ul>
<li><strong>Objective assignment</strong> — each objective module has a “Player” dropdown: All Players, Player 1, Player 2, etc. Shared objectives require all assigned players to contribute. Per-player objectives belong to one player.</li>
<li><strong>Trigger scoping</strong> — triggers can fire based on a specific player’s actions: “When Player 2’s units enter this region” vs “When any allied unit enters this region.” The trigger’s faction/player filter handles this.</li>
<li><strong>Per-player briefings</strong> — the briefing module supports per-slot text: Player 1 sees “Commander, your objective is the bridge…” while Player 2 sees “Comrade, you will hold the flank…”</li>
<li><strong>Split victory conditions</strong> — the mission can require ALL players to complete their individual objectives, or ANY player, or a custom Lua condition combining them.</li>
</ul>
<h4 id="co-op-campaigns"><a class="header" href="#co-op-campaigns">Co-op Campaigns</a></h4>
<p>Co-op extends beyond individual missions into campaigns (D021). The Campaign Editor supports multi-player campaigns with these additional properties per mission node:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Player count</strong></td><td>Min and max human players for this mission (1 for solo-compatible, 2+ for co-op)</td></tr>
<tr><td><strong>Co-op mode</strong></td><td>Which mode applies (see table above)</td></tr>
<tr><td><strong>Solo fallback</strong></td><td>How the mission plays if solo: AI ally, simplified objectives, or unavailable</td></tr>
</tbody>
</table>
</div>
<p><strong>Shared roster management:</strong> In persistent campaigns, the carried-forward roster is shared between co-op players. The intermission screen shows the combined roster with options for dividing control:</p>
<ul>
<li><strong>Draft</strong> — players take turns picking units from the survivor pool (fantasy football for tanks)</li>
<li><strong>Split by type</strong> — infantry to Player 1, vehicles to Player 2 (configured by the scenario designer)</li>
<li><strong>Free claim</strong> — each player grabs what they want from the shared pool, first come first served</li>
<li><strong>Designer-assigned</strong> — the mission YAML specifies which named characters belong to which player slot</li>
</ul>
<p><strong>Drop-in / drop-out:</strong> If a co-op player disconnects mid-mission, their units revert to AI control (or a configurable fallback: pause, auto-extract, or continue without). Reconnection restores control.</p>
<h4 id="multiplayer-testing"><a class="header" href="#multiplayer-testing">Multiplayer Testing</a></h4>
<p>Testing multiplayer scenarios is painful in every editor — you normally need to launch two game instances and play both yourself. IC reduces this friction:</p>
<ul>
<li><strong>Multi-slot preview</strong> — preview the mission with AI controlling unfilled player slots. Test your co-op triggers and per-player objectives without needing a real partner.</li>
<li><strong>Slot switching</strong> — during preview, hot-switch between player viewpoints to verify each player’s experience (camera, fog of war, objectives).</li>
<li><strong>Network delay simulation</strong> — preview with configurable artificial latency to catch timing-sensitive trigger issues in multiplayer.</li>
<li><strong>Lobby preview</strong> — see how the mission appears in the multiplayer lobby before publishing: slot configuration, team layout, map preview, description.</li>
</ul>
<h3 id="game-mode-templates"><a class="header" href="#game-mode-templates">Game Mode Templates</a></h3>
<p>Almost every popular RTS game mode can be built with IC’s existing module system + triggers + Lua. But discoverability matters — a modder shouldn’t need to reinvent the Survival mode from scratch when the pattern is well-known.</p>
<p><strong>Game Mode Templates</strong> are pre-configured scenario setups: a starting point with the right modules, triggers, variables, and victory conditions already wired. The designer customizes the specifics (which units, which map, which waves) without building the infrastructure.</p>
<p><strong>Built-in templates:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Template</th><th>Inspired By</th><th>What’s Pre-Configured</th></tr>
</thead>
<tbody>
<tr><td><strong>Skirmish (Standard)</strong></td><td>Every RTS</td><td>Spawn points, tech tree, resource deposits, standard victory conditions (destroy all enemy buildings)</td></tr>
<tr><td><strong>Survival / Horde</strong></td><td>They Are Billions, CoD Zombies</td><td>Wave Spawners with escalation, base defense zone, wave counter variable, survival timer, difficulty scaling per wave</td></tr>
<tr><td><strong>King of the Hill</strong></td><td>FPS/RTS variants</td><td>Central capture zone, scoreboard tracking cumulative hold time per faction, configurable score-to-win</td></tr>
<tr><td><strong>Regicide</strong></td><td>AoE2</td><td>King/Commander unit per player (named character, must-survive), kill the king = victory, king abilities optional</td></tr>
<tr><td><strong>Treaty</strong></td><td>AoE2</td><td>No-combat timer (configurable), force peace during treaty, countdown display, auto-reveal on treaty end</td></tr>
<tr><td><strong>Nomad</strong></td><td>AoE2</td><td>No starting base — each player gets only an MCV (or equivalent). Random spawn positions. Land grab gameplay.</td></tr>
<tr><td><strong>Empire Wars</strong></td><td>AoE2 DE</td><td>Pre-built base per player (configurable: small/medium/large), starting army, skip early game</td></tr>
<tr><td><strong>Assassination</strong></td><td>StarCraft UMS</td><td>Commander unit per player (powerful but fragile), protect yours, kill theirs. Commander death = defeat.</td></tr>
<tr><td><strong>Tower Defense</strong></td><td>Desktop TD, custom WC3 maps</td><td>Pre-defined enemy paths (waypoints), restricted build zones, economy from kills, wave system with boss rounds</td></tr>
<tr><td><strong>Tug of War</strong></td><td>WC3 custom maps</td><td>Automated unit spawning on timer, player controls upgrades/abilities/composition. Push the enemy back.</td></tr>
<tr><td><strong>Base Defense</strong></td><td>They Are Billions, C&amp;C missions</td><td>Defend a position for N minutes/waves. Pre-placed base, incoming attacks from multiple directions, escalating difficulty.</td></tr>
<tr><td><strong>Capture the Flag</strong></td><td>FPS tradition</td><td>Each player has a flag entity (or MCV). Steal the opponent’s and return it to your base. Combines economy + raiding.</td></tr>
<tr><td><strong>Free for All</strong></td><td>Every RTS</td><td>3+ players, no alliances allowed. Last player standing. Diplomacy module optional (alliances that can be broken).</td></tr>
<tr><td><strong>Diplomacy</strong></td><td>Civilization, AoE4</td><td>FFA with dynamic alliance system. Players can propose/accept/break alliances. Shared vision opt-in. Betrayal is a game mechanic.</td></tr>
<tr><td><strong>Sandbox</strong></td><td>Garry’s Mod, Minecraft Creative</td><td>Unlimited resources, no enemies, no victory condition. Pure building and experimentation. Good for testing and screenshots.</td></tr>
<tr><td><strong>Co-op Survival</strong></td><td>Deep Rock Galactic, Helldivers</td><td>Multiple human players vs escalating AI waves. Shared base. Team objectives. Difficulty scales with player count.</td></tr>
<tr><td><strong>Sudden Death</strong></td><td>Various</td><td>No rebuilding — if a building is destroyed, it’s gone. Every engagement is high-stakes. Smaller starting armies.</td></tr>
</tbody>
</table>
</div>
<p><strong>Templates are starting points, not constraints.</strong> Open a template, add your own triggers/modules/Lua, publish to Workshop. Templates save 30–60 minutes of boilerplate setup and ensure the core game mode logic is correct.</p>
<p><strong>Phasing:</strong> Not all 17 templates ship simultaneously. <strong>Phase 6b core set</strong> (8 templates): Skirmish, Survival/Horde, King of the Hill, Regicide, Free for All, Co-op Survival, Sandbox, Base Defense — these cover the most common community needs and validate the template system. <strong>Phase 7 / community-contributed</strong> (9 templates): Treaty, Nomad, Empire Wars, Assassination, Tower Defense, Tug of War, Capture the Flag, Diplomacy, Sudden Death — these are well-defined patterns that the community can build and publish via Workshop before (or instead of) first-party implementation. Scope to what you have (Principle #6); don’t ship 17 mediocre templates when 8 excellent ones plus a thriving Workshop library serves players better.</p>
<p><strong>Custom game mode templates:</strong> Modders can create new templates and publish them to Workshop (D030). A “Zombie Survival” template, a “MOBA Lanes” template, a “RPG Quest Hub” template — the community extends the library indefinitely. Templates use the same composition + module + trigger format as everything else.</p>
<p><strong>Community tools &gt; first-party completeness.</strong> Garry’s Mod shipped ~25 built-in tools; the community built hundreds more that matched or exceeded first-party quality — because the tool API was clean enough that addon authors could. The same philosophy applies here: ship 8 excellent templates, make the authoring format so clean that community templates are indistinguishable from built-in ones, and let Workshop do the rest. The limiting factor should be community imagination, not API complexity.</p>
<p><strong>Sandbox as default preview.</strong> The Sandbox template (unlimited resources, no enemies, no victory condition) doubles as the default environment when the editor’s Preview button is pressed without a specific scenario loaded. This follows Garry’s Mod’s lesson: sandbox mode is how people <strong>learn the tools</strong> before making real content. A zero-pressure environment where every entity and module can be tested without mission constraints.</p>
<p><strong>Templates + Co-op:</strong> Several templates have natural co-op variants. Co-op Survival is explicit, but most templates work with 2+ players if the designer adds co-op spawn points and per-player objectives.</p>
<h3 id="workshop-distributed-editor-plugins"><a class="header" href="#workshop-distributed-editor-plugins">Workshop-Distributed Editor Plugins</a></h3>
<p>Garry’s Mod’s most powerful pattern: community-created tools appear alongside built-in tools in the same menu. The community doesn’t just create content — they <strong>extend the creation tools themselves.</strong> Wire Mod and Expression 2 are the canonical examples: community-built systems that became essential editor infrastructure, indistinguishable from first-party tools.</p>
<p>IC supports this explicitly. Workshop-published packages can contain:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Plugin Type</th><th>What It Adds</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><strong>Custom modules</strong></td><td>New entries in the Modules panel (YAML definition + Lua implementation)</td><td>“Convoy System” module — defines waypoints + spawn + escort</td></tr>
<tr><td><strong>Custom triggers</strong></td><td>New trigger condition/action types</td><td>“Music trigger” — plays specific track on activation</td></tr>
<tr><td><strong>Compositions</strong></td><td>Pre-built reusable entity groups (see Compositions section)</td><td>“Tournament 1v1 Start” — balanced spawn with resources</td></tr>
<tr><td><strong>Game mode templates</strong></td><td>Complete game mode setups (see Game Mode Templates section)</td><td>“MOBA Lanes” — 3-lane auto-spawner with towers and heroes</td></tr>
<tr><td><strong>Editor tools</strong></td><td>New editing tools and panels (Lua-based UI extensions, Phase 7)</td><td>“Formation Arranger” — visual grid formation editor tool</td></tr>
<tr><td><strong>Terrain brushes</strong></td><td>Custom terrain painting presets</td><td>“River Painter” — places water + bank tiles + bridge snaps</td></tr>
</tbody>
</table>
</div>
<p>All plugin types use the tiered modding system (invariant #3): YAML for data definitions, Lua for logic, WASM for complex tools. Plugins are sandboxed — an editor plugin cannot access the filesystem, network, or sim internals beyond the editor’s public API. They install via Workshop like any other resource and appear in the editor’s palettes automatically.</p>
<p>This aligns with philosophy principle #19 (“Build for surprise — expose primitives, not just parameterized behaviors”): the module/trigger/composition system is powerful enough that community extensions can create things the engine developers never imagined.</p>
<p><strong>Phase:</strong> Custom modules and compositions are publishable from Phase 6a (they use the existing YAML + Lua format). Custom editor tools (Lua-based UI extensions) are a Phase 7 capability that depends on the editor’s Lua plugin API.</p>
<h3 id="editor-onboarding-for-veterans"><a class="header" href="#editor-onboarding-for-veterans">Editor Onboarding for Veterans</a></h3>
<p>The IC editor’s concepts — triggers, waypoints, entities, layers — aren’t new. They’re the same ideas that OFP, AoE2, StarCraft, and WC3 editors have used for decades. But each editor uses different names, different hotkeys, and different workflows. A 20-year AoE2 scenario editor veteran has deep muscle memory that IC shouldn’t fight — it should channel.</p>
<p><strong>“Coming From” profile (first-launch):</strong></p>
<p>When the editor opens for the first time, a non-blocking welcome panel asks: “Which editor are you most familiar with?” Options:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Profile</th><th>Sets Default Keybindings</th><th>Sets Terminology Hints</th><th>Sets Tutorial Path</th></tr>
</thead>
<tbody>
<tr><td><strong>New to editing</strong></td><td>IC Default</td><td>IC terms only</td><td>Full guided tour, start with Simple mode</td></tr>
<tr><td><strong>OFP / Eden</strong></td><td>F1–F7 mode switching</td><td>OFP equivalents shown</td><td>Skip basics, focus on RTS differences</td></tr>
<tr><td><strong>AoE2</strong></td><td>AoE2 trigger workflow</td><td>AoE2 equivalents shown</td><td>Skip triggers, focus on Lua + modules</td></tr>
<tr><td><strong>StarCraft / WC3</strong></td><td>WC3 trigger shortcuts</td><td>Location→Region, etc.</td><td>Skip locations, focus on compositions</td></tr>
<tr><td><strong>Other / Skip</strong></td><td>IC Default</td><td>No hints</td><td>Condensed overview</td></tr>
</tbody>
</table>
</div>
<p>This is a <strong>one-time suggestion, not a lock-in.</strong> Profile can be changed anytime in settings. All it does is set initial keybindings and toggle contextual hints.</p>
<p><strong>Customizable keybinding presets:</strong></p>
<p>Full key remapping with shipped presets:</p>
<pre><code>IC Default   — Tab cycles modes, 1-9 entity selection, Space preview
OFP Classic  — F1-F7 modes, Enter properties, Space preview
Eden Modern  — Ctrl+1-7 modes, double-click properties, P preview
AoE2 Style   — T triggers, U units, R resources, Ctrl+C copy trigger
WC3 Style    — Ctrl+T trigger editor, Ctrl+B triggers browser
</code></pre>
<p>Not just hotkeys — mode switching behavior and right-click context menus adapt to the profile. OFP veterans expect right-click on empty ground to deselect; AoE2 veterans expect right-click to open a context menu.</p>
<p><strong>Terminology Rosetta Stone:</strong></p>
<p>A toggleable panel (or contextual tooltips) that maps IC terms to familiar ones:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>IC Term</th><th>OFP / Eden</th><th>AoE2</th><th>StarCraft / WC3</th></tr>
</thead>
<tbody>
<tr><td>Region</td><td>Trigger (area-only)</td><td>Trigger Area</td><td>Location</td></tr>
<tr><td>Module</td><td>Module</td><td>Looping Trigger Pattern</td><td>GUI Trigger Template</td></tr>
<tr><td>Composition</td><td>Composition</td><td>(Copy-paste group)</td><td>Template</td></tr>
<tr><td>Variables Panel</td><td>(setVariable in SQF)</td><td>(Invisible unit on map edge)</td><td>Deaths counter / Switch</td></tr>
<tr><td>Inline Script</td><td>Init field (SQF)</td><td>—</td><td>Custom Script</td></tr>
<tr><td>Connection</td><td>Synchronize</td><td>—</td><td>—</td></tr>
<tr><td>Layer</td><td>Layer</td><td>—</td><td>—</td></tr>
<tr><td>Probability of Presence</td><td>Probability of Presence</td><td>—</td><td>—</td></tr>
<tr><td>Named Character</td><td>Playable unit</td><td>Named hero (scenario)</td><td>Named hero</td></tr>
</tbody>
</table>
</div>
<p>Displayed as <strong>tooltips on hover</strong> — when an AoE2 veteran hovers over “Region” in the UI, a tiny tooltip says “AoE2: Trigger Area.” Not blocking, not patronizing, just a quick orientation aid. Tooltips disappear after the first few uses (configurable).</p>
<p><strong>Interactive migration cheat sheets:</strong></p>
<p>Context-sensitive help that recognizes familiar patterns:</p>
<ul>
<li>Designer opens Variables Panel → tip: “In AoE2, you might have used invisible units placed off-screen as variables. IC has native variables — no workarounds needed.”</li>
<li>Designer creates first trigger → tip: “In OFP, triggers were areas on the map. IC triggers work the same way, but you can also use Regions for reusable areas across multiple triggers.”</li>
<li>Designer writes first Lua line → tip: “Coming from SQF? Here’s a quick Lua comparison: <code>_myVar = 5</code> → <code>local myVar = 5</code>. <code>hint \"hello\"</code> → <code>Game.message(\"hello\")</code>. Full cheat sheet: Help → SQF to Lua.”</li>
</ul>
<p>These only appear once per concept. They’re dismissable and disable-all with one toggle. They’re not tutorials — they’re translation aids.</p>
<p><strong>Scenario import (partial):</strong></p>
<p>Full import of complex scenarios from other engines is unrealistic — but partial import of the most tedious-to-recreate elements saves real time:</p>
<ul>
<li><strong>AoE2 trigger import</strong> — parse AoE2 scenario trigger data, convert condition→effect pairs to IC triggers + modules. Not all triggers translate, but simple ones (timer, area detection, unit death) map cleanly.</li>
<li><strong>StarCraft trigger import</strong> — parse StarCraft triggers, convert locations to IC Regions, convert trigger conditions/actions to IC equivalents.</li>
<li><strong>OFP mission.sqm import</strong> — parse entity placements, trigger positions, and waypoint connections. SQF init scripts flag as “needs Lua conversion” but the spatial layout transfers.</li>
<li><strong>OpenRA .oramap entities</strong> — already supported by the asset pipeline (D025/D026). Editor imports the map and entity placement directly.</li>
</ul>
<p>Import is always <strong>best-effort</strong> with clear reporting: “Imported 47 of 52 triggers. 5 triggers used features without IC equivalents — see import log.” Better to import 90% and fix 10% than to recreate 100% from scratch.</p>
<p><strong>The 30-minute goal:</strong> A veteran editor from ANY background should feel productive within 30 minutes. Not expert — productive. They recognize familiar concepts wearing new names, their muscle memory partially transfers via keybinding presets, and the migration cheat sheet fills the gaps. The learning curve is a gentle slope, not a cliff.</p>
<h3 id="controller--steam-deck-support"><a class="header" href="#controller--steam-deck-support">Controller &amp; Steam Deck Support</a></h3>
<p>Steam Deck is a target platform (Invariant #10), so the editor must be usable without mouse+keyboard — but it doesn’t need to be <em>equally</em> powerful. The approach: full functionality on mouse+keyboard, comfortable core workflows on controller.</p>
<ul>
<li><strong>Controller input mapping:</strong> Left stick for cursor movement (with adjustable acceleration), right stick for camera pan/zoom. D-pad cycles editing modes. Face buttons: place (A), delete (B), properties panel (X), context menu (Y). Triggers: undo (LT), redo (RT). Bumpers: cycle selected entity type</li>
<li><strong>Radial menus</strong> — controller-optimized selection wheels for entity types, trigger types, and module categories (replacing mouse-dependent dropdowns)</li>
<li><strong>Snap-to-grid</strong> — always active on controller (optional on mouse) to compensate for lower cursor precision</li>
<li><strong>Touch input (Steam Deck / mobile):</strong> Tap to place, pinch to zoom, two-finger drag to pan. Long press for properties panel. Touch works as a complement to controller, not a replacement for mouse</li>
<li><strong>Scope:</strong> Core editing (terrain, entity placement, triggers, waypoints, modules, preview) is controller-compatible at launch. Advanced features (inline Lua editing, campaign graph wiring, dialogue tree authoring) require keyboard and are flagged in the UI: “Connect a keyboard for this feature.” This is the same trade-off Eden Editor made — and Steam Deck has a built-in keyboard for occasional text entry</li>
</ul>
<p><strong>Phase:</strong> Controller input for the editor ships with Phase 6a. Touch input is Phase 7.</p>
<h3 id="accessibility"><a class="header" href="#accessibility">Accessibility</a></h3>
<p>The editor’s “accessibility through layered complexity” principle applies to disability access, not just skill tiers. These features ensure the editor is usable by the widest possible audience.</p>
<p><strong>Visual accessibility:</strong></p>
<ul>
<li><strong>Colorblind modes</strong> — all color-coded elements (trigger folders, layer colors, region colors, connection lines, complexity meter) use a palette designed for deuteranopia, protanopia, and tritanopia. In addition to color, elements use distinct <strong>shapes and patterns</strong> (dashed vs solid lines, different node shapes) so color is never the only differentiator</li>
<li><strong>High contrast mode</strong> — editor UI switches to high-contrast theme with stronger borders and larger text. Toggle in editor settings</li>
<li><strong>Scalable UI</strong> — all editor panels respect the game’s global UI scale setting (50%–200%). Editor-specific elements (attribute labels, trigger text, node labels) scale independently if needed</li>
<li><strong>Zoom and magnification</strong> — the isometric viewport supports arbitrary zoom levels. Combined with UI scaling, users with low vision can work at comfortable magnification</li>
</ul>
<p><strong>Motor accessibility:</strong></p>
<ul>
<li><strong>Full keyboard navigation</strong> — every editor operation is reachable via keyboard. Tab cycles panels, arrow keys navigate within panels, Enter confirms, Escape cancels. No operation requires mouse-only gestures</li>
<li><strong>Adjustable click timing</strong> — double-click speed and drag thresholds are configurable for users with reduced dexterity</li>
<li><strong>Sticky modes</strong> — editing modes (terrain, entity, trigger) stay active until explicitly switched, rather than requiring held modifier keys</li>
</ul>
<p><strong>Cognitive accessibility:</strong></p>
<ul>
<li><strong>Simple/Advanced mode</strong> (already designed) is the primary cognitive accessibility feature — it reduces the number of visible options from 30+ to ~10</li>
<li><strong>Consistent layout</strong> — panels don’t rearrange based on context. The attributes panel is always on the right, the mode selector always on the left. Predictable layout reduces cognitive load</li>
<li><strong>Tooltips with examples</strong> — every field in the attributes panel has a tooltip with a concrete example, not just a description. “Probability of Presence: 75” → tooltip: “75% chance this unit exists when the mission starts. Example: set to 50 for a coin-flip ambush.”</li>
</ul>
<p><strong>Phase:</strong> Colorblind modes, UI scaling, and keyboard navigation ship with Phase 6a. High contrast mode and motor accessibility refinements ship in Phase 6b–7.</p>
<blockquote>
<p><strong>Note:</strong> The accessibility features above cover the <strong>editor</strong> UI. <strong>Game-level accessibility</strong> — colorblind faction colors, minimap palettes, resource differentiation, screen reader support for menus, subtitle options for EVA/briefings, and remappable controls — is a separate concern that applies to <code>ic-render</code> and <code>ic-ui</code>, not <code>ic-editor</code>. Game accessibility ships in Phase 7 (see <code>08-ROADMAP.md</code>).</p>
</blockquote>
<h3 id="alternatives-considered"><a class="header" href="#alternatives-considered">Alternatives Considered</a></h3>
<ol>
<li><strong>In-game editor (original design, revised by D040):</strong> The original D038 design embedded the editor inside the game binary. Revised to SDK-separate architecture — players shouldn’t see creator tools. The SDK still reuses the same Bevy rendering and sim crates, so there’s no loss of live preview capability. See D040 § SDK Architecture for the full rationale.</li>
<li><strong>Text-only editing (YAML + Lua):</strong> Already supported for power users and LLM generation. The visual editor is the accessibility layer on top of the same data format.</li>
<li><strong>Node-based visual scripting (like Unreal Blueprints):</strong> Too complex for the casual audience. Modules + triggers cover the sweet spot. Advanced users write Lua directly. A node editor is a potential Phase 7+ community contribution.</li>
</ol>
<p><strong>Phase:</strong> Core scenario editor (terrain + entities + triggers + waypoints + modules + compositions + preview + autosave + controller input + accessibility) ships in <strong>Phase 6a</strong> alongside the modding SDK and full Workshop. Campaign editor (graph, state dashboard, intermissions, dialogue, named characters), game mode templates, multiplayer/co-op scenario tools, and Game Master mode ship in <strong>Phase 6b</strong>. Editor onboarding (“Coming From” profiles, keybinding presets, migration cheat sheets, partial import) and touch input ship in <strong>Phase 7</strong>. The campaign editor’s graph, state dashboard, and intermission screens build on D021’s campaign system (Phase 4) — the sim-side campaign engine must exist before the visual editor can drive it.</p>
<hr>
<h2 id="d040-asset-studio--visual-resource-editor--agentic-generation"><a class="header" href="#d040-asset-studio--visual-resource-editor--agentic-generation">D040: Asset Studio — Visual Resource Editor &amp; Agentic Generation</a></h2>
<p><strong>Decision:</strong> Ship an Asset Studio as part of the IC SDK — a visual tool for browsing, viewing, editing, and generating game resources (sprites, palettes, terrain tiles, UI chrome, 3D models). Optionally agentic: modders can describe what they want and an LLM generates or modifies assets, with in-context preview and iterative refinement. The Asset Studio is a tab/mode within the SDK application alongside the scenario editor (D038) — separate from the game binary.</p>
<p><strong>Context:</strong> The current design covers the full lifecycle <em>around</em> assets — parsing (ra-formats), runtime loading (Bevy pipeline), in-game use (ic-render), mission editing (D038), and distribution (D030 Workshop) — but nothing for the creative work of making or modifying assets. A modder who wants to create a new unit sprite, adjust a palette, or redesign menu chrome has zero tooling in our chain. They use external tools (Photoshop, GIMP, Aseprite) and manually convert. The community’s most-used asset tool is XCC Mixer (a 20-year-old Windows utility for browsing .mix archives). We can do better.</p>
<p>Bevy does not fill this gap. Bevy’s asset system handles loading and hot-reloading at runtime. The in-development Bevy Editor is a scene/entity inspector, not an art tool. No Bevy ecosystem crate provides C&amp;C-format-aware asset editing.</p>
<p><strong>What this is NOT:</strong> A Photoshop competitor. The Asset Studio does not provide pixel-level painting or 3D modeling. Artists use professional external tools for that. The Asset Studio handles the last mile: making assets game-ready, previewing them in context, and bridging the gap between “I have a PNG” and “it works as a unit in the game.”</p>
<h3 id="sdk-architecture--editorgame-separation"><a class="header" href="#sdk-architecture--editorgame-separation">SDK Architecture — Editor/Game Separation</a></h3>
<p><strong>The IC SDK is a separate application from the game.</strong> Normal players never see editor UI. Creators download the SDK alongside the game (or as part of the <code>ic</code> CLI toolchain). This follows the industry standard: Bethesda’s Creation Kit, Valve’s Hammer/Source SDK, Epic’s Unreal Editor, Blizzard’s StarEdit/World Editor (bundled but launches separately).</p>
<pre><code>┌──────────────────────────────┐     ┌──────────────────────────────┐
│         IC Game              │     │          IC SDK              │
│  (ic-game binary)            │     │  (ic-sdk binary)             │
│                              │     │                              │
│  • Play skirmish/campaign    │     │  ┌────────────────────────┐  │
│  • Online multiplayer        │     │  │   Scenario Editor      │  │
│  • Browse/install mods       │     │  │   (D038)               │  │
│  • Watch replays             │     │  ├────────────────────────┤  │
│  • Settings &amp; profiles       │     │  │   Asset Studio         │  │
│                              │     │  │   (D040)               │  │
│  No editor UI.               │     │  ├────────────────────────┤  │
│  No asset tools.             │     │  │   Campaign Editor      │  │
│  Clean player experience.    │     │  │   (D038/D021)          │  │
│                              │     │  ├────────────────────────┤  │
│                              │     │  │   Game Master Mode     │  │
│                              │     │  │   (D038)               │  │
│                              │     │  └────────────────────────┘  │
│                              │     │                              │
│                              │     │  Shares: ic-render, ic-sim,  │
│                              │     │  ic-ui, ic-protocol,         │
│                              │     │  ra-formats                  │
└──────────────────────────────┘     └──────────────────────────────┘
         ▲                                      │
         │         ic mod run / Test button      │
         └───────────────────────────────────────┘
</code></pre>
<p><strong>Why separate binaries instead of in-game editor:</strong></p>
<ul>
<li><strong>Players aren’t overwhelmed.</strong> A player launches the game and sees: Play, Multiplayer, Replays, Settings. No “Editor” menu item they’ll never use.</li>
<li><strong>SDK can be complex without apology.</strong> The SDK UI can have dense panels, multi-tab layouts, technical property editors. It’s for creators — they expect professional tools.</li>
<li><strong>Smaller game binary.</strong> All editor systems, asset processing code, LLM integration, and creator UI are excluded from the game build. Players download less.</li>
<li><strong>Industry convention.</strong> Players expect an SDK. “Download the Creation Kit” is understood. “Open the in-game editor” confuses casual players who accidentally click it.</li>
</ul>
<p><strong>Why this still works for fast iteration:</strong></p>
<ul>
<li><strong>“Test” button in SDK</strong> launches <code>ic-game</code> with the current scenario/asset loaded. One click, instant playtest. Same <code>LocalNetwork</code> path as before — the preview is real gameplay.</li>
<li><strong>Hot-reload bridge.</strong> While the game is running from a Test launch, the SDK watches for file changes. Edit a YAML file, save → game hot-reloads. Edit a sprite, save → game picks up the new asset. The iteration loop is seconds, not minutes.</li>
<li><strong>Shared Bevy crates.</strong> The SDK reuses <code>ic-render</code> for its preview viewports, <code>ic-sim</code> for gameplay preview, <code>ic-ui</code> for shared components. It’s the same rendering and simulation — just in a different window with different chrome.</li>
</ul>
<p><strong>Crate boundary:</strong> <code>ic-editor</code> contains all SDK functionality (scenario editor, asset studio, campaign editor, Game Master mode). It depends on <code>ic-render</code>, <code>ic-sim</code>, <code>ic-ui</code>, <code>ic-protocol</code>, <code>ra-formats</code>, and optionally <code>ic-llm</code> (via traits). <code>ic-game</code> does NOT depend on <code>ic-editor</code>. Both <code>ic-game</code> and <code>ic-editor</code> are separate binary targets in the workspace — they share library crates but produce independent executables.</p>
<p><strong>Game Master mode exception:</strong> Game Master mode requires real-time manipulation of a live game session. The SDK connects to a running game as a special client — the Game Master’s SDK sends <code>PlayerOrder</code>s through <code>ic-protocol</code> to the game’s <code>NetworkModel</code>, same as any other player. The game doesn’t know it’s being controlled by an SDK — it receives orders. The Game Master’s SDK renders its own view (top-down strategic overview, budget panel, entity palette) but the game session runs in <code>ic-game</code>. Open questions deferred to Phase 6b design: how matchmaking/lobby handles GM slots (dedicated GM slot vs. spectator-with-controls), whether GM can join mid-match, and how GM presence is communicated to players.</p>
<h3 id="three-layers"><a class="header" href="#three-layers">Three Layers</a></h3>
<h4 id="layer-1--asset-browser--viewer"><a class="header" href="#layer-1--asset-browser--viewer">Layer 1 — Asset Browser &amp; Viewer</a></h4>
<p>Browse, search, and preview every asset the engine can load. This is the XCC Mixer replacement — but integrated into a modern Bevy-based UI with live preview.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Capability</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Archive browser</strong></td><td>Browse .mix archive contents, see file list, extract individual files or bulk export</td></tr>
<tr><td><strong>Sprite viewer</strong></td><td>View .shp sprites with palette applied, animate frame sequences, scrub through frames, zoom</td></tr>
<tr><td><strong>Palette viewer</strong></td><td>View .pal palettes as color grids, compare palettes side-by-side, see palette applied to any sprite</td></tr>
<tr><td><strong>Terrain tile viewer</strong></td><td>Preview .tmp terrain tiles in grid layout, see how tiles connect</td></tr>
<tr><td><strong>Audio player</strong></td><td>Play .aud/.wav/.ogg/.mp3 files directly, waveform visualization, spectral view, loop point markers, sample rate / bit depth / channel info display</td></tr>
<tr><td><strong>Video player</strong></td><td>Play .vqa/.mp4/.webm cutscenes, frame-by-frame scrub, preview in all three display modes (fullscreen, radar_comm, picture_in_picture)</td></tr>
<tr><td><strong>Chrome previewer</strong></td><td>View UI theme sprite sheets (D032) with 9-slice visualization, see button states</td></tr>
<tr><td><strong>3D model viewer</strong></td><td>Preview GLTF/GLB models (and .vxl voxel models for future RA2 module) with rotation, lighting</td></tr>
<tr><td><strong>Asset search</strong></td><td>Full-text search across all loaded assets — by filename, type, archive, tags</td></tr>
<tr><td><strong>In-context preview</strong></td><td>“Preview as unit” — see this sprite on an actual map tile. “Preview as building” — see footprint. “Preview as chrome” — see in actual menu layout.</td></tr>
<tr><td><strong>Dependency graph</strong></td><td>Which assets reference this one? What does this mod override? Visual dependency tree.</td></tr>
</tbody>
</table>
</div>
<p><strong>Format support by game module:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Game</th><th>Archive</th><th>Sprites</th><th>Models</th><th>Palettes</th><th>Audio</th><th>Video</th><th>Source</th></tr>
</thead>
<tbody>
<tr><td>RA1 / TD</td><td>.mix</td><td>.shp</td><td>—</td><td>.pal</td><td>.aud</td><td>.vqa</td><td>EA GPL release — fully open</td></tr>
<tr><td>RA2 / TS</td><td>.mix</td><td>.shp, .vxl (voxels)</td><td>.hva (voxel anim)</td><td>.pal</td><td>.aud</td><td>.bik</td><td>Community-documented (XCC, Ares, Phobos)</td></tr>
<tr><td>Generals / ZH</td><td>.big</td><td>—</td><td>.w3d (3D meshes)</td><td>—</td><td>—</td><td>.bik</td><td>EA GPL release — fully open</td></tr>
<tr><td>OpenRA</td><td>.oramap (ZIP)</td><td>.png</td><td>—</td><td>.pal</td><td>.wav/.ogg</td><td>—</td><td>Open source</td></tr>
<tr><td>IC native</td><td>—</td><td>.png, sprite sheets</td><td>.glb/.gltf</td><td>.pal, .yaml</td><td>.wav/.ogg/.mp3</td><td>.mp4/.webm</td><td>Our format</td></tr>
</tbody>
</table>
</div>
<p><strong>Minimal reverse engineering required.</strong> RA1/TD and Generals/ZH are fully open-sourced by EA (GPL). RA2/TS formats are not open-sourced but have been community-documented for 20+ years — .vxl, .hva, .csf are thoroughly understood by the XCC, Ares, and Phobos projects. The <code>FormatRegistry</code> trait (D018) already anticipates per-module format loaders.</p>
<h4 id="layer-2--asset-editor"><a class="header" href="#layer-2--asset-editor">Layer 2 — Asset Editor</a></h4>
<p>Scoped asset editing operations. Not pixel painting — structured operations on game asset types.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Tool</th><th>What It Does</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><strong>Palette editor</strong></td><td>Remap colors, adjust faction-color ranges, create palette variants, shift hue/saturation/brightness per range</td><td>“Make a winter palette from temperate” — shift greens to whites</td></tr>
<tr><td><strong>Sprite sheet organizer</strong></td><td>Reorder frames, adjust animation timing, add/remove frames, composite sprite layers, set hotpoints/offsets</td><td>Import 8 PNG frames → assemble into .shp-compatible sprite sheet with correct facing rotations</td></tr>
<tr><td><strong>Chrome / theme designer</strong></td><td>Visual editor for D032 UI themes — drag 9-slice panels, position elements, see result live in actual menu mockup</td><td>Design a new sidebar layout: drag resource bar, build queue, minimap into position. Live preview updates.</td></tr>
<tr><td><strong>Terrain tile editor</strong></td><td>Create terrain tile sets — assign connectivity rules, transition tiles, cliff edges. Preview tiling on a test map.</td><td>Paint a new snow terrain set: assign which tiles connect to which edges</td></tr>
<tr><td><strong>Import pipeline</strong></td><td>Convert standard formats to game-ready assets: PNG → palette-quantized .shp, GLTF → game model with LODs, font → bitmap font sheet</td><td>Drag in a 32-bit PNG → auto-quantize to .pal, preview dithering options, export as .shp</td></tr>
<tr><td><strong>Batch operations</strong></td><td>Apply operations across multiple assets: bulk palette remap, bulk resize, bulk re-export</td><td>“Remap all Soviet unit sprites to use the Tiberium Sun palette”</td></tr>
<tr><td><strong>Diff / compare</strong></td><td>Side-by-side comparison of two versions of an asset — sprite diff, palette diff, before/after</td><td>Compare original RA1 sprite with your modified version, pixel-diff highlighted</td></tr>
<tr><td><strong>Video converter</strong></td><td>Convert between C&amp;C video formats (.vqa) and modern formats (.mp4, .webm). Trim, crop, resize. Subtitle overlay. Frame rate control.</td><td>Record a briefing in OBS → import .mp4 → convert to .vqa for classic feel, or keep as .mp4 for modern campaigns. Extract original RA1 briefings to .mp4 for remixing in Premiere/DaVinci.</td></tr>
<tr><td><strong>Audio converter</strong></td><td>Convert between C&amp;C audio format (.aud) and modern formats (.wav, .ogg). Trim, normalize, fade in/out. Sample rate conversion. Batch convert entire sound libraries.</td><td>Extract all RA1 sound effects to .wav for remixing in Audacity/Reaper. Record custom EVA lines → normalize → convert to .aud for classic feel. Batch-convert a voice pack from .wav to .ogg for Workshop publish.</td></tr>
</tbody>
</table>
</div>
<p><strong>Design rule:</strong> Every operation the Asset Studio performs produces standard output formats. Palette edits produce .pal files. Sprite operations produce .shp or sprite sheet PNGs. Chrome editing produces YAML + sprite sheet PNGs. No proprietary intermediate format — the output is always mod-ready.</p>
<h4 id="layer-3--agentic-asset-generation-d016-extension-phase-7"><a class="header" href="#layer-3--agentic-asset-generation-d016-extension-phase-7">Layer 3 — Agentic Asset Generation (D016 Extension, Phase 7)</a></h4>
<p>LLM-powered asset creation for modders who have ideas but not art skills. Same BYOLLM pattern as D016 — user brings their own provider (DALL-E, Stable Diffusion, Midjourney API, local model), <code>ic-llm</code> routes the request.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Capability</th><th>How It Works</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><strong>Sprite generation</strong></td><td>Describe unit → LLM generates sprite sheet → preview on map → iterate</td><td>“Soviet heavy tank, double barrel, darker than the Mammoth Tank” → generates 8-facing sprite sheet → preview as unit on map → “make the turret bigger” → re-generates</td></tr>
<tr><td><strong>Palette generation</strong></td><td>Describe mood/theme → LLM generates palette → preview applied to existing sprites</td><td>“Volcanic wasteland palette — reds, oranges, dark stone” → generates .pal → preview on temperate map sprites</td></tr>
<tr><td><strong>Chrome generation</strong></td><td>Describe UI style → LLM generates theme elements → preview in actual menu</td><td>“Brutalist concrete UI theme, sharp corners, red accents” → generates chrome sprite sheet → preview in sidebar</td></tr>
<tr><td><strong>Terrain generation</strong></td><td>Describe biome → LLM generates tile set → preview tiling</td><td>“Frozen tundra with ice cracks and snow drifts” → generates terrain tiles with connectivity → preview on test map</td></tr>
<tr><td><strong>Asset variation</strong></td><td>Take existing asset + describe change → LLM produces variant</td><td>“Take this Allied Barracks and make a Nod version — darker, angular, with a scorpion emblem”</td></tr>
<tr><td><strong>Style transfer</strong></td><td>Apply visual style across asset set</td><td>“Make all these units look hand-drawn like Advance Wars”</td></tr>
</tbody>
</table>
</div>
<p><strong>Workflow:</strong></p>
<ol>
<li>Describe what you want (text prompt + optional reference image)</li>
<li>LLM generates candidate(s) — multiple options when possible</li>
<li>Preview in-context (on map, in menu, as unit) — not just a floating image, but in the actual game rendering</li>
<li>Iterate: refine prompt, adjust, regenerate</li>
<li>Post-process: palette quantize, frame extract, format convert</li>
<li>Export as mod-ready asset → ready for Workshop publish</li>
</ol>
<p><strong>Crate boundary:</strong> <code>ic-editor</code> defines an <code>AssetGenerator</code> trait (input: text description + format constraints + optional reference → output: generated image data). <code>ic-llm</code> implements it by routing to the configured provider. <code>ic-game</code> wires them at startup in the SDK binary. Same pattern as <code>NarrativeGenerator</code> for the replay-to-scenario pipeline. The SDK works without an LLM — Layers 1 and 2 are fully functional. Layer 3 activates when a provider is configured.</p>
<p><strong>What the LLM does NOT replace:</strong></p>
<ul>
<li>Professional art. LLM-generated sprites are good enough for prototyping, playtesting, and small mods. Professional pixel art for a polished release still benefits from a human artist.</li>
<li>Format knowledge. The LLM generates images. The Asset Studio handles palette quantization, frame extraction, sprite sheet assembly, and format conversion. The LLM doesn’t need to know about .shp internals.</li>
<li>Quality judgment. The modder decides if the result is good enough. The Asset Studio shows it in context so the judgment is informed.</li>
</ul>
<h3 id="menu--chrome-design-workflow"><a class="header" href="#menu--chrome-design-workflow">Menu / Chrome Design Workflow</a></h3>
<p>UI themes (D032) are YAML + sprite sheets. Currently there’s no visual editor — modders hand-edit coordinates and pixel offsets. The Asset Studio’s chrome designer closes this gap:</p>
<ol>
<li><strong>Load a base theme</strong> (Classic, Remastered, Modern, or any workshop theme)</li>
<li><strong>Visual element editor</strong> — see the 9-slice panels, button states, scrollbar tracks as overlays on the sprite sheet. Drag edges to resize. Click to select.</li>
<li><strong>Layout preview</strong> — split view: sprite sheet on left, live menu mockup on right. Every edit updates the mockup instantly.</li>
<li><strong>Element properties</strong> — per-element: padding, margins, color tint, opacity, font assignment, animation (hover/press states)</li>
<li><strong>Full menu preview</strong> — “Preview as: Main Menu / Sidebar / Build Queue / Lobby / Settings” — switch between all game screens to see the theme in each context</li>
<li><strong>Export</strong> — produces <code>theme.yaml</code> + sprite sheet PNG, ready for <code>ic mod publish</code></li>
<li><strong>Agentic mode</strong> — describe desired changes: “make the sidebar narrower with a brushed metal look” → LLM modifies the sprite sheet + adjusts YAML layout → preview → iterate</li>
</ol>
<h3 id="cross-game-asset-bridge"><a class="header" href="#cross-game-asset-bridge">Cross-Game Asset Bridge</a></h3>
<p>The Asset Studio understands multiple C&amp;C format families and can convert between them:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Conversion</th><th>Direction</th><th>Use Case</th><th>Phase</th></tr>
</thead>
<tbody>
<tr><td>.shp (RA1) → .png</td><td>Export</td><td>Extract classic sprites for editing in external tools</td><td>6a</td></tr>
<tr><td>.png → .shp + .pal</td><td>Import</td><td>Turn modern art into classic-compatible format</td><td>6a</td></tr>
<tr><td>.vxl (RA2) → .glb</td><td>Export</td><td>Convert RA2 voxel models to standard 3D format for editing</td><td>Future</td></tr>
<tr><td>.glb → game model</td><td>Import</td><td>Import artist-created 3D models for future 3D game modules</td><td>Future</td></tr>
<tr><td>.w3d (Generals) → .glb</td><td>Export</td><td>Convert Generals models for viewing and editing</td><td>Future</td></tr>
<tr><td>.vqa → .mp4/.webm</td><td>Export</td><td>Extract original RA/TD cutscenes to modern formats for viewing, remixing, or re-editing in standard video tools (Premiere, DaVinci, Kdenlive)</td><td>6a</td></tr>
<tr><td>.mp4/.webm → .vqa</td><td>Import</td><td>Convert custom-recorded campaign briefings/cutscenes to classic VQA format (palette-quantized, VQ-compressed) for authentic retro feel</td><td>6a</td></tr>
<tr><td>.mp4/.webm passthrough</td><td>Native</td><td>Modern video formats play natively — no conversion required. Campaign creators can use .mp4/.webm directly for briefings and radar comms.</td><td>4</td></tr>
<tr><td>.aud → .wav/.ogg</td><td>Export</td><td>Extract original RA/TD sound effects, EVA lines, and music to modern formats for remixing or editing in standard audio tools (Audacity, Reaper, FL Studio)</td><td>6a</td></tr>
<tr><td>.wav/.ogg → .aud</td><td>Import</td><td>Convert custom audio recordings to classic Westwood AUD format (IMA ADPCM compressed) for authentic retro sound or OpenRA mod compatibility</td><td>6a</td></tr>
<tr><td>.wav/.ogg/.mp3 passthrough</td><td>Native</td><td>Modern audio formats play natively — no conversion required. Mod creators can use .wav/.ogg/.mp3 directly for sound effects, music, and EVA lines.</td><td>3</td></tr>
<tr><td>Theme YAML ↔ visual</td><td>Bidirectional</td><td>Edit themes visually or as YAML — changes sync both ways</td><td>6a</td></tr>
</tbody>
</table>
</div>
<p><strong>ra-formats write support:</strong> Currently <code>ra-formats</code> is read-only (parse .mix, .shp, .pal, .vqa, .aud). The Asset Studio requires write support — generating .shp from frames, writing .pal files, encoding .vqa video, encoding .aud audio, optionally packing .mix archives. This is an additive extension to <code>ra-formats</code> (no redesign of existing parsers), but non-trivial engineering: .shp writing requires correct header generation, frame offset tables, and optional LCW/RLE compression; .vqa encoding requires VQ codebook generation and frame differencing; .aud encoding requires IMA ADPCM compression with correct <code>AUDHeaderType</code> generation and <code>IndexTable</code>/<code>DiffTable</code> lookup table application; .mix packing requires building the file index and CRC hash table. All encoders reference the EA GPL source code implementations directly (see <code>05-FORMATS.md</code> § Binary Format Codec Reference). Budget accordingly in Phase 6a.</p>
<p><strong>Video pipeline:</strong> The game engine natively plays .mp4 and .webm via standard media decoders (platform-provided or bundled). Campaign creators can use modern formats directly — no conversion needed. The .vqa ↔ .mp4/.webm conversion in the Asset Studio is for creators who <em>want</em> the classic C&amp;C aesthetic (palette-quantized, low-res FMV look) or who need to extract and remix original EA cutscenes. The conversion pipeline lives in <code>ra-formats</code> (VQA codec) + <code>ic-editor</code> (UI, preview, trim/crop tools). Someone recording a briefing with a webcam or screen recorder imports their .mp4, previews it in the Video Playback module’s display modes (fullscreen, radar_comm, picture_in_picture), optionally converts to .vqa for retro feel, and publishes via Workshop (D030).</p>
<p><strong>Audio pipeline:</strong> The game engine natively plays .wav, .ogg, and .mp3 via standard audio decoders (Bevy audio plugin + platform codecs). Modern formats are the recommended choice for new content — .ogg for music and voice lines (good compression, no licensing issues), .wav for short sound effects (zero decode latency). The .aud ↔ .wav/.ogg conversion in the Asset Studio is for creators who need to extract and remix original EA audio (hundreds of classic sound effects, EVA voice lines, and Hell March variations) or who want to encode custom audio in classic AUD format for OpenRA mod compatibility. The conversion pipeline lives in <code>ra-formats</code> (AUD codec — IMA ADPCM encode/decode using the original Westwood <code>IndexTable</code>/<code>DiffTable</code> from the EA GPL source) + <code>ic-editor</code> (UI, waveform preview, trim/normalize/fade tools). Someone recording custom EVA voice lines imports their .wav files, previews with waveform visualization, normalizes volume, optionally converts to .aud for classic feel or keeps as .ogg for modern mods, and publishes via Workshop (D030). Batch conversion handles entire sound libraries — extract all 200+ RA1 sound effects to .wav in one operation.</p>
<h3 id="alternatives-considered-1"><a class="header" href="#alternatives-considered-1">Alternatives Considered</a></h3>
<ol>
<li><strong>Rely on external tools entirely</strong> (Photoshop, Aseprite, XCC Mixer) — Rejected. Forces modders to learn multiple disconnected tools with no in-context preview. The “last mile” problem (PNG → game-ready .shp with correct palette, offsets, and facing rotations) is where most modders give up.</li>
<li><strong>Build a full art suite</strong> (pixel editor, 3D modeler) — Rejected. Scope explosion. Aseprite and Blender exist. We handle the game-specific parts they can’t.</li>
<li><strong>In-game asset tools</strong> — Rejected. Same reasoning as the overall SDK separation: players shouldn’t see asset editing tools. The SDK is for creators.</li>
<li><strong>Web-based editor</strong> — Deferred. A browser-based asset viewer/editor is a compelling Phase 7+ goal (especially for the WASM target), but the primary tool ships as a native Bevy application in the SDK.</li>
</ol>
<h3 id="phase"><a class="header" href="#phase">Phase</a></h3>
<ul>
<li><strong>Phase 0:</strong> <code>ra-formats</code> delivers CLI asset inspection (dump/inspect/validate) — the text-mode precursor.</li>
<li><strong>Phase 6a:</strong> Asset Studio ships as part of the SDK alongside the scenario editor. Layer 1 (browser/viewer) and Layer 2 (editor) are the deliverables. Chrome designer ships alongside the UI theme system (D032).</li>
<li><strong>Phase 7:</strong> Layer 3 (agentic generation via <code>ic-llm</code>). Same phase as LLM text generation (D016).</li>
<li><strong>Future:</strong> .vxl/.hva write support (for RA2 module), .w3d viewing (for Generals module), browser-based viewer.</li>
</ul>
<hr>
<h2 id="d039-engine-scope--general-purpose-classic-rts-platform"><a class="header" href="#d039-engine-scope--general-purpose-classic-rts-platform">D039: Engine Scope — General-Purpose Classic RTS Platform</a></h2>
<p><strong>Decision:</strong> Iron Curtain is a general-purpose classic RTS engine. It ships with built-in C&amp;C game modules (Red Alert, Tiberian Dawn) as its primary content, but at the architectural level, the engine’s design does not prevent building any classic RTS — from C&amp;C to Age of Empires to StarCraft to Supreme Commander to original games.</p>
<p><strong>The framing:</strong> Built for C&amp;C, open to anything. C&amp;C games and the OpenRA community remain the primary audience, the roadmap, and the compatibility target. What changes is how we think about the underlying engine: nothing in the engine core should assume a specific resource model, base building model, camera system, or UI layout. These are all game module concerns.</p>
<p><strong>What this means concretely:</strong></p>
<ol>
<li><strong>Red Alert and Tiberian Dawn are built-in mods</strong> — they ship with the engine, like OpenRA bundles RA/TD/D2K. The engine launches into RA1 by default. Other game modules are selectable from a mod menu</li>
<li><strong>Crate naming reflects engine identity</strong> — engine crates use <code>ic-*</code> (Iron Curtain), not <code>ra-*</code>. The exception is <code>ra-formats</code> which genuinely reads C&amp;C/Red Alert file formats. If someone builds an AoE game module, they’d write their own format reader</li>
<li><strong><code>GameModule</code> (D018) becomes the central abstraction</strong> — the trait defines everything that differs between RTS games: resource model, building model, camera, pathfinding implementation, UI layout, tech progression, population model</li>
<li><strong>OpenRA experience as a composable profile</strong> — D019 (balance) + D032 (themes) + D033 (QoL) combine into “experience profiles.” “OpenRA” is a profile: OpenRA balance values + Modern theme + OpenRA QoL conventions. “Classic RA” is another profile. Each is a valid interpretation of the same game module</li>
<li><strong>The C&amp;C variety IS the architectural stress test</strong> — across the franchise (TD, RA1, TS, RA2, Generals, C&amp;C3, RA3, C&amp;C4, Renegade), C&amp;C games already span harvester/supply/streaming/zero-resource economies, sidebar/dozer/crawler building, 2D/3D cameras, grid/navmesh pathing, FPS/RTS hybrids. If the engine supports every C&amp;C game, it inherently supports most classic RTS patterns</li>
</ol>
<p><strong>What this does NOT mean:</strong></p>
<ul>
<li>We don’t dilute the C&amp;C focus. RA1 is the default module, TD ships alongside it. The roadmap doesn’t change</li>
<li>We don’t build generic RTS features that no C&amp;C game needs. Non-C&amp;C capability is an architectural property, not a deliverable</li>
<li>We don’t de-prioritize OpenRA community compatibility. D023–D027 are still critical</li>
<li>We don’t build format readers for non-C&amp;C games. That’s community work on top of the engine</li>
</ul>
<p><strong>Why “any classic RTS” and not “strictly C&amp;C”:</strong></p>
<ul>
<li>The C&amp;C franchise already spans such diverse mechanics that supporting it fully means supporting most classic RTS patterns anyway</li>
<li>Artificial limitations on non-C&amp;C use would require extra code to enforce — it’s harder to close doors than to leave them open</li>
<li>A community member building “StarCraft in IC” exercises and validates the same <code>GameModule</code> API that a community member building “RA2 in IC” uses. Both make the engine more robust</li>
<li>Westwood’s philosophy was engine-first: the same engine technology powered vastly different games. IC follows this spirit</li>
<li>Cancelled C&amp;C games (Tiberium FPS, Generals 2, C&amp;C Arena) and fan concepts exist in the space between “strictly C&amp;C” and “any RTS” — the community should be free to explore them</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>C&amp;C-only scope (rejected — artificially limits what the community can create, while the architecture already supports broader use)</li>
<li>“Any game” scope (rejected — too broad, dilutes C&amp;C identity. Classic RTS is the right frame)</li>
<li>No scope declaration (rejected — ambiguity about what game modules are welcome leads to confusion)</li>
</ul>
<p><strong>Phase:</strong> Baked into architecture from Phase 0 (via D018 and Invariant #9). This decision formalizes what D018 already implied and extends it.</p>
<hr>
<h2 id="d041-trait-abstracted-subsystem-strategy--beyond-networking-and-pathfinding"><a class="header" href="#d041-trait-abstracted-subsystem-strategy--beyond-networking-and-pathfinding">D041: Trait-Abstracted Subsystem Strategy — Beyond Networking and Pathfinding</a></h2>
<p><strong>Decision:</strong> Extend the <code>NetworkModel</code>/<code>Pathfinder</code>/<code>SpatialIndex</code> trait-abstraction pattern to five additional engine subsystems that carry meaningful risk of regret if hardcoded: <strong>AI strategy, fog of war, damage resolution, ranking/matchmaking, and order validation</strong>. Each gets a formal trait in the engine, a default implementation in the RA1 game module, and the same “costs near-zero now, prevents rewrites later” guarantee.</p>
<p><strong>Context:</strong> The engine already trait-abstracts 13 subsystems (see inventory below). These were designed individually — some as architectural invariants (D006 networking, D013 pathfinding), others as consequences of multi-game extensibility (D018 <code>GameModule</code>, <code>Renderable</code>, <code>FormatRegistry</code>). But several critical <em>algorithm-level</em> concerns remain hardcoded in RA1’s system implementations. For data-driven concerns (weather, campaigns, achievements, themes), YAML+Lua modding provides sufficient flexibility — no trait needed. For <em>algorithmic</em> concerns, the resolution logic itself is what varies between game types and modding ambitions.</p>
<p><strong>The principle:</strong> Abstract the <em>algorithm</em>, not the <em>data</em>. If a modder can change behavior through YAML values or Lua scripts, a trait is unnecessary overhead. If changing behavior requires replacing the <em>logic</em> — the decision-making process, the computation pipeline, the scoring formula — that’s where a trait prevents a future rewrite.</p>
<h3 id="inventory-already-trait-abstracted-13"><a class="header" href="#inventory-already-trait-abstracted-13">Inventory: Already Trait-Abstracted (13)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Crate</th><th>Decision</th><th>Phase</th></tr>
</thead>
<tbody>
<tr><td><code>NetworkModel</code></td><td>ic-net</td><td>D006</td><td>2</td></tr>
<tr><td><code>Pathfinder</code></td><td>ic-sim (trait), game module (impl)</td><td>D013</td><td>2</td></tr>
<tr><td><code>SpatialIndex</code></td><td>ic-sim (trait), game module (impl)</td><td>D013</td><td>2</td></tr>
<tr><td><code>InputSource</code></td><td>ic-game</td><td>D018</td><td>2</td></tr>
<tr><td><code>ScreenToWorld</code></td><td>ic-render</td><td>D018</td><td>1</td></tr>
<tr><td><code>Renderable</code> / <code>RenderPlugin</code></td><td>ic-render</td><td>D017/D018</td><td>1</td></tr>
<tr><td><code>GameModule</code></td><td>ic-game</td><td>D018</td><td>2</td></tr>
<tr><td><code>OrderCodec</code></td><td>ic-protocol</td><td>D007</td><td>5</td></tr>
<tr><td><code>TrackingServer</code></td><td>ic-net</td><td>D007</td><td>5</td></tr>
<tr><td><code>LlmProvider</code></td><td>ic-llm</td><td>D016</td><td>7</td></tr>
<tr><td><code>FormatRegistry</code> / <code>FormatLoader</code></td><td>ra-formats</td><td>D018</td><td>0</td></tr>
<tr><td><code>SimReconciler</code></td><td>ic-net</td><td>D011</td><td>Future</td></tr>
<tr><td><code>CommunityBridge</code></td><td>ic-net</td><td>D011</td><td>Future</td></tr>
</tbody>
</table>
</div>
<h3 id="new-trait-abstractions-5"><a class="header" href="#new-trait-abstractions-5">New Trait Abstractions (5)</a></h3>
<h4 id="1-aistrategy--pluggable-ai-decision-making"><a class="header" href="#1-aistrategy--pluggable-ai-decision-making">1. <code>AiStrategy</code> — Pluggable AI Decision-Making</a></h4>
<p><strong>Problem:</strong> <code>ic-ai</code> defines <code>AiPersonality</code> as a YAML-configurable parameter struct (aggression, tech preference, micro level) that tunes behavior within a fixed decision algorithm. This is great for balance knobs — but a modder who wants a fundamentally different AI approach (GOAP planner, Monte Carlo tree search, neural network, scripted state machine, or a tournament-specific meta-counter AI) cannot plug one in. They’d have to fork <code>ic-ai</code> or write a WASM mod that reimplements the entire AI from scratch.</p>
<p><strong>Solution:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Game modules and mods implement this to provide AI opponents.
/// The default RA1 implementation uses AiPersonality-driven behavior trees.
/// Mods can provide alternatives: planning-based, neural, procedural, etc.
pub trait AiStrategy: Send + Sync {
    /// Called once per AI player per tick. Reads visible game state, emits orders.
    fn decide(
        &amp;mut self,
        player: PlayerId,
        view: &amp;FogFilteredView,  // only what this player can see
        tick: u64,
    ) -&gt; Vec&lt;PlayerOrder&gt;;

    /// Human-readable name for lobby display.
    fn name(&amp;self) -&gt; &amp;str;

    /// Difficulty tier for matchmaking/UI categorization.
    fn difficulty(&amp;self) -&gt; AiDifficulty;

    /// Optional: per-tick compute budget hint (microseconds).
    fn tick_budget_hint(&amp;self) -&gt; Option&lt;u64&gt;;

    // --- Event callbacks (inspired by Spring Engine + BWAPI research) ---
    // Default implementations are no-ops. AIs override what they care about.
    // Events are pushed by the engine at the same pipeline point as decide(),
    // before the decide() call — so the AI can react within the same tick.

    /// Own unit finished construction/training.
    fn on_unit_created(&amp;mut self, _unit: EntityId, _unit_type: &amp;str) {}
    /// Own unit destroyed.
    fn on_unit_destroyed(&amp;mut self, _unit: EntityId, _attacker: Option&lt;EntityId&gt;) {}
    /// Own unit has no orders (idle).
    fn on_unit_idle(&amp;mut self, _unit: EntityId) {}
    /// Enemy unit enters line of sight.
    fn on_enemy_spotted(&amp;mut self, _unit: EntityId, _unit_type: &amp;str) {}
    /// Known enemy unit destroyed.
    fn on_enemy_destroyed(&amp;mut self, _unit: EntityId) {}
    /// Own unit taking damage.
    fn on_under_attack(&amp;mut self, _unit: EntityId, _attacker: EntityId) {}
    /// Own building completed.
    fn on_building_complete(&amp;mut self, _building: EntityId) {}
    /// Research/upgrade completed.
    fn on_research_complete(&amp;mut self, _tech: &amp;str) {}

    // --- Parameter introspection (inspired by MicroRTS research) ---
    // Enables: automated parameter tuning, UI-driven difficulty sliders,
    // tournament parameter search, AI vs AI evaluation.

    /// Expose tunable parameters for external configuration.
    fn get_parameters(&amp;self) -&gt; Vec&lt;ParameterSpec&gt; { vec![] }
    /// Set a parameter value (called by engine from YAML config or UI).
    fn set_parameter(&amp;mut self, _name: &amp;str, _value: i32) {}

    // --- Engine difficulty scaling (inspired by 0 A.D. + AoE2 research) ---

    /// Whether this AI uses engine-level difficulty scaling (resource bonuses,
    /// reaction delays, etc.). Default: true. Sophisticated AIs that handle
    /// difficulty internally can return false to opt out.
    fn uses_engine_difficulty_scaling(&amp;self) -&gt; bool { true }
}

pub enum AiDifficulty { Sandbox, Easy, Normal, Hard, Brutal, Custom(String) }

pub struct ParameterSpec {
    pub name: String,
    pub description: String,
    pub min_value: i32,
    pub max_value: i32,
    pub default_value: i32,
    pub current_value: i32,
}
<span class="boring">}</span></code></pre>
<p><strong>Key design points:</strong></p>
<ul>
<li><code>FogFilteredView</code> ensures AI honesty — no maphack by default. Campaign scripts can provide an omniscient view for specific AI players via conditions.</li>
<li><code>AiPersonality</code> becomes the configuration for the <em>default</em> <code>AiStrategy</code> implementation (<code>PersonalityDrivenAi</code>), not the only way to configure AI.</li>
<li><strong>Event callbacks</strong> (from Spring Engine/BWAPI research, see <code>research/rts-ai-extensibility-survey.md</code>) enable reactive AI without polling. Pure <code>decide()</code>-only AI works fine (events are optional), but event-aware AI can respond immediately to threats, idle units, and scouting information. Events fire before <code>decide()</code> in the same tick, so the AI can incorporate event data into its tick decision.</li>
<li><strong>Parameter introspection</strong> (from MicroRTS research) enables automated parameter tuning and UI-driven difficulty sliders. Every <code>AiStrategy</code> can expose its knobs — tournament systems use this for automated parameter search, the lobby UI uses it for “Advanced AI Settings” sliders.</li>
<li><strong>Engine difficulty scaling opt-out</strong> (from 0 A.D. + AoE2 research) lets sophisticated AIs handle difficulty internally. Simple AIs get engine-provided resource bonuses and reaction time delays; advanced AIs that model difficulty as behavioral parameters can opt out.</li>
<li>AI strategies are selectable in the lobby: “IC Default (Normal)”, “IC Default (Brutal)”, “Workshop: Neural Net v2.1”, etc.</li>
<li>WASM Tier 3 mods can provide <code>AiStrategy</code> implementations — the trait is part of the stable mod API surface.</li>
<li>Lua Tier 2 mods can script lightweight AI via the existing Lua API (trigger-based). <code>AiStrategy</code> trait is for full-replacement AI, not scripted behaviors.</li>
<li>Adaptive difficulty (D034 integration) is implemented inside the default strategy, not in the trait — it’s an implementation detail of <code>PersonalityDrivenAi</code>.</li>
<li>Determinism: <code>decide()</code> and all event callbacks are called at a fixed point in the system pipeline. All clients run the same AI with the same state → same orders. Mod-provided AI is subject to the same determinism requirements as any sim code.</li>
</ul>
<p><strong>Event accumulation — <code>AiEventLog</code>:</strong></p>
<p>The engine provides an <code>AiEventLog</code> utility struct to every <code>AiStrategy</code> instance. It accumulates fog-filtered events from the callbacks above into a structured, queryable log — the “inner game event log” that D044 (LLM-enhanced AI) consumes as its primary context source. Non-LLM AI can ignore the log entirely (zero cost if <code>to_narrative()</code> is never called); LLM-based AI uses it as the bridge between simulation events and natural-language prompts.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Accumulates fog-filtered game events into a structured log.
/// Provided by the engine to every AiStrategy instance. Events are pushed
/// into the log when callbacks fire — the AI gets both the callback
/// AND a persistent log entry.
pub struct AiEventLog {
    entries: CircularBuffer&lt;AiEventEntry&gt;,  // bounded, oldest entries evicted
    capacity: usize,                        // default: 1000 entries
}

pub struct AiEventEntry {
    pub tick: u64,
    pub event_type: AiEventType,
    pub description: String,  // human/LLM-readable summary
    pub entity: Option&lt;EntityId&gt;,
    pub related_entity: Option&lt;EntityId&gt;,
}

pub enum AiEventType {
    UnitCreated, UnitDestroyed, UnitIdle,
    EnemySpotted, EnemyDestroyed,
    UnderAttack, BuildingComplete, ResearchComplete,
    StrategicUpdate,  // injected by orchestrator AI when plan changes (D044)
}

impl AiEventLog {
    /// All events since a given tick (for periodic LLM consultations).
    pub fn since(&amp;self, tick: u64) -&gt; &amp;[AiEventEntry] { /* ... */ }

    /// Natural-language narrative summary — suitable for LLM prompts.
    /// Produces chronological text: "Tick 450: Enemy tank spotted near our
    /// expansion. Tick 460: Our refinery under attack by 3 enemy units."
    pub fn to_narrative(&amp;self, since_tick: u64) -&gt; String { /* ... */ }

    /// Structured summary — counts by event type, key entities, threat level.
    pub fn summary(&amp;self) -&gt; EventSummary { /* ... */ }
}
<span class="boring">}</span></code></pre>
<p>Key properties of the event log:</p>
<ul>
<li><strong>Fog-filtered by construction.</strong> All entries originate from the same callback pipeline that respects <code>FogFilteredView</code> — no event reveals information the AI shouldn’t have. This is the architectural guarantee the user asked for: the “action story / context” the LLM reads is honest.</li>
<li><strong>Bounded.</strong> Circular buffer with configurable capacity (default 1000 entries). Oldest entries are evicted. No unbounded memory growth.</li>
<li><strong><code>to_narrative(since_tick)</code></strong> generates a chronological natural-language account of events since a given tick — this is the “inner game event log / action story / context” that D044’s <code>LlmOrchestratorAi</code> sends to the LLM for strategic guidance.</li>
<li><strong><code>StrategicUpdate</code> event type.</strong> D044’s LLM orchestrator records its own plan changes into the log, creating a complete narrative that includes both game events and AI strategic decisions.</li>
<li><strong>Useful beyond LLM.</strong> Debug/spectator overlays for any AI (“what does this AI know?”), D042’s behavioral profile building, and replay analysis all benefit from a structured event log.</li>
<li><strong>Zero cost if unused.</strong> The engine pushes entries regardless (they’re cheap structs), but <code>to_narrative()</code> — the expensive serialization — is only called by consumers that need it.</li>
</ul>
<p><strong>Modder-selectable and modder-provided:</strong> The <code>AiStrategy</code> trait is open — not locked to first-party implementations. This follows the same pattern as <code>Pathfinder</code> (D013/D045) and render modes (D048):</p>
<ol>
<li><strong>Select</strong> any registered <code>AiStrategy</code> for a mod (e.g., a Generals total conversion uses a GOAP planner instead of behavior trees)</li>
<li><strong>Provide</strong> a custom <code>AiStrategy</code> via a Tier 3 WASM module and distribute it through the Workshop (D030)</li>
<li><strong>Use someone else’s</strong> community-created AI — declare it as a dependency in the mod manifest</li>
</ol>
<p>Unlike pathfinders (one axis: algorithm), AI has <strong>two orthogonal axes</strong>: which algorithm (<code>AiStrategy</code> impl) and how hard it plays (difficulty level). See D043 for the full two-axis difficulty system.</p>
<p><strong>What we build now:</strong> Only <code>PersonalityDrivenAi</code> (the existing YAML-configurable behavior). The trait exists from Phase 4 (when AI ships); alternative implementations are future work by us or the community.</p>
<p><strong>Phase:</strong> Phase 4 (AI &amp; Single Player).</p>
<h4 id="2-fogprovider--pluggable-fog-of-war-computation"><a class="header" href="#2-fogprovider--pluggable-fog-of-war-computation">2. <code>FogProvider</code> — Pluggable Fog of War Computation</a></h4>
<p><strong>Problem:</strong> <code>fog_system()</code> is system #21 in the RA1 pipeline. It computes visibility based on unit sight ranges — but the computation algorithm is baked into the system implementation. Different game modules need different fog models: radius-based (RA1), line-of-sight with elevation raycast (RA2/TS), hex-grid fog (non-C&amp;C mods), or even no fog at all (sandbox modes). The future fog-authoritative <code>NetworkModel</code> needs server-side fog computation that fundamentally differs from client-side — the same <code>FogProvider</code> trait would serve both.</p>
<p><strong>Solution:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Game modules implement this to define how visibility is computed.
/// The engine calls this from fog_system() — the system schedules the work,
/// the provider computes the result.
pub trait FogProvider: Send + Sync {
    /// Recompute visibility for a player. Called by fog_system() each tick
    /// (or staggered per 10-PERFORMANCE.md amortization rules).
    fn update_visibility(
        &amp;mut self,
        player: PlayerId,
        sight_sources: &amp;[(WorldPos, SimCoord)],  // (position, sight_range) pairs
        terrain: &amp;TerrainData,
    );

    /// Is this position visible to this player right now?
    fn is_visible(&amp;self, player: PlayerId, pos: WorldPos) -&gt; bool;

    /// Is this position explored (ever seen) by this player?
    fn is_explored(&amp;self, player: PlayerId, pos: WorldPos) -&gt; bool;

    /// Bulk query: all entity IDs visible to this player (for AI, render culling).
    fn visible_entities(&amp;self, player: PlayerId) -&gt; &amp;[EntityId];
}
<span class="boring">}</span></code></pre>
<p><strong>Key design points:</strong></p>
<ul>
<li>RA1 module registers <code>RadiusFogProvider</code> — simple circle-based visibility. Fast, cache-friendly, matches original RA behavior.</li>
<li>RA2/TS module would register <code>ElevationFogProvider</code> — raycasts against terrain heightmap for line-of-sight.</li>
<li>Non-C&amp;C mods could implement hex fog, cone-of-vision, or always-visible. Sandbox/debug modes: <code>NoFogProvider</code> (everything visible).</li>
<li>Fog-authoritative server (<code>FogAuthoritativeNetwork</code> from D006 future architectures) reuses the same <code>FogProvider</code> on the server side to determine which entities to send to each client.</li>
<li>Performance: <code>fog_system()</code> drives the amortization schedule (stagger updates per <code>10-PERFORMANCE.md</code>). The provider does the math; the system decides when to call it.</li>
<li>Shroud (unexplored terrain) vs. fog (explored but not currently visible) distinction is preserved in the trait via <code>is_visible()</code> vs. <code>is_explored()</code>.</li>
</ul>
<p><strong>What we build now:</strong> Only <code>RadiusFogProvider</code>. The trait exists from Phase 2; <code>ElevationFogProvider</code> ships when RA2/TS module development begins.</p>
<p><strong>Phase:</strong> Phase 2 (built alongside <code>fog_system()</code> in the sim).</p>
<h4 id="3-damageresolver--pluggable-damage-pipeline-resolution"><a class="header" href="#3-damageresolver--pluggable-damage-pipeline-resolution">3. <code>DamageResolver</code> — Pluggable Damage Pipeline Resolution</a></h4>
<p><strong>Problem:</strong> D028 defines the full damage pipeline: Armament → Projectile → Warhead → Versus table → multiplier stack → Health reduction. The <em>data</em> flowing through this pipeline is deeply moddable — warheads, versus tables, modifier stacks are all YAML-configurable. But the <em>resolution algorithm</em> — the order in which shields, armor, conditions, and multipliers are applied — is hardcoded in <code>projectile_system()</code>. A game module where shields absorb before armor checks, or where sub-object targeting distributes damage across components (Generals-style), or where damage types bypass armor entirely (TS ion storms) needs a different resolution order. These aren’t data changes — they’re algorithmic.</p>
<p><strong>Solution:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Game modules implement this to define how damage is resolved after
/// a warhead makes contact. The default RA1 implementation applies the
/// standard Versus table + modifier stack pipeline.
pub trait DamageResolver: Send + Sync {
    /// Resolve final damage from a warhead impact on a target.
    /// Called by projectile_system() after hit detection.
    fn resolve_damage(
        &amp;self,
        warhead: &amp;WarheadDef,
        target: &amp;DamageTarget,
        modifiers: &amp;StatModifiers,
        distance_from_impact: SimCoord,
    ) -&gt; DamageResult;
}

pub struct DamageTarget {
    pub entity: EntityId,
    pub armor_type: ArmorType,
    pub current_health: i32,
    pub shield: Option&lt;ShieldState&gt;,  // D029 shield system
    pub conditions: Conditions,
}

pub struct DamageResult {
    pub health_damage: i32,
    pub shield_damage: i32,
    pub conditions_applied: Vec&lt;(ConditionId, u32)&gt;,  // condition grants from warhead
    pub overkill: i32,  // excess damage (for death effects)
}
<span class="boring">}</span></code></pre>
<p><strong>Key design points:</strong></p>
<ul>
<li>The default <code>StandardDamageResolver</code> implements the RA1 pipeline from D028: Versus table lookup → distance falloff → multiplier stack → health reduction. This handles 95% of C&amp;C damage scenarios.</li>
<li>RA2 registers <code>ShieldFirstDamageResolver</code>: absorb shield → then armor → then health. Same trait, different algorithm.</li>
<li>Generals-class modules could register <code>SubObjectDamageResolver</code>: distributes damage across multiple hit zones per unit.</li>
<li>The trait boundary is <em>after hit detection</em> and <em>before health reduction</em>. Projectile flight, homing, and area-of-effect detection are shared infrastructure. Only the final damage-number calculation varies.</li>
<li>Warhead-applied conditions (e.g., “irradiated” from D028’s composable warhead design) flow through <code>DamageResult.conditions_applied</code> — the resolver decides which conditions apply based on its game’s rules.</li>
<li>WASM Tier 3 mods can provide custom resolvers for total conversions.</li>
</ul>
<p><strong>What we build now:</strong> Only <code>StandardDamageResolver</code>. The trait exists from Phase 2 (ships with D028). Shield-aware resolver ships when the D029 shield system lands.</p>
<p><strong>Phase:</strong> Phase 2 (ships with D028 damage pipeline).</p>
<h4 id="4-rankingprovider--pluggable-rating-and-matchmaking"><a class="header" href="#4-rankingprovider--pluggable-rating-and-matchmaking">4. <code>RankingProvider</code> — Pluggable Rating and Matchmaking</a></h4>
<p><strong>Problem:</strong> The competitive infrastructure (AGENTS.md) specifies Glicko-2 ratings, but the ranking algorithm is implemented directly in the relay/tracking server with no abstraction boundary. Tournament organizers and community servers may want Elo (simpler, well-understood), TrueSkill (better for team games), or custom rating systems (handicap-adjusted, seasonal decay variants, faction-specific ratings). Since tracking servers are community-hostable and federated (D030/D037), locking the rating algorithm to Glicko-2 limits what community operators can offer.</p>
<p><strong>Solution:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Tracking servers implement this to provide rating calculations.
/// The default implementation uses Glicko-2.
pub trait RankingProvider: Send + Sync {
    /// Calculate updated ratings after a match result.
    fn update_ratings(
        &amp;mut self,
        result: &amp;CertifiedMatchResult,
        current_ratings: &amp;[PlayerRating],
    ) -&gt; Vec&lt;PlayerRating&gt;;

    /// Estimate match quality / fairness for proposed matchmaking.
    fn match_quality(&amp;self, team_a: &amp;[PlayerRating], team_b: &amp;[PlayerRating]) -&gt; MatchQuality;

    /// Rating display for UI (e.g., "1500 ± 200" for Glicko, "Silver II" for league).
    fn display_rating(&amp;self, rating: &amp;PlayerRating) -&gt; String;

    /// Algorithm identifier for interop (ratings from different algorithms aren't comparable).
    fn algorithm_id(&amp;self) -&gt; &amp;str;
}

pub struct PlayerRating {
    pub player_id: PlayerId,
    pub rating: i64,        // fixed-point, algorithm-specific
    pub deviation: i64,     // uncertainty (Glicko RD, TrueSkill σ)
    pub volatility: i64,    // Glicko-2 specific; other algorithms may ignore
    pub games_played: u32,
}

pub struct MatchQuality {
    pub fairness: i32,      // 0-1000 (fixed-point), higher = more balanced
    pub estimated_draw_probability: i32,  // 0-1000 (fixed-point)
}
<span class="boring">}</span></code></pre>
<p><strong>Key design points:</strong></p>
<ul>
<li>Default: <code>Glicko2Provider</code> — well-suited for 1v1 and small teams, proven in chess and competitive gaming.</li>
<li>Community operators provide alternatives: <code>EloProvider</code> (simpler), <code>TrueSkillProvider</code> (better team rating), or custom implementations.</li>
<li><code>algorithm_id()</code> prevents mixing ratings from different algorithms — a Glicko-2 “1800” is not an Elo “1800”.</li>
<li><code>CertifiedMatchResult</code> (from relay server, D007) is the input — no self-reported results.</li>
<li>Ratings stored in SQLite (D034) on the tracking server.</li>
<li>The official tracking server uses Glicko-2. Community tracking servers choose their own.</li>
<li>Fixed-point ratings (matching sim math conventions) — no floating-point in the ranking pipeline.</li>
</ul>
<p><strong>What we build now:</strong> Only <code>Glicko2Provider</code>. The trait exists from Phase 5 (when competitive infrastructure ships). Alternative providers are community work.</p>
<p><strong>Phase:</strong> Phase 5 (Multiplayer &amp; Competitive).</p>
<h4 id="5-ordervalidator--explicit-per-module-order-validation"><a class="header" href="#5-ordervalidator--explicit-per-module-order-validation">5. <code>OrderValidator</code> — Explicit Per-Module Order Validation</a></h4>
<p><strong>Problem:</strong> D012 mandates that every order is validated inside the sim before execution, deterministically. Currently, validation is implicit — it happens inside <code>apply_orders()</code>, which is part of the game module’s system pipeline. This works because <code>GameModule::system_pipeline()</code> lets each module define its own <code>apply_orders()</code> implementation. But the validation contract is informal: nothing in the architecture <em>requires</em> a game module to validate orders, or specifies what validation means. A game module that forgets validation breaks the anti-cheat guarantee (D012) silently.</p>
<p><strong>Solution:</strong> Add <code>order_validator()</code> to the <code>GameModule</code> trait, making validation an explicit, required contract:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Added to GameModule trait (D018):
pub trait GameModule: Send + Sync + 'static {
    // ... existing methods ...

    /// Provide the module's order validation logic.
    /// Called by the engine before apply_orders() — not by the module's own systems.
    /// The engine enforces that ALL orders pass validation before execution.
    fn order_validator(&amp;self) -&gt; Box&lt;dyn OrderValidator&gt;;
}

/// Game modules implement this to define legal orders.
/// The engine calls this for EVERY order, EVERY tick — the game module
/// cannot accidentally skip validation.
pub trait OrderValidator: Send + Sync {
    /// Validate an order against current game state.
    /// Returns Valid or Rejected with a reason for logging/anti-cheat.
    fn validate(
        &amp;self,
        player: PlayerId,
        order: &amp;PlayerOrder,
        state: &amp;SimReadView,
    ) -&gt; OrderValidity;
}

pub enum OrderValidity {
    Valid,
    Rejected(RejectionReason),
}

pub enum RejectionReason {
    NotOwner,
    InsufficientFunds,
    MissingPrerequisite,
    InvalidPlacement,
    CooldownActive,
    InvalidTarget,
    RateLimited,       // OrderBudget exceeded (D006 security)
    Custom(String),    // game-module-specific reasons
}
<span class="boring">}</span></code></pre>
<p><strong>Key design points:</strong></p>
<ul>
<li>The engine (not the game module) calls <code>validate()</code> before <code>apply_orders()</code>. This means a game module <em>cannot</em> skip validation — the architecture enforces D012’s anti-cheat guarantee.</li>
<li><code>SimReadView</code> is a read-only view of sim state — the validator cannot mutate game state.</li>
<li><code>RejectionReason</code> includes standard reasons (shared across all game modules) plus <code>Custom</code> for game-specific rules.</li>
<li>Repeated rejections from the same player are logged for anti-cheat pattern detection (existing D012 design, now formalized).</li>
<li>The default RA1 implementation validates ownership, affordability, prerequisites, placement rules, and rate limits. RA2 would add superweapon authorization, garrison capacity checks, etc.</li>
<li>This is the lowest-risk trait in the set — it formalizes what <code>apply_orders()</code> already does informally. The cost is moving validation from “inside the first system” to “explicit engine-level contract.”</li>
</ul>
<p><strong>What we build now:</strong> RA1 <code>StandardOrderValidator</code>. The trait exists from Phase 2.</p>
<p><strong>Phase:</strong> Phase 2 (ships with <code>apply_orders()</code>).</p>
<h3 id="costbenefit-analysis"><a class="header" href="#costbenefit-analysis">Cost/Benefit Analysis</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Cost Now</th><th>Prevents Later</th></tr>
</thead>
<tbody>
<tr><td><code>AiStrategy</code></td><td>One trait + <code>PersonalityDrivenAi</code> wrapper</td><td>Community AI cannot plug in without forking ic-ai</td></tr>
<tr><td><code>FogProvider</code></td><td>One trait + <code>RadiusFogProvider</code></td><td>RA2 elevation fog requires rewriting fog_system(); fog-authoritative server requires separate fog codebase</td></tr>
<tr><td><code>DamageResolver</code></td><td>One trait + <code>StandardDamageResolver</code></td><td>Shield/sub-object games require rewriting projectile_system()</td></tr>
<tr><td><code>RankingProvider</code></td><td>One trait + <code>Glicko2Provider</code></td><td>Community tracking servers stuck with one rating algorithm</td></tr>
<tr><td><code>OrderValidator</code></td><td>One trait + explicit validate() call</td><td>Game modules can silently skip validation; anti-cheat guarantee is informal</td></tr>
</tbody>
</table>
</div>
<p>All five follow the established pattern: <strong>one trait definition, one default implementation, zero overhead</strong> (Rust monomorphizes single-impl traits to direct calls). The architectural cost is 5 trait definitions (~50 lines total) and 5 wrapper implementations (~200 lines total). The benefit is that none of these subsystems becomes a rewrite-required bottleneck when game modules, mods, or community servers need different behavior.</p>
<h3 id="what-does-not-need-a-trait"><a class="header" href="#what-does-not-need-a-trait">What Does NOT Need a Trait</a></h3>
<p>These subsystems are already sufficiently modular through data-driven design (YAML/Lua/WASM):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Subsystem</th><th>Why No Trait Needed</th></tr>
</thead>
<tbody>
<tr><td>Weather (D022)</td><td>State machine defined in YAML, transitions driven by Lua. Algorithm is trivial; data is everything.</td></tr>
<tr><td>Campaign (D021)</td><td>Graph structure in YAML, logic in Lua. The campaign engine runs any graph; no algorithmic variation needed.</td></tr>
<tr><td>Achievements (D036)</td><td>Definitions in YAML, triggers in Lua. Storage in SQLite. No algorithm to swap.</td></tr>
<tr><td>UI Themes (D032)</td><td>Pure YAML + sprite sheets. No computation to abstract.</td></tr>
<tr><td>QoL Toggles (D033)</td><td>YAML config flags. Each toggle is a sim-affecting or client-only boolean.</td></tr>
<tr><td>Audio (P003)</td><td>Bevy abstracts the audio backend. <code>ic-audio</code> is a Bevy plugin, not an algorithm.</td></tr>
<tr><td>Balance Presets (D019)</td><td>YAML rule sets. Switching preset = loading different YAML.</td></tr>
</tbody>
</table>
</div>
<p>The distinction: <strong>traits abstract algorithms; YAML/Lua abstracts data and behavior parameters.</strong> A damage <em>formula</em> is an algorithm (trait). A damage <em>value</em> is data (YAML). An AI <em>decision process</em> is an algorithm (trait). An AI <em>aggression level</em> is a parameter (YAML).</p>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Trait-abstract everything (rejected — unnecessary overhead for data-driven systems; violates D015’s “no speculative abstractions” principle from D018)</li>
<li>Trait-abstract nothing new (rejected — the 5 identified systems carry real risk of regret; the <code>NetworkModel</code> pattern has proven its value; the cost is near-zero)</li>
<li>Abstract only AI and fog (rejected — damage resolution and ranking carry comparable risk, and <code>OrderValidator</code> formalizes an existing implicit contract)</li>
</ul>
<p><strong>Relationship to existing decisions:</strong></p>
<ul>
<li>Extends D006’s philosophy (“pluggable via trait”) to 5 new subsystems</li>
<li>Extends D013’s pattern (“trait-abstracted, default impl first”) identically</li>
<li>Extends D018’s <code>GameModule</code> trait with <code>order_validator()</code></li>
<li>Supports D028 (damage pipeline) by abstracting the resolution step</li>
<li>Supports D029 (shield system) by allowing shield-first damage resolution</li>
<li>Supports future fog-authoritative server (D006 future architecture)</li>
</ul>
<p><strong>Phase:</strong> Trait definitions exist from the phase each subsystem ships (Phase 2–5). Alternative implementations are future work.</p>
<hr>
<h2 id="d042-player-behavioral-profiles--training-system--the-black-box"><a class="header" href="#d042-player-behavioral-profiles--training-system--the-black-box">D042: Player Behavioral Profiles &amp; Training System — The Black Box</a></h2>
<p><strong>Status:</strong> Accepted
<strong>Scope:</strong> <code>ic-ai</code>, <code>ic-ui</code>, <code>ic-llm</code> (optional), <code>ic-sim</code> (read-only), D034 SQLite extension
<strong>Phase:</strong> Core profiles + quick training: Phase 4–5. LLM coaching loop: Phase 7.</p>
<h3 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h3>
<p>Every gameplay session generates rich structured data (D031 <code>GameplayEvent</code> stream, D034 SQLite storage). Today this data feeds:</p>
<ul>
<li>Post-game stats and career analytics (<code>ic-ui</code>)</li>
<li>Adaptive AI difficulty and counter-strategy (<code>ic-ai</code>, between-game queries)</li>
<li>LLM personalization: coaching suggestions, post-match commentary, rivalry narratives (<code>ic-llm</code>, optional)</li>
<li>Replay-to-scenario pipeline: extract one replay’s behavior into AI modules (<code>ic-editor</code> + <code>ic-ai</code>, D038)</li>
</ul>
<p>But three capabilities are missing:</p>
<ol>
<li>
<p><strong>Aggregated player style profiles.</strong> The replay-to-scenario pipeline extracts behavior from <em>one</em> replay. The adaptive AI mentions “per-player gameplay patterns” but only for difficulty tuning, not for creating a reusable AI opponent. There’s no cross-game model that captures <em>how a specific player tends to play</em> — their preferred build orders, timing windows, unit composition habits, engagement style, faction tendencies — aggregated from all recorded games.</p>
</li>
<li>
<p><strong>Quick training mode.</strong> Training against a human’s style currently requires the full scenario editor pipeline (import replay → configure extraction → save → play). There’s no “pick an opponent from your match history and play against their style on any map right now” flow.</p>
</li>
<li>
<p><strong>Iterative training loop with progress tracking.</strong> Coaching suggestions exist as one-off readouts. There’s no structured system for: play → get coached → play again with targeted AI → measure improvement → repeat. No weakness tracking over time.</p>
</li>
</ol>
<h3 id="the-black-box-concept"><a class="header" href="#the-black-box-concept">The Black Box Concept</a></h3>
<p>Every match produces a <em>flight recorder</em> — a structured event log informative enough that an AI system (rule-based or LLM) can reconstruct:</p>
<ul>
<li><strong>What happened</strong> — build timelines, army compositions, engagement sequences, resource curves</li>
<li><strong>How the player plays</strong> — timing patterns, aggression level, unit preferences, micro tendencies, strategic habits</li>
<li><strong>Where the player struggles</strong> — loss patterns, weaknesses by faction/map/timing, unit types with poor survival rates</li>
</ul>
<p>The gameplay event stream (D031) already captures this data. D042 adds the systems that <em>interpret</em> it: profile building, profile-driven AI, and a training workflow that uses both.</p>
<h3 id="player-style-profiles"><a class="header" href="#player-style-profiles">Player Style Profiles</a></h3>
<p>A <code>PlayerStyleProfile</code> aggregates gameplay patterns across multiple games into a reusable behavioral model:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Aggregated behavioral model built from gameplay event history.
/// Drives StyleDrivenAi and training recommendations.
pub struct PlayerStyleProfile {
    pub player_id: HashedPlayerId,
    pub games_analyzed: u32,
    pub last_updated: Timestamp,

    // Strategic tendencies (averages across games)
    pub preferred_factions: Vec&lt;(String, f32)&gt;,         // faction → usage rate
    pub avg_expansion_timing: FixedPoint,               // ticks until first expansion
    pub avg_first_attack_timing: FixedPoint,            // ticks until first offensive
    pub build_order_templates: Vec&lt;BuildOrderTemplate&gt;, // most common opening sequences
    pub unit_composition_profile: UnitCompositionProfile, // preferred unit mix by game phase
    pub aggression_index: FixedPoint,                   // 0.0 = turtle, 1.0 = all-in rusher
    pub tech_priority: TechPriority,                    // rush / balanced / fast-tech
    pub resource_efficiency: FixedPoint,                // avg resource utilization rate
    pub micro_intensity: FixedPoint,                    // orders-per-unit-per-minute

    // Engagement patterns
    pub preferred_attack_directions: Vec&lt;MapQuadrant&gt;,  // where they tend to attack from
    pub retreat_threshold: FixedPoint,                  // health % at which units disengage
    pub multi_prong_frequency: FixedPoint,              // how often they split forces

    // Weakness indicators (for training)
    pub loss_patterns: Vec&lt;LossPattern&gt;,                // recurring causes of defeat
    pub weak_matchups: Vec&lt;(String, FixedPoint)&gt;,       // faction/strategy → loss rate
    pub underused_counters: Vec&lt;String&gt;,                // unit types available but rarely built
}
<span class="boring">}</span></code></pre>
<p><strong>How profiles are built:</strong></p>
<ul>
<li><code>ic-ai</code> runs aggregation queries against the SQLite <code>gameplay_events</code> and <code>match_players</code> tables at profile-build time (not during matches)</li>
<li>Profile building is triggered after each completed match and cached in a new <code>player_profiles</code> SQLite table</li>
<li>For the local player: full data from all local games</li>
<li>For opponents: data reconstructed from matches where you were a participant — you can only model players you’ve actually played against, using the events visible in those shared sessions</li>
</ul>
<p><strong>Privacy:</strong> Opponent profiles are built entirely from your local replay data. No data is fetched from other players’ machines. You see their behavior <em>from your games with them</em>, not from their solo play. No profile data is exported or shared unless the player explicitly opts in.</p>
<h4 id="sqlite-extension-d034"><a class="header" href="#sqlite-extension-d034">SQLite Extension (D034)</a></h4>
<pre><code class="language-sql">-- Player style profiles (D042 — cached aggregated behavior models)
CREATE TABLE player_profiles (
    id              INTEGER PRIMARY KEY,
    player_id_hash  TEXT NOT NULL UNIQUE,  -- hashed player identifier
    display_name    TEXT,                  -- last known display name
    games_analyzed  INTEGER NOT NULL,
    last_updated    TEXT NOT NULL,
    profile_json    TEXT NOT NULL,         -- serialized PlayerStyleProfile
    is_local        INTEGER NOT NULL DEFAULT 0  -- 1 for the local player's own profile
);

-- Training session tracking (D042 — iterative improvement measurement)
CREATE TABLE training_sessions (
    id              INTEGER PRIMARY KEY,
    started_at      TEXT NOT NULL,
    target_weakness TEXT NOT NULL,         -- what weakness this session targets
    opponent_profile TEXT,                 -- player_id_hash of the style being trained against
    map_name        TEXT NOT NULL,
    result          TEXT,                  -- 'victory', 'defeat', null if incomplete
    duration_ticks  INTEGER,
    weakness_score_before REAL,            -- measured weakness metric before session
    weakness_score_after  REAL,            -- measured weakness metric after session
    notes_json      TEXT                   -- LLM-generated or rule-based coaching notes
);
</code></pre>
<h3 id="style-driven-ai"><a class="header" href="#style-driven-ai">Style-Driven AI</a></h3>
<p>A new <code>AiStrategy</code> implementation (extends D041) that reads a <code>PlayerStyleProfile</code> and approximates that player’s behavior:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// AI strategy that mimics a specific player's style from their profile.
pub struct StyleDrivenAi {
    profile: PlayerStyleProfile,
    variance: FixedPoint,  // 0.0 = exact reproduction, 1.0 = loose approximation
    difficulty_scale: FixedPoint,  // adjusts execution speed/accuracy
}

impl AiStrategy for StyleDrivenAi {
    fn name(&amp;self) -&gt; &amp;str { "style_driven" }

    fn decide(&amp;self, world: &amp;World, player: PlayerId, budget: &amp;mut TickBudget) -&gt; Vec&lt;PlayerOrder&gt; {
        // 1. Check game phase (opening / mid / late) from tick count + base count
        // 2. Select build order template from profile.build_order_templates
        //    (with variance: slight timing jitter, occasional substitution)
        // 3. Match unit composition targets from profile.unit_composition_profile
        // 4. Engagement decisions use profile.aggression_index and retreat_threshold
        // 5. Attack timing follows profile.avg_first_attack_timing (± variance)
        // 6. Multi-prong attacks at profile.multi_prong_frequency rate
        todo!()
    }

    fn difficulty(&amp;self) -&gt; AiDifficulty { AiDifficulty::Custom }
    fn tick_budget_hint(&amp;self) -&gt; Duration { Duration::from_micros(200) }
}
<span class="boring">}</span></code></pre>
<p><strong>Relationship to existing <code>ReplayBehaviorExtractor</code> (D038):</strong> The extractor converts one replay into scripted AI waypoints/triggers (deterministic, frame-level). <code>StyleDrivenAi</code> is different — it reads an aggregated <em>profile</em> and makes real-time decisions based on tendencies, not a fixed script. The extractor says “at tick 300, build a Barracks at (120, 45).” <code>StyleDrivenAi</code> says “this player tends to build a Barracks within the first 250–350 ticks, usually near their War Factory” — then adapts to the actual game state. Both are useful:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>System</th><th>Input</th><th>Output</th><th>Fidelity</th><th>Replayability</th></tr>
</thead>
<tbody>
<tr><td><code>ReplayBehaviorExtractor</code> (D038)</td><td>One replay file</td><td>Scripted AI modules (waypoints, timed triggers)</td><td>High — frame-level reproduction of one game</td><td>Low — same script every time (mitigated by Probability of Presence)</td></tr>
<tr><td><code>StyleDrivenAi</code> (D042)</td><td>Aggregated <code>PlayerStyleProfile</code></td><td>Real-time AI decisions based on tendencies</td><td>Medium — captures style, not exact moves</td><td>High — different every game because it reacts to the actual situation</td></tr>
</tbody>
</table>
</div>
<h3 id="quick-training-mode"><a class="header" href="#quick-training-mode">Quick Training Mode</a></h3>
<p>A streamlined UI flow that bypasses the scenario editor entirely:</p>
<p><strong>“Train Against” flow:</strong></p>
<ol>
<li>Open match history or player profile screen</li>
<li>Click “Train Against [Player Name]” on any opponent you’ve encountered</li>
<li>Pick a map (or let the system choose one matching your weak matchups)</li>
<li>The engine generates a temporary scenario: your starting position + <code>StyleDrivenAi</code> loaded with that opponent’s profile</li>
<li>Play immediately — no editor, no saving, no publishing</li>
</ol>
<p><strong>“Challenge My Weakness” flow:</strong></p>
<ol>
<li>Open training menu (accessible from main menu)</li>
<li>System shows your weakness summary: “You lose 68% of games against Allied air rushes” / “Your expansion timing is slow (6:30 vs. 4:15 average)”</li>
<li>Click a weakness → system auto-generates a training scenario:
<ul>
<li>Selects a map that exposes the weakness (e.g., map with air-favorable terrain)</li>
<li>Configures AI to exploit that specific weakness (aggressive air build)</li>
<li>Sets appropriate difficulty (slightly above your current level)</li>
</ul>
</li>
<li>Play → post-match summary highlights whether the weakness improved</li>
</ol>
<p><strong>Implementation:</strong></p>
<ul>
<li><code>ic-ui</code> provides the training screens (match history integration, weakness display, map picker)</li>
<li><code>ic-ai</code> provides <code>StyleDrivenAi</code> + weakness analysis queries + temporary scenario generation</li>
<li>No <code>ic-editor</code> dependency — training scenarios are generated programmatically and never saved to disk (unless the player explicitly exports them)</li>
<li>The temporary scenario uses the same sim infrastructure as any skirmish — <code>LocalNetwork</code> (D006), standard map loading, standard game loop</li>
</ul>
<h3 id="iterative-training-loop"><a class="header" href="#iterative-training-loop">Iterative Training Loop</a></h3>
<p>Training isn’t one session — it’s a cycle with tracked progress:</p>
<pre><code>┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│  Analyze        │────▶│  Train           │────▶│  Review         │
│  (identify      │     │  (play targeted  │     │  (measure       │
│  weaknesses)    │     │  session)        │     │  improvement)   │
└─────────────────┘     └──────────────────┘     └─────────────────┘
        ▲                                                │
        └────────────────────────────────────────────────┘
                         next cycle
</code></pre>
<p><strong>Without LLM (always available):</strong></p>
<ul>
<li>Weakness identification: rule-based analysis of <code>gameplay_events</code> aggregates — loss rate by faction/map/timing window, unit survival rates, resource efficiency compared to wins</li>
<li>Training scenario generation: map + AI configuration targeting the weakness</li>
<li>Progress tracking: <code>training_sessions</code> table records before/after weakness scores per area</li>
<li>Post-session summary: structured stats comparison (“Your anti-air unit production increased from 2.1 to 4.3 per game. Survival rate against air improved 12%.”)</li>
</ul>
<p><strong>With LLM (optional, BYOLLM — D016):</strong></p>
<ul>
<li>Natural language training plans: “Week 1: Focus on expansion timing. Session 1: Practice fast expansion against passive AI. Session 2: Defend early rush while expanding. Session 3: Full game with aggressive opponent.”</li>
<li>Post-session coaching: “You expanded at 4:45 this time — 90 seconds faster than your average. But you over-invested in base defense, delaying your tank push by 2 minutes. Next session, try lighter defenses.”</li>
<li>Contextual tips during weakness review: “PlayerX always opens with two Barracks into Ranger rush. Build a Pillbox at your choke point before your second Refinery.”</li>
<li>LLM reads <code>training_sessions</code> history to track multi-session arcs: “Over 5 sessions, your anti-air response time improved from 45s to 18s. Let’s move on to defending naval harassment.”</li>
</ul>
<h3 id="what-this-is-not"><a class="header" href="#what-this-is-not">What This Is NOT</a></h3>
<ul>
<li><strong>Not machine learning during gameplay.</strong> All profile building and analysis happens between sessions, reading SQLite. The sim remains deterministic (invariant #1).</li>
<li><strong>Not a replay bot.</strong> <code>StyleDrivenAi</code> makes real-time strategic decisions informed by tendencies, not a frame-by-frame replay script. It adapts to the actual game state.</li>
<li><strong>Not surveillance.</strong> Opponent profiles are built from your local data only. You cannot fetch another player’s solo games, ranked history, or private matches. You model what you’ve seen firsthand.</li>
<li><strong>Not required.</strong> The training system is entirely optional. Players can ignore it and play skirmish/multiplayer normally. No game mode requires a profile to exist.</li>
</ul>
<h3 id="crate-boundaries"><a class="header" href="#crate-boundaries">Crate Boundaries</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Crate</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>PlayerStyleProfile</code> struct</td><td><code>ic-ai</code></td><td>Behavioral model — part of AI system</td></tr>
<tr><td><code>StyleDrivenAi</code> (AiStrategy impl)</td><td><code>ic-ai</code></td><td>AI decision-making logic</td></tr>
<tr><td>Profile aggregation queries</td><td><code>ic-ai</code></td><td>Reads SQLite <code>gameplay_events</code> + <code>match_players</code></td></tr>
<tr><td>Training UI (match history, weakness display, map picker)</td><td><code>ic-ui</code></td><td>Player-facing screens</td></tr>
<tr><td>Temporary scenario generation</td><td><code>ic-ai</code></td><td>Programmatic scenario setup without <code>ic-editor</code></td></tr>
<tr><td>Training session recording</td><td><code>ic-ui</code> + <code>ic-ai</code></td><td>Writes <code>training_sessions</code> to SQLite after each session</td></tr>
<tr><td>LLM coaching + training plans</td><td><code>ic-llm</code></td><td>Optional — reads <code>training_sessions</code> + <code>player_profiles</code></td></tr>
<tr><td>SQLite schema (<code>player_profiles</code>, <code>training_sessions</code>)</td><td><code>ic-game</code></td><td>Schema migration on startup, like all D034 tables</td></tr>
</tbody>
</table>
</div>
<p><code>ic-editor</code> is NOT involved in quick training mode. The scenario editor’s replay-to-scenario pipeline (D038) remains separate — it’s for creating publishable community content, not ephemeral training matches.</p>
<h3 id="consumers-of-player-data-d034-extension"><a class="header" href="#consumers-of-player-data-d034-extension">Consumers of Player Data (D034 Extension)</a></h3>
<p>Two new rows for the D034 consumer table:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Consumer</th><th>Crate</th><th>What it reads</th><th>What it produces</th><th>Required?</th></tr>
</thead>
<tbody>
<tr><td><strong>Player style profiles</strong></td><td><code>ic-ai</code></td><td><code>gameplay_events</code>, <code>match_players</code>, <code>matches</code></td><td><code>player_profiles</code> table — aggregated behavioral models for local player + opponents</td><td>Always on (profile building)</td></tr>
<tr><td><strong>Training system</strong></td><td><code>ic-ai</code> + <code>ic-ui</code></td><td><code>player_profiles</code>, <code>training_sessions</code>, <code>gameplay_events</code></td><td>Quick training scenarios, weakness analysis, progress tracking</td><td>Always on (training UI)</td></tr>
</tbody>
</table>
</div>
<h3 id="relationship-to-existing-decisions"><a class="header" href="#relationship-to-existing-decisions">Relationship to Existing Decisions</a></h3>
<ul>
<li><strong>D031 (telemetry):</strong> Gameplay events are the raw data. D042 adds interpretation — the <code>GameplayEvent</code> stream is the black box recorder; the profile builder is the flight data analyst.</li>
<li><strong>D034 (SQLite):</strong> Two new tables (<code>player_profiles</code>, <code>training_sessions</code>). Same patterns: schema migration, read-only consumers, local-first.</li>
<li><strong>D038 (replay-to-scenario):</strong> Complementary, not overlapping. D038 extracts one replay into a publishable scenario. D042 aggregates many games into a live AI personality. D038 produces scripts; D042 produces strategies.</li>
<li><strong>D041 (trait abstraction):</strong> <code>StyleDrivenAi</code> implements the <code>AiStrategy</code> trait. Same plug-in pattern — the engine doesn’t know it’s running a profile-driven AI vs. a scripted one.</li>
<li><strong>D016 (BYOLLM):</strong> LLM coaching is optional. Without it, the rule-based weakness identification and structured summary system works standalone.</li>
<li><strong>D010 (snapshots):</strong> Training sessions use standard sim snapshots for save/restore. No special infrastructure needed.</li>
</ul>
<h3 id="alternatives-considered-2"><a class="header" href="#alternatives-considered-2">Alternatives Considered</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Alternative</th><th>Why Not</th></tr>
</thead>
<tbody>
<tr><td>ML model trained on replays (neural-net opponent)</td><td>Too complex, non-deterministic, opaque behavior, requires GPU inference during gameplay. Profile-driven rule selection is transparent and runs in microseconds.</td></tr>
<tr><td>Server-side profile building</td><td>Conflicts with local-first principle. Opponent profiles come from your replays, not a central database. Server could aggregate opt-in community profiles in the future, but the base system is entirely local.</td></tr>
<tr><td>Manual profile creation (“custom AI personality editor”)</td><td>Useful but separate. D042 is about automated profile extraction. A manual personality editor is a future nice-to-have that reads/writes the same <code>PlayerStyleProfile</code> struct — the systems compose.</td></tr>
<tr><td>Integrate training into scenario editor only</td><td>Too much friction for casual training. The editor is for content creation; training is a play mode. Different UX goals.</td></tr>
</tbody>
</table>
</div>
<p><strong>Phase:</strong> Profile building infrastructure ships in <strong>Phase 4</strong> (available for single-player training against AI tendencies). Opponent profile building and “Train Against” flow ship in <strong>Phase 5</strong> (requires multiplayer match data). LLM coaching loop ships in <strong>Phase 7</strong> (optional BYOLLM). The <code>training_sessions</code> table and progress tracking ship alongside the training UI in Phase 4–5.</p>
<hr>
<h2 id="d043-ai-behavior-presets--classic-openra-and-ic-default"><a class="header" href="#d043-ai-behavior-presets--classic-openra-and-ic-default">D043: AI Behavior Presets — Classic, OpenRA, and IC Default</a></h2>
<p><strong>Status:</strong> Accepted
<strong>Scope:</strong> <code>ic-ai</code>, <code>ic-sim</code> (read-only), game module configuration
<strong>Phase:</strong> Phase 4 (ships with AI &amp; Single Player)</p>
<h3 id="the-problem-1"><a class="header" href="#the-problem-1">The Problem</a></h3>
<p>D019 gives players switchable <em>balance</em> presets (Classic RA vs. OpenRA vs. Remastered values). D041 provides the <code>AiStrategy</code> trait for pluggable AI algorithms. But neither addresses a parallel concern: AI <em>behavioral</em> style. Original Red Alert AI, OpenRA AI, and a research-informed IC AI all make fundamentally different decisions given the same balance values. A player who selects “Classic RA” balance expects an AI that <em>plays like Classic RA</em> — predictable build orders, minimal micro, base-walk expansion, no focus-fire — not an advanced AI that happens to use 1996 damage tables.</p>
<h3 id="decision"><a class="header" href="#decision">Decision</a></h3>
<p>Ship <strong>AI behavior presets</strong> as first-class configurations alongside balance presets (D019). Each preset defines how the AI plays — its decision-making style, micro level, strategic patterns, and quirks — independent of which balance values or pathfinding behavior are active.</p>
<h3 id="built-in-presets"><a class="header" href="#built-in-presets">Built-In Presets</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Preset</th><th>Behavior Description</th><th>Source</th></tr>
</thead>
<tbody>
<tr><td><strong>Classic RA</strong></td><td>Mimics original RA AI quirks: predictable build queues, base-walk expansion, minimal unit micro, no focus-fire, doesn’t scout, doesn’t adapt to player strategy</td><td>EA Red Alert source code analysis</td></tr>
<tr><td><strong>OpenRA</strong></td><td>Matches OpenRA skirmish AI: better micro, uses attack-move, scouts, adapts build to counter player’s army composition, respects fog of war properly</td><td>OpenRA AI implementation analysis</td></tr>
<tr><td><strong>IC Default</strong></td><td>Research-informed enhanced AI: flowfield-aware group tactics, proper formation movement, multi-prong attacks, economic harassment, tech-switching, adaptive aggression</td><td>Open-source RTS AI research (see below)</td></tr>
</tbody>
</table>
</div>
<h3 id="ic-default-ai--research-foundation"><a class="header" href="#ic-default-ai--research-foundation">IC Default AI — Research Foundation</a></h3>
<p>The IC Default preset draws from published research and open-source implementations across the RTS genre:</p>
<ul>
<li><strong>0 A.D.</strong> — economic AI with resource balancing heuristics, expansion timing models</li>
<li><strong>Spring Engine (BAR/Zero-K)</strong> — group micro, terrain-aware positioning, retreat mechanics, formation movement</li>
<li><strong>Wargus (Stratagus)</strong> — Warcraft II AI with build-order scripting and adaptive counter-play</li>
<li><strong>OpenRA</strong> — the strongest open-source C&amp;C AI; baseline for improvement</li>
<li><strong>MicroRTS / AIIDE competitions</strong> — academic RTS AI research: MCTS-based planning, influence maps, potential fields for tactical positioning</li>
<li><strong>StarCraft: Brood War AI competitions (SSCAIT, AIIDE)</strong> — decades of research on build-order optimization, scouting, harassment timing</li>
</ul>
<p>The IC Default AI is not a simple difficulty bump — it’s a qualitatively different decision process. Where Classic RA groups all units and attack-moves to the enemy base, IC Default maintains map control, denies expansions, and probes for weaknesses before committing.</p>
<h3 id="ic-default-ai--implementation-architecture"><a class="header" href="#ic-default-ai--implementation-architecture">IC Default AI — Implementation Architecture</a></h3>
<p>Based on cross-project analysis of EA Red Alert, EA Generals/Zero Hour, OpenRA, 0 A.D. Petra, Spring Engine, MicroRTS, and Stratagus (see <code>research/rts-ai-implementation-survey.md</code> and <code>research/stratagus-stargus-opencraft-analysis.md</code>), <code>PersonalityDrivenAi</code> uses a <strong>priority-based manager hierarchy</strong> — the dominant pattern across all surveyed RTS AI implementations (independently confirmed in 7 codebases):</p>
<pre><code>PersonalityDrivenAi → AiStrategy trait impl
├── EconomyManager
│   ├── HarvesterController     (nearest-resource assignment, danger avoidance)
│   ├── PowerMonitor            (urgency-based power plant construction)
│   └── ExpansionPlanner        (economic triggers for new base timing)
├── ProductionManager
│   ├── UnitCompositionTarget   (share-based, self-correcting — from OpenRA)
│   ├── BuildOrderEvaluator     (priority queue with urgency — from Petra)
│   └── StructurePlanner        (influence-map placement — from 0 A.D.)
├── MilitaryManager
│   ├── AttackPlanner           (composition thresholds + timing — from Petra)
│   ├── DefenseResponder        (event-driven reactive defense — from OpenRA)
│   └── SquadManager            (unit grouping, assignment, retreat)
└── AiState (shared)
    ├── ThreatMap               (influence map: enemy unit positions + DPS)
    ├── ResourceMap             (known resource node locations and status)
    ├── ScoutingMemory          (last-seen timestamps for enemy buildings)
    └── StrategyClassification  (Phase 5+: opponent archetype tracking)
</code></pre>
<p>Each manager runs on its own tick-gated schedule (see Performance Budget below). Managers communicate through shared <code>AiState</code>, not direct calls — the same pattern used by 0 A.D. Petra and OpenRA’s modular bot architecture.</p>
<h4 id="key-techniques-phase-4"><a class="header" href="#key-techniques-phase-4">Key Techniques (Phase 4)</a></h4>
<p>These six techniques form the Phase 4 implementation. Each is proven across multiple surveyed projects:</p>
<ol>
<li>
<p><strong>Priority-based resource allocation</strong> (from Petra’s <code>QueueManager</code>) — single most impactful pattern. Build requests go into a priority queue ordered by urgency. Power plant at 90% capacity is urgent; third barracks is not. Prevents the “AI has 50k credits and no power” failure mode seen in EA Red Alert.</p>
</li>
<li>
<p><strong>Share-based unit composition</strong> (from OpenRA’s <code>UnitBuilderBotModule</code>) — production targets expressed as ratios (e.g., infantry 40%, vehicles 50%, air 10%). Each production cycle builds whatever unit type is furthest below its target share. Self-correcting: losing tanks naturally shifts production toward tanks. Personality parameters (D043 YAML config) tune the ratios per preset.</p>
</li>
<li>
<p><strong>Influence map for building placement</strong> (from 0 A.D. Petra) — a grid overlay scoring each cell by proximity to resources, distance from known threats, and connectivity to existing base. Dramatically better base layouts than EA RA’s random placement. The influence map is a fixed-size array in <code>AiScratch</code>, cleared and rebuilt on the building-placement schedule.</p>
</li>
<li>
<p><strong>Tick-gated evaluation</strong> (from Generals/Petra/MicroRTS) — expensive decisions run infrequently, cheap ones run often. Defense response is near-instant (every tick, event-driven). Strategic reassessment is every 60 ticks (~2 seconds). This pattern appears in <em>every</em> surveyed project that handles 200+ units. See Performance Budget table below.</p>
</li>
<li>
<p><strong>Fuzzy engagement logic</strong> (from OpenRA’s <code>AttackOrFleeFuzzy</code>) — combat decisions use fuzzy membership functions over health ratio, relative DPS, and nearby ally strength, producing a continuous attack↔retreat score rather than a binary threshold. This avoids the “oscillating dance” where units alternate between attacking and fleeing at a hard HP boundary.</p>
</li>
<li>
<p><strong>Computation budget cap</strong> (from MicroRTS) — <code>AiStrategy::tick_budget_hint()</code> (D041) returns a microsecond budget. The AI <em>must</em> return within this budget, even if evaluation is incomplete — partial results are better than frame stalls. The manager hierarchy makes this natural: if the budget is exhausted after <code>EconomyManager</code> and <code>ProductionManager</code>, <code>MilitaryManager</code> runs its cached plan from last evaluation.</p>
</li>
</ol>
<h4 id="evaluation-and-threat-assessment"><a class="header" href="#evaluation-and-threat-assessment">Evaluation and Threat Assessment</a></h4>
<p>The evaluation function is the foundation of all AI decision-making. A bad evaluation function makes every other component worse (MicroRTS research). Iron Curtain uses <strong>Lanchester-inspired threat scoring</strong>:</p>
<pre><code>threat(army) = Σ(unit_dps × unit_hp) × count^0.7
</code></pre>
<p>This captures Lanchester’s Square Law — military power scales superlinearly with unit count. Two tanks aren’t twice as effective as one; they’re ~1.6× as effective (at exponent 0.7, conservative vs. full Lanchester exponent of 2.0). The exponent is a YAML-tunable personality parameter, allowing presets to value army mass differently.</p>
<p>For evaluating damage taken against our own units:</p>
<pre><code>value(unit) = unit_cost × sqrt(hp / max_hp) × 40
</code></pre>
<p>The <code>sqrt(hp/maxHP)</code> gives diminishing returns for overkill — killing a 10% HP unit is worth less than the same cost in fresh units. This is the MicroRTS <code>SimpleSqrtEvaluationFunction</code> pattern, validated across years of AI competition.</p>
<p>Both formulas use fixed-point arithmetic (integer math only, consistent with sim determinism).</p>
<h4 id="phase-5-enhancements"><a class="header" href="#phase-5-enhancements">Phase 5+ Enhancements</a></h4>
<p>These techniques are explicitly deferred — the Phase 4 AI ships without them:</p>
<ul>
<li><strong>Strategy classification and adaptation:</strong> Track opponent behavior patterns (build timing, unit composition, attack frequency). Classify into archetypes: “rush”, “turtle”, “boom”, “all-in”. Select counter-strategy from personality parameters. This is the MicroRTS Stratified Strategy Selection (SCV) pattern applied at RTS scale.</li>
<li><strong>Active scouting system:</strong> No surveyed project scouts well — opportunity to lead. Periodically send cheap units to explore unknown areas. Maintain “last seen” timestamps for enemy building locations in <code>AiState::ScoutingMemory</code>. Higher urgency when opponent is quiet (they’re probably teching up).</li>
<li><strong>Multi-pronged attacks:</strong> Graduate from Petra/OpenRA’s single-army-blob pattern. Split forces based on attack plan (main force + flanking/harassment force). Coordinate timing via shared countdown in <code>AiState</code>. The <code>AiEventLog</code> (D041) enables coordination visibility between sub-plans.</li>
<li><strong>Advanced micro:</strong> Kiting, focus-fire priority targeting, ability usage. Kept out of Phase 4 to avoid the “chasing optimal AI” anti-pattern.</li>
</ul>
<h4 id="what-to-explicitly-not-do"><a class="header" href="#what-to-explicitly-not-do">What to Explicitly Not Do</a></h4>
<p>Five anti-patterns identified from surveyed implementations (full analysis in <code>research/rts-ai-implementation-survey.md</code> §9):</p>
<ol>
<li><strong>Don’t implement MCTS/minimax for strategic decisions.</strong> The search space is too large for 500+ unit games. MicroRTS research confirms: portfolio/script search beats raw MCTS at RTS scale. Reserve tree search for micro-scale decisions only (if at all).</li>
<li><strong>Don’t use behavior trees for the strategic AI.</strong> Every surveyed RTS uses priority cascades or manager hierarchies, not BTs. BTs add complexity without proven benefit at RTS strategic scale.</li>
<li><strong>Don’t chase “optimal” AI at launch.</strong> RA shipped with terrible AI and sold 10 million copies. The Remastered Collection shipped with the same terrible AI. Get a good-enough AI working, then iterate. Phase 4 target: “better than EA RA, comparable to OpenRA.”</li>
<li><strong>Don’t hardcode strategies.</strong> Use YAML configuration (the personality model above) so modders and the difficulty system can tune behavior without code changes.</li>
<li><strong>Don’t skip evaluation function design.</strong> A bad evaluation function makes every other AI component worse. Invest time in getting threat assessment right (Lanchester scoring above) — it’s the foundation everything else builds on.</li>
</ol>
<h4 id="ai-performance-budget"><a class="header" href="#ai-performance-budget">AI Performance Budget</a></h4>
<p>Based on the efficiency pyramid (D015) and surveyed projects’ performance characteristics (see also <code>10-PERFORMANCE.md</code>):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>AI Component</th><th>Frequency</th><th>Target Time</th><th>Approach</th></tr>
</thead>
<tbody>
<tr><td>Harvester assignment</td><td>Every 4 ticks</td><td>&lt; 0.1ms</td><td>Nearest-resource lookup</td></tr>
<tr><td>Defense response</td><td>Every tick (reactive)</td><td>&lt; 0.1ms</td><td>Event-driven, not polling</td></tr>
<tr><td>Unit production</td><td>Every 8 ticks</td><td>&lt; 0.2ms</td><td>Priority queue evaluation</td></tr>
<tr><td>Building placement</td><td>On demand</td><td>&lt; 1.0ms</td><td>Influence map lookup</td></tr>
<tr><td>Attack planning</td><td>Every 30 ticks</td><td>&lt; 2.0ms</td><td>Composition check + timing</td></tr>
<tr><td>Strategic reassessment</td><td>Every 60 ticks</td><td>&lt; 5.0ms</td><td>Full state evaluation</td></tr>
<tr><td><strong>Total per tick (amortized)</strong></td><td></td><td><strong>&lt; 0.5ms</strong></td><td><strong>Budget for 500 units</strong></td></tr>
</tbody>
</table>
</div>
<p>All AI working memory (influence maps, squad rosters, composition tallies, priority queues) is pre-allocated in <code>AiScratch</code> — analogous to <code>TickScratch</code> (Layer 5 of the efficiency pyramid). Zero per-tick heap allocation. Influence maps are fixed-size arrays, cleared and rebuilt on their evaluation schedule.</p>
<h3 id="configuration-model"><a class="header" href="#configuration-model">Configuration Model</a></h3>
<p>AI presets are YAML-driven, paralleling balance presets:</p>
<pre><code class="language-yaml"># ai/presets/classic-ra.yaml
ai_preset:
  name: "Classic Red Alert"
  description: "Faithful recreation of original RA AI behavior"
  strategy: personality-driven     # AiStrategy implementation to use
  personality:
    aggression: 0.6
    tech_priority: rush
    micro_level: none              # no individual unit control
    scout_frequency: never
    build_order: scripted          # fixed build queues per faction
    expansion_style: base_walk     # builds structures adjacent to existing base
    focus_fire: false
    retreat_behavior: never        # units fight to the death
    adaptation: none               # doesn't change strategy based on opponent
    group_tactics: blob            # all units in one control group

# ai/presets/ic-default.yaml
ai_preset:
  name: "IC Default"
  description: "Research-informed AI with modern RTS intelligence"
  strategy: personality-driven
  personality:
    aggression: 0.5
    tech_priority: balanced
    micro_level: moderate          # focus-fire, kiting ranged units, retreat wounded
    scout_frequency: periodic      # sends scouts every 60-90 seconds
    build_order: adaptive          # adjusts build based on scouting information
    expansion_style: strategic     # expands to control resource nodes
    focus_fire: true
    retreat_behavior: wounded      # retreats units below 30% HP
    adaptation: reactive           # counters observed army composition
    group_tactics: multi_prong     # splits forces for flanking/harassment
    influence_maps: true           # uses influence maps for threat assessment
    harassment: true               # sends small squads to attack economy
</code></pre>
<h3 id="relationship-to-existing-decisions-1"><a class="header" href="#relationship-to-existing-decisions-1">Relationship to Existing Decisions</a></h3>
<ul>
<li><strong>D019 (balance presets):</strong> Orthogonal. Balance defines <em>what units can do</em>; AI presets define <em>how the AI uses them</em>. A player can combine any balance preset with any AI preset. “Classic RA balance + IC Default AI” is valid and interesting.</li>
<li><strong>D041 (<code>AiStrategy</code> trait):</strong> AI presets are configurations for the default <code>PersonalityDrivenAi</code> strategy. The trait allows entirely different AI algorithms (neural net, GOAP planner); presets are parameter sets within one algorithm. Both coexist — presets for built-in AI, traits for custom AI.</li>
<li><strong>D042 (<code>StyleDrivenAi</code>):</strong> Player behavioral profiles are a fourth source of AI behavior (alongside Classic/OpenRA/IC Default presets). No conflict — <code>StyleDrivenAi</code> implements <code>AiStrategy</code> independently of presets.</li>
<li><strong>D033 (QoL toggles / experience profiles):</strong> AI preset selection integrates naturally into experience profiles. The “Classic Red Alert” experience profile bundles classic balance + classic AI + classic theme.</li>
</ul>
<h3 id="experience-profile-integration"><a class="header" href="#experience-profile-integration">Experience Profile Integration</a></h3>
<pre><code class="language-yaml">profiles:
  classic-ra:
    balance: classic
    ai_preset: classic-ra          # D043 — original RA AI behavior
    pathfinding: classic-ra        # D045 — original RA movement feel
    render_mode: classic           # D048 — original sprite rendering
    theme: classic
    qol: vanilla

  openra-ra:
    balance: openra
    ai_preset: openra
    pathfinding: openra            # D045 — OpenRA movement feel
    render_mode: classic           # D048
    theme: modern
    qol: openra

  iron-curtain-ra:
    balance: classic
    ai_preset: ic-default          # D043 — enhanced AI
    pathfinding: ic-default        # D045 — modern flowfield movement
    render_mode: hd                # D048 — high-definition sprites
    theme: modern
    qol: iron_curtain
</code></pre>
<h3 id="lobby-integration"><a class="header" href="#lobby-integration">Lobby Integration</a></h3>
<p>AI preset is selectable per AI player slot in the lobby, independent of game-wide balance preset:</p>
<pre><code>Player 1: [Human]           Faction: Soviet
Player 2: [AI] IC Default (Hard)    Faction: Allied
Player 3: [AI] Classic RA (Normal)  Faction: Allied
Player 4: [AI] OpenRA (Brutal)      Faction: Soviet

Balance Preset: Classic RA
</code></pre>
<p>This allows mixed AI playstyles in the same game – useful for testing, fun for variety, and educational for understanding how different AI approaches handle the same scenario.</p>
<h3 id="community-ai-presets"><a class="header" href="#community-ai-presets">Community AI Presets</a></h3>
<p>Modders can create custom AI presets as Workshop resources (D030):</p>
<ul>
<li>YAML preset files defining <code>personality</code> parameters for <code>PersonalityDrivenAi</code></li>
<li>Full <code>AiStrategy</code> implementations via WASM Tier 3 mods (D041)</li>
<li>AI tournament brackets: community members compete by submitting AI presets, tournament server runs automated matches</li>
</ul>
<h3 id="engine-level-difficulty-system"><a class="header" href="#engine-level-difficulty-system">Engine-Level Difficulty System</a></h3>
<p>Inspired by 0 A.D.’s two-axis difficulty (engine cheats + behavioral parameters) and AoE2’s strategic number scaling with opt-out (see <code>research/rts-ai-extensibility-survey.md</code>), Iron Curtain separates difficulty into two independent layers:</p>
<p><strong>Layer 1 — Engine scaling (applies to ALL AI players by default):</strong></p>
<p>The engine provides resource, build-time, and reaction-time multipliers that scale an AI’s raw capability independent of how smart its decisions are. This ensures that even a simple YAML-configured AI can be made harder or easier without touching its behavioral parameters.</p>
<pre><code class="language-yaml"># difficulties/built-in.yaml
difficulties:
  sandbox:
    name: "Sandbox"
    description: "AI barely acts — for learning the interface"
    engine_scaling:
      resource_gather_rate: 0.5     # AI gathers half speed (fixed-point: 512/1024)
      build_time_multiplier: 1.5    # AI builds 50% slower
      reaction_delay_ticks: 30      # AI waits 30 ticks (~1s) before acting on events
      vision_range_multiplier: 0.8  # AI sees 20% less
    personality_overrides:
      aggression: 0.1
      adaptation: none

  easy:
    name: "Easy"
    engine_scaling:
      resource_gather_rate: 0.8
      build_time_multiplier: 1.2
      reaction_delay_ticks: 8
      vision_range_multiplier: 1.0

  normal:
    name: "Normal"
    engine_scaling:
      resource_gather_rate: 1.0     # No modification
      build_time_multiplier: 1.0
      reaction_delay_ticks: 0
      vision_range_multiplier: 1.0

  hard:
    name: "Hard"
    engine_scaling:
      resource_gather_rate: 1.0     # No economic bonus
      build_time_multiplier: 1.0
      reaction_delay_ticks: 0
      vision_range_multiplier: 1.0
    # Hard is purely behavioral — the AI makes smarter decisions, not cheaper ones
    personality_overrides:
      micro_level: moderate
      adaptation: reactive

  brutal:
    name: "Brutal"
    engine_scaling:
      resource_gather_rate: 1.3     # AI gets 30% bonus
      build_time_multiplier: 0.8    # AI builds 20% faster
      reaction_delay_ticks: 0
      vision_range_multiplier: 1.2  # AI sees 20% further
    personality_overrides:
      aggression: 0.8
      micro_level: extreme
      adaptation: full
</code></pre>
<p><strong>Layer 2 — Implementation-level difficulty (per-<code>AiStrategy</code> impl):</strong></p>
<p>Each <code>AiStrategy</code> implementation interprets difficulty through its own behavioral parameters. <code>PersonalityDrivenAi</code> uses the <code>personality:</code> YAML config (aggression, micro level, adaptation). A neural-net AI might have a “skill cap” parameter. A GOAP planner might limit search depth. The <code>get_parameters()</code> method (from MicroRTS research) exposes these as introspectable knobs.</p>
<p><strong>Engine scaling opt-out</strong> (from AoE2’s <code>sn-do-not-scale-for-difficulty-level</code>): Sophisticated AI implementations that model difficulty internally can opt out of engine scaling by returning <code>false</code> from <code>uses_engine_difficulty_scaling()</code>. This prevents double-scaling — an advanced AI that already weakens its play at Easy difficulty shouldn’t also get the engine’s gather-rate penalty on top.</p>
<p><strong>Modder-addable difficulty levels:</strong> Difficulty levels are YAML files, not hardcoded enums. Community modders can define new difficulties via Workshop (D030) — no code required (Tier 1):</p>
<pre><code class="language-yaml"># workshop: community/nightmare-difficulty/difficulty.yaml
difficulty:
  name: "Nightmare"
  description: "Economy bonuses + perfect micro — for masochists"
  engine_scaling:
    resource_gather_rate: 2.0
    build_time_multiplier: 0.5
    reaction_delay_ticks: 0
    vision_range_multiplier: 1.5
  personality_overrides:
    aggression: 0.95
    micro_level: extreme
    adaptation: full
    harassment: true
    group_tactics: multi_prong
</code></pre>
<p>Once installed, “Nightmare” appears alongside built-in difficulties in the lobby dropdown. Any <code>AiStrategy</code> implementation (first-party or community) can be paired with any difficulty level — they compose independently.</p>
<h3 id="mod-selectable-and-mod-provided-ai"><a class="header" href="#mod-selectable-and-mod-provided-ai">Mod-Selectable and Mod-Provided AI</a></h3>
<p>The three built-in behavior presets (Classic RA, OpenRA, IC Default) are configurations for <code>PersonalityDrivenAi</code>. They are not the only <code>AiStrategy</code> implementations. The trait (D041) is explicitly open to community implementations — following the same pattern as <code>Pathfinder</code> (D013/D045) and render modes (D048).</p>
<p><strong>Two-axis lobby selection:</strong></p>
<p>In the lobby, each AI player slot has two independent selections:</p>
<ol>
<li><strong>AI implementation</strong> — which <code>AiStrategy</code> algorithm</li>
<li><strong>Difficulty level</strong> — which engine scaling + personality config</li>
</ol>
<pre><code>Player 2: [AI] IC Default / Hard        Faction: Allied
Player 3: [AI] Classic RA / Normal      Faction: Allied
Player 4: [AI] Workshop: GOAP Planner / Brutal   Faction: Soviet
Player 5: [AI] Workshop: Neural Net v2 / Nightmare   Faction: Soviet

Balance Preset: Classic RA
</code></pre>
<p>This is different from pathfinders (one axis: which algorithm). AI has two orthogonal axes because <em>how smart the AI plays</em> and <em>what advantages it gets</em> are independent concerns. A “Brutal Classic RA” AI should play with original 1996 patterns but get economic bonuses and instant reactions; an “Easy IC Default” AI should use modern tactics but gather slowly and react late.</p>
<p><strong>Modder as consumer — selecting an AI:</strong></p>
<p>A mod’s YAML manifest can declare which <code>AiStrategy</code> implementations it ships with or requires:</p>
<pre><code class="language-yaml"># mod.yaml — total conversion with custom AI
mod:
  name: "Zero Hour Remake"
  ai_strategies:
    - goap-planner              # Requires this community AI
    - personality-driven        # Also supports the built-in default
  default_ai: goap-planner
  depends:
    - community/goap-planner-ai@^2.0
</code></pre>
<p>If the mod doesn’t specify <code>ai_strategies</code>, all registered AI implementations are available.</p>
<p><strong>Modder as author — providing an AI:</strong></p>
<p>A Tier 3 WASM mod can implement the <code>AiStrategy</code> trait and register it:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WASM mod: GOAP (Goal-Oriented Action Planning) AI
impl AiStrategy for GoapPlannerAi {
    fn decide(&amp;mut self, player: PlayerId, view: &amp;FogFilteredView, tick: u64) -&gt; Vec&lt;PlayerOrder&gt; {
        // 1. Update world model from FogFilteredView
        // 2. Evaluate goal priorities (expand? attack? defend? tech?)
        // 3. GOAP search: find action sequence to achieve highest-priority goal
        // 4. Emit orders for first action in plan
        // ...
    }

    fn name(&amp;self) -&gt; &amp;str { "GOAP Planner" }
    fn difficulty(&amp;self) -&gt; AiDifficulty { AiDifficulty::Custom("adaptive".into()) }

    fn on_enemy_spotted(&amp;mut self, unit: EntityId, unit_type: &amp;str) {
        // Re-prioritize goals: if enemy spotted near base, defend goal priority increases
        self.goal_priorities.defend += self.threat_weight(unit_type);
    }

    fn on_under_attack(&amp;mut self, _unit: EntityId, _attacker: EntityId) {
        // Emergency re-plan: abort current plan, switch to defense
        self.force_replan = true;
    }

    fn get_parameters(&amp;self) -&gt; Vec&lt;ParameterSpec&gt; {
        vec![
            ParameterSpec { name: "plan_depth".into(), min_value: 1, max_value: 10, default_value: 5, .. },
            ParameterSpec { name: "replan_interval".into(), min_value: 10, max_value: 120, default_value: 30, .. },
            ParameterSpec { name: "aggression_weight".into(), min_value: 0, max_value: 100, default_value: 50, .. },
        ]
    }

    fn uses_engine_difficulty_scaling(&amp;self) -&gt; bool { false } // handles difficulty internally
}
<span class="boring">}</span></code></pre>
<p>The mod registers its AI in its manifest:</p>
<pre><code class="language-yaml"># goap_planner/mod.yaml
mod:
  name: "GOAP Planner AI"
  type: ai_strategy
  ai_strategy_id: goap-planner
  display_name: "GOAP Planner"
  description: "Goal-oriented action planning AI — plans multi-step strategies"
  wasm_module: goap_planner.wasm
  capabilities:
    read_visible_state: true
    issue_orders: true
  config:
    plan_depth: 5
    replan_interval_ticks: 30
</code></pre>
<p><strong>Workshop distribution:</strong> Community AI implementations are Workshop resources (D030). They can be rated, reviewed, and depended upon — same as pathfinder mods. The Workshop can host AI tournament leaderboards: automated matches between community AI submissions, ranked by Elo/TrueSkill (inspired by BWAPI’s SSCAIT and AoE2’s AI ladder communities, see <code>research/rts-ai-extensibility-survey.md</code>).</p>
<p><strong>Multiplayer implications:</strong> AI selection is NOT sim-affecting in the same way pathfinding is. In a human-vs-AI game, each AI player can run a different <code>AiStrategy</code> — they’re independent agents. In AI-vs-AI tournaments, all AI players can be different. The engine doesn’t need to validate that all clients have the same AI WASM module (unlike pathfinding). However, for determinism, the AI’s <code>decide()</code> output must be identical on all clients — so the WASM binary hash IS validated per AI player slot.</p>
<h3 id="relationship-to-existing-decisions-2"><a class="header" href="#relationship-to-existing-decisions-2">Relationship to Existing Decisions</a></h3>
<ul>
<li><strong>D019 (balance presets):</strong> Orthogonal. Balance defines <em>what units can do</em>; AI presets define <em>how the AI uses them</em>. A player can combine any balance preset with any AI preset. “Classic RA balance + IC Default AI” is valid and interesting.</li>
<li><strong>D041 (<code>AiStrategy</code> trait):</strong> AI behavior presets are configurations for the default <code>PersonalityDrivenAi</code> strategy. The trait allows entirely different AI algorithms (neural net, GOAP planner); presets are parameter sets within one algorithm. Both coexist — presets for built-in AI, traits for custom AI. The trait now includes event callbacks, parameter introspection, and engine scaling opt-out based on cross-project research.</li>
<li><strong>D042 (<code>StyleDrivenAi</code>):</strong> Player behavioral profiles are a fourth source of AI behavior (alongside Classic/OpenRA/IC Default presets). No conflict — <code>StyleDrivenAi</code> implements <code>AiStrategy</code> independently of presets.</li>
<li><strong>D033 (QoL toggles / experience profiles):</strong> AI preset selection integrates naturally into experience profiles. The “Classic Red Alert” experience profile bundles classic balance + classic AI + classic theme.</li>
<li><strong>D045 (pathfinding presets):</strong> Same modder-selectable pattern. Mods select or provide pathfinders; mods select or provide AI implementations. Both distribute via Workshop; both compose with experience profiles. Key difference: pathfinding is one axis (algorithm), AI is two axes (algorithm + difficulty).</li>
<li><strong>D048 (render modes):</strong> Same modder-selectable pattern. The trait-per-subsystem architecture means every pluggable system follows the same model: engine ships built-in implementations, mods can add more, players/modders pick what they want.</li>
</ul>
<h3 id="alternatives-considered-3"><a class="header" href="#alternatives-considered-3">Alternatives Considered</a></h3>
<ul>
<li>AI difficulty only, no style presets (rejected — difficulty is orthogonal to style; a “Hard Classic RA” AI should be hard but still play like original RA, not like a modern AI turned up)</li>
<li>One “best” AI only (rejected — the community is split like they are on balance; offer choice)</li>
<li>Lua-only AI scripting (rejected — too slow for tick-level decisions; Lua is for mission triggers, WASM for full AI replacement)</li>
<li>Difficulty as a fixed enum only (rejected — modders should be able to define new difficulty levels via YAML without code changes; AoE2’s 20+ years of community AI prove that a large parameter space outlasts a restrictive one)</li>
<li>No engine-level difficulty scaling (rejected — delegating difficulty entirely to AI implementations produces inconsistent experiences across different AIs; 0 A.D. and AoE2 both provide engine scaling with opt-out, proving this is the right separation of concerns)</li>
<li>No event callbacks on <code>AiStrategy</code> (rejected — polling-only AI misses reactive opportunities; Spring Engine and BWAPI both use event + tick hybrid, which is the proven model)</li>
</ul>
<hr>
<h2 id="d044-llm-enhanced-ai--orchestrator-and-experimental-llm-player"><a class="header" href="#d044-llm-enhanced-ai--orchestrator-and-experimental-llm-player">D044: LLM-Enhanced AI — Orchestrator and Experimental LLM Player</a></h2>
<p><strong>Status:</strong> Accepted
<strong>Scope:</strong> <code>ic-llm</code>, <code>ic-ai</code>, <code>ic-sim</code> (read-only)
<strong>Phase:</strong> LLM Orchestrator: Phase 7. LLM Player: Experimental, no scheduled phase.</p>
<h3 id="the-problem-2"><a class="header" href="#the-problem-2">The Problem</a></h3>
<p>D016 provides LLM integration for mission generation. D042 provides LLM coaching between games. But neither addresses LLM involvement <em>during</em> gameplay — using an LLM to influence or directly control AI decisions in real-time. Two distinct use cases exist:</p>
<ol>
<li><strong>Enhancing existing AI</strong> — an LLM advisor that reads game state and nudges a conventional AI toward better strategic decisions, without replacing the tick-level execution</li>
<li><strong>Full LLM control</strong> — an experimental mode where an LLM makes every decision, exploring whether modern language models can play RTS games competently</li>
</ol>
<h3 id="decision-1"><a class="header" href="#decision-1">Decision</a></h3>
<p>Define two new <code>AiStrategy</code> implementations (D041) for LLM-integrated gameplay:</p>
<h3 id="1-llm-orchestrator-llmorchestratorai"><a class="header" href="#1-llm-orchestrator-llmorchestratorai">1. LLM Orchestrator (<code>LlmOrchestratorAi</code>)</a></h3>
<p>Wraps any existing <code>AiStrategy</code> implementation (D041) and periodically consults an LLM for high-level strategic guidance. The inner AI handles tick-level execution; the LLM provides strategic direction.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Wraps an existing AiStrategy with LLM strategic oversight.
/// The inner AI makes tick-level decisions; the LLM provides
/// periodic strategic guidance that the inner AI incorporates.
pub struct LlmOrchestratorAi {
    inner: Box&lt;dyn AiStrategy&gt;,         // the AI that actually issues orders
    provider: Box&lt;dyn LlmProvider&gt;,     // D016 BYOLLM
    consultation_interval: u64,         // ticks between LLM consultations
    last_consultation: u64,
    current_plan: Option&lt;StrategicPlan&gt;,
    event_log: AiEventLog,              // D041 — fog-filtered event accumulator
}
<span class="boring">}</span></code></pre>
<p><strong>How it works:</strong></p>
<pre><code>Every N ticks (configurable, default ~300 = ~10 seconds at 30 tick/s):
  1. Serialize visible game state into a structured prompt:
     - Own base layout, army composition, resource levels
     - Known enemy positions, army composition estimate
     - Current strategic plan (if any)
     - event_log.to_narrative(last_consultation) — fog-filtered event chronicle
  2. Send prompt to LlmProvider (D016)
  3. LLM returns a StrategicPlan:
     - Priority targets (e.g., "attack enemy expansion at north")
     - Build focus (e.g., "switch to anti-air production")
     - Economic guidance (e.g., "expand to second ore field")
     - Risk assessment (e.g., "enemy likely to push soon, fortify choke")
  4. Translate StrategicPlan into inner AI parameter adjustments via set_parameter()
     (e.g., "switch to anti-air" → set_parameter("tech_priority_aa", 80))
  5. Record plan change as StrategicUpdate event in event_log
  6. Inner AI incorporates guidance into its normal tick-level decisions

Between consultations:
  - Inner AI runs normally, using the last parameter adjustments as guidance
  - Tick-level micro, build queue management, unit control all handled by inner AI
  - No LLM latency in the hot path
  - Events continue accumulating in event_log for the next consultation
</code></pre>
<p><strong>Event log as LLM context (D041 integration):</strong></p>
<p>The <code>AiEventLog</code> (defined in D041) is the bridge between simulation events and LLM understanding. The orchestrator accumulates fog-filtered events from the D041 callback pipeline — <code>on_enemy_spotted</code>, <code>on_under_attack</code>, <code>on_unit_destroyed</code>, etc. — and serializes them into a natural-language narrative via <code>to_narrative(since_tick)</code>. This narrative is the “inner game event log / action story / context” the LLM reads to understand what happened since its last consultation.</p>
<p>The event log is <strong>fog-filtered by construction</strong> — all events originate from the same fog-filtered callback pipeline that respects <code>FogFilteredView</code>. The LLM never receives information about actions behind fog of war, only events the AI player is supposed to be aware of. This is an architectural guarantee, not a filtering step that could be bypassed.</p>
<p><strong>Event callback forwarding:</strong></p>
<p>The orchestrator implements all D041 event callbacks by forwarding to both the inner AI and the event log:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AiStrategy for LlmOrchestratorAi {
    fn decide(&amp;mut self, player: PlayerId, view: &amp;FogFilteredView, tick: u64) -&gt; Vec&lt;PlayerOrder&gt; {
        // Check if it's time for an LLM consultation
        if tick - self.last_consultation &gt;= self.consultation_interval {
            self.consult_llm(player, view, tick);
        }
        // Delegate tick-level decisions to the inner AI
        self.inner.decide(player, view, tick)
    }

    fn on_enemy_spotted(&amp;mut self, unit: EntityId, unit_type: &amp;str) {
        self.event_log.push(AiEventEntry {
            tick: self.current_tick,
            event_type: AiEventType::EnemySpotted,
            description: format!("Enemy {} spotted", unit_type),
            entity: Some(unit),
            related_entity: None,
        });
        self.inner.on_enemy_spotted(unit, unit_type);  // forward to inner AI
    }

    fn on_under_attack(&amp;mut self, unit: EntityId, attacker: EntityId) {
        self.event_log.push(/* ... */);
        self.inner.on_under_attack(unit, attacker);
    }

    // ... all other callbacks follow the same pattern:
    // 1. Record in event_log  2. Forward to inner AI

    fn name(&amp;self) -&gt; &amp;str { "LLM Orchestrator" }
    fn difficulty(&amp;self) -&gt; AiDifficulty { self.inner.difficulty() }
    fn tick_budget_hint(&amp;self) -&gt; Option&lt;u64&gt; { self.inner.tick_budget_hint() }

    // Delegate parameter introspection — expose orchestrator params + inner AI params
    fn get_parameters(&amp;self) -&gt; Vec&lt;ParameterSpec&gt; {
        let mut params = vec![
            ParameterSpec {
                name: "consultation_interval".into(),
                description: "Ticks between LLM consultations".into(),
                min_value: 30, max_value: 3000,
                default_value: 300, current_value: self.consultation_interval as i32,
            },
        ];
        // Include inner AI's parameters (prefixed for clarity)
        params.extend(self.inner.get_parameters());
        params
    }

    fn set_parameter(&amp;mut self, name: &amp;str, value: i32) {
        match name {
            "consultation_interval" =&gt; self.consultation_interval = value as u64,
            _ =&gt; self.inner.set_parameter(name, value),  // delegate to inner AI
        }
    }

    // Delegate engine scaling to inner AI — the orchestrator adds LLM guidance,
    // difficulty scaling applies to the underlying AI that executes orders
    fn uses_engine_difficulty_scaling(&amp;self) -&gt; bool {
        self.inner.uses_engine_difficulty_scaling()
    }
}
<span class="boring">}</span></code></pre>
<p><strong>How StrategicPlan reaches the inner AI:</strong></p>
<p>The orchestrator translates <code>StrategicPlan</code> fields into <code>set_parameter()</code> calls on the inner AI (D041). For example:</p>
<ul>
<li>“Switch to anti-air production” → <code>set_parameter("tech_priority_aa", 80)</code></li>
<li>“Be more aggressive” → <code>set_parameter("aggression", 75)</code></li>
<li>“Expand to second ore field” → <code>set_parameter("expansion_priority", 90)</code></li>
</ul>
<p>This uses D041’s existing parameter introspection infrastructure — no new trait methods needed. The inner AI’s <code>get_parameters()</code> exposes its tunable knobs; the LLM’s strategic output maps to those knobs. An inner AI that doesn’t expose relevant parameters simply ignores guidance it can’t act on — the orchestrator degrades gracefully.</p>
<p><strong>Key design points:</strong></p>
<ul>
<li><strong>No latency impact on gameplay.</strong> LLM consultation is async — fires off a request, continues with the previous plan until the response arrives. If the LLM is slow (or unavailable), the inner AI plays normally.</li>
<li><strong>BYOLLM (D016).</strong> Same provider system — users configure their own model. Local models (Ollama) give lowest latency; cloud APIs work but add ~1-3s round-trip per consultation.</li>
<li><strong>Determinism maintained.</strong> In multiplayer, the LLM runs on exactly one machine (the AI slot owner’s client). The resulting <code>StrategicPlan</code> is submitted as an order through the <code>NetworkModel</code> — the same path as human player orders. Other clients never run the LLM; they receive and apply the same plan at the same deterministic tick boundary. In singleplayer, determinism is trivially preserved (orders are recorded in the replay, not LLM calls).</li>
<li><strong>Inner AI is any <code>AiStrategy</code>.</strong> Orchestrator wraps IC Default, Classic RA, a community WASM AI (D043), or even a <code>StyleDrivenAi</code> (D042). The LLM adds strategic thinking on top of whatever execution style is underneath. Because the orchestrator communicates through the generic <code>AiStrategy</code> trait (event callbacks + <code>set_parameter()</code>), it works with any implementation — including community-provided WASM AI mods.</li>
<li><strong>Two-axis difficulty compatibility (D043).</strong> The orchestrator delegates <code>difficulty()</code> and <code>uses_engine_difficulty_scaling()</code> to the inner AI. Engine-level difficulty scaling (resource bonuses, reaction delays) applies to the inner AI’s execution; the LLM consultation frequency and depth are separate parameters exposed via <code>get_parameters()</code>. In the lobby, players select the inner AI + difficulty normally, then optionally enable LLM orchestration on top.</li>
<li><strong>Observable.</strong> The current <code>StrategicPlan</code> and the event log narrative are displayed in a debug overlay (developer/spectator mode), letting players see the LLM’s “thinking” and the events that informed it.</li>
<li><strong>Prompt engineering is in YAML.</strong> Prompt templates are mod-data, not hardcoded. Modders can customize LLM prompts for different game modules or scenarios.</li>
</ul>
<pre><code class="language-yaml"># llm/prompts/orchestrator.yaml
orchestrator:
  system_prompt: |
    You are a strategic advisor for a Red Alert AI player.
    Analyze the game state and provide high-level strategic guidance.
    Do NOT issue specific unit orders — your AI subordinate handles execution.
    Focus on: what to build, where to expand, when to attack, what threats to prepare for.
  response_format:
    type: structured
    schema: StrategicPlan
  consultation_interval_ticks: 300
  max_tokens: 500
</code></pre>
<h3 id="2-llm-player-llmplayerai--experimental"><a class="header" href="#2-llm-player-llmplayerai--experimental">2. LLM Player (<code>LlmPlayerAi</code>) — Experimental</a></h3>
<p>A fully LLM-driven player where the language model makes every decision. No inner AI — the LLM receives game state and emits player orders directly. This is the “LLM makes every small decision” path — the architecture supports it through the same <code>AiStrategy</code> trait and <code>AiEventLog</code> infrastructure as the orchestrator.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Experimental: LLM makes all decisions directly.
/// Every N ticks, the LLM receives game state and returns orders.
/// Performance and quality depend entirely on the LLM model and latency.
pub struct LlmPlayerAi {
    provider: Box&lt;dyn LlmProvider&gt;,
    decision_interval: u64,           // ticks between LLM decisions
    pending_orders: Vec&lt;PlayerOrder&gt;, // buffered orders from last LLM response
    order_cursor: usize,              // index into pending_orders for drip-feeding
    event_log: AiEventLog,            // D041 — fog-filtered event accumulator
}
<span class="boring">}</span></code></pre>
<p><strong>How it works:</strong></p>
<ul>
<li>Every N ticks, serialize <code>FogFilteredView</code> + <code>event_log.to_narrative(last_decision_tick)</code> → send to LLM → receive a batch of <code>PlayerOrder</code> values</li>
<li>The event log narrative gives the LLM a chronological understanding of what happened — “what has been going on in this game” — rather than just a snapshot of current state</li>
<li>Between decisions, drip-feed buffered orders to the sim (one or few per tick)</li>
<li>If the LLM response is slow, the player idles (no orders until response arrives)</li>
<li>Event callbacks continue accumulating into the event log between LLM decisions, building a richer narrative for the next consultation</li>
</ul>
<p><strong>Why the event log matters for full LLM control:</strong></p>
<p>The LLM Player receives <code>FogFilteredView</code> (current game state) AND <code>AiEventLog</code> (recent game history). Together these give the LLM:</p>
<ul>
<li><strong>Spatial awareness</strong> — what’s where right now (from <code>FogFilteredView</code>)</li>
<li><strong>Temporal awareness</strong> — what happened recently (from the event log narrative)</li>
<li><strong>Causal understanding</strong> — “I was attacked from the north, my refinery was destroyed, I spotted 3 enemy tanks” forms a coherent story the LLM can reason about</li>
</ul>
<p>Without the event log, the LLM would see only a static snapshot every N ticks, with no continuity between decisions. The log bridges decisions into a narrative that LLMs are natively good at processing.</p>
<p><strong>Why this is experimental:</strong></p>
<ul>
<li><strong>Latency.</strong> Even local LLMs take 100-500ms per response. A 30 tick/s sim expects decisions every 33ms. The LLM Player will always be slower than a conventional AI.</li>
<li><strong>Quality ceiling.</strong> Current LLMs struggle with spatial reasoning and precise micro. The LLM Player will likely lose to even Easy conventional AI in direct combat efficiency.</li>
<li><strong>Cost.</strong> Cloud LLMs charge per token. A full game might generate thousands of consultations. Local models are free but slower.</li>
<li><strong>The value is educational and entertaining</strong>, not competitive. Watching an LLM try to play Red Alert — making mistakes, forming unexpected strategies, explaining its reasoning — is intrinsically interesting. Community streaming of “GPT vs. Claude playing Red Alert” is a content opportunity.</li>
</ul>
<p><strong>Design constraints:</strong></p>
<ul>
<li><strong>Never the default.</strong> LLM Player is clearly labeled “Experimental” in the lobby.</li>
<li><strong>Not allowed in ranked.</strong> LLM AI modes are excluded from competitive matchmaking.</li>
<li><strong>Observable.</strong> The LLM’s reasoning text and event log narrative are capturable as a spectator overlay, enabling commentary-style viewing.</li>
<li><strong>Same BYOLLM infrastructure.</strong> Uses <code>LlmProvider</code> trait (D016), same configuration, same provider options.</li>
<li><strong>Two-axis difficulty compatibility (D043).</strong> Engine-level difficulty scaling (resource bonuses, reaction delays) applies normally — <code>uses_engine_difficulty_scaling()</code> returns <code>true</code>. The LLM’s “skill” is inherent in the model’s capability and prompt engineering, not in engine parameters. <code>get_parameters()</code> exposes LLM-specific knobs: decision interval, max tokens, model selection, prompt template — but the LLM’s quality is ultimately model-dependent, not engine-controlled. This is an honest design: we don’t pretend to make the LLM “harder” or “easier” through engine scaling, but we do let the engine give it economic advantages or handicaps.</li>
<li><strong>Determinism:</strong> The LLM runs on one machine (the AI slot owner’s client) and submits orders through the <code>NetworkModel</code>, just like human input. All clients apply the same orders at the same deterministic tick boundaries. The LLM itself is non-deterministic (different responses per run), but that non-determinism is resolved before orders enter the sim — the sim only sees deterministic order streams. Replays record orders (not LLM calls), so replay playback is fully deterministic.</li>
</ul>
<h3 id="relationship-to-d041d043--integration-summary"><a class="header" href="#relationship-to-d041d043--integration-summary">Relationship to D041/D043 — Integration Summary</a></h3>
<p>The LLM AI modes build entirely on the <code>AiStrategy</code> trait (D041) and the two-axis difficulty system (D043):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Orchestrator</th><th>LLM Player</th></tr>
</thead>
<tbody>
<tr><td>Implements <code>AiStrategy</code>?</td><td>Yes — wraps an inner <code>AiStrategy</code></td><td>Yes — direct implementation</td></tr>
<tr><td>Uses <code>AiEventLog</code>?</td><td>Yes — accumulates events for LLM prompts, forwards callbacks to inner AI</td><td>Yes — accumulates events for LLM self-context</td></tr>
<tr><td><code>FogFilteredView</code>?</td><td>Yes — serialized into LLM prompt alongside event narrative</td><td>Yes — serialized into LLM prompt</td></tr>
<tr><td>Event callbacks?</td><td>Forwards to inner AI + records in event log</td><td>Records in event log for next LLM consultation</td></tr>
<tr><td><code>set_parameter()</code>?</td><td>Exposes orchestrator params + delegates to inner AI; translates LLM plans to param adjustments</td><td>Exposes LLM-specific params (decision_interval, max_tokens)</td></tr>
<tr><td><code>get_parameters()</code>?</td><td>Returns orchestrator params + inner AI’s params</td><td>Returns LLM Player params</td></tr>
<tr><td><code>uses_engine_difficulty_scaling()</code>?</td><td>Delegates to inner AI</td><td>Returns <code>true</code> (engine bonuses/handicaps apply)</td></tr>
<tr><td><code>difficulty()</code>?</td><td>Delegates to inner AI</td><td>Returns selected difficulty (user picks in lobby)</td></tr>
<tr><td>Two-axis difficulty?</td><td>Inner AI axis applies to execution; orchestrator params are separate</td><td>Engine scaling applies; LLM quality is model-dependent</td></tr>
</tbody>
</table>
</div>
<p>The critical architectural property: <strong>neither LLM AI mode introduces any new trait methods, crate dependencies, or sim-layer concepts.</strong> They compose entirely from existing infrastructure — <code>AiStrategy</code>, <code>AiEventLog</code>, <code>FogFilteredView</code>, <code>set_parameter()</code>, <code>LlmProvider</code>. This means the LLM AI path doesn’t constrain or complicate the non-LLM AI path. A modder who never uses LLM features is completely unaffected.</p>
<h3 id="future-path-full-llm-control-at-scale"><a class="header" href="#future-path-full-llm-control-at-scale">Future Path: Full LLM Control at Scale</a></h3>
<p>The current <code>LlmPlayerAi</code> is limited by latency (LLM responses take 100-500ms vs. 33ms sim ticks) and spatial reasoning capability. As LLM inference speeds improve and models gain better spatial/numerical reasoning, the same architecture scales:</p>
<ul>
<li>Faster models → lower <code>decision_interval</code> → more responsive LLM play</li>
<li>Better spatial reasoning → LLM can handle micro, not just strategy</li>
<li>Multimodal models → render a minimap image as additional LLM context alongside the event narrative</li>
<li>The <code>AiStrategy</code> trait, <code>AiEventLog</code>, and <code>FogFilteredView</code> infrastructure are all model-agnostic — they serve whatever LLM capability exists at runtime</li>
</ul>
<p>The architecture is deliberately designed not to stand in the way of full LLM control becoming practical. Every piece needed for “LLM makes every small decision” already exists in the trait design — the only bottleneck is LLM speed and quality, which are external constraints that improve over time.</p>
<h3 id="crate-boundaries-1"><a class="header" href="#crate-boundaries-1">Crate Boundaries</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Crate</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>LlmOrchestratorAi</code> struct</td><td><code>ic-ai</code></td><td>AI strategy implementation</td></tr>
<tr><td><code>LlmPlayerAi</code> struct</td><td><code>ic-ai</code></td><td>AI strategy implementation</td></tr>
<tr><td><code>StrategicPlan</code> type</td><td><code>ic-ai</code></td><td>AI-internal data structure</td></tr>
<tr><td><code>AiEventLog</code> struct</td><td><code>ic-ai</code></td><td>Engine-provided event accumulator (D041 design, <code>ic-ai</code> impl)</td></tr>
<tr><td><code>LlmProvider</code> trait</td><td><code>ic-llm</code></td><td>Existing D016 infrastructure</td></tr>
<tr><td>Prompt templates (YAML)</td><td>mod data</td><td>Game-module-specific, moddable</td></tr>
<tr><td>Game state serializer for LLM</td><td><code>ic-ai</code></td><td>Reads sim state (read-only), formats for LLM prompts</td></tr>
<tr><td>Debug overlay (plan viewer)</td><td><code>ic-ui</code></td><td>Spectator/dev UI for observing LLM reasoning + event narrative</td></tr>
</tbody>
</table>
</div>
<h3 id="alternatives-considered-4"><a class="header" href="#alternatives-considered-4">Alternatives Considered</a></h3>
<ul>
<li>LLM replaces inner AI entirely in orchestrator mode (rejected — latency makes tick-level LLM control impractical; hybrid is better)</li>
<li>LLM operates between games only (rejected — D042 already covers between-game coaching; real-time guidance is the new capability)</li>
<li>No LLM Player mode (rejected — the experimental mode has minimal implementation cost and high community interest/entertainment value)</li>
<li>LLM in the sim crate (rejected — violates BYOLLM optionality; <code>ic-ai</code> imports <code>ic-llm</code> optionally, <code>ic-sim</code> never imports either)</li>
<li>New trait method <code>set_strategic_guidance()</code> for LLM → inner AI communication (rejected — <code>set_parameter()</code> already provides the mechanism; adding an LLM-specific method to the generic <code>AiStrategy</code> trait would couple the trait to an optional feature)</li>
<li>Custom event log per AI instead of engine-provided <code>AiEventLog</code> (rejected — the log benefits all AI implementations for debugging/observation, not just LLM; making it engine infrastructure avoids redundant implementations)</li>
</ul>
<h3 id="relationship-to-existing-decisions-3"><a class="header" href="#relationship-to-existing-decisions-3">Relationship to Existing Decisions</a></h3>
<ul>
<li><strong>D016 (BYOLLM):</strong> Same provider infrastructure. Both LLM AI modes use <code>LlmProvider</code> trait for model access.</li>
<li><strong>D041 (<code>AiStrategy</code> trait):</strong> Both modes implement <code>AiStrategy</code>. The orchestrator wraps any <code>AiStrategy</code> via the generic trait. Both use <code>AiEventLog</code> (D041) for fog-filtered event accumulation. The orchestrator communicates with the inner AI through <code>set_parameter()</code> and event callback forwarding — all D041 infrastructure.</li>
<li><strong>D042 (<code>StyleDrivenAi</code>):</strong> The orchestrator can wrap <code>StyleDrivenAi</code> — LLM strategic guidance on top of a mimicked player’s style. The <code>AiEventLog</code> serves both D042 (profile building reads events) and D044 (LLM reads events).</li>
<li><strong>D043 (AI presets + two-axis difficulty):</strong> LLM AI integrates with the two-axis difficulty system. Orchestrator delegates difficulty to inner AI; LLM Player accepts engine scaling. Users select inner AI + difficulty in the lobby, then optionally enable LLM orchestration.</li>
<li><strong>D031 (telemetry):</strong> The <code>GameplayEvent</code> stream (D031) feeds the fog-filtered callback pipeline that populates <code>AiEventLog</code>. D031 is the raw data source; D041 callbacks are the filtered AI-facing interface; <code>AiEventLog</code> is the accumulated narrative.</li>
<li><strong>D034 (SQLite):</strong> LLM consultation history (prompts sent, plans received, execution outcomes) stored in SQLite for debugging and quality analysis. No new tables required — uses the existing <code>gameplay_events</code> schema with LLM-specific event types.</li>
</ul>
<hr>
<h2 id="d045-pathfinding-behavior-presets--movement-feel"><a class="header" href="#d045-pathfinding-behavior-presets--movement-feel">D045: Pathfinding Behavior Presets — Movement Feel</a></h2>
<p><strong>Status:</strong> Accepted
<strong>Scope:</strong> <code>ic-sim</code>, game module configuration
<strong>Phase:</strong> Phase 2 (ships with simulation)</p>
<h3 id="the-problem-3"><a class="header" href="#the-problem-3">The Problem</a></h3>
<p>D013 provides the <code>Pathfinder</code> trait for pluggable pathfinding <em>algorithms</em> (multi-layer hybrid vs. navmesh). D019 provides switchable <em>balance</em> values. But movement <em>feel</em> — how units navigate, group, avoid each other, and handle congestion — varies dramatically between Classic RA, OpenRA, and what modern pathfinding research enables. This is partially balance (unit speed values) but mostly <em>behavioral</em>: how the pathfinder handles collisions, how units merge into formations, how traffic jams resolve, and how responsive movement commands feel.</p>
<h3 id="decision-2"><a class="header" href="#decision-2">Decision</a></h3>
<p>Ship <strong>pathfinding behavior presets</strong> as separate <code>Pathfinder</code> trait implementations (D013), each sourced from the codebase it claims to reproduce. Presets are selectable alongside balance presets (D019) and AI presets (D043), bundled into experience profiles, and presented through progressive disclosure so casual players never see the word “pathfinding.”</p>
<h3 id="built-in-presets-1"><a class="header" href="#built-in-presets-1">Built-In Presets</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Preset</th><th>Movement Feel</th><th>Source</th><th><code>Pathfinder</code> Implementation</th></tr>
</thead>
<tbody>
<tr><td><strong>Classic RA</strong></td><td>Unit-level A*-like pathing, units block each other, congestion causes jams, no formation movement, units take wide detours around obstacles</td><td>EA Remastered Collection source code (GPL v3)</td><td><code>RemastersPathfinder</code></td></tr>
<tr><td><strong>OpenRA</strong></td><td>Improved cell-based pathing, basic crush/push logic, units attempt to flow around blockages, locomotor-based speed modifiers, no formal formations</td><td>OpenRA pathfinding implementation (GPL v3)</td><td><code>OpenRaPathfinder</code></td></tr>
<tr><td><strong>IC Default</strong></td><td>Multi-layer hybrid: hierarchical sectors for routing, JPS for small groups, flow field tiles for mass movement, ORCA-lite local avoidance, formation-aware group coordination</td><td>Open-source RTS research + IC original (see below)</td><td><code>IcPathfinder</code></td></tr>
</tbody>
</table>
</div>
<p>Each preset is a <strong>distinct <code>Pathfinder</code> trait implementation</strong>, not a parameterized variant of one algorithm. The Remastered pathfinder and OpenRA pathfinder use fundamentally different algorithms and produce fundamentally different movement behavior — parameterizing one to emulate the other would be an approximation at best and a lie at worst. The <code>Pathfinder</code> trait (D013) was designed for exactly this: slot in different implementations without touching sim code.</p>
<p><strong>Why “IcPathfinder,” not “IcFlowfieldPathfinder”?</strong> Research revealed that no shipped RTS engine uses pure flowfields (except SupCom2/PA by the same team). Spring Engine tried flow maps and abandoned them. Independent developers (jdxdev) documented the same “ant line” failure with 100+ units. IC’s default pathfinder is a multi-layer hybrid — flowfield tiles are one layer activated for large groups, not the system’s identity. See <code>research/pathfinding-ic-default-design.md</code> for full architecture.</p>
<p><strong>Why Remastered, not original RA source?</strong> The Remastered Collection engine DLLs (GPL v3) contain the same pathfinding logic as original RA but with bug fixes and modernized C++ that’s easier to port to Rust. The original RA source is also GPL and available for cross-reference. Both produce the same movement feel — the Remastered version is simply a cleaner starting point.</p>
<h3 id="ic-default-pathfinding--research-foundation"><a class="header" href="#ic-default-pathfinding--research-foundation">IC Default Pathfinding — Research Foundation</a></h3>
<p>The IC Default preset (<code>IcPathfinder</code>) is a five-layer hybrid architecture synthesizing pathfinding approaches from across the open-source RTS ecosystem and academic research. Full design: <code>research/pathfinding-ic-default-design.md</code>.</p>
<p><strong>Layer 1 — Cost Field &amp; Passability:</strong> Per-cell movement cost (u8, 1–255) per locomotor type, inspired by EA Remastered terrain cost tables and 0 A.D.’s passability classes.</p>
<p><strong>Layer 2 — Hierarchical Sector Graph:</strong> Map divided into 32×32-cell sectors with portal connections between them. Flood-fill domain IDs for O(1) reachability checks. Inspired by OpenRA’s hierarchical abstraction and HPA* research.</p>
<p><strong>Layer 3 — Adaptive Detailed Pathfinding:</strong> JPS (Jump Point Search) for small groups (&lt;8 units) — 10–100× faster than A* on uniform-cost grids. Flow field tiles for mass movement (≥8 units sharing a destination). Weighted A* fallback for non-uniform terrain. LRU flow field cache. Inspired by 0 A.D.’s JPS, SupCom2’s flow field tiles, Game AI Pro 2’s JPS+ precomputed tables.</p>
<p><strong>Layer 4 — ORCA-lite Local Avoidance:</strong> Fixed-point deterministic collision avoidance based on RVO2/ORCA (Reciprocal Velocity Obstacles). Commitment locking prevents hallway dance. Cooperative side selection (“mind reading”) from HowToRTS research.</p>
<p><strong>Layer 5 — Group Coordination:</strong> Formation offset assignment, synchronized arrival, chokepoint compression. Inspired by jdxdev’s boids-for-RTS formation offsets and Spring Engine’s group movement.</p>
<p><strong>Source engines studied:</strong></p>
<ul>
<li><strong>EA Remastered Collection</strong> (GPL v3) — obstacle-tracing, terrain cost tables, integer math</li>
<li><strong>OpenRA</strong> (GPL v3) — hierarchical A*, custom search graph with 10×10 abstraction</li>
<li><strong>Spring Engine</strong> (GPL v2) — QTPFS quadtree, flow-map attempt (abandoned), unit push/slide</li>
<li><strong>0 A.D.</strong> (GPL v2/MIT) — JPS long-range + vertex short-range, clearance-based sizing, fixed-point <code>CFixed_15_16</code></li>
<li><strong>Warzone 2100</strong> (GPL v2) — A* with LRU context caching, gateway optimization</li>
<li><strong>SupCom2/PA</strong> — flow field tiles (only shipped flowfield RTS)</li>
<li><strong>Academic</strong> — RVO2/ORCA (UNC), HPA*, continuum crowds (Treuille et al.), JPS+ (Game AI Pro 2)</li>
</ul>
<h3 id="configuration-model-1"><a class="header" href="#configuration-model-1">Configuration Model</a></h3>
<p>Each <code>Pathfinder</code> implementation exposes its own tunable parameters via YAML. Parameters differ between implementations because they control fundamentally different algorithms — there is no shared “pathfinding config” struct that applies to all three.</p>
<pre><code class="language-yaml"># pathfinding/remastered.yaml — RemastersPathfinder tunables
remastered_pathfinder:
  name: "Classic Red Alert"
  description: "Movement feel matching the original game"
  # These are behavioral overrides on the Remastered pathfinder.
  # Defaults reproduce original behavior exactly.
  harvester_stuck_fix: false         # true = apply minor QoL fix for harvesters stuck on each other
  bridge_queue_behavior: original    # original | relaxed (slightly wider queue threshold)
  infantry_scatter_pattern: original # original | smoothed (less jagged scatter on damage)

# pathfinding/openra.yaml — OpenRaPathfinder tunables
openra_pathfinder:
  name: "OpenRA"
  description: "Movement feel matching OpenRA's pathfinding"
  locomotor_speed_modifiers: true    # per-terrain speed multipliers (OpenRA feature)
  crush_logic: true                  # vehicles can crush infantry
  blockage_flow: true                # units attempt to flow around blocking units

# pathfinding/ic-default.yaml — IcPathfinder tunables
ic_pathfinder:
  name: "IC Default"
  description: "Multi-layer hybrid: JPS + flow field tiles + ORCA-lite avoidance"

  # Layer 2 — Hierarchical sectors
  sector_size: 32                    # cells per sector side
  portal_max_width: 8                # max portal opening (cells)

  # Layer 3 — Adaptive pathfinding
  flowfield_group_threshold: 8       # units sharing dest before flowfield activates
  flowfield_cache_size: 64           # LRU cache entries for flow field tiles
  jps_enabled: true                  # JPS for small groups on uniform terrain
  repath_frequency: adaptive         # low | medium | high | adaptive

  # Layer 4 — Local avoidance (ORCA-lite)
  avoidance_radius_multiplier: 1.2   # multiplier on unit collision radius
  commitment_frames: 4               # frames locked into avoidance direction
  cooperative_avoidance: true        # "mind reading" side selection

  # Layer 5 — Group coordination
  formation_movement: true           # groups move in formation
  synchronized_arrival: true         # units slow down to arrive together
  chokepoint_compression: true       # formation compresses at narrow passages

  # General
  path_smoothing: funnel             # none | funnel | spline
  influence_avoidance: true          # avoid areas with high enemy threat
</code></pre>
<p>Power users can override any parameter in the lobby’s advanced settings or in mod YAML. Casual players never see these — they pick an experience profile and the correct implementation + parameters are selected automatically.</p>
<h3 id="sim-affecting-nature"><a class="header" href="#sim-affecting-nature">Sim-Affecting Nature</a></h3>
<p>Pathfinding presets are <strong>sim-affecting</strong> — they change how the deterministic simulation resolves movement. Like balance presets (D019):</p>
<ul>
<li>All players in a multiplayer game must use the same pathfinding preset (enforced by lobby, validated by sim)</li>
<li>Preset selection is part of the game configuration hash for desync detection</li>
<li>Replays record the active pathfinding preset</li>
</ul>
<h3 id="experience-profile-integration-1"><a class="header" href="#experience-profile-integration-1">Experience Profile Integration</a></h3>
<pre><code class="language-yaml">profiles:
  classic-ra:
    balance: classic
    ai_preset: classic-ra
    pathfinding: classic-ra          # NEW — movement feel
    theme: classic
    qol: vanilla

  openra-ra:
    balance: openra
    ai_preset: openra
    pathfinding: openra              # NEW — OpenRA movement feel
    theme: modern
    qol: openra

  iron-curtain-ra:
    balance: classic
    ai_preset: ic-default
    pathfinding: ic-default          # NEW — modern movement
    theme: modern
    qol: iron_curtain
</code></pre>
<h3 id="user-facing-ux--progressive-disclosure"><a class="header" href="#user-facing-ux--progressive-disclosure">User-Facing UX — Progressive Disclosure</a></h3>
<p>Pathfinding selection follows the same progressive disclosure pyramid as the rest of the experience profile system. A casual player should never encounter the word “pathfinding.”</p>
<p><strong>Level 1 — One dropdown (casual player):</strong> The lobby’s experience profile selector offers “Classic RA,” “OpenRA,” or “Iron Curtain.” Picking one sets balance, theme, QoL, AI, movement feel, AND render mode. The pathfinder and render mode selections are invisible — they’re bundled. A player who picks “Classic RA” gets Remastered pathfinding and classic pixel art because that’s what Classic RA <em>is</em>.</p>
<p><strong>Level 2 — Per-axis override (intermediate player):</strong> An “Advanced” toggle in the lobby expands the experience profile into its 6 independent axes. The movement axis is labeled by feel, not algorithm: “Movement: Classic / OpenRA / Modern” — not “<code>RemastersPathfinder</code> / <code>OpenRaPathfinder</code> / <code>IcPathfinder</code>.” The render mode axis shows “Graphics: Classic / HD / 3D” (D048). The player can mix “OpenRA balance + Classic movement + HD graphics” if they want.</p>
<p><strong>Level 3 — Parameter tuning (power user / modder):</strong> A gear icon next to the movement axis opens implementation-specific parameters (see Configuration Model above). This is where harvester stuck fixes, pressure diffusion strength, and formation toggles live.</p>
<h3 id="scenario-required-pathfinding"><a class="header" href="#scenario-required-pathfinding">Scenario-Required Pathfinding</a></h3>
<p>Scenarios and campaign missions can specify a <strong>required</strong> or <strong>recommended</strong> pathfinding preset in their YAML metadata:</p>
<pre><code class="language-yaml">scenario:
  name: "Bridge Assault"
  pathfinding:
    required: classic-ra    # this mission depends on chokepoint blocking behavior
    reason: "Mission balance depends on single-file bridge queuing"
</code></pre>
<p>When the lobby loads this scenario, it auto-selects the required pathfinder and shows the player why: “This scenario requires Classic movement (mission balance depends on chokepoint behavior).” The player cannot override a <code>required</code> setting. A <code>recommended</code> setting auto-selects but allows override with a warning.</p>
<p>This preserves original campaign missions. A mission designed around units jamming at a bridge works correctly because it ships with <code>required: classic-ra</code>. A modern community scenario can ship with <code>required: ic-default</code> to ensure smooth flowfield behavior.</p>
<h3 id="mod-selectable-and-mod-provided-pathfinders"><a class="header" href="#mod-selectable-and-mod-provided-pathfinders">Mod-Selectable and Mod-Provided Pathfinders</a></h3>
<p>The three built-in presets are the <strong>first-party</strong> <code>Pathfinder</code> implementations. They are not the only ones. The <code>Pathfinder</code> trait (D013) is explicitly open to community implementations.</p>
<p><strong>Modder as consumer — selecting a pathfinder:</strong></p>
<p>A mod’s YAML manifest can declare which pathfinder it uses. The modder picks from any available implementation — first-party or community:</p>
<pre><code class="language-yaml"># mod.yaml — total conversion mod that uses IC's modern pathfinding
mod:
  name: "Desert Strike"
  pathfinder: ic-default            # Use IC's multi-layer hybrid
  # Or: remastered, openra, layered-grid-generals, community/navmesh-pro, etc.
</code></pre>
<p>If the mod doesn’t specify a pathfinder, it inherits whatever the player’s experience profile selects. When specified, it overrides the experience profile’s pathfinding axis — the same way <code>scenario.pathfinding.required</code> works (see “Scenario-Required Pathfinding” above), but at the mod level.</p>
<p><strong>Modder as author — providing a pathfinder:</strong></p>
<p>A Tier 3 WASM mod can implement the <code>Pathfinder</code> trait and register it as a new option:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WASM mod: custom pathfinder (e.g., Generals-style layered grid)
impl Pathfinder for LayeredGridPathfinder {
    fn request_path(&amp;mut self, origin: WorldPos, dest: WorldPos, locomotor: LocomotorType) -&gt; PathId {
        // Surface bitmask check, zone reachability, A* with bridge layers
        // ...
    }
    fn get_path(&amp;self, id: PathId) -&gt; Option&lt;&amp;[WorldPos]&gt; { /* ... */ }
    fn is_passable(&amp;self, pos: WorldPos, locomotor: LocomotorType) -&gt; bool { /* ... */ }
    fn invalidate_area(&amp;mut self, center: WorldPos, radius: SimCoord) { /* ... */ }
}
<span class="boring">}</span></code></pre>
<p>The mod registers its pathfinder in its manifest with a YAML config block (like the built-in presets):</p>
<pre><code class="language-yaml"># mod.yaml — community pathfinder distributed via Workshop
mod:
  name: "Generals Pathfinder"
  type: pathfinder                   # declares this mod provides a Pathfinder impl
  pathfinder_id: layered-grid-generals
  display_name: "Generals (Layered Grid)"
  description: "Grid pathfinding with bridge layers and surface bitmasks, inspired by C&amp;C Generals"
  wasm_module: generals_pathfinder.wasm
  config:
    zone_block_size: 10
    bridge_clearance: 10.0
    surface_types: [ground, water, cliff, air, rubble]
</code></pre>
<p>Once installed, the community pathfinder appears alongside first-party presets in the lobby’s Level 2 per-axis override (“Movement: Classic / OpenRA / Modern / Generals”) and is selectable by other mods via <code>pathfinder: layered-grid-generals</code>.</p>
<p><strong>Workshop distribution:</strong> Community pathfinders are Workshop resources (D030) like any other mod. They can be rated, reviewed, and depended upon. A total conversion mod declares <code>depends: community/generals-pathfinder@^1.0</code> and the engine auto-downloads it on lobby join (same as CS:GO-style auto-download).</p>
<p><strong>Sim-affecting implications:</strong> Because pathfinding is deterministic and sim-affecting, all players in a multiplayer game must use the same pathfinder. A community pathfinder is synced like a first-party preset — the lobby validates that all clients have the same pathfinder WASM module (by SHA-256 hash), same config, same version.</p>
<h3 id="relationship-to-existing-decisions-4"><a class="header" href="#relationship-to-existing-decisions-4">Relationship to Existing Decisions</a></h3>
<ul>
<li><strong>D013 (<code>Pathfinder</code> trait):</strong> Each preset is a separate <code>Pathfinder</code> trait implementation. <code>RemastersPathfinder</code>, <code>OpenRaPathfinder</code>, and <code>IcPathfinder</code> are all registered by the RA1 game module. Community mods add more via WASM. The trait boundary serves triple duty: it separates algorithmic families (grid vs. navmesh), behavioral families (Classic vs. Modern), AND first-party from community-provided implementations.</li>
<li><strong>D018 (<code>GameModule</code> trait):</strong> The RA1 game module ships all three first-party pathfinder implementations. Community pathfinders are registered by the mod loader alongside them. The lobby’s experience profile selection determines which one is active — <code>fn pathfinder()</code> returns whichever <code>Box&lt;dyn Pathfinder&gt;</code> was selected, whether first-party or community.</li>
<li><strong>D019 (balance presets):</strong> Parallel concept. Balance = what units can do. Pathfinding = how they get there. Both are sim-affecting, synced in multiplayer, and open to community alternatives.</li>
<li><strong>D043 (AI presets):</strong> Orthogonal. AI decides where to send units; pathfinding decides how they move. An AI preset + pathfinding preset combination determines overall movement behavior. Both are modder-selectable.</li>
<li><strong>D033 (QoL toggles):</strong> Some implementation-specific parameters (harvester stuck fix, infantry scatter smoothing) could be classified as QoL. Presets bundle them for consistency; individual toggles in advanced settings allow fine-tuning.</li>
<li><strong>D048 (render modes):</strong> Same modder-selectable pattern. Mods select or provide render modes; mods select or provide pathfinders. The trait-per-subsystem architecture means every pluggable system follows the same model.</li>
</ul>
<h3 id="alternatives-considered-5"><a class="header" href="#alternatives-considered-5">Alternatives Considered</a></h3>
<ul>
<li><strong>One “best” pathfinding only</strong> (rejected — Classic RA movement feel is part of the nostalgia and is critical for original scenario compatibility; forcing modern pathing on purists would alienate them AND break existing missions)</li>
<li><strong>Pathfinding differences handled by balance presets</strong> (rejected — movement behavior is fundamentally different from numeric values; a separate axis deserves separate selection)</li>
<li><strong>One parameterized implementation that emulates all three</strong> (rejected — Remastered pathfinding and IC flowfield pathfinding are fundamentally different algorithms with different data structures and different computational models; parameterizing one to approximate the other produces a neither-fish-nor-fowl result that reproduces neither accurately; separate implementations are honest and maintainable)</li>
<li><strong>Only IC Default pathfinding, with “classic mode” as a cosmetic approximation</strong> (rejected — scenario compatibility requires <em>actual</em> reproduction of original movement behavior, not an approximation; bridge missions, chokepoint defense, harvester timing all depend on specific pathfinding quirks)</li>
</ul>
<hr>
<h2 id="d046-community-platform--premium-content--comprehensive-platform-integration"><a class="header" href="#d046-community-platform--premium-content--comprehensive-platform-integration">D046: Community Platform — Premium Content &amp; Comprehensive Platform Integration</a></h2>
<p><strong>Status:</strong> Accepted
<strong>Scope:</strong> <code>ic-game</code>, <code>ic-ui</code>, Workshop infrastructure, platform SDK integration
<strong>Phase:</strong> Platform integration: Phase 5. Premium content framework: Phase 6a+.</p>
<h3 id="context"><a class="header" href="#context">Context</a></h3>
<p>D030 designs the Workshop resource registry including Steam Workshop as a source type. D035 designs voluntary creator tipping with explicit rejection of mandatory paid content. D036 designs the achievement system including Steam achievement sync. These decisions remain valid — D046 extends them in two directions that were previously out of scope:</p>
<ol>
<li><strong>Premium content from official publishers</strong> — allowing companies like EA to offer premium content (e.g., Remastered-quality art packs, soundtrack packs) through the Workshop, with proper licensing and revenue</li>
<li><strong>Comprehensive platform integration</strong> — going beyond “Steam Workshop as a source” to full Steam platform compatibility (and other platforms: GOG, Epic, etc.)</li>
</ol>
<h3 id="decision-3"><a class="header" href="#decision-3">Decision</a></h3>
<p>Extend the Workshop and platform layer to support <em>optional paid content from verified publishers</em> alongside the existing free ecosystem, and provide comprehensive platform service integration beyond just Workshop.</p>
<h3 id="premium-content-framework"><a class="header" href="#premium-content-framework">Premium Content Framework</a></h3>
<p><strong>Who can sell:</strong> Only <strong>verified publishers</strong> — entities that have passed identity verification and (for copyrighted IP) provided proof of rights. This is NOT a general marketplace where any modder can charge money. The tipping model (D035) remains the primary creator recognition system.</p>
<p><strong>Use cases:</strong></p>
<ul>
<li>EA publishes Remastered Collection art assets (high-resolution sprites, remastered audio) as a premium resource pack. Players who own the Remastered Collection on Steam get it bundled; others can purchase separately.</li>
<li>Professional content studios publish high-quality campaign packs, voice acting, or soundtrack packs.</li>
<li>Tournament organizers sell premium cosmetic packs for event fundraising.</li>
</ul>
<p><strong>What premium content CANNOT be:</strong></p>
<ul>
<li><strong>Gameplay-affecting.</strong> No paid units, weapons, factions, or balance-changing content. Premium content is cosmetic or supplementary: art packs, soundtrack packs, voice packs, campaign packs (story content, not gameplay advantages).</li>
<li><strong>Required for multiplayer.</strong> No player can be excluded from a game because they don’t own a premium pack. If a premium art pack is active, non-owners see the default sprites — never a “buy to play” gate.</li>
<li><strong>Exclusive to one platform.</strong> Premium content purchased through any platform is accessible from all platforms (subject to platform holder agreements).</li>
</ul>
<pre><code class="language-yaml"># Workshop resource metadata extension for premium content
resource:
  name: "Remastered Art Pack"
  publisher:
    name: "Electronic Arts"
    verified: true
    publisher_id: "ea-official"
  pricing:
    model: premium                    # free | tip | premium
    price_usd: "4.99"                # publisher sets price
    bundled_with:                     # auto-granted if player owns:
      - platform: steam
        app_id: 1213210              # C&amp;C Remastered Collection
    revenue_split:
      platform_store: 30             # Steam/GOG/Epic standard store cut (from gross)
      ic_project: 10                 # IC Workshop hosting fee (from gross)
      publisher: 60                  # remainder to publisher
  content_type: cosmetic             # cosmetic | supplementary | campaign
  requires_base_game: true
  multiplayer_fallback: default      # non-owners see default assets
</code></pre>
<h3 id="comprehensive-platform-integration"><a class="header" href="#comprehensive-platform-integration">Comprehensive Platform Integration</a></h3>
<p>Beyond Workshop, IC integrates with platform services holistically:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform Service</th><th>Steam</th><th>GOG Galaxy</th><th>Epic</th><th>Standalone</th></tr>
</thead>
<tbody>
<tr><td><strong>Achievements</strong></td><td>Full sync (D036)</td><td>GOG achievement sync</td><td>Epic achievement sync</td><td>IC-only achievements (SQLite)</td></tr>
<tr><td><strong>Friends &amp; Presence</strong></td><td>Steam friends list, rich presence</td><td>GOG friends, presence</td><td>Epic friends, presence</td><td>IC account friends (future)</td></tr>
<tr><td><strong>Overlay</strong></td><td>Steam overlay (shift+tab)</td><td>GOG overlay</td><td>Epic overlay</td><td>None</td></tr>
<tr><td><strong>Matchmaking invite</strong></td><td>Steam invite → lobby join</td><td>GOG invite → lobby join</td><td>Epic invite → lobby join</td><td>Join code / direct IP</td></tr>
<tr><td><strong>Cloud saves</strong></td><td>Steam Cloud for save games</td><td>GOG Cloud for save games</td><td>Epic Cloud for save games</td><td>Local saves (export/import)</td></tr>
<tr><td><strong>Workshop</strong></td><td>Steam Workshop as source (D030)</td><td>GOG Workshop (if supported)</td><td>N/A</td><td>IC Workshop (always available)</td></tr>
<tr><td><strong>DRM</strong></td><td><strong>None.</strong> IC is DRM-free always.</td><td>DRM-free</td><td>DRM-free</td><td>DRM-free</td></tr>
<tr><td><strong>Premium purchases</strong></td><td>Steam Commerce</td><td>GOG store</td><td>Epic store</td><td>IC direct purchase (future)</td></tr>
<tr><td><strong>Leaderboards</strong></td><td>Steam leaderboards + IC leaderboards</td><td>IC leaderboards</td><td>IC leaderboards</td><td>IC leaderboards</td></tr>
<tr><td><strong>Multiplayer</strong></td><td>IC netcode (all platforms together)</td><td>IC netcode</td><td>IC netcode</td><td>IC netcode</td></tr>
</tbody>
</table>
</div>
<p><strong>Critical principle: All platforms play together.</strong> IC’s multiplayer is platform-agnostic (IC relay servers, D007). A Steam player, a GOG player, and a standalone player can all join the same lobby. Platform services (friends, invites, overlay) are convenience features — never multiplayer gates.</p>
<h3 id="platform-abstraction-layer"><a class="header" href="#platform-abstraction-layer">Platform Abstraction Layer</a></h3>
<p>The <code>PlatformServices</code> trait is defined in <code>ic-ui</code> (where platform-aware UI — friends list, invite buttons, achievement popups — lives). Concrete implementations (<code>SteamPlatform</code>, <code>GogPlatform</code>, <code>StandalonePlatform</code>) live in <code>ic-game</code> and are injected as a Bevy resource at startup. <code>ic-ui</code> accesses the trait via <code>Res&lt;dyn PlatformServices&gt;</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Engine-side abstraction over platform services.
/// Defined in ic-ui; implementations in ic-game, injected as Bevy resource.
pub trait PlatformServices: Send + Sync {
    /// Sync an achievement unlock to the platform
    fn unlock_achievement(&amp;self, id: &amp;str) -&gt; Result&lt;(), PlatformError&gt;;

    /// Set rich presence status
    fn set_presence(&amp;self, status: &amp;str, details: &amp;PresenceDetails) -&gt; Result&lt;(), PlatformError&gt;;

    /// Get friends list (for invite UI)
    fn friends_list(&amp;self) -&gt; Result&lt;Vec&lt;PlatformFriend&gt;, PlatformError&gt;;

    /// Invite a friend to the current lobby
    fn invite_friend(&amp;self, friend: &amp;PlatformFriend) -&gt; Result&lt;(), PlatformError&gt;;

    /// Upload save to cloud storage
    fn cloud_save(&amp;self, slot: &amp;str, data: &amp;[u8]) -&gt; Result&lt;(), PlatformError&gt;;

    /// Download save from cloud storage
    fn cloud_load(&amp;self, slot: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, PlatformError&gt;;

    /// Platform display name
    fn platform_name(&amp;self) -&gt; &amp;str;
}
<span class="boring">}</span></code></pre>
<p>Implementations: <code>SteamPlatform</code> (via Steamworks SDK), <code>GogPlatform</code> (via GOG Galaxy SDK), <code>StandalonePlatform</code> (no-op or IC-native services).</p>
<h3 id="monetization-model-for-backend-services"><a class="header" href="#monetization-model-for-backend-services">Monetization Model for Backend Services</a></h3>
<p>D035 established that IC infrastructure has real hosting costs. D046 formalizes the backend monetization model:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Revenue Source</th><th>Description</th><th>D035 Alignment</th></tr>
</thead>
<tbody>
<tr><td><strong>Community donations</strong></td><td>Open Collective, GitHub Sponsors — existing model</td><td>✓ unchanged</td></tr>
<tr><td><strong>Premium relay tier</strong></td><td>Optional paid tier: priority queue, larger replay archive, custom clan pages</td><td>✓ D035</td></tr>
<tr><td><strong>Verified publisher fees</strong></td><td>Publishers pay a listing fee + revenue share for premium Workshop content</td><td>NEW — extends D035</td></tr>
<tr><td><strong>Sponsored featured slots</strong></td><td>Workshop featured section for promoted resources</td><td>✓ D035</td></tr>
<tr><td><strong>Platform store revenue share</strong></td><td>Steam/GOG/Epic take their standard cut on premium purchases made through their stores</td><td>NEW — platform standard</td></tr>
</tbody>
</table>
</div>
<p><strong>Free tier is always fully functional.</strong> Premium content is cosmetic/supplementary. Backend monetization sustainably funds relay servers, tracking servers, and Workshop infrastructure without gating gameplay.</p>
<h3 id="relationship-to-existing-decisions-5"><a class="header" href="#relationship-to-existing-decisions-5">Relationship to Existing Decisions</a></h3>
<ul>
<li><strong>D030 (Workshop):</strong> D046 extends D030’s schema with <code>pricing.model: premium</code> and <code>publisher.verified: true</code>. The Workshop architecture (federated, multi-source) supports premium content as another resource type.</li>
<li><strong>D035 (Creator recognition):</strong> D046 does NOT replace tipping. Individual modders use tips (D035). Verified publishers use premium pricing (D046). Both coexist — a modder can publish free mods with tip links AND work for a publisher that sells premium packs.</li>
<li><strong>D036 (Achievements):</strong> D046 formalizes the multi-platform achievement sync that D036 mentioned briefly (“Steam achievements sync for Steam builds”).</li>
<li><strong>D037 (Governance):</strong> Premium content moderation, verified publisher approval, and revenue-related disputes fall under community governance (D037).</li>
</ul>
<h3 id="alternatives-considered-6"><a class="header" href="#alternatives-considered-6">Alternatives Considered</a></h3>
<ul>
<li>No premium content ever (rejected — leaves money on the table for both the project and legitimate IP holders like EA; the Remastered art pack use case is too valuable)</li>
<li>Open marketplace for all creators (rejected — Skyrim paid mods disaster; tips-only for individual creators, premium only for verified publishers)</li>
<li>Platform-exclusive content (rejected — violates cross-platform play principle)</li>
<li>IC processes all payments directly (rejected — regulatory burden, payment processing complexity; delegate to platform stores and existing payment processors)</li>
</ul>
<hr>
<h2 id="d047-llm-configuration-manager--provider-management--community-sharing"><a class="header" href="#d047-llm-configuration-manager--provider-management--community-sharing">D047: LLM Configuration Manager — Provider Management &amp; Community Sharing</a></h2>
<p><strong>Status:</strong> Accepted
<strong>Scope:</strong> <code>ic-ui</code>, <code>ic-llm</code>, <code>ic-game</code>
<strong>Phase:</strong> Phase 7 (ships with LLM features)</p>
<h3 id="the-problem-4"><a class="header" href="#the-problem-4">The Problem</a></h3>
<p>D016 established the BYOLLM architecture: users configure an <code>LlmProvider</code> (endpoint, API key, model name) in settings. But as LLM features expand across the engine — mission generation (D016), coaching (D042), AI orchestrator (D044), asset generation (D040) — managing provider configurations becomes non-trivial. Users may want:</p>
<ul>
<li>Multiple providers configured simultaneously (local Ollama for AI orchestrator speed, cloud API for high-quality mission generation)</li>
<li>Task-specific routing (use a cheap model for real-time AI, expensive model for campaign generation)</li>
<li>Sharing working configurations with the community (without sharing API keys)</li>
<li>Discovering which models work well for which IC features</li>
<li>An achievement for configuring and using LLM features (engagement incentive)</li>
</ul>
<h3 id="decision-4"><a class="header" href="#decision-4">Decision</a></h3>
<p>Provide a dedicated <strong>LLM Manager</strong> UI screen and a community-shareable configuration format for LLM provider setups.</p>
<h3 id="llm-manager-ui"><a class="header" href="#llm-manager-ui">LLM Manager UI</a></h3>
<p>Accessible from Settings → LLM Providers:</p>
<pre><code>┌─────────────────────────────────────────────────────────┐
│  LLM Providers                                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  [+] Add Provider                                       │
│                                                         │
│  ┌─ Local Ollama (llama3.2) ──────── ✓ Active ───────┐ │
│  │  Endpoint: http://localhost:11434                   │ │
│  │  Model: llama3.2:8b                                │ │
│  │  Assigned to: AI Orchestrator, Quick coaching       │ │
│  │  Avg latency: 340ms  │  Status: ● Connected        │ │
│  │  [Test] [Edit] [Remove]                            │ │
│  └────────────────────────────────────────────────────┘ │
│                                                         │
│  ┌─ OpenAI API (GPT-4o) ───────── ✓ Active ──────────┐ │
│  │  Endpoint: https://api.openai.com/v1               │ │
│  │  Model: gpt-4o                                     │ │
│  │  Assigned to: Mission generation, Campaign briefings│ │
│  │  Avg latency: 1.2s   │  Status: ● Connected        │ │
│  │  [Test] [Edit] [Remove]                            │ │
│  └────────────────────────────────────────────────────┘ │
│                                                         │
│  ┌─ Anthropic API (Claude) ────── ○ Inactive ─────────┐ │
│  │  Endpoint: https://api.anthropic.com/v1            │ │
│  │  Model: claude-sonnet-4-20250514                          │ │
│  │  Assigned to: (none)                               │ │
│  │  [Test] [Edit] [Remove] [Activate]                 │ │
│  └────────────────────────────────────────────────────┘ │
│                                                         │
│  Task Routing:                                          │
│  ┌──────────────────────┬──────────────────────────┐    │
│  │ Task                 │ Provider                 │    │
│  ├──────────────────────┼──────────────────────────┤    │
│  │ AI Orchestrator      │ Local Ollama (fast)      │    │
│  │ Mission Generation   │ OpenAI API (quality)     │    │
│  │ Campaign Briefings   │ OpenAI API (quality)     │    │
│  │ Post-Match Coaching  │ Local Ollama (fast)      │    │
│  │ Asset Generation     │ OpenAI API (quality)     │    │
│  └──────────────────────┴──────────────────────────┘    │
│                                                         │
│  [Export Config] [Import Config] [Browse Community]      │
└─────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="community-shareable-configurations"><a class="header" href="#community-shareable-configurations">Community-Shareable Configurations</a></h3>
<p>LLM configurations can be exported (without API keys) and shared via the Workshop (D030):</p>
<pre><code class="language-yaml"># Exported LLM configuration (shareable)
llm_config:
  name: "Budget-Friendly RA Setup"
  author: "PlayerName"
  description: "Ollama for real-time features, free API tier for generation"
  version: 1
  providers:
    - name: "Local Ollama"
      type: ollama
      endpoint: "http://localhost:11434"
      model: "llama3.2:8b"
      # NO api_key — never exported
    - name: "Cloud Provider"
      type: openai-compatible
      # endpoint intentionally omitted — user fills in their own
      model: "gpt-4o-mini"
      notes: "Works well with OpenAI or any compatible API"
  routing:
    ai_orchestrator: "Local Ollama"
    mission_generation: "Cloud Provider"
    coaching: "Local Ollama"
    campaign_briefings: "Cloud Provider"
    asset_generation: "Cloud Provider"
  performance_notes: |
    Tested on RTX 3060 + Ryzen 5600X.
    Ollama latency ~300ms for orchestrator (acceptable).
    GPT-4o-mini at ~$0.02 per mission generation.
  compatibility:
    ic_version: "&gt;=0.5.0"
    tested_models:
      - "llama3.2:8b"
      - "mistral:7b"
      - "gpt-4o-mini"
      - "gpt-4o"
</code></pre>
<p><strong>Security:</strong> API keys are <strong>never</strong> included in exported configurations. The export contains provider types, model names, and routing — the user fills in their own credentials after importing.</p>
<h3 id="workshop-integration"><a class="header" href="#workshop-integration">Workshop Integration</a></h3>
<p>LLM configurations are a Workshop resource type (D030):</p>
<ul>
<li><strong>Category:</strong> “LLM Configurations” in the Workshop browser</li>
<li><strong>Ratings and reviews:</strong> Community rates configurations by reliability, cost, quality</li>
<li><strong>Tagging:</strong> <code>budget</code>, <code>high-quality</code>, <code>local-only</code>, <code>fast</code>, <code>creative</code>, <code>coaching</code></li>
<li><strong>Compatibility tracking:</strong> Configurations specify which IC version and features they’ve been tested with</li>
</ul>
<h3 id="achievement-integration-d036"><a class="header" href="#achievement-integration-d036">Achievement Integration (D036)</a></h3>
<p>LLM configuration is an achievement milestone — encouraging discovery and adoption:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Achievement</th><th>Trigger</th><th>Category</th></tr>
</thead>
<tbody>
<tr><td>“Intelligence Officer”</td><td>Configure your first LLM provider</td><td>Community</td></tr>
<tr><td>“Strategic Command”</td><td>Win a game with LLM Orchestrator AI active</td><td>Exploration</td></tr>
<tr><td>“Artificial Intelligence”</td><td>Play 10 games with any LLM-enhanced AI mode</td><td>Exploration</td></tr>
<tr><td>“The Sharing Protocol”</td><td>Publish an LLM configuration to the Workshop</td><td>Community</td></tr>
<tr><td>“Commanding General”</td><td>Use task routing with 2+ providers simultaneously</td><td>Exploration</td></tr>
</tbody>
</table>
</div>
<h3 id="storage-d034"><a class="header" href="#storage-d034">Storage (D034)</a></h3>
<pre><code class="language-sql">CREATE TABLE llm_providers (
    id          INTEGER PRIMARY KEY,
    name        TEXT NOT NULL,
    type        TEXT NOT NULL,           -- 'ollama', 'openai', 'anthropic', 'custom'
    endpoint    TEXT,
    model       TEXT NOT NULL,
    api_key     TEXT,                    -- encrypted at rest
    is_active   INTEGER NOT NULL DEFAULT 1,
    created_at  TEXT NOT NULL,
    last_tested TEXT
);

CREATE TABLE llm_task_routing (
    task_name   TEXT PRIMARY KEY,        -- 'ai_orchestrator', 'mission_generation', etc.
    provider_id INTEGER REFERENCES llm_providers(id)
);
</code></pre>
<h3 id="relationship-to-existing-decisions-6"><a class="header" href="#relationship-to-existing-decisions-6">Relationship to Existing Decisions</a></h3>
<ul>
<li><strong>D016 (BYOLLM):</strong> D047 is the UI and management layer for D016’s <code>LlmProvider</code> trait. D016 defined the trait and provider types; D047 provides the user experience for configuring them.</li>
<li><strong>D036 (Achievements):</strong> LLM-related achievements encourage exploration of optional features without making them required.</li>
<li><strong>D030 (Workshop):</strong> LLM configurations become another shareable resource type.</li>
<li><strong>D034 (SQLite):</strong> Provider configurations stored locally, encrypted API keys.</li>
<li><strong>D044 (LLM AI):</strong> The task routing table directly determines which provider the orchestrator and LLM player use.</li>
</ul>
<h3 id="alternatives-considered-7"><a class="header" href="#alternatives-considered-7">Alternatives Considered</a></h3>
<ul>
<li>Settings-only configuration, no dedicated UI (rejected — multiple providers with task routing is too complex for a settings page)</li>
<li>No community sharing (rejected — LLM configuration is a significant friction point; community knowledge sharing reduces the barrier)</li>
<li>Include API keys in exports (rejected — obvious security risk; never export secrets)</li>
<li>Centralized LLM service run by IC project (rejected — conflicts with BYOLLM principle; users control their own data and costs)</li>
</ul>
<hr>
<h2 id="d048-switchable-render-modes--classic-hd-and-3d-in-one-game"><a class="header" href="#d048-switchable-render-modes--classic-hd-and-3d-in-one-game">D048: Switchable Render Modes — Classic, HD, and 3D in One Game</a></h2>
<p><strong>Status:</strong> Accepted
<strong>Scope:</strong> <code>ic-render</code>, <code>ic-game</code>, <code>ic-ui</code>
<strong>Phase:</strong> Phase 2 (render mode infrastructure), Phase 3 (toggle UI), Phase 6a (3D mode mod support)</p>
<h3 id="the-problem-5"><a class="header" href="#the-problem-5">The Problem</a></h3>
<p>The C&amp;C Remastered Collection’s most iconic UX feature is pressing F1 to instantly toggle between classic 320×200 sprites and hand-painted HD art — mid-game, no loading screen. This isn’t just swapping sprites. It’s switching the <em>entire visual presentation</em>: sprite resolution, palette handling, terrain tiles, shadow rendering, UI chrome, and scaling behavior. The engine already has pieces to support this (resource packs in <code>04-MODDING.md</code>, dual asset rendering in D029, <code>Renderable</code> trait, <code>ScreenToWorld</code> trait, 3D render mods in <code>02-ARCHITECTURE.md</code>), but they exist as independent systems with no unified mechanism for “switch everything at once.” Furthermore, the current design treats 3D rendering exclusively as a Tier 3 WASM mod that <strong>replaces</strong> the default renderer — there’s no concept of a game or mod that ships <em>both</em> 2D and 3D views and lets the player toggle between them.</p>
<h3 id="decision-5"><a class="header" href="#decision-5">Decision</a></h3>
<p>Introduce <strong>render modes</strong> as a first-class engine concept. A render mode bundles a rendering backend, camera system, resource pack selection, and visual configuration into a named, instantly-switchable unit. Game modules and mods can register multiple render modes; the player toggles between them with a keybind or settings menu.</p>
<h3 id="what-a-render-mode-is"><a class="header" href="#what-a-render-mode-is">What a Render Mode Is</a></h3>
<p>A render mode composes four concerns that must change together:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>What Changes</th><th>Trait / System</th></tr>
</thead>
<tbody>
<tr><td><strong>Render backend</strong></td><td>Sprite renderer vs. mesh renderer vs. voxel renderer</td><td><code>Renderable</code> impl</td></tr>
<tr><td><strong>Camera</strong></td><td>Isometric orthographic vs. free 3D perspective</td><td><code>ScreenToWorld</code> impl</td></tr>
<tr><td><strong>Resource packs</strong></td><td>Which asset set to use (classic <code>.shp</code>, HD sprites, GLTF models)</td><td>Resource pack selection</td></tr>
<tr><td><strong>Visual config</strong></td><td>Scaling mode, palette handling, shadow style, post-FX preset</td><td><code>RenderSettings</code> subset</td></tr>
</tbody>
</table>
</div>
<p>A render mode is NOT a game module. The simulation, pathfinding, networking, balance, and game rules are completely unchanged between modes. Two players in the same multiplayer game can use different render modes — the sim is view-agnostic (this is already an established architectural property).</p>
<h3 id="render-mode-registration"><a class="header" href="#render-mode-registration">Render Mode Registration</a></h3>
<p>Game modules register their supported render modes via the <code>GameModule</code> trait:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RenderMode {
    pub id: String,                        // "classic", "hd", "3d"
    pub display_name: String,              // "Classic (320×200)", "HD Sprites", "3D View"
    pub render_backend: RenderBackendId,   // Which Renderable impl to use
    pub camera: CameraMode,                // Isometric, Perspective, FreeRotate
    pub resource_pack_overrides: Vec&lt;ResourcePackRef&gt;, // Per-category pack selections
    pub visual_config: VisualConfig,       // Scaling, palette, shadow, post-FX
    pub keybind: Option&lt;KeyCode&gt;,          // Optional dedicated toggle key
}

pub struct VisualConfig {
    pub scaling: ScalingMode,              // IntegerNearest, Bilinear, Native
    pub palette_mode: PaletteMode,         // IndexedPalette, DirectColor
    pub shadow_style: ShadowStyle,         // SpriteShadow, ProjectedShadow, None
    pub post_fx: PostFxPreset,             // None, Classic, Enhanced
}
<span class="boring">}</span></code></pre>
<p>The RA1 game module would register:</p>
<pre><code class="language-yaml">render_modes:
  classic:
    display_name: "Classic"
    render_backend: sprite
    camera: isometric
    resource_packs:
      sprites: classic-shp
      terrain: classic-tiles
    visual_config:
      scaling: integer_nearest
      palette_mode: indexed
      shadow_style: sprite_shadow
      post_fx: none
    description: "Original 320×200 pixel art, integer-scaled"

  hd:
    display_name: "HD"
    render_backend: sprite
    camera: isometric
    resource_packs:
      sprites: hd-sprites         # Requires HD sprite resource pack
      terrain: hd-terrain
    visual_config:
      scaling: native
      palette_mode: direct_color
      shadow_style: sprite_shadow
      post_fx: enhanced
    description: "High-definition sprites at native resolution"
</code></pre>
<p>A 3D render mod adds a third mode:</p>
<pre><code class="language-yaml"># 3d_mod/render_modes.yaml (extends base game module)
render_modes:
  3d:
    display_name: "3D View"
    render_backend: mesh            # Provided by the WASM mod
    camera: free_rotate
    resource_packs:
      sprites: 3d-models           # GLTF meshes mapped to unit types
      terrain: 3d-terrain
    visual_config:
      scaling: native
      palette_mode: direct_color
      shadow_style: projected_shadow
      post_fx: enhanced
    description: "Full 3D rendering with free camera"
    requires_mod: "3d-ra"          # Only available when this mod is loaded
</code></pre>
<h3 id="toggle-mechanism"><a class="header" href="#toggle-mechanism">Toggle Mechanism</a></h3>
<p><strong>Default keybind:</strong> F1 cycles through available render modes (matching the Remastered Collection). A game with only <code>classic</code> and <code>hd</code> modes: F1 toggles between them. A game with three modes: F1 cycles classic → hd → 3d → classic. The cycle order matches the <code>render_modes</code> declaration order.</p>
<p><strong>Settings UI:</strong></p>
<pre><code>Settings → Graphics → Render Mode
┌───────────────────────────────────────────────┐
│ Active Render Mode:  [HD ▾]                   │
│                                               │
│ Toggle Key: [F1]                              │
│ Cycle Order: Classic → HD → 3D                │
│                                               │
│ Available Modes:                              │
│ ● Classic — Original pixel art, integer-scaled│
│ ● HD — High-definition sprites (requires      │
│         HD sprite pack)                       │
│ ○ 3D View — Full 3D (requires 3D RA mod)     │
│              [Not installed — Browse Workshop] │
└───────────────────────────────────────────────┘
</code></pre>
<p>Modes whose required resource packs or mods aren’t installed appear grayed out with an install/browse link.</p>
<h3 id="how-the-switch-works-runtime"><a class="header" href="#how-the-switch-works-runtime">How the Switch Works (Runtime)</a></h3>
<p>The toggle is instant — no loading screen, no fade-to-black for same-backend switches:</p>
<ol>
<li>
<p><strong>Same render backend</strong> (classic ↔ hd): Swap <code>Handle</code> references on all <code>Renderable</code> components. Both asset sets are loaded at startup (or on first toggle). Bevy’s asset system makes this a single-frame operation — exactly like the Remastered Collection’s F1.</p>
</li>
<li>
<p><strong>Different render backend</strong> (2D ↔ 3D): Swap the active <code>Renderable</code> implementation and camera. This is heavier — the first switch loads the 3D asset set (brief loading indicator). Subsequent switches are instant because both backends stay resident. Camera interpolates smoothly between isometric and perspective over ~0.3 seconds.</p>
</li>
<li>
<p><strong>Multiplayer</strong>: Render mode is a client-only setting. The sim doesn’t know or care. No sync, no lobby lock. One player on Classic, one on HD, one on 3D — all in the same game. This already works architecturally; D048 just formalizes it.</p>
</li>
<li>
<p><strong>Replays</strong>: Render mode is switchable during replay playback. Watch a classic-era replay in 3D, or vice versa.</p>
</li>
</ol>
<h3 id="cross-view-multiplayer"><a class="header" href="#cross-view-multiplayer">Cross-View Multiplayer</a></h3>
<p>This deserves emphasis because it’s a feature no shipped C&amp;C game has offered: <strong>players using different visual presentations in the same multiplayer match.</strong> The sim/render split (Invariant #1, #9) makes this free. A competitive player who prefers classic pixel clarity plays against someone using 3D — same rules, same sim, same balance, different eyes.</p>
<p>Cross-view also means <strong>cross-view spectating</strong>: an observer can watch a tournament match in 3D while the players compete in classic 2D. This creates unique content creation and broadcasting opportunities.</p>
<h3 id="relationship-to-existing-systems"><a class="header" href="#relationship-to-existing-systems">Relationship to Existing Systems</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>System</th><th>Before D048</th><th>After D048</th></tr>
</thead>
<tbody>
<tr><td><strong>Resource Packs</strong></td><td>Per-category asset selection in Settings</td><td>Resource packs become a <em>component</em> of render modes; the mode auto-selects the right packs</td></tr>
<tr><td><strong>D029 Dual Asset</strong></td><td>Dual asset handles per entity</td><td>Generalized to N render modes, not just two. D029’s mechanism is how same-backend switches work</td></tr>
<tr><td><strong>3D Render Mods</strong></td><td>Tier 3 WASM mod that <em>replaces</em> the default renderer</td><td>Tier 3 WASM mod that <em>adds</em> a render mode alongside the default — toggleable, not a replacement</td></tr>
<tr><td><strong>D032 UI Themes</strong></td><td>Switchable UI chrome</td><td>UI theme can optionally be paired with a render mode (classic mode + classic chrome)</td></tr>
<tr><td><strong>Render Quality Tiers</strong></td><td>Hardware-adaptive Baseline → Ultra</td><td>Tiers apply <em>within</em> a render mode. Classic mode on Tier 0 hardware; 3D mode requires Tier 2 minimum</td></tr>
<tr><td><strong>Experience Profiles</strong></td><td>Balance + theme + QoL + AI + pathfinding</td><td>Now also include a default render mode</td></tr>
</tbody>
</table>
</div>
<h3 id="what-mod-authors-need-to-do"><a class="header" href="#what-mod-authors-need-to-do">What Mod Authors Need to Do</a></h3>
<p><strong>For a sprite HD pack</strong> (most common case): Nothing new. Publish a resource pack with HD sprites. The game module’s <code>hd</code> render mode references it. The player installs it and F1 toggles.</p>
<p><strong>For a 3D rendering mod</strong> (Tier 3): Ship a WASM mod that provides a <code>Renderable</code> impl (mesh renderer) and a <code>ScreenToWorld</code> impl (3D camera). Declare a render mode in YAML that references these implementations and the 3D asset resource packs. The engine registers the mode alongside the built-in modes — F1 now cycles through all three.</p>
<p><strong>For a complete 3D game module</strong> (e.g., Generals clone): The game module can register only 3D render modes — no classic 2D at all. Or it can ship both. The architecture supports any combination.</p>
<h3 id="minimum-viable-scope"><a class="header" href="#minimum-viable-scope">Minimum Viable Scope</a></h3>
<p>Phase 2 delivers the infrastructure — render mode registration, asset handle swapping, the <code>RenderMode</code> struct. The HD/SD toggle (classic ↔ hd) works. Phase 3 adds the settings UI and keybind. Phase 6a supports mod-provided render modes (3D). The architecture supports all of this from day one; the phases gate what’s <em>tested and polished.</em></p>
<h3 id="alternatives-considered-8"><a class="header" href="#alternatives-considered-8">Alternatives Considered</a></h3>
<ol>
<li><strong>Resource packs only, no render mode concept</strong> — Rejected. Switching from 2D to 3D requires changing the render backend and camera, not just assets. Resource packs can’t do that.</li>
<li><strong>3D as a separate game module</strong> — Rejected. A “3D RA1” game module would duplicate all the rules, balance, and systems from the base RA1 module. The whole point is that the sim is unchanged.</li>
<li><strong>No 2D↔3D toggle; 3D replaces 2D permanently when mod is active</strong> — Rejected. The Remastered Collection proved that <em>toggling</em> is the feature, not just having two visual options. Players love comparing. Content creators use it for dramatic effect. It’s also a safety net — if the 3D mod has rendering bugs, you can toggle back.</li>
</ol>
<hr>
<h2 id="d049-workshop-asset-formats--distribution--bevy-native-canonical-p2p-delivery"><a class="header" href="#d049-workshop-asset-formats--distribution--bevy-native-canonical-p2p-delivery">D049: Workshop Asset Formats &amp; Distribution — Bevy-Native Canonical, P2P Delivery</a></h2>
<p><strong>Decision:</strong> The Workshop’s canonical asset formats are <strong>Bevy-native modern formats</strong> (OGG, PNG, WAV, WebM, KTX2, GLTF). C&amp;C legacy formats (.aud, .shp, .pal, .vqa, .mix) are fully supported for backward compatibility but are not the recommended distribution format for new content. Workshop delivery uses <strong>peer-to-peer distribution</strong> (BitTorrent/WebTorrent protocol) with HTTP fallback, reducing hosting costs from CDN-level to a lightweight tracker.</p>
<blockquote>
<p><strong>Note (D050):</strong> The format recommendations in this section are <strong>IC-specific</strong> — they reflect Bevy’s built-in asset pipeline. The Workshop’s P2P distribution protocol and package format are engine-agnostic (see D050). Future projects consuming the Workshop core library will define their own format recommendations based on their engine’s capabilities. The <code>.icpkg</code> extension, <code>ic mod</code> CLI commands, and <code>game_module</code> manifest fields are likewise IC-specific — the Workshop core library uses configurable equivalents.</p>
</blockquote>
<h3 id="the-format-problem"><a class="header" href="#the-format-problem">The Format Problem</a></h3>
<p>The engine serves two audiences with conflicting format needs:</p>
<ol>
<li><strong>Legacy community:</strong> Thousands of existing .shp, .aud, .mix, .pal assets. OpenRA mods. Original game files. These must load.</li>
<li><strong>New content creators:</strong> Making sprites in Aseprite/Photoshop, recording audio in Audacity/Reaper, editing video in DaVinci Resolve. These tools export PNG, OGG, WAV, WebM — not .shp or .aud.</li>
</ol>
<p>Forcing new creators to encode into C&amp;C formats creates unnecessary friction. Forcing legacy content through format converters before it can load breaks the “community’s existing work is sacred” invariant. The answer is: <strong>accept both, recommend modern.</strong></p>
<h3 id="canonical-format-recommendations"><a class="header" href="#canonical-format-recommendations">Canonical Format Recommendations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Asset Type</th><th>Workshop Format (new content)</th><th>Legacy Support (existing)</th><th>Runtime Decode</th><th>Rationale</th></tr>
</thead>
<tbody>
<tr><td><strong>Music</strong></td><td>OGG Vorbis (128–320kbps)</td><td>.aud (ra-formats decode)</td><td>PCM via rodio</td><td>Bevy default feature, excellent quality/size ratio, open/patent-free, WASM-safe. OGG at 192kbps ≈ 1.4MB/min vs .aud at ~0.5MB/min but dramatically higher quality (stereo, 44.1kHz vs mono 22kHz)</td></tr>
<tr><td><strong>SFX</strong></td><td>WAV (16-bit PCM) or OGG</td><td>.aud (ra-formats decode)</td><td>PCM via rodio</td><td>WAV = zero decode latency for gameplay-critical sounds (weapon fire, explosions). OGG for larger ambient/UI sounds where decode latency is acceptable</td></tr>
<tr><td><strong>Voice</strong></td><td>OGG Vorbis (96–128kbps)</td><td>.aud (ra-formats decode)</td><td>PCM via rodio</td><td>Speech compresses well. OGG at 96kbps is transparent for voice. EVA packs with 200+ lines stay under 30MB</td></tr>
<tr><td><strong>Sprites</strong></td><td>PNG (RGBA, indexed, or truecolor)</td><td>.shp+.pal (ra-formats)</td><td>GPU texture via Bevy</td><td>Bevy-native via <code>image</code> crate. Lossless. Every art tool exports it. Palette-indexed PNG preserves classic aesthetic. HD packs use truecolor RGBA</td></tr>
<tr><td><strong>HD Textures</strong></td><td>KTX2 (GPU-compressed: BC7/ASTC)</td><td>N/A</td><td>Zero-cost GPU upload</td><td>Bevy-native. No decode — GPU reads directly. Best runtime performance. <code>ic mod build</code> can batch-convert PNG→KTX2 for release builds</td></tr>
<tr><td><strong>Terrain</strong></td><td>PNG tiles (indexed or RGBA)</td><td>.tmp+.pal (ra-formats)</td><td>GPU texture</td><td>Same as sprites. Theater tilesets are sprite sheets</td></tr>
<tr><td><strong>Cutscenes</strong></td><td>WebM (VP9, 720p–1080p)</td><td>.vqa (ra-formats decode)</td><td>Frame→texture (custom)</td><td>Open, royalty-free, browser-compatible (WASM target). VP9 achieves ~5MB/min at 720p. Neither WebM nor VQA is Bevy-native — both need custom decode, so no advantage to VQA here</td></tr>
<tr><td><strong>3D Models</strong></td><td>GLTF/GLB</td><td>N/A (future: .vxl)</td><td>Bevy mesh</td><td>Bevy’s native 3D format. Community 3D mods (D048) use this</td></tr>
<tr><td><strong>Palettes</strong></td><td>.pal (768 bytes) or PNG strip</td><td>.pal (ra-formats)</td><td>Palette texture</td><td>.pal is already tiny and universal in the C&amp;C community. No reason to change. PNG strip is an alternative for tools that don’t understand .pal</td></tr>
<tr><td><strong>Maps</strong></td><td>IC YAML (native)</td><td>.oramap (ZIP+MiniYAML)</td><td>ECS world state</td><td>Already designed (D025, D026)</td></tr>
</tbody>
</table>
</div>
<h3 id="why-modern-formats-as-default"><a class="header" href="#why-modern-formats-as-default">Why Modern Formats as Default</a></h3>
<p><strong>Bevy integration:</strong> OGG, WAV, PNG, KTX2, and GLTF load through Bevy’s built-in asset pipeline with zero custom code. Every Bevy feature — hot-reload, asset dependencies, async loading, platform abstraction — works automatically. C&amp;C formats require custom <code>AssetLoader</code> implementations in ra-formats with manual integration into Bevy’s pipeline.</p>
<p><strong>Security:</strong> OGG (lewton/rodio), PNG (image crate), and WebM decoders in the Rust ecosystem have been fuzz-tested and used in production by thousands of projects. Browser vendors (Chrome, Firefox, Safari) have security-audited these formats for decades. Our .aud/.shp/.vqa parsers in ra-formats are custom code that has never been independently security-audited. For Workshop content downloaded from untrusted sources, mature parsers with established security track records are strictly safer. C&amp;C format parsers use <code>BoundedReader</code> (see <code>06-SECURITY.md</code>), but defense in depth favors formats with deeper audit history.</p>
<p><strong>Multi-game:</strong> Non-C&amp;C game modules (D039) won’t use .shp or .aud at all. A tower defense mod, a naval RTS, a Dune-inspired game — these ship PNG sprites and OGG audio. The Workshop serves all game modules, not just the C&amp;C family.</p>
<p><strong>Tooling:</strong> Every image editor saves PNG. Every DAW exports WAV/OGG. Every video editor exports WebM/MP4. Nobody’s toolchain outputs .aud or .shp. Requiring C&amp;C formats forces creators through a conversion step before they can publish — unnecessary friction.</p>
<p><strong>WASM/browser:</strong> OGG and PNG work in Bevy’s WASM builds out of the box. C&amp;C formats need custom WASM decoders compiled into the browser bundle.</p>
<p><strong>Storage efficiency comparison:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Content</th><th>C&amp;C Format</th><th>Modern Format</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>3min music track</td><td>.aud: ~1.5MB (22kHz mono ADPCM)</td><td>OGG: ~2.8MB (44.1kHz stereo 128kbps)</td><td>OGG is 2× larger but dramatically higher quality. At mono 22kHz OGG: ~0.7MB</td></tr>
<tr><td>Full soundtrack (30 tracks)</td><td>.aud: ~45MB</td><td>OGG 128kbps: ~84MB</td><td>Acceptable for modern bandwidth/storage</td></tr>
<tr><td>Unit sprite sheet (200 frames)</td><td>.shp+.pal: ~50KB</td><td>PNG indexed: ~80KB</td><td>PNG slightly larger but universal tooling</td></tr>
<tr><td>HD sprite sheet (200 frames)</td><td>N/A (.shp can’t do HD)</td><td>PNG RGBA: ~500KB</td><td>Only modern format option for HD content</td></tr>
<tr><td>3min cutscene (720p)</td><td>.vqa: ~15MB</td><td>WebM VP9: ~15MB</td><td>Comparable. WebM quality is higher at same bitrate</td></tr>
</tbody>
</table>
</div>
<p>Modern formats are somewhat larger for legacy-quality content but the difference is small relative to modern storage and bandwidth. For HD content, modern formats are the only option.</p>
<h3 id="the-conversion-escape-hatch"><a class="header" href="#the-conversion-escape-hatch">The Conversion Escape Hatch</a></h3>
<p>The Asset Studio (D040) converts in both directions:</p>
<ul>
<li><strong>Import:</strong> .aud/.shp/.vqa/.pal → OGG/PNG/WebM/.pal (for modders working with legacy assets)</li>
<li><strong>Export:</strong> OGG/PNG/WebM → .aud/.shp/.vqa (for modders targeting OpenRA compatibility or classic aesthetic)</li>
<li><strong>Batch convert:</strong> <code>ic mod convert --to-modern</code> or <code>ic mod convert --to-classic</code> converts entire mod directories</li>
</ul>
<p>The engine loads both format families at runtime. <code>ra-formats</code> decoders handle legacy formats; Bevy’s built-in loaders handle modern formats. No manual conversion is ever required — only recommended for new Workshop publications.</p>
<h3 id="workshop-package-format-icpkg"><a class="header" href="#workshop-package-format-icpkg">Workshop Package Format (.icpkg)</a></h3>
<p>Workshop packages are <strong>ZIP archives</strong> with a standardized manifest — the same pattern as <code>.oramap</code> but generalized to any resource type:</p>
<pre><code>my-hd-sprites-1.2.0.icpkg          # ZIP archive
├── manifest.yaml                    # Package metadata (required)
├── README.md                        # Long description (optional)
├── CHANGELOG.md                     # Version history (optional)
├── preview.png                      # Thumbnail, max 512×512 (required for Workshop listing)
└── assets/                          # Actual content files
    ├── sprites/
    │   ├── infantry-allied.png
    │   └── vehicles-soviet.png
    └── palettes/
        └── temperate-hd.pal
</code></pre>
<p><strong>manifest.yaml:</strong></p>
<pre><code class="language-yaml">package:
  name: "hd-allied-sprites"
  publisher: "community-hd-project"
  version: "1.2.0"
  license: "CC-BY-SA-4.0"
  description: "HD sprite replacements for Allied infantry and vehicles"
  category: sprites
  game_module: ra1
  engine_version: "^0.3.0"

  # Per-file integrity (verified on install)
  files:
    sprites/infantry-allied.png:
      sha256: "a1b2c3d4..."
      size: 524288
    sprites/vehicles-soviet.png:
      sha256: "e5f6a7b8..."
      size: 1048576

  dependencies:
    - id: "community-hd-project/base-palettes"
      version: "^1.0"

  # P2P distribution metadata (added by Workshop server on publish)
  distribution:
    sha256: "full-package-hash..."        # Hash of entire .icpkg
    size: 1572864                          # Total package size in bytes
    infohash: "btih:abc123def..."          # BitTorrent info hash (for P2P)
</code></pre>
<p>ZIP was chosen over tar.gz because: random access to individual files (no full decompression to read manifest.yaml), universal tooling, <code>.oramap</code> precedent, and Rust’s <code>zip</code> crate is mature.</p>
<h3 id="p2p-distribution-bittorrentwebtorrent"><a class="header" href="#p2p-distribution-bittorrentwebtorrent">P2P Distribution (BitTorrent/WebTorrent)</a></h3>
<p><strong>The cost problem:</strong> A popular 500MB mod downloaded 10,000 times generates 5TB of egress. At CDN rates ($0.01–0.09/GB), that’s $50–450/month — per mod. For a community project sustained by donations, centralized hosting is financially unsustainable at scale. A BitTorrent tracker VPS costs $5–20/month regardless of popularity.</p>
<p><strong>The solution:</strong> Workshop distribution uses the <strong>BitTorrent protocol</strong> for large packages, with HTTP direct download as fallback. The Workshop server acts as both metadata registry (SQLite, lightweight) and BitTorrent tracker (peer coordination, lightweight). Actual content transfer happens peer-to-peer between players who have the package.</p>
<p><strong>How it works:</strong></p>
<pre><code>┌─────────────┐     1. Search/browse     ┌──────────────────┐
│  ic CLI /    │ ───────────────────────► │  Workshop Server │
│  In-Game     │ ◄─────────────────────── │  (metadata +     │
│  Browser     │  2. manifest.yaml +      │   tracker)       │
│              │     torrent info         │                  │
│              │                          └──────────────────┘
│              │     3. P2P download
│              │ ◄──────────────────────► Other players (peers/seeds)
│              │     (BitTorrent protocol)
│              │
│              │     4. Fallback: HTTP direct download
│              │ ◄─────────────────────── Workshop server / mirrors / seed box
└─────────────┘     5. Verify SHA-256
</code></pre>
<ol>
<li><strong>Publish:</strong> <code>ic mod publish</code> uploads .icpkg to Workshop server. Server computes SHA-256, generates torrent metadata (info hash), starts seeding the package alongside any initial seed infrastructure.</li>
<li><strong>Browse/Search:</strong> Workshop server handles all metadata queries (search, dependency resolution, ratings) via the existing SQLite + FTS5 design. Lightweight.</li>
<li><strong>Install:</strong> <code>ic mod install</code> fetches the manifest from the server, then downloads the .icpkg via BitTorrent from other players who have it. Falls back to HTTP direct download if no peers are available or if P2P is too slow.</li>
<li><strong>Seed:</strong> Players who have downloaded a package automatically seed it to others (opt-out in settings). The more popular a resource, the faster it downloads — the opposite of CDN economics where popularity means higher cost.</li>
<li><strong>Verify:</strong> SHA-256 checksum validation on the complete package, regardless of download method. BitTorrent’s built-in piece-level hashing provides additional integrity during transfer.</li>
</ol>
<p><strong>WebTorrent for browser builds (WASM):</strong> Standard BitTorrent uses TCP/UDP, which browsers can’t access. <a href="https://webtorrent.io/">WebTorrent</a> extends the BitTorrent protocol over WebRTC, enabling browser-to-browser P2P. The Workshop server includes a WebTorrent tracker endpoint. Desktop clients and browser clients can interoperate — desktop seeds serve browser peers and vice versa through hybrid WebSocket/WebRTC bridges. <strong>HTTP fallback is mandatory:</strong> if WebTorrent signaling fails (signaling server down, WebRTC blocked), the client must fall back to direct HTTP download without user intervention. Multiple signaling servers are maintained for redundancy. Signaling servers only facilitate WebRTC negotiation — they never see package content, so even a compromised signaling server cannot serve tampered data (SHA-256 verification catches that).</p>
<p><strong>Tracker authentication &amp; token rotation:</strong> P2P tracker access uses per-session tokens tied to client authentication (Workshop credentials or anonymous session token), not static URL secrets. Tokens rotate every release cycle. Even unauthorized peers joining a swarm cannot serve corrupt data (SHA-256 + piece hashing), but token rotation limits unauthorized swarm observation and bandwidth waste. See <code>06-SECURITY.md</code> for the broader security model.</p>
<p><strong>Transport strategy by package size:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Package Size</th><th>Strategy</th><th>Rationale</th></tr>
</thead>
<tbody>
<tr><td>&lt; 5MB</td><td>HTTP direct only</td><td>P2P overhead exceeds benefit for small files. Maps, balance presets, palettes.</td></tr>
<tr><td>5–50MB</td><td>P2P preferred, HTTP fallback</td><td>Small sprite packs, sound effect packs, script libraries. P2P helps but HTTP is acceptable.</td></tr>
<tr><td>&gt; 50MB</td><td>P2P strongly preferred</td><td>HD resource packs, cutscene packs, full mods. P2P’s cost advantage is decisive.</td></tr>
</tbody>
</table>
</div>
<p>Thresholds are configurable in <code>settings.yaml</code>. Players on connections where BitTorrent is throttled or blocked can force HTTP-only mode.</p>
<p><strong>Auto-download on lobby join (D030 interaction):</strong> When joining a lobby with missing resources, the client first attempts P2P download (likely fast, since other players in the lobby are already seeding). If the lobby timer is short or P2P is slow, falls back to HTTP. The lobby UI shows download progress with source indicators (P2P/HTTP). See D052 § “In-Lobby P2P Resource Sharing” for the detailed lobby protocol, including host-as-tracker, verification against Workshop index, and security constraints.</p>
<p><strong>Gaming industry precedent:</strong></p>
<ul>
<li><strong>Blizzard (WoW, StarCraft 2, Diablo 3):</strong> Used a custom P2P downloader (“Blizzard Downloader”, later integrated into Battle.net) for game patches and updates from 2004–2016. Saved millions in CDN costs for multi-GB patches distributed to millions of players.</li>
<li><strong>Wargaming (World of Tanks):</strong> Used P2P distribution for game updates.</li>
<li><strong>Linux distributions:</strong> Ubuntu, Fedora, Arch all offer torrent downloads for ISOs — the standard solution for distributing large files from community infrastructure.</li>
<li><strong>Steam Workshop:</strong> Steam subsidizes centralized hosting from game sales revenue. We don’t have that luxury — P2P is the community-sustainable alternative.</li>
</ul>
<p><strong>Competitive landscape — game mod platforms:</strong></p>
<p>IC’s Workshop exists in a space with several established modding platforms. None offer the combination of P2P distribution, federation, self-hosting, and in-engine integration that IC targets.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Model</th><th>Scale</th><th>In-game integration</th><th>P2P</th><th>Federation / Self-host</th><th>Dependencies</th><th>Open source</th></tr>
</thead>
<tbody>
<tr><td><strong><a href="https://www.nexusmods.com">Nexus Mods</a></strong></td><td>Centralized web portal + Vortex mod manager. CDN distribution, throttled for free users. Revenue: premium membership + ads.</td><td>70.7M users, 4,297 games, 21B downloads. Largest modding platform.</td><td>None — external app (Vortex).</td><td>❌</td><td>❌</td><td>❌</td><td>Vortex client (GPL-3.0). Backend proprietary.</td></tr>
<tr><td><strong><a href="https://mod.io">mod.io</a></strong></td><td>UGC middleware — embeddable SDKs (Unreal/Unity/C++), REST API, white-label UI. Revenue: B2B SaaS (free tier + enterprise).</td><td>2.5B downloads, 38M MAU, 332 live games. Backed by Tencent ($26M Series A).</td><td>Yes — SDK provides in-game browsing, download, moderation. Console-certified (PS/Xbox/Switch).</td><td>❌</td><td>❌</td><td>partial</td><td>SDKs open (MIT/Apache). Backend/service proprietary.</td></tr>
<tr><td><strong><a href="https://modrinth.com">Modrinth</a></strong></td><td>Open-source mod registry. Centralized CDN. Revenue: ads + donations.</td><td>~100K projects, millions of monthly downloads. Growing fast.</td><td>Through third-party launchers (Prism, etc).</td><td>❌</td><td>❌</td><td>✅</td><td>Server (AGPL), API open.</td></tr>
<tr><td><strong><a href="https://www.curseforge.com">CurseForge</a></strong> (Overwolf)</td><td>Centralized mod registry + CurseForge app. Revenue: Overwolf overlay ads.</td><td>Dominant for Minecraft, WoW, other Blizzard games.</td><td>CurseForge app, some launcher integrations.</td><td>❌</td><td>❌</td><td>✅</td><td>❌</td></tr>
<tr><td><strong><a href="https://thunderstore.io">Thunderstore</a></strong></td><td>Open-source mod registry. Centralized CDN.</td><td>Popular for Risk of Rain 2, Lethal Company, Valheim.</td><td>Through r2modman manager.</td><td>❌</td><td>❌</td><td>✅</td><td>Server (AGPL-3.0).</td></tr>
<tr><td><strong>Steam Workshop</strong></td><td>Integrated into Steam. Free hosting (subsidized by game sales revenue).</td><td>Thousands of games, billions of downloads.</td><td>Deep Steam integration.</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><td><strong><a href="https://moddb.com">ModDB</a> / <a href="https://gamebanana.com">GameBanana</a></strong></td><td>Web portals — manual upload/download, community features, editorial content. Legacy platforms (2001–2002).</td><td>ModDB: 12.5K+ mods, 108M+ downloads. GameBanana: strong in Source Engine games.</td><td>None.</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td></tr>
</tbody>
</table>
</div>
<p><strong>Competitive landscape — P2P + Registry infrastructure:</strong></p>
<p>The game mod platforms above are all centralized. A separate set of projects tackle P2P distribution at the infrastructure level, but none target game modding specifically. See <code>research/p2p-federated-registry-analysis.md</code> for a comprehensive standalone analysis of this space and its applicability beyond IC.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Architecture</th><th>Domain</th><th>How it relates to IC Workshop</th></tr>
</thead>
<tbody>
<tr><td><strong><a href="https://github.com/uber/kraken">Uber Kraken</a></strong> (6.6k★)</td><td>P2P Docker registry — custom BitTorrent-like protocol, Agent/Origin/Tracker/Build-Index. Pluggable storage (S3/GCS/HDFS).</td><td>Container images (datacenter)</td><td>Closest architectural match. Kraken’s Agent/Origin/Tracker/Build-Index maps to IC’s Peer/Seed-box/Tracker/Workshop-Index. IC’s P2P protocol design (peer selection policy, piece request strategy, connection state machine, announce cycle, bandwidth limiting) is directly informed by Kraken’s production experience — see protocol details above and <code>research/p2p-federated-registry-analysis.md</code> § “Uber Kraken — Deep Dive” for the full analysis. Key difference: Kraken is intra-datacenter (3s announce, 10Gbps links), IC is internet-scale (30s announce, residential connections).</td></tr>
<tr><td><strong><a href="https://github.com/dragonflyoss/dragonfly">Dragonfly</a></strong> (3k★, CNCF Graduated)</td><td>P2P content distribution — Manager/Scheduler/Seed-Peer/Peer. Centralized evaluator-based scheduling with 4-dimensional peer scoring (<code>LoadQuality×0.6 + IDCAffinity×0.2 + LocationAffinity×0.1 + HostType×0.1</code>). DAG-based peer graph, back-to-source fallback. Persistent cache with replica management. Client rewritten in Rust (v2). Trail of Bits audited (2023).</td><td>Container images, AI models, artifacts</td><td>Same P2P-with-fallback pattern. Dragonfly’s hierarchical location affinity (<code>country|province|city|zone</code>), statistical bad-peer detection (three-sigma rule), capacity-aware scoring, persistent replica count, and download priority tiers are all patterns IC adapts. Key differences: Dragonfly uses centralized scheduling (IC uses BitTorrent swarm — simpler, more resilient to churn), Dragonfly is single-cluster with no cross-cluster P2P (IC is federated), Dragonfly requires K8s+Redis+MySQL (IC requires only SQLite). Dragonfly’s own RFC #3713 acknowledges piece-level selection is FCFS — BitTorrent’s rarest-first is already better. See <code>research/p2p-federated-registry-analysis.md</code> § “Dragonfly — CNCF P2P Distribution (Deep Dive)” for full analysis.</td></tr>
<tr><td><strong>JFrog Artifactory P2P</strong> (proprietary)</td><td>Enterprise P2P distribution — mesh of nodes sharing cached binary artifacts within corporate networks.</td><td>Enterprise build artifacts</td><td>The direct inspiration for IC’s repository model. JFrog added P2P because CDN costs for large binaries at scale are unsustainable — same motivation as IC.</td></tr>
<tr><td><strong>Blizzard NGDP/Agent</strong> (proprietary)</td><td>Custom P2P game patching — BitTorrent-based, CDN+P2P hybrid, integrated into Battle.net launcher.</td><td>Game patches (WoW, SC2, Diablo)</td><td>Closest gaming precedent. Proved P2P game content distribution works at massive scale. Proprietary, not a registry (no search/ratings/deps), not federated.</td></tr>
<tr><td><strong>Homebrew / crates.io-index</strong></td><td>Git-backed package indexes. CDN for actual downloads.</td><td>Software packages</td><td>IC’s Phase 0–3 git-index is directly inspired by these. No P2P distribution.</td></tr>
<tr><td><strong>IPFS</strong></td><td>Content-addressed P2P storage — any content gets a CID, any node can pin and serve it. DHT-based discovery. Bitswap protocol for block exchange with Decision Engine and Score Ledger.</td><td>General-purpose decentralized storage</td><td>Rejected as primary distribution protocol (too general, slow cold-content discovery, complex setup, poor game-quality UX). However, IPFS’s Bitswap protocol contributes significant patterns IC adopts: EWMA peer scoring with time-decaying reputation (Score Ledger), per-peer fairness caps (<code>MaxOutstandingBytesPerPeer</code>), want-have/want-block two-phase discovery, broadcast control (target proven-useful peers), dual WAN/LAN discovery (validates IC’s LAN party mode), delegated HTTP routing (validates IC’s registry-as-router), server/client mode separation, and batch provider announcements (Sweep Provider). IPFS’s 9-year-unresolved bandwidth limiting issue (#3065, 73 👍) proves bandwidth caps must ship day one. See <code>research/p2p-federated-registry-analysis.md</code> § “IPFS — Content-Addressed P2P Storage (Deep Dive)” for full analysis.</td></tr>
<tr><td><strong>Microsoft Delivery Optimization</strong></td><td>Windows Update P2P — peers on the same network share update packages.</td><td>OS updates</td><td>Proves P2P works for verified package distribution at billions-of-devices scale. Proprietary, no registry model.</td></tr>
</tbody>
</table>
</div>
<p><strong>What’s novel about IC’s combination:</strong> No existing system — modding platform or infrastructure — combines (1) federated registry with repository types, (2) P2P distribution via BitTorrent/WebTorrent, (3) zero-infrastructure git-hosted bootstrap, (4) browser-compatible P2P via WebTorrent, (5) in-engine integration with lobby auto-download, and (6) fully open-source with self-hosting as a first-class use case. The closest architectural comparison is mod.io (embeddable SDK approach, in-game integration) but mod.io is a proprietary centralized SaaS — no P2P, no federation, no self-hosting. The closest distribution comparison is Uber Kraken (P2P registry) but it has no modding features. Each piece has strong precedent; the combination is new. The Workshop architecture is game-agnostic and could serve as a standalone platform — see the research analysis for exploration of this possibility.</p>
<p><strong>Seeding infrastructure:</strong></p>
<p>The Workshop doesn’t rely solely on player altruism for seeding:</p>
<ul>
<li><strong>Workshop seed server:</strong> A dedicated seed box (modest: a VPS with good upload bandwidth) that permanently seeds all Workshop content. This ensures new/unpopular packages are always downloadable even with zero player peers. Cost: ~$20-50/month for a VPS with 1TB+ storage and unmetered bandwidth.</li>
<li><strong>Community seed volunteers:</strong> Players who opt in to extended seeding (beyond just while the game is running). Similar to how Linux mirror operators volunteer bandwidth. Could be incentivized with Workshop badges/reputation (D036/D037).</li>
<li><strong>Mirror servers (federation):</strong> Community-hosted Workshop servers (D030 federation) also seed the content they host. Regional community servers naturally become regional seeds.</li>
<li><strong>Lobby-optimized seeding:</strong> When a lobby host has required mods, the game client prioritizes seeding to joining players who are downloading. The “auto-download on lobby join” flow becomes: download from lobby peers first → swarm → HTTP fallback.</li>
</ul>
<p><strong>Privacy and security:</strong></p>
<ul>
<li><strong>IP visibility:</strong> Standard BitTorrent exposes peer IP addresses. This is the same exposure as any multiplayer game (players already see each other’s IPs or relay IPs). For privacy-sensitive users, HTTP-only mode avoids P2P IP exposure.</li>
<li><strong>Content integrity:</strong> SHA-256 verification on complete packages catches any tampering. BitTorrent’s piece-level hashing catches corruption during transfer. Double-verified.</li>
<li><strong>No metadata leakage:</strong> The tracker only knows which peers have which packages (by info hash). It doesn’t inspect content. Package contents are just game assets — sprites, audio, maps.</li>
<li><strong>ISP throttling mitigation:</strong> BitTorrent traffic can be throttled by ISPs. Mitigations: protocol encryption (standard in modern BT clients), WebSocket transport (looks like web traffic), and HTTP fallback as ultimate escape. Settings allow forcing HTTP-only mode.</li>
<li><strong>Resource exhaustion:</strong> Rate-limited seeding (configurable upload cap in settings). Players control how much bandwidth they donate. Default: 1MB/s upload, adjustable to 0 (leech-only, no seeding — discouraged but available).</li>
</ul>
<p><strong>P2P protocol design details:</strong></p>
<p>The Workshop’s P2P engine is informed by production experience from Uber Kraken (Apache 2.0, 6.6k★) and Dragonfly (Apache 2.0, CNCF Graduated). Kraken distributes 1M+ container images/day across 15K+ hosts using a custom BitTorrent-inspired protocol; Dragonfly uses centralized evaluator-based scheduling at Alibaba scale. IC adapts Kraken’s connection management and Dragonfly’s scoring insights for internet-scale game mod distribution. See <code>research/p2p-federated-registry-analysis.md</code> for full architectural analyses of both systems.</p>
<blockquote>
<p><strong>Cross-pollination with IC netcode and community infrastructure.</strong> The Workshop P2P engine and IC’s netcode infrastructure (relay server, tracking server — <code>03-NETCODE.md</code>) share deep structural parallels: federation, heartbeat/TTL, rate control, connection state machines, observability, deployment model. Patterns flow both directions — netcode’s three-layer rate control and token-based liveness improve Workshop; Workshop’s EWMA scoring and multi-dimensional peer evaluation improve relay server quality tracking. A full cross-pollination analysis (including shared infrastructure opportunities: unified server binary, federation library, auth/identity layer) is in <code>research/p2p-federated-registry-analysis.md</code> § “Netcode ↔ Workshop Cross-Pollination.” Additional cross-pollination with D052/D053 (community servers, player profiles, trust-based filtering) is catalogued in D052 § “Cross-Pollination” — highlights include: two-key architecture for index signing and publisher identity, trust-based source filtering, server-side validation as a shared invariant, and trust-verified peer selection scoring.</p>
</blockquote>
<p><em>Peer selection policy (tracker-side):</em> The tracker returns a sorted peer list on each announce response. The sorting policy is <strong>pluggable</strong> — inspired by Kraken’s <code>assignmentPolicy</code> interface pattern. IC’s default policy prioritizes:</p>
<ol>
<li><strong>Seeders</strong> (completed packages — highest priority, like Kraken’s <code>completeness</code> policy)</li>
<li><strong>Lobby peers</strong> (peers in the same multiplayer lobby — guaranteed to have the content, lowest latency)</li>
<li><strong>Geographically close peers</strong> (same region/ASN — reduces cross-continent transfers)</li>
<li><strong>High-completion peers</strong> (more pieces available — better utilization of each connection)</li>
<li><strong>Random</strong> (fallback for ties — prevents herding)</li>
</ol>
<p>Peer handout limit: 30 peers per announce response (Kraken uses 50, but IC has fewer total peers per package). Community-hosted trackers can implement custom policies via the server config.</p>
<p><em>Planned evolution — weighted multi-dimensional scoring (Phase 5+):</em> Dragonfly’s evaluator demonstrates that combining capacity, locality, and node type into a weighted score produces better peer selection than linear priority tiers. IC’s Phase 5+ peer selection evolves to a weighted scoring model informed by Dragonfly’s approach:</p>
<pre><code>PeerScore = Capacity(0.4) + Locality(0.3) + SeedStatus(0.2) + LobbyContext(0.1)
</code></pre>
<ul>
<li><strong>Capacity (weight 0.4):</strong> Spare bandwidth reported in announce (<code>1 - upload_bw_used / upload_bw_max</code>). Peers with more headroom score higher. Inspired by Dragonfly’s <code>LoadQuality</code> metric (which sub-decomposes into peak bandwidth, sustained load, and concurrency). IC uses a single utilization ratio — simpler, captures the same core insight.</li>
<li><strong>Locality (weight 0.3):</strong> Hierarchical location matching. Clients self-report location as <code>continent|country|region|city</code> (4-level, pipe-delimited — adapted from Dragonfly’s 5-level <code>country|province|city|zone|cluster</code>). Score = <code>matched_prefix_elements / 4</code>. Two peers in the same city score 0.75; same country but different region: 0.5; same continent: 0.25.</li>
<li><strong>SeedStatus (weight 0.2):</strong> Seed box = 1.0, completed seeder = 0.7, uploading leecher = 0.3. Inspired by Dragonfly’s <code>HostType</code> score (seed peers = 1.0, normal = 0.5).</li>
<li><strong>LobbyContext (weight 0.1):</strong> Same lobby = 1.0, same game session = 0.5, no context = 0. IC-specific — Dragonfly has no equivalent (no lobby concept).</li>
</ul>
<p>The initial 5-tier priority system (above) ships first and is adequate for community scale. Weighted scoring is additive — the same pluggable policy interface supports both approaches. Community servers can configure their own weights or contribute custom scoring policies.</p>
<p><em>Piece request strategy (client-side):</em> The engine uses <strong>rarest-first</strong> piece selection by default — a priority queue sorted by fewest peers having each piece. This is standard BitTorrent behavior, well-validated for internet conditions. Kraken also implements this as <code>rarestFirstPolicy</code>.</p>
<ul>
<li><strong>Pipeline limit:</strong> 3 concurrent piece requests per peer (matches Kraken’s default). Prevents overwhelming slow peers.</li>
<li><strong>Piece request timeout:</strong> 8s base + 6s per MB of piece size (more generous than Kraken’s 4s+4s/MB, compensating for residential internet variance).</li>
<li><strong>Endgame mode:</strong> When remaining pieces ≤ 5, the engine sends duplicate piece requests to multiple peers. This prevents the “last piece stall” — a well-known BitTorrent problem where the final piece’s sole holder is slow. Kraken implements this as <code>EndgameThreshold</code> — it’s essential.</li>
</ul>
<p><em>Connection state machine (client-side):</em></p>
<pre><code>pending ──connect──► active ──timeout/error──► blacklisted
   ▲                    │                          │
   │                    │                          │
   └──────────── cooldown (5min) ◄─────────────────┘
</code></pre>
<ul>
<li><code>MaxConnectionsPerPackage: 8</code> (lower than Kraken’s 10 — residential connections have less bandwidth to share)</li>
<li>Blacklisting: peers that produce zero useful throughput over 30 seconds are temporarily blacklisted (5-minute cooldown). Catches both dead peers and ISP-throttled connections.</li>
<li><em>Sybil resistance:</em> Maximum 3 peers per /24 subnet in a single swarm. Prefer peers from diverse autonomous systems (ASNs) when possible. Sybil attacks can waste bandwidth but cannot serve corrupt data (SHA-256 integrity), so the risk ceiling is low.</li>
<li><em>Statistical degradation detection (Phase 5+):</em> Inspired by Dragonfly’s <code>IsBadParent</code> algorithm — track per-peer piece transfer times. Peers whose last transfer exceeds <code>max(3 × mean, 2 × p95)</code> of observed transfer times are demoted in scoring (not hard-blacklisted — they may recover). For sparse data (&lt; 50 samples per peer), fall back to the simpler “20× mean” ratio check. Hard blacklist remains only for zero-throughput (complete failure). This catches degrading peers before they fail completely.</li>
<li>Connections have TTL — idle connections are closed after 60 seconds to free resources.</li>
</ul>
<p><em>Announce cycle (client → tracker):</em> Clients announce to the tracker every <strong>30 seconds</strong> (Kraken uses 3s for datacenter — far too aggressive for internet). The tracker can dynamically adjust: faster intervals (10s) during active downloads, slower (60s) when seeding idle content. Max interval cap (120s) prevents unbounded growth. Announce payload includes: PeerID, package info hash, bitfield (what pieces the client has), upload/download speed.</p>
<p><em>Size-based piece length:</em> Different package sizes use different piece lengths to balance metadata overhead against download granularity (inspired by Kraken’s <code>PieceLengths</code> config):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Package Size</th><th>Piece Length</th><th>Rationale</th></tr>
</thead>
<tbody>
<tr><td>&lt; 5MB</td><td>N/A — HTTP only</td><td>P2P overhead exceeds benefit</td></tr>
<tr><td>5–50MB</td><td>256KB</td><td>Fine-grained. Good for partial recovery and slow connections.</td></tr>
<tr><td>50–500MB</td><td>1MB</td><td>Balanced. Reasonable metadata overhead.</td></tr>
<tr><td>&gt; 500MB</td><td>4MB</td><td>Reduced metadata overhead for large packages.</td></tr>
</tbody>
</table>
</div>
<p><em>Bandwidth limiting:</em> Configurable per-client in <code>settings.yaml</code>. Residential users cannot have their connection saturated by mod seeding — this is a hard requirement that Kraken solves with <code>egress_bits_per_sec</code>/<code>ingress_bits_per_sec</code> and IC must match.</p>
<pre><code class="language-yaml"># settings.yaml — P2P bandwidth configuration
workshop:
  p2p:
    max_upload_speed: "1 MB/s"       # Default. 0 = unlimited, "0 B/s" = no seeding
    max_download_speed: "unlimited"   # Default. Most users won't limit.
    seed_after_download: true         # Keep seeding while game is running
    seed_duration_after_exit: "30m"   # Background seeding after game closes (0 = none)
    cache_size_limit: "2 GB"          # LRU eviction when exceeded
    prefer_p2p: true                  # false = always use HTTP direct
</code></pre>
<p><em>Health checks:</em> Seed boxes implement heartbeat health checks (30s interval, 3 failures → unhealthy, 2 passes → healthy again — matching Kraken’s active health check parameters). The tracker marks peers as offline after 2× announce interval without contact. Unhealthy seed boxes are removed from the announce response until they recover.</p>
<p><em>Content lifecycle:</em> Downloaded packages stay in the seeding pool for 30 minutes after the game exits (configurable via <code>seed_duration_after_exit</code>). This is longer than Kraken’s 5-minute <code>seeder_tti</code> because IC has fewer peers per package — each seeder is more valuable. Disk cache uses LRU eviction when over <code>cache_size_limit</code>. Packages currently in use or being seeded are never evicted.</p>
<p><em>Download priority tiers:</em> Inspired by Dragonfly’s 7-level priority system (Level0–Level6), IC uses 3 priority tiers to enable QoS differentiation. Higher-priority downloads preempt lower-priority ones (pause background downloads, reallocate bandwidth and connection slots):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Priority</th><th>Name</th><th>When Used</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td>1 (high)</td><td><code>lobby-urgent</code></td><td>Player joining a lobby that requires missing mods</td><td>Preempts all other downloads. Uses all available bandwidth</td></tr>
<tr><td>2 (mid)</td><td><code>user-requested</code></td><td>Player manually downloads from Workshop browser</td><td>Normal bandwidth. Runs alongside background.</td></tr>
<tr><td>3 (low)</td><td><code>background</code></td><td>Cache warming, auto-updates, subscribed mod pre-download</td><td>Bandwidth-limited. Paused when higher-priority active.</td></tr>
</tbody>
</table>
</div>
<p><em>Preheat / prefetch:</em> Adapted from Dragonfly’s preheat jobs (which pre-warm content on seed peers before demand). IC uses two prefetch patterns:</p>
<ul>
<li><strong>Lobby prefetch:</strong> When a lobby host sets required mods, the Workshop server (Phase 5+) can pre-seed those mods to seed boxes before players join. The lobby creation event is the prefetch signal. This ensures seed infrastructure is warm when players start downloading.</li>
<li><strong>Subscription prefetch:</strong> Players can subscribe to Workshop publishers or resources. Subscribed content auto-downloads in the background at <code>background</code> priority. When a subscribed mod updates, the new version downloads automatically before the player next launches the game.</li>
</ul>
<p><em>Persistent replica count (Phase 5+):</em> Inspired by Dragonfly’s <code>PersistentReplicaCount</code>, the Workshop server tracks how many seed boxes hold each resource. If the count drops below a configurable threshold (default: 2 for popular resources, 1 for all others), the server triggers automatic re-seeding from HTTP origin. This ensures the “always available” guarantee — even if all player peers are offline, seed infrastructure maintains minimum replica coverage.</p>
<p><strong>Early-phase bootstrap — Git-hosted package index:</strong></p>
<p>Before the full Workshop server is built (Phase 4-5), a <strong>GitHub-hosted package index repository</strong> serves as the Workshop’s discovery and coordination layer. This is a well-proven pattern — Homebrew (<code>homebrew-core</code>), Rust (<code>crates.io-index</code>), Winget (<code>winget-pkgs</code>), and Nixpkgs all use a git repository as their canonical package index.</p>
<p><strong>How it works:</strong></p>
<p>A public GitHub repository (e.g., <code>iron-curtain/workshop-index</code>) contains YAML manifest files — one per package — that describe available resources, their versions, checksums, download locations, and dependencies. The repo itself contains NO asset files — only lightweight metadata.</p>
<pre><code>workshop-index/                      # The git-hosted package index
├── index.yaml                       # Consolidated index (single-fetch for game client)
├── packages/
│   ├── alice/
│   │   └── soviet-march-music/
│   │       ├── 1.0.0.yaml           # Per-version manifests
│   │       └── 1.1.0.yaml
│   ├── community-hd-project/
│   │   └── allied-infantry-hd/
│   │       └── 2.0.0.yaml
│   └── ...
├── sources.yaml                     # List of storage servers, mirrors, seed boxes
└── .github/
    └── workflows/
        └── validate.yml             # CI: validates manifest format, checks SHA-256
</code></pre>
<p><strong>Per-package manifest (<code>packages/alice/soviet-march-music/1.1.0.yaml</code>):</strong></p>
<pre><code class="language-yaml">name: soviet-march-music
publisher: alice
version: 1.1.0
license: CC-BY-4.0
description: "Soviet faction battle music pack"
size: 48_000_000  # 48MB
sha256: "a1b2c3d4..."

sources:
  - type: http
    url: "https://github.com/iron-curtain/workshop-packages/releases/download/alice-soviet-march-music-1.1.0/soviet-march-music-1.1.0.icpkg"
  - type: torrent
    info_hash: "e5f6a7b8..."
    trackers:
      - "wss://tracker.ironcurtain.gg/announce"   # WebTorrent tracker
      - "udp://tracker.ironcurtain.gg:6969/announce"

dependencies:
  community-hd-project/base-audio-lib: "^1.0"

game_modules: [ra]
tags: [music, soviet, battle]
</code></pre>
<p><strong><code>sources.yaml</code> — storage server and tracker registry:</strong></p>
<pre><code class="language-yaml"># Where to find actual .icpkg files and BitTorrent peers.
# The engine reads this to discover available download sources.
# Adding an official server later = adding a line here.
storage_servers:
  - url: "https://github.com/iron-curtain/workshop-packages/releases"  # GitHub Releases (Phase 0-3)
    type: github-releases
    priority: 1
  # - url: "https://cdn.ironcurtain.gg"   # Future: official CDN (Phase 5+)
  #   type: http
  #   priority: 1

torrent_trackers:
  - "wss://tracker.ironcurtain.gg/announce"      # WebTorrent (browser + desktop)
  - "udp://tracker.ironcurtain.gg:6969/announce"  # UDP (desktop only)

seed_boxes:
  - "https://seed1.ironcurtain.gg"  # Permanent seeder for all packages
</code></pre>
<p><strong>Two client access patterns:</strong></p>
<ol>
<li><strong>HTTP fetch</strong> (game client default): The engine fetches <code>index.yaml</code> via <code>raw.githubusercontent.com</code> — a single GET request returns the full package listing. Fast, no git dependency, CDN-backed globally by GitHub. Cached locally with ETag/Last-Modified for incremental updates.</li>
<li><strong>Git clone/pull</strong> (SDK, power users, offline): <code>git clone</code> the entire index repo. <code>git pull</code> for incremental atomic updates. Full offline browsing. Better for the SDK/editor and users who want to script against the index.</li>
</ol>
<p>The engine’s Workshop source configuration (D030) treats this as a new source type:</p>
<pre><code class="language-yaml"># settings.yaml — Phase 0-3 configuration
workshop:
  sources:
    - url: "https://github.com/iron-curtain/workshop-index"  # git-index source
      type: git-index
      priority: 1
    - path: "C:/my-local-workshop"   # local development
      type: local
      priority: 2
</code></pre>
<p><strong>Community contribution workflow (manual):</strong></p>
<ol>
<li>Modder creates a <code>.icpkg</code> package and uploads it to GitHub Releases (or any HTTP host)</li>
<li>Modder submits a PR to <code>workshop-index</code> adding a manifest YAML with SHA-256 and download URL</li>
<li>GitHub Actions validates manifest format, checks SHA-256 against the download URL, verifies metadata</li>
<li>Maintainers review and merge → package is discoverable to all players on next index fetch</li>
<li>When the full Workshop server ships (Phase 4-5), published packages migrate automatically — the manifest format is the same</li>
</ol>
<p><strong>Git-index security hardening</strong> (see <code>06-SECURITY.md</code> § Vulnerabilities 20–21 and <code>research/workshop-registry-vulnerability-analysis.md</code> for full threat analysis):</p>
<ul>
<li><strong>Path-scoped PR validation:</strong> CI rejects PRs that modify files outside the submitter’s package directory. A PR adding <code>packages/alice/tanks/1.0.0.yaml</code> may ONLY modify files under <code>packages/alice/</code>. Modification of other paths → automatic CI failure.</li>
<li><strong>CODEOWNERS:</strong> Maps <code>packages/alice/** @alice-github</code>. GitHub enforces that only the package owner can approve changes to their manifests.</li>
<li><strong><code>manifest_hash</code> verification:</strong> CI downloads the <code>.icpkg</code>, extracts <code>manifest.yaml</code>, computes its SHA-256, and verifies it matches the <code>manifest_hash</code> field in the index entry. Prevents manifest confusion (registry entry diverging from package contents).</li>
<li><strong>Consolidated <code>index.yaml</code> is CI-generated:</strong> Deterministically rebuilt from per-package manifests — never hand-edited. Any contributor can reproduce locally to verify integrity.</li>
<li><strong>Index signing (Phase 3–4):</strong> CI signs the consolidated <code>index.yaml</code> with an Ed25519 key stored outside GitHub. Clients verify the signature. Repository compromise without the signing key produces unsigned (rejected) indexes. Uses the <strong>two-key architecture</strong> from D052 (§ Key Lifecycle): the CI-held key is the Signing Key (SK); a Recovery Key (RK), held offline by ≥2 maintainers, enables key rotation on compromise without breaking client trust chains. See D052 § “Cross-Pollination” for the full rationale.</li>
<li><strong>Actions pinned to commit SHAs:</strong> All GitHub Actions referenced by SHA, not by mutable tag. Minimal <code>GITHUB_TOKEN</code> permissions. No secrets in the PR validation pipeline.</li>
<li><strong>Branch protection on main:</strong> Require signed commits, no force-push, require PR reviews, no single-person merge. Repository must have ≥3 maintainers.</li>
</ul>
<p><strong>Automated publish via <code>ic</code> CLI (same UX as Phase 5+):</strong></p>
<p>The <code>ic mod publish</code> command works against the git-index backend in Phase 0–3:</p>
<ol>
<li><code>ic mod publish</code> packages content into <code>.icpkg</code>, computes SHA-256</li>
<li>Uploads <code>.icpkg</code> to GitHub Releases (via GitHub API, using a personal access token configured in <code>ic auth</code>)</li>
<li>Generates the index manifest YAML from <code>mod.yaml</code> metadata</li>
<li>Opens a PR to <code>workshop-index</code> with the manifest file</li>
<li>Modder reviews the PR and confirms; GitHub Actions validates; maintainers merge</li>
</ol>
<p>The command is identical to Phase 5+ publishing (<code>ic mod publish</code>) — the only difference is the backend. When the Workshop server ships, <code>ic mod publish</code> targets the server instead. Modders don’t change their workflow.</p>
<p><strong>Adding official storage servers later:</strong></p>
<p>When official infrastructure is ready (Phase 5+), adding it is a one-line change to <code>sources.yaml</code> — no architecture change, no client update. The <code>sources.yaml</code> in the index repo is the single place that lists where packages can be downloaded from. Community mirrors and CDN endpoints are added the same way.</p>
<p><strong>Phased progression:</strong></p>
<ol>
<li><strong>Phase 0–3 — Git-hosted index + GitHub Releases:</strong> The index repo is the Workshop. Players fetch <code>index.yaml</code> for discovery, download <code>.icpkg</code> files from GitHub Releases (2GB per file, free, CDN-backed). Community contributes via PR. Zero custom server code. Zero hosting cost.</li>
<li><strong>Phase 3–4 — Add BitTorrent tracker:</strong> A minimal tracker binary goes live ($5-10/month VPS). Package manifests gain <code>torrent</code> source entries. P2P delivery begins for large packages. The index repo remains the discovery layer.</li>
<li><strong>Phase 4–5 — Full Workshop server:</strong> Search, ratings, dependency resolution, FTS5, integrated P2P tracker. The Workshop server can either replace the git index or coexist alongside it (both are valid D030 sources). The git index remains available as a fallback and for community-hosted Workshop servers.</li>
</ol>
<p>The progression is smooth because the federated source model (D030) already supports multiple source types — <code>git-index</code>, <code>local</code>, <code>remote</code> (Workshop server), and <code>steam</code> all coexist in <code>settings.yaml</code>.</p>
<p><strong>Industry precedent:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Project</th><th>Index Mechanism</th><th>Scale</th></tr>
</thead>
<tbody>
<tr><td><strong>Homebrew</strong> (<code>homebrew-core</code>)</td><td>Git repo of Ruby formulae; <code>brew update</code> = <code>git pull</code></td><td>~7K packages</td></tr>
<tr><td><strong>Rust crates.io</strong> (<code>crates.io-index</code>)</td><td>Git repo of JSON metadata; sparse HTTP fetch added later</td><td>~150K crates</td></tr>
<tr><td><strong>Winget</strong> (<code>winget-pkgs</code>)</td><td>Git repo of YAML manifests; community PRs</td><td>~5K packages</td></tr>
<tr><td><strong>Nixpkgs</strong></td><td>Git repo of Nix expressions</td><td>~100K packages</td></tr>
<tr><td><strong>Scoop</strong> (Windows)</td><td>Git repo (“buckets”) of JSON manifests</td><td>~5K packages</td></tr>
</tbody>
</table>
</div>
<p>All of these started with git-as-index and some (crates.io) later augmented with sparse HTTP fetching for performance at scale. The same progression applies here — git index works perfectly for a community of hundreds to low thousands, and can be complemented (not replaced) by a Workshop API when scale demands it.</p>
<p><strong>Workshop server architecture with P2P:</strong></p>
<pre><code>┌─────────────────────────────────────────────────────┐
│                  Workshop Server                     │
│  ┌─────────────┐  ┌──────────┐  ┌────────────────┐ │
│  │  Metadata    │  │ Tracker  │  │  HTTP Fallback │ │
│  │  (SQLite +   │  │ (BT/WT   │  │  (S3/R2 or     │ │
│  │   FTS5)      │  │  peer     │  │   local disk)  │ │
│  │             │  │  coord)   │  │               │ │
│  └─────────────┘  └──────────┘  └────────────────┘ │
│        ▲               ▲               ▲            │
│        │ search/browse │ announce/     │ GET .icpkg  │
│        │ deps/ratings  │ scrape        │ (fallback)  │
└────────┼───────────────┼───────────────┼────────────┘
         │               │               │
    ┌────┴────┐    ┌─────┴─────┐   ┌─────┴─────┐
    │ ic CLI  │    │  Players  │   │ Seed Box  │
    │ Browser │    │  (seeds)  │   │ (always   │
    └─────────┘    └───────────┘   │  seeds)   │
                                   └───────────┘
</code></pre>
<p>All three components (metadata, tracker, HTTP fallback) run in the same binary — “just a Rust binary” deployment philosophy. Community self-hosters get the full stack with one executable.</p>
<h3 id="rust-implementation"><a class="header" href="#rust-implementation">Rust Implementation</a></h3>
<p><strong>BitTorrent client library:</strong> The <code>ic</code> CLI and game client embed a BitTorrent client. Rust options:</p>
<ul>
<li><a href="https://github.com/ikatson/rqbit"><code>librqbit</code></a> — pure Rust, async (tokio), actively maintained, supports WebTorrent</li>
<li><a href="https://github.com/mandreyel/cratetorrent"><code>cratetorrent</code></a> — pure Rust, educational focus</li>
<li>Custom minimal client — only needs download + seed + tracker announce; no DHT, no PEX needed for a controlled Workshop ecosystem</li>
</ul>
<p><strong>BitTorrent tracker:</strong> Embeddable in the Workshop server binary. Rust options:</p>
<ul>
<li><a href="https://github.com/greatest-ape/aquatic"><code>aquatic</code></a> — high-performance Rust tracker</li>
<li>Custom minimal tracker — HTTP announce/scrape endpoints, peer list management. The Workshop server already has SQLite; peer lists are another table.</li>
</ul>
<p><strong>WebTorrent:</strong> <code>librqbit</code> has WebTorrent support. The WASM build would use the WebRTC transport.</p>
<h3 id="rationale-1"><a class="header" href="#rationale-1">Rationale</a></h3>
<ul>
<li><strong>Cost sustainability:</strong> P2P reduces Workshop hosting costs by 90%+. A community project cannot afford CDN bills that scale with popularity. A tracker + seed box for $30-50/month serves unlimited download volume.</li>
<li><strong>Fits federation (D030):</strong> P2P is another source in the federated model. The virtual repository queries metadata from remote servers, then downloads content from the swarm — same user experience, different transport.</li>
<li><strong>Fits “no single point of failure” (D037):</strong> P2P is inherently resilient. If the Workshop server goes down, peers keep sharing. Content already downloaded is always available.</li>
<li><strong>Fits SHA-256 integrity (D030):</strong> P2P needs exactly the integrity verification already designed. Same <code>manifest.yaml</code> checksums, same <code>ic.lock</code> pinning, same verification on install.</li>
<li><strong>Fits WASM target (invariant #10):</strong> WebTorrent enables browser-to-browser P2P. Desktop and browser clients interoperate. No second-class platform.</li>
<li><strong>Popular resources get faster:</strong> More downloads → more seeders → faster downloads for everyone. The opposite of CDN economics where popularity increases cost.</li>
<li><strong>Self-hosting scales:</strong> Community Workshop servers (D030 federation) benefit from the same P2P economics. A small community server needs only a $5 VPS — the community’s players provide the bandwidth.</li>
<li><strong>Privacy-responsible:</strong> IP exposure is equivalent to any multiplayer game. HTTP-only mode available for privacy-sensitive users. No additional surveillance beyond standard BitTorrent protocol.</li>
<li><strong>Proven technology:</strong> BitTorrent has been distributing large files reliably for 20+ years. Blizzard used it for WoW patches. The protocol is well-understood, well-documented, and well-implemented.</li>
</ul>
<h3 id="alternatives-considered-9"><a class="header" href="#alternatives-considered-9">Alternatives Considered</a></h3>
<ul>
<li><strong>Centralized CDN only</strong> (rejected — financially unsustainable for a donation-funded community project. A popular 500MB mod downloaded 10K times = 5TB = $50-450/month. P2P reduces this to near-zero marginal cost)</li>
<li><strong>IPFS</strong> (rejected as primary distribution protocol — slow cold-content discovery, complex setup, ecosystem declining, content pinning is expensive, poor game-quality UX. However, multiple Bitswap protocol design patterns adopted: EWMA peer scoring, per-peer fairness caps, want-have/want-block two-phase discovery, broadcast control, dual WAN/LAN discovery, delegated HTTP routing, batch provider announcements. See competitive landscape table above and research deep dive)</li>
<li><strong>Custom P2P protocol</strong> (rejected — massive engineering effort with no advantage over BitTorrent’s 20-year-proven protocol)</li>
<li><strong>Git LFS</strong> (rejected — 1GB free then paid; designed for source code, not binary asset distribution; no P2P)</li>
<li><strong>Steam Workshop only</strong> (rejected — platform lock-in, Steam subsidizes hosting from game sales revenue we don’t have, excludes non-Steam/WASM builds)</li>
<li><strong>GitHub Releases only</strong> (rejected — works for bootstrap but no search, ratings, dependency resolution, P2P, or lobby auto-download. Adequate interim solution, not long-term architecture)</li>
<li><strong>HTTP-only with community mirrors</strong> (rejected — still fragile. Mirrors are one operator away from going offline. P2P is inherently more resilient than any number of mirrors)</li>
<li><strong>No git index / custom server from day one</strong> (rejected — premature complexity. A git-hosted index costs $0 and ships with the first playable build. Custom server code can wait until Phase 4-5 when the community is large enough to need search/ratings)</li>
</ul>
<h3 id="phase-1"><a class="header" href="#phase-1">Phase</a></h3>
<ul>
<li><strong>Phase 0–3:</strong> Git-hosted package index (<code>workshop-index</code> repo) + GitHub Releases for <code>.icpkg</code> storage. Zero infrastructure cost. Community contributes via PR. Game client fetches <code>index.yaml</code> for discovery.</li>
<li><strong>Phase 3–4:</strong> Add BitTorrent tracker ($5-10/month VPS). Package manifests gain <code>torrent</code> source entries. P2P delivery begins for large packages. Git index remains the discovery layer.</li>
<li><strong>Phase 4–5:</strong> Full Workshop server with integrated BitTorrent/WebTorrent tracker, search, ratings, dependency resolution, P2P delivery, HTTP fallback via S3-compatible storage. Git index can coexist or be subsumed.</li>
<li><strong>Phase 6a:</strong> Federation (community servers join the P2P swarm), Steam Workshop as additional source, Publisher workflows</li>
<li><strong>Format recommendations</strong> apply from Phase 0 — all first-party content uses the recommended canonical formats</li>
</ul>
<hr>
<h2 id="d050-workshop-as-cross-project-reusable-library"><a class="header" href="#d050-workshop-as-cross-project-reusable-library">D050: Workshop as Cross-Project Reusable Library</a></h2>
<p><strong>Decision:</strong> The Workshop core (registry, distribution, federation, P2P) is designed as a <strong>standalone, engine-agnostic, game-agnostic Rust library</strong> that Iron Curtain is the first consumer of, with the explicit intent that future game projects (XCOM-inspired tactics clone, Civilization-inspired 4X clone, Operation Flashpoint/ArmA-inspired military sim) will be additional consumers. These future projects may or may not use Bevy — the Workshop library must not depend on any specific game engine.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>The author plans to build multiple open-source game clones in the spirit of OpenRA, each targeting a different genre’s community. Every one of these projects faces the same Workshop problem: mod distribution, versioning, dependencies, integrity, community hosting, P2P delivery</li>
<li>Building Workshop infrastructure once and reusing it across projects amortizes the significant design and engineering investment over multiple games</li>
<li>An XCOM clone needs soldier mods, ability packs, map presets, voice packs. A Civ clone needs civilization packs, map scripts, leader art, scenario bundles. An OFP/ArmA clone needs terrains (often 5–20 GB), vehicle models, weapon packs, mission scripts, campaign packages. All of these are “versioned packages with metadata, dependencies, and integrity verification” — the same core abstraction</li>
<li>The P2P distribution layer is especially valuable for the ArmA-style project where mod sizes routinely exceed what any free CDN can sustain</li>
<li>Making the library engine-agnostic also produces cleaner IC code — the Bevy integration layer is thinner, better tested, and easier to maintain</li>
</ul>
<h3 id="two-layer-architecture"><a class="header" href="#two-layer-architecture">Two-Layer Architecture</a></h3>
<p>The Workshop is split into two layers with a clean boundary:</p>
<pre><code>┌─────────────────────────────────────────────────────────┐
│  Game Integration Layer (per-project, engine-specific)  │
│                                                         │
│  IC: Bevy plugin, lobby auto-download, game_module,     │
│       .icpkg extension, `ic mod` CLI, ra-formats,       │
│       Bevy-native format recommendations (D049)         │
│                                                         │
│  XCOM clone: its engine plugin, mission-trigger          │
│       download, .xpkg, its CLI, its format prefs        │
│                                                         │
│  Civ clone: its engine plugin, scenario-load download,  │
│       .cpkg, its CLI, its format prefs                  │
│                                                         │
│  OFP clone: its engine plugin, server-join download,    │
│       .opkg, its CLI, its format prefs                  │
├─────────────────────────────────────────────────────────┤
│  Workshop Core Library (engine-agnostic, game-agnostic) │
│                                                         │
│  Registry: search, publish, version, depend, license    │
│  Distribution: BitTorrent/WebTorrent, HTTP fallback     │
│  Federation: multi-source, git-index, remote, local     │
│  Integrity: SHA-256, piece hashing, signed manifests    │
│  Identity: publisher/name@version                       │
│  P2P engine: peer scoring, piece selection, bandwidth   │
│  CLI core: auth, publish, install, update, resolve      │
│  Protocol: federation spec, manifest schema, APIs       │
└─────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="core-library-boundary--whats-in-and-whats-out"><a class="header" href="#core-library-boundary--whats-in-and-whats-out">Core Library Boundary — What’s In and What’s Out</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Core Library (game-agnostic)</th><th>Game Integration Layer (per-project)</th></tr>
</thead>
<tbody>
<tr><td><strong>Package format</strong></td><td>ZIP archive with <code>manifest.yaml</code>. Extension is configurable (default: <code>.pkg</code>)</td><td>IC uses <code>.icpkg</code>, other projects choose their own</td></tr>
<tr><td><strong>Manifest schema</strong></td><td>Core fields: <code>name</code>, <code>version</code>, <code>publisher</code>, <code>description</code>, <code>license</code>, <code>dependencies</code>, <code>platforms</code>, <code>sha256</code>, <code>tags</code></td><td>Extension fields: <code>game_module</code>, <code>engine_version</code>, <code>category</code> (IC-specific). Each project defines its own extension fields</td></tr>
<tr><td><strong>Resource categories</strong></td><td>Tags (free-form strings). Core provides no fixed category enum</td><td>Each project defines a recommended tag vocabulary (IC: <code>sprites</code>, <code>music</code>, <code>map</code>; XCOM: <code>soldiers</code>, <code>abilities</code>, <code>missions</code>; Civ: <code>civilizations</code>, <code>leaders</code>, <code>scenarios</code>; OFP: <code>terrains</code>, <code>vehicles</code>, <code>campaigns</code>)</td></tr>
<tr><td><strong>Package identity</strong></td><td><code>publisher/name@version</code> — already game-agnostic</td><td>No change needed</td></tr>
<tr><td><strong>Dependency resolution</strong></td><td>semver resolution, lockfile, integrity verification</td><td>Per-project compatibility checks (e.g., IC checks <code>game_module</code> + <code>engine_version</code>)</td></tr>
<tr><td><strong>P2P distribution</strong></td><td>BitTorrent/WebTorrent protocol, tracker, peer scoring, piece selection, bandwidth limiting, HTTP fallback</td><td>Per-project seed infrastructure (IC uses <code>ironcurtain.gg</code> tracker, OFP clone uses its own)</td></tr>
<tr><td><strong>P2P peer scoring</strong></td><td>Weighted multi-dimensional: <code>Capacity × w1 + Locality × w2 + SeedStatus × w3 + ApplicationContext × w4</code>. Weights and dimensions configurable</td><td>Each project defines <code>ApplicationContext</code>: IC = same-lobby bonus, OFP = same-server bonus, Civ = same-matchmaking-pool bonus. Projects that have no context concept set weight to 0</td></tr>
<tr><td><strong>Download priority</strong></td><td>Three tiers: <code>critical</code> (blocking gameplay), <code>requested</code> (user-initiated), <code>background</code> (cache warming)</td><td>Each project maps its triggers: IC’s lobby-join → <code>critical</code>. OFP’s server-join → <code>critical</code>. Civ’s scenario-load → <code>requested</code></td></tr>
<tr><td><strong>Auto-download trigger</strong></td><td>Library provides <code>download_packages(list, priority)</code> API</td><td>Integration layer decides WHEN to call it: IC calls on lobby join, OFP calls on server connect, XCOM calls on mod browser click</td></tr>
<tr><td><strong>CLI operations</strong></td><td>Core operations: <code>auth</code>, <code>publish</code>, <code>install</code>, <code>update</code>, <code>search</code>, <code>resolve</code>, <code>lock</code>, <code>audit</code>, <code>export-bundle</code>, <code>import-bundle</code></td><td>Each project wraps as its own CLI: <code>ic mod *</code>, <code>xcom mod *</code>, etc.</td></tr>
<tr><td><strong>Format recommendations</strong></td><td>None. The core library is format-agnostic — it distributes opaque files</td><td>Each project recommends formats for its engine: IC recommends Bevy-native (D049). A Godot-based project recommends Godot-native formats. A custom-engine project recommends whatever it loads</td></tr>
<tr><td><strong>Federation</strong></td><td>Multi-source registry, <code>sources.yaml</code>, git-index support, remote server API, local repository</td><td>Per-project default sources: IC uses <code>ironcurtain.gg</code> + <code>iron-curtain/workshop-index</code>. Each project configures its own</td></tr>
<tr><td><strong>Config paths</strong></td><td>Library accepts a config root path</td><td>Each project sets its own: IC uses <code>~/.ic/</code>, XCOM clone uses <code>~/.xcom/</code>, etc.</td></tr>
<tr><td><strong>Auth tokens</strong></td><td>Token generation, storage, scoping (publish/admin/readonly), environment variable override</td><td>Per-project env var names: <code>IC_AUTH_TOKEN</code>, <code>XCOM_AUTH_TOKEN</code>, etc.</td></tr>
<tr><td><strong>Lockfile</strong></td><td>Core lockfile format with package hashes</td><td>Per-project lockfile name: <code>ic.lock</code>, <code>xcom.lock</code>, etc.</td></tr>
</tbody>
</table>
</div>
<h3 id="impact-on-existing-d030d049-design"><a class="header" href="#impact-on-existing-d030d049-design">Impact on Existing D030/D049 Design</a></h3>
<p>The existing Workshop design requires only <strong>architectural clarification</strong>, not redesign. The core abstractions (packages, manifests, publishers, dependencies, federation, P2P) are already game-agnostic in concept. The changes are:</p>
<ol>
<li>
<p><strong>Naming</strong>: Where the design says <code>.icpkg</code>, the implementation will have a configurable extension with <code>.icpkg</code> as IC’s default. Where it says <code>ic mod *</code>, the core library provides operations and IC wraps them as <code>ic mod *</code> subcommands.</p>
</li>
<li>
<p><strong>Categories</strong>: Where D030 lists a fixed <code>ResourceCategory</code> enum (Music, Sprites, Maps…), the core library uses free-form tags. IC’s integration layer provides a recommended tag vocabulary and UI groupings. Other projects provide their own.</p>
</li>
<li>
<p><strong>Manifest</strong>: The <code>manifest.yaml</code> schema splits into core fields (in the library) and extension fields (per-project). <code>game_module: ra1</code> is an IC extension field, not a core manifest requirement.</p>
</li>
<li>
<p><strong>Format recommendations</strong>: D049’s Bevy-native format table is IC-specific guidance, not a core Workshop concern. The core library is format-agnostic. Each consuming project publishes its own format recommendations based on its engine’s capabilities.</p>
</li>
<li>
<p><strong>P2P scoring</strong>: The <code>LobbyContext</code> dimension in peer scoring becomes <code>ApplicationContext</code> — a generic callback where any project can inject context-aware peer prioritization. IC implements it as “same lobby = bonus.” An ArmA-style project implements it as “same server = bonus.”</p>
</li>
<li>
<p><strong>Infrastructure</strong>: Domain names (<code>ironcurtain.gg</code>), GitHub org (<code>iron-curtain/</code>), tracker URLs — these are IC deployment configuration. The core library is configured via <code>sources.yaml</code> with no hardcoded URLs.</p>
</li>
</ol>
<h3 id="cross-project-infrastructure-sharing"><a class="header" href="#cross-project-infrastructure-sharing">Cross-Project Infrastructure Sharing</a></h3>
<p>While each project has its own Workshop deployment, sharing is possible:</p>
<ul>
<li><strong>Shared tracker</strong>: A single BitTorrent tracker can serve multiple game projects. The info-hash namespace is naturally disjoint (different packages = different hashes).</li>
<li><strong>Shared git-index hosting</strong>: One GitHub org could host workshop-index repos for multiple projects.</li>
<li><strong>Shared seed boxes</strong>: Seed infrastructure can serve packages from multiple games simultaneously — BitTorrent doesn’t care about content semantics.</li>
<li><strong>Cross-project dependencies</strong>: A music pack or shader effect could be published once and depended on by packages from multiple games. The identity system (<code>publisher/name@version</code>) is globally unique.</li>
<li><strong>Shared federation network</strong>: Community-hosted Workshop servers could participate in multiple games’ federation networks simultaneously.</li>
</ul>
<blockquote>
<p><strong>Also shared with IC’s netcode infrastructure.</strong> The tracking server, relay server, and Workshop server share deep structural parallels within IC itself — federation, heartbeats, rate control, connection management, observability, deployment principles. The cross-pollination analysis (<code>research/p2p-federated-registry-analysis.md</code> § “Netcode ↔ Workshop Cross-Pollination”) identifies four shared infrastructure opportunities: a unified <code>ic-server</code> binary (tracking + relay + workshop in one process for small community operators), a shared federation library (multi-source aggregation used by both tracking and Workshop), a shared auth/identity layer (one Ed25519 keypair for multiplayer + publishing + profile), and shared scoring infrastructure (EWMA time-decaying reputation used by both P2P peer scoring and relay player quality tracking). The federation library and scoring infrastructure belong in the Workshop core library (D050) since they’re already game-agnostic.</p>
</blockquote>
<h3 id="engine-agnostic-p2p-and-netcode"><a class="header" href="#engine-agnostic-p2p-and-netcode">Engine-Agnostic P2P and Netcode</a></h3>
<p>The P2P distribution protocol (BitTorrent/WebTorrent) and all the patterns adopted from Kraken, Dragonfly, and IPFS (see D049 competitive landscape and <code>research/p2p-federated-registry-analysis.md</code>) are <strong>already engine-agnostic</strong>. The protocol operates at the TCP/UDP level — it doesn’t know or care whether the consuming application uses Bevy, Godot, Unreal, or a custom engine. The Rust implementation (<code>ic-workshop</code> core library) has no engine dependency.</p>
<p>For projects that use a non-Rust engine (unlikely given the author’s preferences, but architecturally supported): the Workshop core library exposes a C FFI or can be compiled as a standalone process that the game communicates with via IPC/localhost HTTP. The CLI itself serves as a non-Rust integration path — any game engine can shell out to the Workshop CLI for install/update operations.</p>
<h3 id="non-rts-game-considerations"><a class="header" href="#non-rts-game-considerations">Non-RTS Game Considerations</a></h3>
<p>Each future genre introduces patterns the current design doesn’t explicitly address:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Genre</th><th>Key Workshop Differences</th><th>Already Handled</th><th>Needs Attention</th></tr>
</thead>
<tbody>
<tr><td><strong>Turn-based tactics</strong> (XCOM)</td><td>Smaller mod sizes, more code-heavy mods (abilities, AI), procedural map parameters</td><td>Package format, dependencies, P2P</td><td>Ability/behavior mods may need a scripting sandbox equivalent to IC’s Lua/WASM — but that’s a game concern, not a Workshop concern</td></tr>
<tr><td><strong>Turn-based 4X</strong> (Civ)</td><td>Very large mod variety (civilizations, maps, scenarios, art), DLC-like mod structure, long-lived save compatibility</td><td>Package format, dependencies, versioning, P2P</td><td>Save-game compatibility metadata (a Civ mod that changes game rules may break existing saves). Workshop manifest could include <code>breaks_saves: true</code> as an extension field</td></tr>
<tr><td><strong>Military sim</strong> (OFP/ArmA)</td><td>Very large packages (terrains 5–20 GB), server-mandated mod lists, many simultaneous mods active</td><td>P2P (critical for large packages), dependencies, auto-download on server join</td><td>Partial downloads (download terrain mesh now, HD textures later) could benefit from sub-package granularity. Workshop packages already support dependencies — a terrain could be split into <code>base</code> + <code>hd-textures</code> + <code>satellite-imagery</code> packages</td></tr>
<tr><td><strong>Any</strong></td><td>Different scripting languages, different asset formats, different mod structures</td><td>Core library is content-agnostic</td><td>Nothing — this is the point of the two-layer design</td></tr>
</tbody>
</table>
</div>
<h3 id="phase-2"><a class="header" href="#phase-2">Phase</a></h3>
<p>D050 is an architectural principle, not a deliverable with its own phase. It shapes HOW D030 and D049 are implemented:</p>
<ul>
<li><strong>IC Phase 3–4</strong>: Implement Workshop core as a separate Rust library crate within the IC monorepo. The crate has zero Bevy dependencies. IC’s Bevy plugin wraps the core library. The API boundary enforces the two-layer split from the start.</li>
<li><strong>IC Phase 5–6</strong>: If a second game project begins, the core library can be extracted to its own repo with minimal effort because the boundary was enforced from day one.</li>
<li><strong>Post-IC-launch</strong>: Each new game project creates its own integration layer and deployment configuration. The core library, P2P protocol, and federation specification are shared.</li>
</ul>
<hr>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ID</th><th>Topic</th><th>Needs Resolution By</th></tr>
</thead>
<tbody>
<tr><td>P001</td><td><del>ECS crate choice</del> — RESOLVED: Bevy’s built-in ECS</td><td>Resolved</td></tr>
<tr><td>P002</td><td>Fixed-point scale (256? 1024? match OpenRA’s 1024?)</td><td>Phase 2 start</td></tr>
<tr><td>P003</td><td>Audio library choice + music integration design (see note below)</td><td>Phase 3 start</td></tr>
<tr><td>P004</td><td>Lobby/matchmaking protocol specifics — PARTIALLY RESOLVED: architecture + lobby protocol defined (D052), wire format details remain</td><td>Phase 5 start</td></tr>
<tr><td>P005</td><td><del>Map editor architecture</del> — RESOLVED: Scenario editor in SDK (D038+D040)</td><td>Resolved</td></tr>
<tr><td>P006</td><td><del>License choice</del> — RESOLVED: GPL v3 with modding exception (D051)</td><td>Resolved</td></tr>
<tr><td>P007</td><td><del>Workshop: single source vs multi-source</del> — RESOLVED: Federated multi-source (D030)</td><td>Resolved</td></tr>
</tbody>
</table>
</div>
<h3 id="p003--audio-system-design-notes"><a class="header" href="#p003--audio-system-design-notes">P003 — Audio System Design Notes</a></h3>
<p>The audio system is the least-designed critical subsystem. Beyond the library choice, Phase 3 needs to resolve:</p>
<ul>
<li><strong>Original <code>.aud</code> playback and encoding:</strong> Decoding and encoding Westwood’s <code>.aud</code> format (IMA ADPCM, mono/stereo, 8/16-bit, varying sample rates). Full codec implementation based on EA GPL source — <code>AUDHeaderType</code> header, <code>IndexTable</code>/<code>DiffTable</code> lookup tables, 4-bit nibble processing. See <code>05-FORMATS.md</code> § AUD Audio Format for complete struct definitions and algorithm details. Encoding support enables the Asset Studio (D040) audio converter for .aud ↔ .wav/.ogg conversion</li>
<li><strong>Music loading from Remastered Collection:</strong> If the player owns the Remastered Collection, can IC load the remastered soundtrack? Licensing allows personal use of purchased files, but the integration path needs design</li>
<li><strong>Dynamic music states:</strong> Combat/build/idle transitions (original RA had this — “Act on Instinct” during combat, ambient during base building). State machine driven by sim events</li>
<li><strong>Music as Workshop resources:</strong> Swappable soundtrack packs via D030 — architecture supports this, but audio pipeline needs to be resource-pack-aware</li>
<li><strong>Frank Klepacki’s music is integral to C&amp;C identity.</strong> The audio system should treat music as a first-class system, not an afterthought. See <code>13-PHILOSOPHY.md</code> § “Audio Drives Tempo”</li>
</ul>
<h3 id="p006--resolved-see-d051"><a class="header" href="#p006--resolved-see-d051">P006 — RESOLVED: See D051</a></h3>
<hr>
<h2 id="d051-engine-license--gpl-v3-with-explicit-modding-exception"><a class="header" href="#d051-engine-license--gpl-v3-with-explicit-modding-exception">D051: Engine License — GPL v3 with Explicit Modding Exception</a></h2>
<p><strong>Decision:</strong> The Iron Curtain engine is licensed under <strong>GNU General Public License v3.0</strong> (GPL v3) with an explicit <strong>modding exception</strong> that clarifies mods loaded through the engine’s data and scripting interfaces are NOT derivative works.</p>
<p><strong>Rationale:</strong></p>
<ol>
<li>
<p><strong>The C&amp;C open-source community is a GPL community.</strong> EA released every C&amp;C source code drop under GPL v3 — Red Alert, Tiberian Dawn, Generals/Zero Hour, and the Remastered Collection engine. OpenRA uses GPL v3. Stratagus uses GPL-2.0. Spring Engine uses GPL-2.0. The community this project is built for lives in GPL-land. GPL v3 is the license they know, trust, and expect.</p>
</li>
<li>
<p><strong>Legal compatibility with EA source.</strong> <code>ra-formats</code> directly references EA’s GPL v3 source code for struct definitions, compression algorithms, and lookup tables (see <code>05-FORMATS.md</code> § Binary Format Codec Reference). GPL v3 for the engine is the cleanest legal path — no license compatibility analysis required.</p>
</li>
<li>
<p><strong>The engine stays open — forever.</strong> GPL guarantees that no one can fork the engine, close-source it, and compete with the community’s own project. For a community that has watched proprietary decisions kill or fragment C&amp;C projects over three decades, this guarantee matters. MIT/Apache would allow exactly the kind of proprietary fork the community fears.</p>
</li>
<li>
<p><strong>Contributor alignment.</strong> DCO + GPL v3 is the combination used by the Linux kernel — the most successful community-developed project in history. OpenRA contributors moving to IC (or contributing to both) face zero license friction.</p>
</li>
<li>
<p><strong>Modders are NOT restricted.</strong> This is the key concern the old tension analysis raised, and the answer is clear: YAML data files, Lua scripts, and WASM modules loaded through a sandboxed runtime interface are NOT derivative works under GPL. This is the same settled legal interpretation as:</p>
<ul>
<li>Linux kernel (GPL) + userspace programs (any license)</li>
<li>Blender (GPL) + Python scripts (any license)</li>
<li>WordPress (GPL) + themes and plugins loaded via defined APIs</li>
<li>GCC (GPL) + programs compiled by GCC (any license, via runtime library exception)</li>
</ul>
<p>IC’s tiered modding architecture (D003/D004/D005) was specifically designed so that mods operate through data interfaces and sandboxed runtimes, never linking against engine code. The modding exception makes this explicit.</p>
</li>
<li>
<p><strong>Commercial use is allowed.</strong> GPL v3 permits selling copies, hosting commercial servers, running tournaments with prize pools, and charging for relay hosting. It requires sharing source modifications — which is exactly what this community wants.</p>
</li>
</ol>
<p><strong>The modding exception (added to LICENSE header):</strong></p>
<pre><code>Additional permission under GNU GPL version 3 section 7:

If you modify this Program or any covered work, by linking or combining
it with content loaded through the engine's data interfaces (YAML rule
files, Lua scripts, WASM modules, resource packs, Workshop packages, or
any content loaded through the modding tiers described in the
documentation as "Tier 1", "Tier 2", or "Tier 3"), the content loaded
through those interfaces is NOT considered part of the covered work and
is NOT subject to the terms of this License. Authors of such content may
choose any license they wish.

This exception does not affect the copyleft requirement for modifications
to the engine source code itself.
</code></pre>
<p>This exception uses GPL v3 § 7’s “additional permissions” mechanism — the same mechanism GCC uses for its runtime library exception. It is legally sound and well-precedented.</p>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li><strong>MIT / Apache 2.0</strong> (rejected — allows proprietary forks that fragment the community; creates legal ambiguity when referencing GPL’d EA source code; the Bevy ecosystem uses MIT/Apache but Bevy is a general-purpose framework, not a community-specific game engine)</li>
<li><strong>LGPL</strong> (rejected — complex, poorly understood by non-lawyers, and unnecessary given the explicit modding exception under GPL v3 § 7)</li>
<li><strong>Dual license (GPL + commercial)</strong> (rejected — adds complexity with no clear benefit; GPL v3 already permits commercial use)</li>
<li><strong>GPL v3 without modding exception</strong> (rejected — would leave legal ambiguity about WASM mods that might be interpreted as derivative works; the explicit exception removes all doubt)</li>
</ul>
<p><strong>What this means in practice:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Activity</th><th>Allowed?</th><th>Requirement</th></tr>
</thead>
<tbody>
<tr><td>Play the game</td><td>Yes</td><td>—</td></tr>
<tr><td>Create YAML/Lua/WASM mods</td><td>Yes</td><td>Any license you want (modding exception)</td></tr>
<tr><td>Publish mods on Workshop</td><td>Yes</td><td>Author chooses license (D030 requires SPDX declaration)</td></tr>
<tr><td>Sell a total conversion mod</td><td>Yes</td><td>Mod’s license is the author’s choice</td></tr>
<tr><td>Fork the engine</td><td>Yes</td><td>Your fork must also be GPL v3</td></tr>
<tr><td>Run a commercial server</td><td>Yes</td><td>If you modify the server code, share those modifications</td></tr>
<tr><td>Use IC code in a proprietary game</td><td>No</td><td>Engine modifications must be GPL v3</td></tr>
<tr><td>Embed IC engine in a closed-source launcher</td><td>Yes</td><td>The engine remains GPL v3; the launcher is separate</td></tr>
</tbody>
</table>
</div>
<h3 id="phase-3"><a class="header" href="#phase-3">Phase</a></h3>
<p>Resolved. The LICENSE file ships with the GPL v3 text plus the modding exception header from Phase 0 onward.</p>
<h2 id="d052-community-servers-with-portable-signed-credentials"><a class="header" href="#d052-community-servers-with-portable-signed-credentials">D052: Community Servers with Portable Signed Credentials</a></h2>
<p><strong>Decision:</strong> Multiplayer ranking, matchmaking, and competitive history are managed through <strong>Community Servers</strong> — self-hostable services that federate like Workshop sources (D030/D050). Player skill data is stored <strong>locally</strong> in a per-community SQLite credential file, with each record individually signed by the community server using Ed25519. The player presents the credential file when joining games; the server verifies its signature without needing to look up a central database. This is architecturally equivalent to JWT-style portable tokens, but uses a purpose-built binary format (<strong>Signed Credential Records</strong>, SCR) that eliminates the entire class of JWT vulnerabilities.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Server-side storage is expensive and fragile.</strong> A traditional ranking server must store every player’s rating, match history, and achievements — growing linearly with player count. A Community Server that only issues signed credentials can serve thousands of players from a $5/month VPS because it stores almost nothing. Player data lives on the player’s machine (in SQLite, per D034).</li>
<li><strong>Federation is already the architecture.</strong> D030/D050 proved that federated sources work for the Workshop. The same model works for multiplayer: players join communities like they subscribe to Workshop sources. Multiple communities coexist — an “Official IC” community, a clan community, a tournament community, a local LAN community. Each tracks its own independent rankings.</li>
<li><strong>Local-first matches the privacy design.</strong> D042 already stores player behavioral profiles locally. D034 uses SQLite for all persistent state. Keeping credential files local is the natural extension — players own their data, carry it between machines, and decide who sees it.</li>
<li><strong>The relay server already certifies match results.</strong> D007’s relay architecture produces <code>CertifiedMatchResult</code> (relay-signed match outcomes). The community server receives these, computes rating updates, and signs new credential records. The trust chain is: relay certifies the match happened → community server certifies the rating change.</li>
<li><strong>Self-hosting is a core principle.</strong> Any community can run its own server with its own ranking rules, its own matchmaking criteria, and its own competitive identity. The official IC community is just one of many, not a privileged singleton.</li>
</ul>
<h3 id="what-is-a-community-server"><a class="header" href="#what-is-a-community-server">What Is a Community Server?</a></h3>
<p>A Community Server is a unified service endpoint that provides any combination of:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Capability</th><th>Description</th><th>Existing Design</th></tr>
</thead>
<tbody>
<tr><td><strong>Workshop source</strong></td><td>Hosts and distributes mods</td><td>D030 federation, D050 library</td></tr>
<tr><td><strong>Game relay</strong></td><td>Hosts multiplayer game sessions</td><td>D007 relay server</td></tr>
<tr><td><strong>Ranking authority</strong></td><td>Tracks player ratings, signs credential records</td><td>D041 <code>RankingProvider</code> trait, <strong>this decision</strong></td></tr>
<tr><td><strong>Matchmaking service</strong></td><td>Matches players by skill, manages lobbies</td><td>P004 (partially resolved by this decision)</td></tr>
<tr><td><strong>Achievement authority</strong></td><td>Signs achievement unlock records</td><td>D036 achievement system</td></tr>
</tbody>
</table>
</div>
<p>Operators enable/disable each capability independently. A small clan community might run only relay + ranking. A large competitive community runs everything. The official IC community runs all five. The <code>ic-server</code> binary (see D049 § “Netcode ↔ Workshop Cross-Pollination”) bundles all capabilities into a single process with feature flags.</p>
<h3 id="signed-credential-records-scr--not-jwt"><a class="header" href="#signed-credential-records-scr--not-jwt">Signed Credential Records (SCR) — Not JWT</a></h3>
<p>Every player interaction with a community produces a <strong>Signed Credential Record</strong>: a compact binary blob signed by the community server’s Ed25519 private key. These records are stored in the player’s local SQLite credential file and presented to servers for verification.</p>
<p><strong>Why not JWT?</strong></p>
<p>JWT (RFC 7519) is the obvious choice for portable signed credentials, but it carries a decade of known vulnerabilities that IC deliberately avoids:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>JWT Vulnerability</th><th>How It Works</th><th>IC’s SCR Design</th></tr>
</thead>
<tbody>
<tr><td>Algorithm confusion (CVE-2015-9235)</td><td><code>alg</code> header tricks verifier into using wrong algorithm (e.g., RS256 key as HS256 secret)</td><td><strong>No algorithm field.</strong> Always Ed25519. Hardcoded in verifier, not read from token.</td></tr>
<tr><td><code>alg: none</code> bypass</td><td>JWT spec allows unsigned tokens; broken implementations accept them</td><td><strong>No algorithm negotiation.</strong> Signature always required, always Ed25519.</td></tr>
<tr><td>JWKS injection / <code>jku</code> redirect</td><td>Attacker injects keys via URL-based key discovery endpoints</td><td><strong>No URL-based key discovery.</strong> Community public key stored locally at join time. Key rotation uses signed rotation records.</td></tr>
<tr><td>Token replay</td><td>JWT has no built-in replay protection</td><td><strong>Monotonic sequence number</strong> per player per record type. Old sequences rejected.</td></tr>
<tr><td>No revocation</td><td>JWT valid until expiry; requires external blacklists</td><td><strong>Sequence-based revocation.</strong> “Revoke all sequences before N” = one integer per player. Tiny revocation list, not a full token blacklist.</td></tr>
<tr><td>Payload bloat</td><td>Base64(JSON) is verbose. Large payloads inflate HTTP headers.</td><td><strong>Binary format.</strong> No base64, no JSON. Typical record: ~200 bytes.</td></tr>
<tr><td>Signature stripping</td><td>Dot-separated <code>header.payload.signature</code> is trivially separable</td><td><strong>Opaque binary blob.</strong> Signature embedded at fixed offset after payload.</td></tr>
<tr><td>JSON parsing ambiguity</td><td>Duplicate keys, unicode escapes, number precision vary across parsers</td><td><strong>Not JSON.</strong> Deterministic binary serialization. Zero parsing ambiguity.</td></tr>
<tr><td>Cross-service confusion</td><td>JWT from Service A accepted by Service B</td><td><strong>Community key fingerprint embedded.</strong> Record signed by Community A verifiably differs from Community B.</td></tr>
<tr><td>Weak key / HMAC secrets</td><td>HS256 with short secrets is brute-forceable</td><td><strong>Ed25519 only.</strong> Asymmetric, 128-bit security level. No shared secrets.</td></tr>
</tbody>
</table>
</div>
<p><strong>SCR binary format:</strong></p>
<pre><code>┌─────────────────────────────────────────────────────┐
│  version          1 byte     (0x01)                 │
│  record_type      1 byte     (rating|match|ach|rev|keyrot) │
│  community_key    32 bytes   (Ed25519 public key)   │
│  player_key       32 bytes   (Ed25519 public key)   │
│  sequence         8 bytes    (u64 LE, monotonic)    │
│  issued_at        8 bytes    (i64 LE, Unix seconds) │
│  expires_at       8 bytes    (i64 LE, Unix seconds) │
│  payload_len      4 bytes    (u32 LE)               │
│  payload          variable   (record-type-specific)  │
│  signature        64 bytes   (Ed25519)              │
├─────────────────────────────────────────────────────┤
│  Total: 158 + payload_len bytes                     │
│  Signature covers: all bytes before signature       │
└─────────────────────────────────────────────────────┘
</code></pre>
<ul>
<li><strong><code>version</code></strong> — format version for forward compatibility. Start at 1. Version changes require reissuance.</li>
<li><strong><code>record_type</code></strong> — <code>0x01</code> = rating snapshot, <code>0x02</code> = match result, <code>0x03</code> = achievement, <code>0x04</code> = revocation, <code>0x05</code> = key rotation.</li>
<li><strong><code>community_key</code></strong> — the community server’s Ed25519 public key. Binds the record to exactly one community. Verification uses this key.</li>
<li><strong><code>player_key</code></strong> — the player’s Ed25519 public key. This IS the player’s identity within the community.</li>
<li><strong><code>sequence</code></strong> — monotonic per-player counter. Each new record increments it. Revocation is “reject all sequences below N.” This replaces JWT’s lack of revocation with an O(1) check.</li>
<li><strong><code>issued_at</code> / <code>expires_at</code></strong> — timestamps. Expired records require a server sync to refresh. Default expiry: 7 days for rating records, never for match/achievement records.</li>
<li><strong><code>payload</code></strong> — record-type-specific binary data (see below).</li>
<li><strong><code>signature</code></strong> — Ed25519 signature over all preceding bytes. Community server’s private key never leaves the server.</li>
</ul>
<h3 id="community-credential-store-sqlite"><a class="header" href="#community-credential-store-sqlite">Community Credential Store (SQLite)</a></h3>
<p>Each community a player belongs to gets a separate SQLite file in the player’s data directory:</p>
<pre><code>&lt;data_dir&gt;/communities/
  ├── official-ic.db          # Official community
  ├── clan-wolfpack.db        # Clan community
  └── tournament-2026.db      # Tournament community
</code></pre>
<p><strong>Schema:</strong></p>
<pre><code class="language-sql">-- Community identity (one row)
CREATE TABLE community_info (
    community_key   BLOB NOT NULL,     -- Current SK Ed25519 public key (32 bytes)
    recovery_key    BLOB NOT NULL,     -- RK Ed25519 public key (32 bytes) — cached at join
    community_name  TEXT NOT NULL,
    server_url      TEXT NOT NULL,      -- Community server endpoint
    key_fingerprint TEXT NOT NULL,      -- hex(SHA-256(community_key)[0..8])
    rk_fingerprint  TEXT NOT NULL,      -- hex(SHA-256(recovery_key)[0..8])
    sk_rotated_at   INTEGER,           -- when current SK was activated (null = original)
    joined_at       INTEGER NOT NULL,   -- Unix timestamp
    last_sync       INTEGER NOT NULL    -- Last successful server contact
);

-- Key rotation history (for audit trail and chain verification)
CREATE TABLE key_rotations (
    sequence        INTEGER PRIMARY KEY,
    old_key         BLOB NOT NULL,     -- retired SK public key
    new_key         BLOB NOT NULL,     -- replacement SK public key
    signed_by       TEXT NOT NULL,     -- 'signing_key' or 'recovery_key'
    reason          TEXT NOT NULL,     -- 'scheduled', 'migration', 'compromise', 'precautionary'
    effective_at    INTEGER NOT NULL,  -- Unix timestamp
    grace_until     INTEGER NOT NULL,  -- old key accepted until this time
    rotation_record BLOB NOT NULL      -- full signed rotation record bytes
);

-- Player identity within this community (one row)
CREATE TABLE player_info (
    player_key      BLOB NOT NULL,     -- Ed25519 public key (32 bytes)
    display_name    TEXT,
    avatar_hash     TEXT,              -- SHA-256 of avatar image (for cache / fetch)
    bio             TEXT,              -- short self-description (max 500 chars)
    title           TEXT,              -- earned/selected title (e.g., "Iron Commander")
    registered_at   INTEGER NOT NULL
);

-- Current ratings (latest signed snapshot per rating type)
CREATE TABLE ratings (
    game_module     TEXT NOT NULL,      -- 'ra', 'td', etc.
    rating_type     TEXT NOT NULL,      -- algorithm_id() from RankingProvider
    rating          INTEGER NOT NULL,   -- Fixed-point (e.g., 1500000 = 1500.000)
    deviation       INTEGER NOT NULL,   -- Glicko-2 RD, fixed-point
    volatility      INTEGER NOT NULL,   -- Glicko-2 σ, fixed-point
    games_played    INTEGER NOT NULL,
    sequence        INTEGER NOT NULL,
    scr_blob        BLOB NOT NULL,      -- Full signed SCR
    PRIMARY KEY (game_module, rating_type)
);

-- Match history (append-only, each row individually signed)
CREATE TABLE matches (
    match_id        BLOB PRIMARY KEY,   -- SHA-256 of match data
    sequence        INTEGER NOT NULL,
    played_at       INTEGER NOT NULL,
    game_module     TEXT NOT NULL,
    map_name        TEXT,
    duration_ticks  INTEGER,
    result          TEXT NOT NULL,       -- 'win', 'loss', 'draw', 'disconnect'
    rating_before   INTEGER,
    rating_after    INTEGER,
    opponents       BLOB,               -- Serialized: [{key, name, rating}]
    scr_blob        BLOB NOT NULL       -- Full signed SCR
);

-- Achievements (each individually signed)
CREATE TABLE achievements (
    achievement_id  TEXT NOT NULL,
    game_module     TEXT NOT NULL,
    unlocked_at     INTEGER NOT NULL,
    match_id        BLOB,               -- Which match triggered it (nullable)
    sequence        INTEGER NOT NULL,
    scr_blob        BLOB NOT NULL,
    PRIMARY KEY (achievement_id, game_module)
);

-- Revocation records (tiny — one per record type at most)
CREATE TABLE revocations (
    record_type         INTEGER NOT NULL,
    min_valid_sequence  INTEGER NOT NULL,
    scr_blob            BLOB NOT NULL,
    PRIMARY KEY (record_type)
);

-- Indexes for common queries
CREATE INDEX idx_matches_played_at ON matches(played_at DESC);
CREATE INDEX idx_matches_module ON matches(game_module);
</code></pre>
<p><strong>What the Community Server stores vs. what the player stores:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Data</th><th>Player’s SQLite</th><th>Community Server</th></tr>
</thead>
<tbody>
<tr><td>Player public key</td><td>Yes</td><td>Yes (registered members list)</td></tr>
<tr><td>Current rating</td><td>Yes (signed SCR)</td><td>Optionally cached for matchmaking</td></tr>
<tr><td>Full match history</td><td>Yes (signed SCRs)</td><td>No — only recent results queue for signing</td></tr>
<tr><td>Achievements</td><td>Yes (signed SCRs)</td><td>No</td></tr>
<tr><td>Revocation list</td><td>Yes (signed SCRs)</td><td>Yes (one integer per player per type)</td></tr>
<tr><td>Opponent profiles (D042)</td><td>Yes (local analysis)</td><td>No</td></tr>
<tr><td>Replay files</td><td>Yes (local)</td><td>No</td></tr>
</tbody>
</table>
</div>
<p>The community server’s persistent storage is approximately: <code>(player_count × 32 bytes key) + (player_count × 8 bytes revocation)</code> = ~40 bytes per player. A community of 10,000 players needs ~400KB of server storage. The matchmaking cache adds more, but it’s volatile (RAM only, rebuilt from player connections).</p>
<h3 id="verification-flow"><a class="header" href="#verification-flow">Verification Flow</a></h3>
<p>When a player joins a community game:</p>
<pre><code>┌──────────┐                              ┌──────────────────┐
│  Player  │  1. Connect + present        │  Community       │
│          │     latest rating SCR  ────► │  Server          │
│          │                              │                  │
│          │  2. Verify:                  │  • Ed25519 sig ✓ │
│          │     - signature valid?       │  • sequence ≥    │
│          │     - community_key = ours?  │    min_valid? ✓  │
│          │     - not expired?           │  • not expired ✓ │
│          │     - sequence ≥ min_valid?  │                  │
│          │                              │                  │
│          │  3. Accept into matchmaking  │  Place in pool   │
│          │     with verified rating ◄── │  at rating 1500  │
│          │                              │                  │
│          │  ... match plays out ...     │  Relay hosts game │
│          │                              │                  │
│          │  4. Match ends, relay        │  CertifiedMatch  │
│          │     certifies result   ────► │  Result received │
│          │                              │                  │
│          │  5. Server computes rating   │  RankingProvider  │
│          │     update, signs new SCRs   │  .update_ratings()│
│          │                              │                  │
│          │  6. Receive signed SCRs ◄──  │  New rating SCR  │
│          │     Store in local SQLite    │  + match SCR     │
└──────────┘                              └──────────────────┘
</code></pre>
<p><strong>Verification is O(1):</strong> One Ed25519 signature check (fast — ~15,000 verifications/sec on modern hardware), one integer comparison (sequence ≥ min_valid), one timestamp comparison (expires_at &gt; now). No database lookup required for the common case.</p>
<p><strong>Expired credentials:</strong> If a player’s rating SCR has expired (default 7 days since last server sync), the server reissues a fresh SCR after verifying the player’s identity (challenge-response with the player’s Ed25519 private key). This prevents indefinitely using stale ratings.</p>
<p><strong>New player flow:</strong> First connection to a community → server generates initial rating SCR (Glicko-2 default: 1500 ± 350) → player stores it locally. No pre-existing data needed.</p>
<p><strong>Offline play:</strong> Local games and LAN matches can proceed without a community server. Results are unsigned. When the player reconnects, unsigned match data can optionally be submitted for retroactive signing (server decides whether to honor it — tournament communities may reject unsigned results).</p>
<h3 id="server-side-validation-what-the-community-server-signs-and-why"><a class="header" href="#server-side-validation-what-the-community-server-signs-and-why">Server-Side Validation: What the Community Server Signs and Why</a></h3>
<p>A critical question: why should a community server sign anything? What prevents a player from feeding the server fake data and getting a signed credential for a match they didn’t play or a rating they didn’t earn?</p>
<p><strong>The answer: the community server never signs data it didn’t produce or verify itself.</strong> A player cannot walk up to the server with a claim (“I’m 1800 rated”) and get it signed. Every signed credential is the server’s own output — computed from inputs it trusts. This is analogous to a university signing a diploma: the university doesn’t sign because the student claims they graduated. It signs because it has records of every class the student passed.</p>
<p>Here is the full trust chain for every type of signed credential:</p>
<p><strong>Rating SCRs — the server computes the rating, not the player:</strong></p>
<pre><code>Player claims nothing about their rating. The flow is:

1. Two players connect to the relay for a match.
2. The relay (D007) forwards all orders between players (lockstep).
3. The match ends. Both clients report the outcome to the relay.
   - The relay requires BOTH clients to agree on the outcome
     (winner, loser, draw, disconnection). If they disagree,
     the relay flags the match as disputed and does not certify it.
   - For additional integrity, the relay can optionally run a headless
     sim (same deterministic code — Invariant #1) to independently
     verify the outcome. This is expensive but available for ranked
     matches on well-resourced servers.
4. The relay produces a CertifiedMatchResult:
   - Signed by the relay's own key
   - Contains: player keys, game module, map, duration,
     outcome (who won), order hashes, desync status
5. The community server receives the CertifiedMatchResult.
   - Verifies the relay signature (the community server trusts its
     own relay — they're the same process in the bundled deployment,
     or the operator explicitly configures which relay keys to trust).
6. The community server feeds the CertifiedMatchResult into
   RankingProvider::update_ratings() (D041).
7. The RankingProvider computes new Glicko-2 ratings from the
   match outcome + previous ratings.
8. The community server signs the new rating as an SCR.
9. The signed SCR is returned to both players.

At no point does the player provide rating data to the server.
The server computed the rating. The server signs its own computation.
</code></pre>
<p><strong>Match SCRs — the relay certifies the match happened:</strong></p>
<p>The community server signs a match record SCR containing the match metadata (players, map, outcome, duration). This data comes from the <code>CertifiedMatchResult</code> which the relay produced. The server doesn’t trust the player’s claim about the match — it trusts the relay’s attestation, because the relay was the network intermediary that observed every order in real time.</p>
<p><strong>Achievement SCRs — verification depends on context:</strong></p>
<p>Achievements are more nuanced because they can be earned in different contexts:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Context</th><th>How the server validates</th><th>Trust level</th></tr>
</thead>
<tbody>
<tr><td><strong>Multiplayer match</strong></td><td>Achievement condition cross-referenced with <code>CertifiedMatchResult</code> data. E.g., “Win 50 matches” — server counts its own signed match SCRs for this player. “Win under 5 minutes” — server checks match duration from the relay’s certified result.</td><td><strong>High</strong> — server validates against its own records</td></tr>
<tr><td><strong>Multiplayer in-game</strong></td><td>Relay attests that the achievement trigger fired during a live match (the trigger is part of the deterministic sim, so the relay can verify by running headless). Alternatively, both clients attest the trigger fired (same as match outcome consensus).</td><td><strong>High</strong> — relay-attested or consensus-verified</td></tr>
<tr><td><strong>Single-player (online)</strong></td><td>Player submits a replay file. Community server can fast-forward the replay (deterministic sim) to verify the achievement condition was met. Expensive but possible.</td><td><strong>Medium</strong> — replay-verified, but replay submission is voluntary</td></tr>
<tr><td><strong>Single-player (offline)</strong></td><td>Player claims the achievement with no server involvement. When reconnecting, the claim can be submitted with the replay for retroactive verification. Community policy decides whether to accept: casual communities may accept on trust, competitive communities may require replay proof.</td><td><strong>Low</strong> — self-reported unless replay-backed</td></tr>
</tbody>
</table>
</div>
<p>The community server’s policy for achievement signing is configurable per community:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum AchievementPolicy {
    /// Sign any achievement reported by the client (casual community).
    TrustClient,
    /// Sign only achievements backed by a CertifiedMatchResult
    /// or relay attestation (competitive community).
    RequireRelayAttestation,
    /// Sign only if a replay is submitted and server-side verification
    /// confirms the achievement condition (strictest, most expensive).
    RequireReplayVerification,
}
<span class="boring">}</span></code></pre>
<p>Most communities will use <code>RequireRelayAttestation</code> for multiplayer achievements and <code>TrustClient</code> for single-player achievements. The achievement SCR includes a <code>verification_level</code> field so viewers know how the achievement was validated.</p>
<p><strong>Player registration — identity binding and Sybil resistance:</strong></p>
<p>When a player first connects to a community, the community server must decide: should I register this person? What stops one person from creating 100 accounts to game the rating system?</p>
<p>Registration is the one area where the community server does NOT have a relay to vouch for the data. The player is presenting themselves for the first time. The server’s defenses are layered:</p>
<p><strong>Layer 1 — Cryptographic identity (always):</strong></p>
<p>The player presents their Ed25519 public key. The server challenges them to sign a nonce, proving they hold the private key. This establishes <em>key ownership</em>, not <em>personhood</em>. One person can generate infinite keypairs.</p>
<p><strong>Layer 2 — Rate limiting (always):</strong></p>
<p>The server rate-limits new registrations by IP address (e.g., max 3 new accounts per IP per day). This slows mass account creation without requiring any identity verification.</p>
<p><strong>Layer 3 — Reputation bootstrapping (always):</strong></p>
<p>New accounts start at the default rating (Glicko-2: 1500 ± 350) with zero match history. The high deviation (± 350) means the system is uncertain about their skill — it will adjust rapidly over the first ~20 matches. A smurf creating a new account to grief low-rated players will be rated out of the low bracket within a few matches.</p>
<p>Fresh accounts carry no weight in the trust system (D053): they have no signed credentials, no community memberships, no achievement history. The “Verified only” lobby filter (D053 trust-based filtering) excludes players without established credential history — exactly the accounts a Sybil attacker would create.</p>
<p><strong>Layer 4 — Platform binding (optional, configurable per community):</strong></p>
<p>Community servers can require linking a platform account (Steam, GOG, etc.) at registration. This provides real Sybil resistance — Steam accounts have purchase history, play time, and cost money. The community server doesn’t verify the platform directly (it’s not a Steam partner). Instead, it asks the player’s IC client to provide a platform-signed attestation of account ownership (e.g., a Steam Auth Session Ticket). The server verifies the ticket against the platform’s public API.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum RegistrationPolicy {
    /// Anyone with a valid keypair can register. Lowest friction.
    Open,
    /// Require a valid platform account (Steam, GOG, etc.).
    RequirePlatform(Vec&lt;PlatformId&gt;),
    /// Require a vouching invite from an existing member.
    RequireInvite,
    /// Require solving a challenge (CAPTCHA, email verification, etc.).
    RequireChallenge(ChallengeType),
    /// Combination: e.g., platform OR invite.
    AnyOf(Vec&lt;RegistrationPolicy&gt;),
}
<span class="boring">}</span></code></pre>
<p><strong>Layer 5 — Community-specific policies (optional):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Policy</th><th>Description</th><th>Use case</th></tr>
</thead>
<tbody>
<tr><td><strong>Email verification</strong></td><td>Player provides email, server sends confirmation link. One account per email.</td><td>Medium-security communities</td></tr>
<tr><td><strong>Invite-only</strong></td><td>Existing members generate invite codes. New players must have a code.</td><td>Clan servers, private communities</td></tr>
<tr><td><strong>Vouching</strong></td><td>An existing member in good standing (e.g., 100+ matches, no bans) vouches for the new player. If the new player cheats, the voucher’s reputation is penalized too.</td><td>Competitive leagues</td></tr>
<tr><td><strong>Probation period</strong></td><td>New accounts are marked “probationary” for their first N matches (e.g., 10). Probationary players can’t play ranked, can’t join “Verified only” rooms, and their achievements aren’t signed until probation ends.</td><td>Balances accessibility with fraud prevention</td></tr>
</tbody>
</table>
</div>
<p>These policies are <strong>per-community</strong>. The Official IC Community might use <code>RequirePlatform(Steam) + Probation(10 matches)</code>. A clan server uses <code>RequireInvite</code>. A casual LAN community uses <code>Open</code>. IC doesn’t impose a single registration policy — it provides the building blocks and lets community operators assemble the policy that fits their community’s threat model.</p>
<p><strong>Summary — what the server validates before signing each SCR type:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>SCR Type</th><th>Server validates…</th><th>Trust anchor</th></tr>
</thead>
<tbody>
<tr><td>Rating</td><td>Computed by the server itself from relay-certified match results</td><td>Server’s own computation</td></tr>
<tr><td>Match result</td><td>Relay-signed <code>CertifiedMatchResult</code> (both clients agreed on outcome)</td><td>Relay attestation</td></tr>
<tr><td>Achievement (MP)</td><td>Cross-referenced with match data or relay attestation</td><td>Relay + server records</td></tr>
<tr><td>Achievement (SP)</td><td>Replay verification (if required by community policy)</td><td>Replay determinism</td></tr>
<tr><td>Membership</td><td>Registration policy (platform binding, invite, challenge, etc.)</td><td>Community policy</td></tr>
</tbody>
</table>
</div>
<p>The community server is <strong>not</strong> a rubber stamp. It is a <strong>validation authority</strong> that only signs credentials it can independently verify or that it computed itself. The player never provides the data that gets signed — the data comes from the relay, the ranking algorithm, or the community’s own registration policy.</p>
<h3 id="matchmaking-design"><a class="header" href="#matchmaking-design">Matchmaking Design</a></h3>
<p>The community server’s matchmaking uses verified ratings from presented SCRs:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Matchmaking pool entry — one per connected player seeking a game.
pub struct MatchmakingEntry {
    pub player_key: Ed25519PublicKey,
    pub verified_rating: PlayerRating,    // From verified SCR
    pub game_module: GameModuleId,        // What game they want to play
    pub preferences: MatchPreferences,    // Map pool, team size, etc.
    pub queue_time: Instant,              // When they started searching
}

/// Server-side matchmaking loop (simplified).
fn matchmaking_tick(pool: &amp;mut Vec&lt;MatchmakingEntry&gt;, provider: &amp;dyn RankingProvider) {
    // Sort by queue time (longest-waiting first)
    pool.sort_by_key(|e| e.queue_time);
    
    for candidate_pair in pool.windows(2) {
        let quality = provider.match_quality(
            &amp;[candidate_pair[0].verified_rating],
            &amp;[candidate_pair[1].verified_rating],
        );
        
        if quality.fairness &gt; FAIRNESS_THRESHOLD || queue_time_exceeded(candidate_pair) {
            // Accept match — create lobby
            create_lobby(candidate_pair);
        }
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Matchmaking widens over time:</strong> Initial search window is tight (±100 rating). After 30 seconds, widens to ±200. After 60 seconds, ±400. After 120 seconds, accepts any match. This prevents indefinite queues for players at rating extremes.</p>
<p><strong>Team games:</strong> For 2v2+ matchmaking, the server balances team average ratings. Each player’s SCR is individually verified. Team rating = average of individual Glicko-2 ratings.</p>
<h3 id="lobby--room-discovery"><a class="header" href="#lobby--room-discovery">Lobby &amp; Room Discovery</a></h3>
<p>Matchmaking (above) handles competitive/ranked play. But most RTS games are casual — “join my friend’s game,” “let’s play a LAN match,” “come watch my stream and play.” These need a room-based lobby with low-friction discovery. IC provides five discovery tiers, from zero-infrastructure to full game browser. Every tier works on every platform (desktop, browser, mobile — Invariant #10).</p>
<p><strong>Tier 0 — Direct Connect (IP:port)</strong></p>
<p>Always available, zero external dependency. Type an IP address and port, connect. Works on LAN, works over internet with port forwarding. This is the escape hatch — if every server is down, two players with IP addresses can still play.</p>
<pre><code>ic play connect 192.168.1.42:7400
</code></pre>
<p>For P2P lockstep (no relay), the host IS the connection target. For relay-hosted games, this is the relay’s address. No discovery mechanism needed — you already know where to go.</p>
<p><strong>Tier 1 — Room Codes (Among Us pattern, decentralized)</strong></p>
<p>When a host creates a room on any relay or community server, the server assigns a short alphanumeric code. Share it verbally, paste it in Discord, text it to a friend.</p>
<pre><code>Room code: TKR-4N7
</code></pre>
<p><strong>Code format:</strong></p>
<ul>
<li>6 characters from an unambiguous set: <code>23456789ABCDEFGHJKMNPQRSTUVWXYZ</code> (30 chars, excludes 0/O, 1/I/L)</li>
<li>Displayed as <code>XXX-XXX</code> for readability</li>
<li>30^6 ≈ 729 million combinations — more than enough</li>
<li>Case-insensitive input (the UI uppercases automatically)</li>
<li>Codes are ephemeral — exist only in server memory, expire when the room closes + 5-minute grace</li>
</ul>
<p><strong>Resolution:</strong> Player enters the code in-game. The client queries all configured community servers in parallel (typically 1–3 HTTP requests). Whichever server recognizes the code responds with connection info (relay address + room ID + required resources). No central “code directory” — every community server manages its own code namespace. Collision across communities is fine because clients verify the code against the responding server.</p>
<pre><code>ic play join TKR-4N7
</code></pre>
<p><strong>Why Among Us-style codes?</strong> Among Us popularized this pattern because it works for exactly the scenario IC targets: you’re in a voice call, someone says “join TKR-4N7,” everyone types it in 3 seconds. No URLs, no IP addresses, no friend lists. The friction is nearly zero. For an RTS with 2–8 players, this is the sweet spot.</p>
<p><strong>Tier 2 — QR Code</strong></p>
<p>The host’s client generates a QR code that encodes a deep link URI:</p>
<pre><code>ironcurtain://join/community.example.com/TKR-4N7
</code></pre>
<p>Scanning the QR code opens the IC client (or the browser version on mobile) and auto-joins the room. Perfect for:</p>
<ul>
<li><strong>LAN parties:</strong> Display QR on the host’s screen. Everyone scans with their phone/tablet to join via browser client.</li>
<li><strong>Couch co-op:</strong> Scan from a phone to open the WASM browser client on a second device.</li>
<li><strong>Streaming:</strong> Overlay QR on stream → viewers scan to join or spectate.</li>
<li><strong>In-person events / tournaments:</strong> Print QR on table tents.</li>
</ul>
<p>The QR code is regenerated if the room code changes (e.g., room migrates to a different relay). The deep link URI scheme (<code>ironcurtain://</code>) is registered on desktop; on platforms without scheme registration, the QR can encode an HTTPS URL (<code>https://play.ironcurtain.gg/join/TKR-4N7</code>) that redirects to the client or browser version.</p>
<p><strong>Tier 3 — Game Browser</strong></p>
<p>Community servers publish their active rooms to a room listing API. The in-game browser aggregates listings from all configured communities — the same federation model as Workshop source aggregation.</p>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│  Game Browser                                    [Refresh]  │
├──────────────┬──────┬─────────┬────────┬──────┬─────────────┤
│ Room Name    │ Host │ Players │ Map    │ Ping │ Mods        │
├──────────────┼──────┼─────────┼────────┼──────┼─────────────┤
│ Casual 1v1   │ cmdr │ 1/2     │ Arena  │ 23ms │ none        │
│ HD Mod Game  │ alice│ 3/4     │ Europe │ 45ms │ hd-pack 2.1 │
│ Newbies Only │ bob  │ 2/6     │ Desert │ 67ms │ none        │
└──────────────┴──────┴─────────┴────────┴──────┴─────────────┘
</code></pre>
<p>Filter by: game module (RA/TD), map, player count, ping, mods required, community, password protected. Sort by any column. Auto-refresh on configurable interval.</p>
<p>This is the traditional server browser experience (OpenRA has this, Quake had this, every classic RTS had this). It coexists with room codes — a room visible in the browser also has a room code.</p>
<p><strong>Tier 4 — Matchmaking Queue (D052)</strong></p>
<p>Already designed above. Player enters a queue; community server matches by rating. This creates rooms automatically — the player never sees a room code or browser.</p>
<p><strong>Tier 5 — Deep Links / Invites</strong></p>
<p>The <code>ironcurtain://join/...</code> URI scheme works as a clickable link anywhere that supports URI schemes:</p>
<ul>
<li>Discord: paste <code>ironcurtain://join/official.ironcurtain.gg/TKR-4N7</code> → click to join</li>
<li>Browser: HTTPS fallback URL redirects to client or opens browser WASM version</li>
<li>Steam: Steam rich presence integration → “Join Game” button on friend’s profile</li>
<li>In-game friends list (if implemented): one-click invite sends a deep link</li>
</ul>
<p><strong>Discovery summary:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Tier</th><th>Mechanism</th><th>Requires Server?</th><th>Best For</th><th>Friction</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Direct IP:port</td><td>No</td><td>LAN, development, fallback</td><td>High (must know IP)</td></tr>
<tr><td>1</td><td>Room codes</td><td>Yes (any relay/community)</td><td>Friends, voice chat, casual</td><td>Very low (6 chars)</td></tr>
<tr><td>2</td><td>QR code</td><td>Yes (same as room code)</td><td>LAN parties, streaming, mobile</td><td>Near zero (scan)</td></tr>
<tr><td>3</td><td>Game browser</td><td>Yes (community servers)</td><td>Finding public games</td><td>Low (browse + click)</td></tr>
<tr><td>4</td><td>Matchmaking</td><td>Yes (community server)</td><td>Competitive/ranked</td><td>Zero (press “Play”)</td></tr>
<tr><td>5</td><td>Deep links</td><td>Yes (same as room code)</td><td>Discord, web, social</td><td>Near zero (click)</td></tr>
</tbody>
</table>
</div>
<p>Tiers 0–2 work with a single self-hosted relay (a $5 VPS or even localhost). No official infrastructure required. Tiers 3–4 require community servers. Tier 5 requires URI scheme registration (desktop) or an HTTPS redirect service (browser).</p>
<h3 id="lobby-communication"><a class="header" href="#lobby-communication">Lobby Communication</a></h3>
<p>Once players are in a room, they need to communicate — coordinate strategy before the game, socialize, discuss map picks, or just talk. IC provides text chat, voice chat, and visible player identity in every lobby.</p>
<p><strong>Text Chat</strong></p>
<p>All lobby text messages are routed through the relay server (or host in P2P mode) — the same path as game orders. This keeps the trust model consistent: the relay timestamps and sequences messages, making chat moderation actions deterministic and auditable.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Lobby chat message — part of the room protocol, not the sim protocol.
/// Routed through the relay alongside PlayerOrders but on a separate
/// logical channel (not processed by ic-sim).
pub struct LobbyMessage {
    pub sender: PlayerId,
    pub channel: ChatChannel,
    pub content: String,         // UTF-8, max 500 bytes
    pub timestamp: u64,          // relay-assigned, not client-claimed
}

pub enum ChatChannel {
    All,                         // Everyone in the room sees it
    Team(TeamId),                // Team-only (pre-game team selection)
    Whisper(PlayerId),           // Private message to one player
    System,                      // Join/leave/kick notifications (server-generated)
}
<span class="boring">}</span></code></pre>
<p><strong>Chat features:</strong></p>
<ul>
<li><strong>Rate limiting:</strong> Max 5 messages per 3 seconds per player. Prevents spam flooding.</li>
<li><strong>Message length:</strong> Max 500 bytes UTF-8. Long enough for tactical callouts, short enough to prevent wall-of-text abuse.</li>
<li><strong>Host moderation:</strong> Room host can mute individual players (host sends a <code>MutePlayer</code> command; relay enforces). Muted players’ messages are silently dropped by the relay — other clients never receive them.</li>
<li><strong>Persistent for room lifetime:</strong> Chat history is available to newly joining players (last 50 messages). When the room closes, chat is discarded — no server-side chat logging.</li>
<li><strong>In-game chat:</strong> During gameplay, the same chat system operates. <code>All</code> channel becomes <code>Spectator</code> for observers. <code>Team</code> channel carries strategic communication. A configurable <code>AllChat</code> toggle (default: disabled in ranked) controls whether opponents can see your messages during a match.</li>
<li><strong>Links and formatting:</strong> URLs are clickable (opens external browser). No rich text — plain text only. This prevents injection attacks and keeps the UI simple.</li>
<li><strong>Emoji:</strong> Standard Unicode emoji are rendered natively. No custom emoji system — keep it simple.</li>
<li><strong>Block list:</strong> Players can block others locally. Blocked players’ messages are filtered client-side (not server-enforced — the relay doesn’t need to know your block list). Block persists across sessions in local SQLite (D034).</li>
</ul>
<p><strong>In-game chat UI:</strong></p>
<pre><code>┌──────────────────────────────────────────────┐
│ [All] [Team]                          [Hide] │
├──────────────────────────────────────────────┤
│ [SYS] alice joined the room                  │
│ [cmdr] gg ready when you are                 │
│ [alice] let's go desert map?                 │
│ [bob] 👍                                      │
│                                              │
├──────────────────────────────────────────────┤
│ [Type message...]                    [Send]  │
└──────────────────────────────────────────────┘
</code></pre>
<p>The chat panel is collapsible (hotkey: Enter to open, Escape to close — standard RTS convention). During gameplay, it overlays transparently so it doesn’t obscure the battlefield.</p>
<p><strong>Voice Chat</strong></p>
<p>IC includes built-in voice communication using WebRTC peer-to-peer audio. Voice data never touches the sim — it’s a purely transport-layer feature with zero determinism impact.</p>
<p><strong>Architecture:</strong></p>
<pre><code>┌────────┐  WebRTC audio  ┌────────┐
│Player A│◄──────────────►│Player B│
│        │                │        │
│        │  WebRTC audio  │        │
│        │◄──────────────►│Player C│
└────────┘                └────────┘
     ▲                         ▲
     │    Signaling only       │
     └────── Relay Server ─────┘
</code></pre>
<ul>
<li><strong>Peer-to-peer audio:</strong> Voice data flows directly between players via WebRTC (Opus codec, ~32 kbps per stream). The relay server handles only signaling (ICE candidate exchange, session negotiation) — it never processes audio data. This keeps relay costs minimal.</li>
<li><strong>TURN fallback:</strong> For players behind strict NATs where P2P fails, the relay server can act as a TURN relay for voice. This adds bandwidth cost but ensures voice always works. Community server operators can disable TURN to save bandwidth.</li>
<li><strong>Push-to-talk (default):</strong> RTS players need both hands on mouse/keyboard during games. Push-to-talk avoids accidental transmission of keyboard clatter, breathing, and background noise. Default keybind: <code>V</code>. Voice activation mode available in settings for players who prefer it.</li>
<li><strong>Per-player volume:</strong> Each player’s voice volume is adjustable independently (right-click their name in the player list → volume slider). Mute individual players with one click.</li>
<li><strong>Voice channels:</strong> Mirror text chat channels — All, Team. During gameplay, voice defaults to Team-only to prevent leaking strategy to opponents. Spectators have their own voice channel.</li>
<li><strong>Codec:</strong> Opus (standard WebRTC codec). 32 kbps mono is sufficient for clear voice in a game context. Total bandwidth for a full 8-player lobby: ~224 kbps (7 incoming streams × 32 kbps) — negligible compared to game traffic.</li>
<li><strong>Browser (WASM) support:</strong> WebRTC is native to browsers, so voice chat works in the WASM build without additional libraries. Desktop builds use <code>webrtc-rs</code> or platform-native WebRTC bindings.</li>
</ul>
<p><strong>Voice UI indicators:</strong></p>
<pre><code>┌────────────────────────┐
│ Players:               │
│  🔊 cmdr (host)   1800 │  ← speaking indicator
│  🔇 alice         1650 │  ← muted by self
│  🎤 bob           1520 │  ← has mic, not speaking
│  📵 carol         ---- │  ← voice disabled
└────────────────────────┘
</code></pre>
<p>Speaking indicators appear next to player names in the lobby and during gameplay (small icon on the player’s color bar in the sidebar). This lets players see who’s talking at a glance.</p>
<p><strong>Privacy and safety:</strong></p>
<ul>
<li>Voice is opt-in. Players can disable voice entirely in settings. The client never activates the microphone without explicit user action (push-to-talk press or voice activation toggle).</li>
<li>No voice recording by the relay or community server. Voice streams are ephemeral.</li>
<li>Abusive voice users can be muted by any player (locally) or by the host (server-enforced kick from voice channel).</li>
<li>Ranked/competitive rooms can enforce “no voice” or “team-voice-only” policies.</li>
</ul>
<p><strong>When external voice is better:</strong> IC’s built-in voice is designed for casual lobbies, LAN parties, and pickup games where players don’t have a pre-existing Discord/TeamSpeak. Competitive teams will continue using external voice (lower latency, better quality, persistent channels). IC doesn’t try to replace Discord — it provides a frictionless default for when Discord isn’t set up.</p>
<p><strong>Player Identity in Lobby</strong></p>
<p>Every player in a lobby is visible with their profile identity — not just a text name. The lobby player list shows:</p>
<ul>
<li><strong>Avatar:</strong> Small profile image (32×32 in list, 64×64 on hover/click). Sourced from the player’s profile (see D053).</li>
<li><strong>Display name:</strong> The player’s chosen name. If the player has a community-verified identity (D052 SCR), a small badge appears next to the name indicating which community verified them.</li>
<li><strong>Rating badge:</strong> If the room is on a community server, the player’s verified rating for the relevant game module is shown (from their presented SCR). Unranked players show “—”.</li>
<li><strong>Presence indicators:</strong> Microphone status, ready state, download progress (if syncing resources).</li>
</ul>
<p>Clicking a player’s name in the lobby opens a <strong>profile card</strong> — a compact view of their player profile (D053) showing avatar, bio, recent achievements, win rate, and community memberships. This lets players gauge each other before a match without leaving the lobby.</p>
<p><strong>Updated lobby UI with communication:</strong></p>
<pre><code>┌──────────────────────────────────────────────────────────────────────┐
│  Room: TKR-4N7  —  Map: Desert Arena  —  RA1 Classic Balance       │
├──────────────────────────────────┬───────────────────────────────────┤
│  Players                         │  Chat [All ▾]                    │
│  ┌──┐ 🔊 cmdr (host)   ⭐ 1800  │  [SYS] Room created              │
│  │🎖│ Ready                      │  [cmdr] hey all, gg              │
│  └──┘                            │  [alice] glhf!                   │
│  ┌──┐ 🎤 alice         ⭐ 1650  │  [SYS] bob joined                │
│  │👤│ Ready                      │  [bob] yo what map?              │
│  └──┘                            │  [cmdr] desert arena, classic    │
│  ┌──┐ 🎤 bob           ⭐ 1520  │  [bob] 👍                         │
│  │👤│ ⬇️ Syncing 67%             │                                  │
│  └──┘                            │                                  │
│  ┌──┐ 📵 carol          ----    │                                  │
│  │👤│ Connecting...              ├───────────────────────────────────┤
│  └──┘                            │ [Type message...]        [Send]  │
├──────────────────────────────────┴───────────────────────────────────┤
│  Mods: alice/hd-sprites@2.0, bob/desert-map@1.1                     │
│  [Settings]  [Invite]  [Start Game] (waiting for all players)       │
└──────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>The left panel shows players with avatars (small square icons), voice status, community rating badges, and ready state. The right panel is the chat. The layout adapts to screen size (D032 responsive UI) — on narrow screens, chat slides below the player list.</p>
<p><strong>Phase:</strong> Text chat ships with lobby implementation (Phase 5). Voice chat Phase 5–6a. Profile images in lobby require D053 (Player Profile, Phase 3–5).</p>
<h3 id="in-lobby-p2p-resource-sharing"><a class="header" href="#in-lobby-p2p-resource-sharing">In-Lobby P2P Resource Sharing</a></h3>
<p>When a player joins a room that requires resources (mods, maps, resource packs) they don’t have locally, the lobby becomes a P2P swarm for those resources. The relay server (or host in P2P mode) acts as the tracker. This is the existing D049 P2P protocol scoped to a single lobby’s resource list.</p>
<p><strong>Flow:</strong></p>
<pre><code>Host creates room
  → declares required: [alice/hd-sprites@2.0, bob/desert-map@1.1]
  → host seeds both resources

Player joins room
  → receives resource list with SHA-256 from Workshop index
  → checks local cache: has alice/hd-sprites@2.0 ✓, missing bob/desert-map@1.1 ✗

  → Step 1: Verify resource exists in a known Workshop source
    Client fetches manifest for bob/desert-map@1.1 from Workshop index
    (git-index HTTP fetch or Workshop server API)
    Gets: SHA-256, manifest_hash, size, dependencies
    If resource NOT in any configured Workshop source → REFUSE download
    (prevents arbitrary file transfer — Workshop index is the trust anchor)

  → Step 2: Join lobby resource swarm
    Relay/host announces available peers for bob/desert-map@1.1
    Download via BitTorrent protocol from:
      Priority 1: Other lobby players who already have it (lowest latency)
      Priority 2: Workshop P2P swarm (general seeders)
      Priority 3: Workshop HTTP fallback (CDN/GitHub Releases)

  → Step 3: Verify
    SHA-256 of downloaded .icpkg matches Workshop index manifest ✓
    manifest_hash of internal manifest.yaml matches index ✓
    (Same verification chain as regular Workshop install — see V20)

  → Step 4: Report ready
    Client signals lobby: "all resources verified, ready to play"

All players ready → countdown → game starts
</code></pre>
<p><strong>Lobby UI during resource sync:</strong></p>
<pre><code>┌────────────────────────────────────────────────┐
│  Room: TKR-4N7  —  Waiting for players...      │
├────────────────────────────────────────────────┤
│  ✅ cmdr (host)     Ready                       │
│  ✅ alice           Ready                        │
│  ⬇️ bob             Downloading 2/3 resources   │
│     └─ bob/desert-map@1.1  [████░░░░] 67%  P2P │
│     └─ alice/hd-dialog@1.0 [██████░░] 82%  P2P │
│  ⏳ carol           Connecting...                │
├────────────────────────────────────────────────┤
│  Required: alice/hd-sprites@2.0, bob/desert-    │
│  map@1.1, alice/hd-dialog@1.0                   │
│  [Start Game]  (waiting for all players)        │
└────────────────────────────────────────────────┘
</code></pre>
<p><strong>The host-as-tracker model:</strong></p>
<p>For relay-hosted games (the default), the relay IS the tracker — it already manages all connections in the room. It maintains an in-memory peer table: which players have which resources. When a new player joins and needs resources, the relay tells them which peers can seed. This is trivial — a <code>HashMap&lt;ResourceId, Vec&lt;PeerId&gt;&gt;</code> that lives only as long as the room exists.</p>
<p>For P2P games (no relay, LAN): the host’s game client runs a minimal tracker. Same data structure, same protocol, just embedded in the game client instead of a separate relay process. The host was already acting as the game’s connection coordinator — adding resource tracking is marginal.</p>
<p><strong>Security model — preventing malicious content transfer:</strong></p>
<p>The critical constraint: <strong>only Workshop-published resources can be shared in a lobby.</strong> The lobby declares resources by their Workshop identity (<code>publisher/package@version</code>), not by arbitrary file paths. The security chain:</p>
<ol>
<li><strong>Workshop index is the trust anchor.</strong> Every resource has a SHA-256 and <code>manifest_hash</code> recorded in a Workshop index (git-index with signed commits or Workshop server API). The client must be able to look up the resource in a known Workshop source before downloading.</li>
<li><strong>Content verification is mandatory.</strong> After download, the client verifies SHA-256 (full package) and <code>manifest_hash</code> (internal manifest) against the Workshop index — not against the host’s claim. Even if every other player in the lobby is malicious, a single honest Workshop index protects the downloading player.</li>
<li><strong>Unknown resources are refused.</strong> If a room requires <code>evil/malware@1.0</code> and that doesn’t exist in any Workshop source the player has configured, the client refuses to download and warns: “Resource not found in any configured Workshop source. Add the community’s Workshop source or leave the lobby.”</li>
<li><strong>No arbitrary file transfer.</strong> The P2P protocol only transfers <code>.icpkg</code> archives that match Workshop-published checksums. There is no mechanism for peers to push arbitrary files — the protocol is pull-only and content-addressed.</li>
<li><strong>Mod sandbox limits blast radius.</strong> Even a resource that passes all integrity checks is still subject to WASM capability sandbox (D005), Lua execution limits (D004), and YAML schema validation (D003). A malicious mod that sneaks past Workshop review can at most affect gameplay within its declared capabilities.</li>
<li><strong>Post-install scanning (Phase 6a+).</strong> When a resource is auto-downloaded in a lobby, the client checks for Workshop security advisories (V18) before loading it. If the resource version has a known advisory → warn the player before proceeding.</li>
</ol>
<p><strong>What about custom maps not on the Workshop?</strong></p>
<p>For early phases (before Workshop exists) or for truly private content: the host can share a map file by embedding it in the room’s initial payload (small maps are &lt;1MB). The receiving client:</p>
<ul>
<li>Must explicitly accept (“Host wants to share a custom map not published on Workshop. Accept? [Yes/No]”)</li>
<li>The file is verified for format validity (must parse as a valid IC map) but has no Workshop-grade integrity chain</li>
<li>These maps are quarantined (loaded but not added to the player’s Workshop cache)</li>
<li>This is the “developer/testing” escape hatch — not the normal flow</li>
</ul>
<p>This escape hatch is disabled by default in competitive/ranked rooms (community servers can enforce “Workshop-only” policies).</p>
<p><strong>Bandwidth and timing:</strong></p>
<p>The lobby applies D049’s <code>lobby-urgent</code> priority tier — auto-downloads preempt background Workshop activity and get full available bandwidth. Combined with the lobby swarm (host + ready players all seeding), typical resource downloads complete in seconds for common mods (&lt;50MB). The download timer can be configured per-community: tournament servers might set a 60-second download window, casual rooms wait indefinitely.</p>
<p>If a player’s download is too slow (configurable threshold, e.g., 5 minutes), the lobby UI offers: “Download taking too long. [Keep waiting] [Download in background and spectate] [Leave lobby]”.</p>
<p><strong>Local resource lifecycle:</strong> Resources downloaded via lobby P2P are tagged as <strong>transient</strong> (not pinned). They remain fully functional but auto-clean after <code>transient_ttl_days</code> (default 30 days) of non-use. After the session, a post-match toast offers: “[Pin] [Auto-clean in 30 days] [Remove now]”. Frequently-used lobby resources (3+ sessions) are automatically promoted to pinned. See D030 § “Local Resource Management” for the full lifecycle.</p>
<p>Default: <strong>Glicko-2</strong> (already specified in D041 as <code>Glicko2Provider</code>).</p>
<p>Why Glicko-2 over alternatives:</p>
<ul>
<li><strong>Rating deviation</strong> naturally models uncertainty. New players have wide confidence intervals (RD ~350); experienced players have narrow ones (RD ~50). Matchmaking can use RD to avoid matching a highly uncertain new player against a stable veteran.</li>
<li><strong>Inactivity decay:</strong> RD increases over time without play. A player who hasn’t played in months is correctly modeled as “uncertain” — their first few games back will move their rating significantly, then stabilize.</li>
<li><strong>Open and unpatented.</strong> TrueSkill (Microsoft) and TrueSkill 2 are patented. Glicko-2 is published freely by Mark Glickman.</li>
<li><strong>Lichess uses it.</strong> Proven at scale in a competitive community with similar dynamics (skill-based 1v1 with occasional team play).</li>
<li><strong>RankingProvider trait (D041)</strong> makes this swappable. Communities that want Elo, or a league/tier system, or a custom algorithm, implement the trait.</li>
</ul>
<p><strong>Rating storage in SCR payload</strong> (record_type = 0x01, rating snapshot):</p>
<pre><code>rating payload:
  game_module_len   1 byte
  game_module       variable (UTF-8)
  algorithm_id_len  1 byte
  algorithm_id      variable (UTF-8, e.g., "glicko2")
  rating            8 bytes (i64 LE, fixed-point × 1000)
  deviation         8 bytes (i64 LE, fixed-point × 1000)
  volatility        8 bytes (i64 LE, fixed-point × 1000000)
  games_played      4 bytes (u32 LE)
  wins              4 bytes (u32 LE)
  losses            4 bytes (u32 LE)
  draws             4 bytes (u32 LE)
  streak_current    2 bytes (i16 LE, positive = win streak)
  rank_position     4 bytes (u32 LE, 0 = unranked)
  percentile        2 bytes (u16 LE, 0-1000 = 0.0%-100.0%)
</code></pre>
<h3 id="key-lifecycle"><a class="header" href="#key-lifecycle">Key Lifecycle</a></h3>
<h4 id="key-identification"><a class="header" href="#key-identification">Key Identification</a></h4>
<p>Every Ed25519 public key — player or community — has a <strong>key fingerprint</strong> for human reference:</p>
<pre><code>Fingerprint = SHA-256(public_key)[0..8], displayed as 16 hex chars
Example:     3f7a2b91e4d08c56
</code></pre>
<p>The fingerprint is a display convenience. Internally, the full 32-byte public key is the canonical identifier (stored in SCRs, credential tables, etc.). Fingerprints appear in the UI for key verification dialogs, rotation notices, and trust management screens.</p>
<p>Why 8 bytes (64 bits) instead of GPG-style 4-byte short IDs? GPG short key IDs (32 bits) famously suffered birthday-attack collisions — an attacker could generate a key with the same 4-byte fingerprint in minutes. 8 bytes requires ~2^32 key generations to find a collision — far beyond practical for the hobbyist community operators IC targets. For cryptographic operations, the full 32-byte key is always used; the fingerprint is only for human eyeball verification.</p>
<h4 id="player-keys"><a class="header" href="#player-keys">Player Keys</a></h4>
<ul>
<li>Generated on first community join. Ed25519 keypair stored encrypted (AEAD with user passphrase) in the player’s local config.</li>
<li>The same keypair CAN be reused across communities (simpler) or the player CAN generate per-community keypairs (more private). Player’s choice in settings.</li>
<li>Key recovery: if the player loses their keypair, they can re-register with the community (new key = new player with fresh rating). This is intentional — key loss resets reputation, preventing key selling.</li>
<li><strong>Key export:</strong> <code>ic player export-key --encrypted</code> exports the keypair as an encrypted file (AEAD, user passphrase). This is the player’s backup. The UI nags once (“Back up your player key? You’ll need it if you switch computers.”) and never again.</li>
</ul>
<h4 id="community-keys-two-key-architecture"><a class="header" href="#community-keys-two-key-architecture">Community Keys: Two-Key Architecture</a></h4>
<p>Every community server has <strong>two</strong> Ed25519 keypairs, inspired by DNSSEC’s Zone Signing Key (ZSK) / Key Signing Key (KSK) pattern:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Key</th><th>Purpose</th><th>Storage</th><th>Usage Frequency</th></tr>
</thead>
<tbody>
<tr><td><strong>Signing Key (SK)</strong></td><td>Signs all day-to-day SCRs (ratings, matches, achievements)</td><td>On the server, encrypted at rest</td><td>Every match result, every rating update</td></tr>
<tr><td><strong>Recovery Key (RK)</strong></td><td>Signs key rotation records and emergency revocations only</td><td><strong>Offline</strong> — operator saves it, never stored on the server</td><td>Rare: only for key rotation or compromise recovery</td></tr>
</tbody>
</table>
</div>
<p><strong>Why two keys?</strong> A single-key system has a catastrophic failure mode: if the key is lost, the community dies (no way to rotate to a new key). If the key is stolen, the attacker can forge credentials <em>and</em> the operator can’t prove they’re the real owner (both parties have the same key). The two-key pattern solves both:</p>
<ul>
<li><strong>Key loss:</strong> Operator uses the RK (stored offline) to sign a rotation to a new SK. Community survives.</li>
<li><strong>Key theft:</strong> Operator uses the RK to revoke the compromised SK and rotate to a new one. Attacker has the SK but not the RK, so they can’t forge rotation records. Community recovers.</li>
<li><strong>Both lost:</strong> Nuclear option — community is dead, players re-register. But losing both requires extraordinary negligence (the RK was specifically generated for offline backup).</li>
</ul>
<p>This is the same pattern used by DNSSEC (ZSK + KSK), hardware security modules (operational key + root key), cryptocurrency validators (signing key + withdrawal key), and Certificate Authorities (intermediate + root certificates).</p>
<p><strong>Key generation flow:</strong></p>
<pre><code>$ ic community init --name "Clan Wolfpack" --url "https://wolfpack.example.com"

  Generating community Signing Key (SK)...
  SK fingerprint: 3f7a2b91e4d08c56
  SK stored encrypted at: /etc/ironcurtain/server/signing-key.enc

  Generating community Recovery Key (RK)...
  RK fingerprint: 9c4d17e3f28a6b05

  ╔══════════════════════════════════════════════════════════════╗
  ║  SAVE YOUR RECOVERY KEY NOW                                 ║
  ║                                                             ║
  ║  This key will NOT be stored on the server.                 ║
  ║  You need it to recover if your signing key is lost or      ║
  ║  stolen. Without it, a lost key means your community dies.  ║
  ║                                                             ║
  ║  Recovery Key (base64):                                     ║
  ║  rk-ed25519:MC4CAQAwBQYDK2VwBCIEIGXu5Mw8N3...             ║
  ║                                                             ║
  ║  Options:                                                   ║
  ║    1. Copy to clipboard                                     ║
  ║    2. Save to encrypted file                                ║
  ║    3. Display QR code (for paper backup)                    ║
  ║                                                             ║
  ║  Store it in a password manager, a safe, or a USB drive     ║
  ║  in a drawer. Treat it like a master password.              ║
  ╚══════════════════════════════════════════════════════════════╝

  [1/2/3/I saved it, continue]: 
</code></pre>
<p>The RK private key is shown exactly once during <code>ic community init</code>. The server stores only the RK’s <em>public</em> key (so clients can verify rotation records signed by the RK). The RK private key is never written to disk by the server.</p>
<p><strong>Key backup and retrieval:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Command</th><th>What It Does</th></tr>
</thead>
<tbody>
<tr><td>Export SK (encrypted)</td><td><code>ic community export-signing-key</code></td><td>Exports the SK private key in an encrypted file (AEAD, operator passphrase). For backup or server migration.</td></tr>
<tr><td>Import SK</td><td><code>ic community import-signing-key &lt;file&gt;</code></td><td>Restores the SK from an encrypted export. For server migration or disaster recovery.</td></tr>
<tr><td>Rotate SK (voluntary)</td><td><code>ic community rotate-signing-key</code></td><td>Generates a new SK, signs a rotation record with the old SK: “old_SK → new_SK”. Graceful, no disruption.</td></tr>
<tr><td>Emergency rotation (SK lost/stolen)</td><td><code>ic community emergency-rotate --recovery-key &lt;rk&gt;</code></td><td>Generates a new SK, signs a rotation record with the RK: “RK revokes old_SK, authorizes new_SK”. The only operation that uses the RK.</td></tr>
<tr><td>Regenerate RK</td><td><code>ic community regenerate-recovery-key --recovery-key &lt;old_rk&gt;</code></td><td>Generates a new RK, signs a rotation record: “old_RK → new_RK”. The old RK authorizes the new one.</td></tr>
</tbody>
</table>
</div>
<h4 id="key-rotation-voluntary"><a class="header" href="#key-rotation-voluntary">Key Rotation (Voluntary)</a></h4>
<p>Good security hygiene is to rotate signing keys periodically — not because Ed25519 keys weaken over time, but to limit the blast radius of an undetected compromise. IC makes voluntary rotation seamless:</p>
<ol>
<li>Operator runs <code>ic community rotate-signing-key</code>.</li>
<li>Server generates a new SK keypair.</li>
<li>Server signs a <strong>key rotation record</strong> with the OLD SK:</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct KeyRotationRecord {
    pub record_type: u8,          // 0x05 = key rotation
    pub old_key: [u8; 32],        // SK being retired
    pub new_key: [u8; 32],        // replacement SK
    pub signed_by: KeyRole,       // SK (voluntary) or RK (emergency)
    pub reason: RotationReason,
    pub effective_at: i64,        // Unix timestamp
    pub old_key_valid_until: i64, // grace period end (default: +30 days)
    pub signature: [u8; 64],      // signed by old_key or recovery_key
}

pub enum KeyRole {
    SigningKey,    // voluntary rotation — signed by old SK
    RecoveryKey,   // emergency rotation — signed by RK
}

pub enum RotationReason {
    Scheduled,         // periodic rotation (good hygiene)
    ServerMigration,   // moving to new hardware
    Compromise,        // SK compromised, emergency revocation
    PrecautionaryRevoke, // SK might be compromised, revoking as precaution
}
<span class="boring">}</span></code></pre>
<ol start="4">
<li>Server starts signing new SCRs with the new SK immediately.</li>
<li>Clients encountering the rotation record verify it (against the old SK for voluntary rotation, or against the RK for emergency rotation).</li>
<li>Clients update their stored community key.</li>
<li><strong>Grace period (30 days default):</strong> During the grace period, clients accept SCRs signed by EITHER the old or new SK. This handles players who cached credentials signed by the old key and haven’t synced yet.</li>
<li>After the grace period, only the new SK is accepted.</li>
</ol>
<h4 id="key-compromise-recovery"><a class="header" href="#key-compromise-recovery">Key Compromise Recovery</a></h4>
<p>If a community operator discovers (or suspects) their SK has been compromised:</p>
<ol>
<li><strong>Immediate response:</strong> Run <code>ic community emergency-rotate --recovery-key &lt;rk&gt;</code>.</li>
<li>Server generates a new SK.</li>
<li>Server signs an <strong>emergency rotation record</strong> with the <strong>Recovery Key</strong>:
<ul>
<li><code>signed_by: RecoveryKey</code></li>
<li><code>reason: Compromise</code> (or <code>PrecautionaryRevoke</code>)</li>
<li><code>old_key_valid_until: now</code> (no grace period for compromised keys — immediate revocation)</li>
</ul>
</li>
<li>Clients encountering this record verify it against the RK public key (cached since community join).</li>
<li><strong>Compromise window SCRs:</strong> SCRs issued between the compromise and the rotation are potentially forged. The rotation record includes the <code>effective_at</code> timestamp. Clients can flag SCRs signed by the old key after this timestamp as “potentially compromised” (⚠️ in the UI). SCRs signed before the compromise window remain valid — the key was legitimate when they were issued.</li>
<li><strong>Attacker is locked out:</strong> The attacker has the old SK but not the RK. They cannot forge rotation records, so clients who receive the legitimate RK-signed rotation will reject the attacker’s old-SK-signed SCRs going forward.</li>
</ol>
<p><strong>What about third-party compromise reports?</strong> (“Someone told me community X’s key was stolen.”)</p>
<p>IC does <strong>not</strong> support third-party key revocation. Only the RK holder can revoke an SK. This is the same model as PGP — only the key owner can issue a revocation certificate. If you suspect a community’s key is compromised but they haven’t rotated:</p>
<ul>
<li>Remove them from your trusted communities list (D053). This is your defense.</li>
<li>Contact the community operator out-of-band (Discord, email, their website) to alert them.</li>
<li>The community appears as ⚠️ Untrusted in profiles of players who removed them.</li>
</ul>
<p>Central revocation authorities (CRLs, OCSP) require central infrastructure — exactly what IC’s federated model avoids. The tradeoff is that compromise propagation depends on the operator’s responsiveness. This is acceptable: IC communities are run by the same people who already manage Discord servers, game servers, and community websites. They’re reachable.</p>
<h4 id="key-expiry-policy"><a class="header" href="#key-expiry-policy">Key Expiry Policy</a></h4>
<p><strong>Community keys (SK and RK) do NOT expire.</strong> This is an explicit design choice.</p>
<p>Arguments for expiry (and why they don’t apply):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Argument</th><th>Counterpoint</th></tr>
</thead>
<tbody>
<tr><td>“Limits damage from silent compromise”</td><td>SCRs already have per-record <code>expires_at</code> (7 days default for ratings). A silently compromised key can only forge SCRs that expire in a week. Voluntary key rotation provides the same benefit without forced expiry.</td></tr>
<tr><td>“Forces rotation hygiene”</td><td>IC’s community operators are hobbyists running $5 VPSes. Forced expiry creates an operational burden that causes more harm (communities dying from forgotten renewal) than good. Let rotation be voluntary.</td></tr>
<tr><td>“TLS certs expire”</td><td>TLS operates in a CA trust model with automated renewal (ACME/Let’s Encrypt). IC has no CA and no automated renewal infrastructure. The analogy doesn’t hold.</td></tr>
<tr><td>“What if the operator disappears?”</td><td>SCR <code>expires_at</code> handles this naturally. If the server goes offline, rating SCRs expire within 7 days and become un-refreshable. The community dies gracefully — players’ old match/achievement SCRs (which have <code>expires_at: never</code>) remain verifiable, but ratings go stale. No key expiry needed.</td></tr>
</tbody>
</table>
</div>
<p>The correct analogy is SSH host keys (never expire, TOFU model) and PGP keys (no forced expiry, voluntary rotation or revocation), not TLS certificates.</p>
<p><strong>However, IC nudges operators toward good hygiene:</strong></p>
<ul>
<li>The server logs a warning if the SK hasn’t been rotated in 12 months: “Consider rotating your signing key. Run <code>ic community rotate-signing-key</code>.” This is a reminder, not an enforcement.</li>
<li>The client shows a subtle indicator if a community’s SK is older than 24 months: small 🕐 icon next to the community name. This is informational, not blocking.</li>
</ul>
<h4 id="client-side-key-storage"><a class="header" href="#client-side-key-storage">Client-Side Key Storage</a></h4>
<p>When a player joins a community, the client receives and caches both public keys:</p>
<pre><code class="language-sql">-- In the community credential store (community_info table)
CREATE TABLE community_info (
    community_key       BLOB NOT NULL,     -- Current SK public key (32 bytes)
    recovery_key        BLOB NOT NULL,     -- RK public key (32 bytes) — cached at join
    community_name      TEXT NOT NULL,
    server_url          TEXT NOT NULL,
    key_fingerprint     TEXT NOT NULL,     -- hex(SHA-256(community_key)[0..8])
    rk_fingerprint      TEXT NOT NULL,     -- hex(SHA-256(recovery_key)[0..8])
    sk_rotated_at       INTEGER,           -- when current SK was activated
    joined_at           INTEGER NOT NULL,
    last_sync           INTEGER NOT NULL
);

-- Key rotation history (for audit trail)
CREATE TABLE key_rotations (
    sequence        INTEGER PRIMARY KEY,
    old_key         BLOB NOT NULL,         -- retired SK public key
    new_key         BLOB NOT NULL,         -- replacement SK public key
    signed_by       TEXT NOT NULL,         -- 'signing_key' or 'recovery_key'
    reason          TEXT NOT NULL,
    effective_at    INTEGER NOT NULL,
    grace_until     INTEGER NOT NULL,      -- old key accepted until this time
    rotation_record BLOB NOT NULL          -- full signed rotation record bytes
);
</code></pre>
<p>The <code>key_rotations</code> table provides an audit trail: the client can verify the entire chain of key rotations from the original key (cached at join time) to the current key. This means even if a client was offline for months and missed several rotations, they can verify the chain: “original_SK → SK2 (signed by original_SK) → SK3 (signed by SK2) → current_SK (signed by SK3).” If any link in the chain breaks, the client alerts the user.</p>
<h4 id="revocation-player-level"><a class="header" href="#revocation-player-level">Revocation (Player-Level)</a></h4>
<ul>
<li>The community server signs a revocation record: <code>(record_type, min_valid_sequence, signature)</code>.</li>
<li>Clients encountering a revocation update their local <code>revocations</code> table.</li>
<li>Verification checks: <code>scr.sequence &gt;= revocations[scr.record_type].min_valid_sequence</code>.</li>
<li>Use case: player caught cheating → server issues revocation for all their records below a new sequence → player’s cached credentials become unverifiable → they must re-authenticate, and the server can refuse.</li>
</ul>
<p>Revocations are distinct from key rotations. Revocations invalidate a specific player’s credentials. Key rotations replace the community’s signing key. Both use signed records; they solve different problems.</p>
<h4 id="summary-failure-mode-comparison"><a class="header" href="#summary-failure-mode-comparison">Summary: Failure Mode Comparison</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scenario</th><th>Single-Key System</th><th>IC Two-Key System</th></tr>
</thead>
<tbody>
<tr><td>SK lost, operator has no backup</td><td>Community dead. All credentials permanently unverifiable. Players start over.</td><td>Operator uses RK to rotate to new SK. Community survives. All existing SCRs remain valid.</td></tr>
<tr><td>SK stolen</td><td>Attacker can forge credentials AND operator can’t prove legitimacy (both hold same key). Community dead.</td><td>Operator uses RK to revoke stolen SK, rotate to new SK. Attacker locked out. Community recovers.</td></tr>
<tr><td>SK stolen + operator doesn’t notice for weeks</td><td>Unlimited forgery window. No recovery.</td><td>SCR <code>expires_at</code> limits forgery to 7-day windows. RK-signed rotation locks out attacker retroactively.</td></tr>
<tr><td>Both SK and RK lost</td><td>—</td><td>Community dead. But this requires losing both an online server key AND an offline backup. Extraordinary negligence.</td></tr>
<tr><td>RK stolen (but SK is fine)</td><td>—</td><td>No immediate impact — RK isn’t used for day-to-day operations. Operator should regenerate RK immediately: <code>ic community regenerate-recovery-key</code>.</td></tr>
</tbody>
</table>
</div>
<h3 id="cross-community-interoperability"><a class="header" href="#cross-community-interoperability">Cross-Community Interoperability</a></h3>
<p>Communities are independent ranking domains — a 1500 rating on “Official IC” means nothing on “Clan Wolfpack.” This is intentional: different communities can run different game modules, balance presets (D019), and matchmaking rules.</p>
<p><strong>However, portable proofs are useful:</strong></p>
<ul>
<li>“I have 500+ matches on the official community” — provable by presenting signed match SCRs.</li>
<li>“I achieved ‘Iron Curtain’ achievement on Official IC” — provable by presenting the signed achievement SCR.</li>
<li>A tournament community can require “minimum 50 rated matches on any community with verifiable SCRs” as an entry requirement.</li>
</ul>
<p><strong>Leaderboards:</strong></p>
<ul>
<li>Each community maintains its own leaderboard, compiled from the rating SCRs it has issued.</li>
<li>The community server caches current ratings (in RAM or SQLite) for leaderboard display.</li>
<li>Players can view their own full match history locally (from their SQLite credential file) without server involvement.</li>
</ul>
<h3 id="community-server-operational-requirements"><a class="header" href="#community-server-operational-requirements">Community Server Operational Requirements</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Metric</th><th>Estimate</th></tr>
</thead>
<tbody>
<tr><td>Storage per player</td><td>~40 bytes persistent (key + revocation). ~200 bytes cached (rating for matchmaking)</td></tr>
<tr><td>Storage for 10,000 players</td><td>~2.3 MB</td></tr>
<tr><td>RAM for matchmaking (1,000 concurrent)</td><td>~200 KB</td></tr>
<tr><td>CPU per match result signing</td><td>~1ms (Ed25519 sign is ~60μs; rest is rating computation)</td></tr>
<tr><td>Bandwidth per match result</td><td>~500 bytes (2 SCRs returned: rating + match)</td></tr>
<tr><td>Monthly VPS cost (small community, &lt;1000 players)</td><td>$5–10</td></tr>
<tr><td>Monthly VPS cost (large community, 10,000+ players)</td><td>$20–50</td></tr>
</tbody>
</table>
</div>
<p>This is cheaper than any centralized ranking service. Operating a community is within reach of a single motivated community member — the same people who already run OpenRA servers and Discord bots.</p>
<h3 id="relationship-to-existing-decisions-7"><a class="header" href="#relationship-to-existing-decisions-7">Relationship to Existing Decisions</a></h3>
<ul>
<li><strong>D007 (Relay server):</strong> The relay produces <code>CertifiedMatchResult</code> — the input to rating computation. A Community Server bundles relay + ranking in one process.</li>
<li><strong>D030/D050 (Workshop federation):</strong> Community Servers federate like Workshop sources. <code>settings.yaml</code> lists communities the same way it lists Workshop sources.</li>
<li><strong>D034 (SQLite):</strong> The credential file IS SQLite. The community server’s small state IS SQLite.</li>
<li><strong>D036 (Achievements):</strong> Achievement records are SCRs stored in the credential file. The community server is the signing authority.</li>
<li><strong>D041 (RankingProvider trait):</strong> Matchmaking uses <code>RankingProvider</code> implementations. Community operators choose their algorithm.</li>
<li><strong>D042 (Player profiles):</strong> Behavioral profiles remain local-only (D042). The credential file holds signed competitive data (ratings, matches, achievements). They complement each other: D042 = private local analytics, D052 = portable signed reputation.</li>
<li><strong>P004 (Lobby/matchmaking):</strong> This decision partially resolves P004. Room discovery (5 tiers), lobby P2P resource sharing, and matchmaking are now designed. The remaining Phase 5 work is wire format specifics (message framing, serialization, state machine transitions).</li>
</ul>
<h3 id="alternatives-considered-10"><a class="header" href="#alternatives-considered-10">Alternatives Considered</a></h3>
<ul>
<li><strong>Centralized ranking database</strong> (rejected — expensive to host, single point of failure, doesn’t match IC’s federation model, violates local-first privacy principle)</li>
<li><strong>JWT for credentials</strong> (rejected — algorithm confusion attacks, <code>alg: none</code> bypass, JSON parsing ambiguity, no built-in replay protection, no built-in revocation. See comparison table above)</li>
<li><strong>Blockchain/DLT for rankings</strong> (rejected — massively overcomplicated for this use case, environmental concerns, no benefit over Ed25519 signed records)</li>
<li><strong>Web-of-trust (players sign each other’s match results)</strong> (rejected — Sybil attacks trivially game this; a trusted community server as signing authority is simpler and more resistant)</li>
<li><strong>PASETO (Platform-Agnostic Security Tokens)</strong> (considered — fixes many JWT flaws, mandates modern algorithms. Rejected because: still JSON-based, still has header/payload/footer structure that invites parsing issues, and IC’s binary SCR format is more compact and purpose-built. PASETO is good; SCR is better for this niche.)</li>
</ul>
<h3 id="phase-4"><a class="header" href="#phase-4">Phase</a></h3>
<p>Community Server infrastructure ships in <strong>Phase 5</strong> (Multiplayer &amp; Competitive, Months 20–26). The SCR format and credential SQLite schema are defined early (Phase 2) to support local testing with mock community servers.</p>
<ul>
<li><strong>Phase 2:</strong> SCR format crate, local credential store, mock community server for testing.</li>
<li><strong>Phase 5:</strong> Full community server (relay + ranking + matchmaking + achievement signing). <code>ic community join/leave/status</code> CLI commands. In-game community browser.</li>
<li><strong>Phase 6a:</strong> Federation between communities. Community discovery. Cross-community credential presentation. Community reputation.</li>
</ul>
<h3 id="cross-pollination-lessons-flowing-between-d052d053-workshop-and-netcode"><a class="header" href="#cross-pollination-lessons-flowing-between-d052d053-workshop-and-netcode">Cross-Pollination: Lessons Flowing Between D052/D053, Workshop, and Netcode</a></h3>
<p>The work on community servers, trust chains, and player profiles produced patterns that strengthen Workshop and netcode designs — and vice versa. This section catalogues the cross-system lessons beyond the four shared infrastructure opportunities already documented in D049 (unified <code>ic-server</code> binary, federation library, auth/identity layer, EWMA scoring).</p>
<h4 id="d052d053--workshop-d030d049d050"><a class="header" href="#d052d053--workshop-d030d049d050">D052/D053 → Workshop (D030/D049/D050)</a></h4>
<p><strong>1. Two-key architecture for Workshop index signing.</strong></p>
<p>The Workshop’s git-index security (D049) plans a single Ed25519 key for signing <code>index.yaml</code>. That’s the same single-point-of-failure the two-key architecture (§ Key Lifecycle above) was designed to eliminate. CI pipeline compromise is one of the most common supply-chain attack vectors (SolarWinds, Codecov, ua-parser-js). The SK+RK pattern maps directly:</p>
<ul>
<li><strong>Index Signing Key (SK):</strong> Held by CI, used to sign every <code>index.yaml</code> build. Rotated periodically or on compromise.</li>
<li><strong>Index Recovery Key (RK):</strong> Held offline by ≥2 project maintainers (threshold signing or independent copies). Used solely to sign a <code>KeyRotationRecord</code> that re-anchors trust to a new SK.</li>
</ul>
<p>If CI is compromised, the attacker gets SK but not RK. Maintainers rotate via RK — clients that verify the rotation chain continue trusting the index. Without two-key, CI compromise means either (a) the attacker signs malicious indexes indefinitely, or (b) the project mints a new key and every client must manually re-trust it. The rotation chain avoids both.</p>
<p><strong>2. Publisher two-key identity.</strong></p>
<p>Individual mod publishers currently authenticate via GitHub account (Phase 0–3) or Workshop server credentials (Phase 4+). If alice’s account is compromised, her packages can be poisoned. The two-key pattern extends to publishers:</p>
<ul>
<li><strong>Publisher Signing Key (SK):</strong> Used to sign each <code>.icpkg</code> manifest on publish. Stored on the publisher’s development machine.</li>
<li><strong>Publisher Recovery Key (RK):</strong> Generated at first publish. Stored offline (e.g., USB key, password manager). Used only to rotate the SK if compromised.</li>
</ul>
<p>Clients that cache alice’s public key can verify her packages remain authentic through key rotations. The <code>KeyRotationRecord</code> struct from D052 is reusable — same format, same verification logic, different context. This also enables package pinning: <code>ic mod pin alice/tanks --key &lt;fingerprint&gt;</code> refuses installs signed by any other key, even if alice’s Workshop account is hijacked.</p>
<p><strong>3. Trust-based Workshop source filtering.</strong></p>
<p>D053’s <code>TrustRequirement</code> model (None / AnyCommunityVerified / SpecificCommunities) maps to Workshop sources. Currently, <code>settings.yaml</code> implicitly trusts all configured sources equally. Applying D053’s trust tiers:</p>
<ul>
<li><strong>Trusted source:</strong> <code>ic mod install</code> proceeds silently.</li>
<li><strong>Known source:</strong> Install proceeds with an informational note.</li>
<li><strong>Unknown source:</strong> <code>ic mod install</code> warns and requires <code>--allow-untrusted</code> flag (or interactive confirmation).</li>
</ul>
<p>This is the same UX pattern as the game browser trust badges — ✅/⚠️/❌ — applied to the <code>ic</code> CLI and in-game mod browser. When a dependency chain pulls a package from an untrusted source, the solver surfaces this clearly before proceeding.</p>
<p><strong>4. Server-side validation principle as shared invariant.</strong></p>
<p>D052’s explicit principle — “never sign data you didn’t produce or verify” — should be a shared invariant across all IC server components. For the Workshop server, this means:</p>
<ul>
<li>Never accept a publish without verifying: SHA-256 matches, manifest is valid YAML, version doesn’t already exist, publisher key matches the namespace, no path traversal in file entries.</li>
<li>Never sign a package listing without recomputing checksums from the stored <code>.icpkg</code>.</li>
<li>Workshop server attestation: a <code>CertifiedPublishResult</code> (analogous to the relay’s <code>CertifiedMatchResult</code>) signed by the server, proving the publish was validated. Stored in the publisher’s local credential file — portable proof that “this package was accepted by Workshop server X at time T.”</li>
</ul>
<p><strong>5. Registration policies → Workshop publisher policies.</strong></p>
<p>D052’s <code>RegistrationPolicy</code> enum (Open / RequirePlatform / RequireInvite / RequireChallenge / AnyOf) maps to Workshop publisher onboarding. A community-hosted Workshop server can configure who may publish:</p>
<ul>
<li><code>Open</code> — anyone can publish (appropriate for experimental/testing servers)</li>
<li><code>RequirePlatform</code> — must have a linked Steam/platform account</li>
<li><code>RequireInvite</code> — existing publisher must vouch (prevents spam/typosquat floods)</li>
</ul>
<p>This is already implicit in the git-index phase (GitHub account = identity), but should be explicit in the Workshop server design for Phase 4+.</p>
<h4 id="d052d053--netcode-d007d003"><a class="header" href="#d052d053--netcode-d007d003">D052/D053 → Netcode (D007/D003)</a></h4>
<p><strong>6. Relay server two-key pattern.</strong></p>
<p>Relay servers produce signed <code>CertifiedMatchResult</code> records — the trust anchor for all competitive data. If a relay’s signing key leaks, all match results are forgeable. Same SK+RK solution: relay operators generate a signing key (used by the running relay binary) and a recovery key (stored offline). On compromise, the operator rotates via RK without invalidating the community’s entire match history.</p>
<p>Currently D052 says a community server “trusts its own relay” — but this trust should be cryptographically verifiable: the community server knows the relay’s public key (registered in <code>community_info</code>), and the <code>CertifiedMatchResult</code> carries the relay’s signature. Key rotation propagates through the same <code>KeyRotationRecord</code> chain.</p>
<p><strong>7. Trust-verified P2P peer selection.</strong></p>
<p>D049’s P2P peer scoring selects peers by capacity, locality, seed status, and lobby context. D053’s trust model adds a fifth dimension: when downloading mods from lobby peers, prefer peers with verified profiles from trusted communities. A verified player is less likely to serve malicious content (Sybil nodes have no community history). The scoring formula gains an optional trust component:</p>
<pre><code>PeerScore = Capacity(0.35) + Locality(0.25) + SeedStatus(0.2) + Trust(0.1) + LobbyContext(0.1)
</code></pre>
<p>Trust scoring: verified by a trusted community = 1.0, verified by any community = 0.5, unverified = 0. This is opt-in — communities that don’t care about trust verification keep the original 4-factor formula.</p>
<h4 id="workshopnetcode--d052d053"><a class="header" href="#workshopnetcode--d052d053">Workshop/Netcode → D052/D053</a></h4>
<p><strong>8. Profile fetch rate control.</strong></p>
<p>Netcode uses three-layer rate control (per-connection, per-IP, global). Profile fetching in lobbies is susceptible to the same abuse patterns — a malicious client could spam profile requests to exhaust server bandwidth or enumerate player data. The same rate-control architecture applies: per-IP rate limits on profile fetch requests, exponential backoff on repeated fetches of the same profile, and a TTL cache that makes duplicate requests a local cache hit.</p>
<p><strong>9. Content integrity hashing for composite profiles.</strong></p>
<p>The Workshop uses SHA-256 checksums plus <code>manifest_hash</code> for double verification. When a player assembles their composite profile (identity + SCRs from multiple communities), the assembled profile can include a composite hash — enabling cache invalidation without re-fetching every individual SCR. When a profile is requested, the server returns the composite hash first; if it matches the cached version, no further transfer is needed. This is the same “content-addressed fetch” pattern the Workshop uses for <code>.icpkg</code> files.</p>
<p><strong>10. EWMA scoring for community member standing.</strong></p>
<p>The Workshop’s EWMA (Exponentially Weighted Moving Average) peer scoring — already identified as shared infrastructure in D049 — has a concrete consumer in D052/D053: community member standing. A community server can track per-member quality signals (connection stability, disconnect rate, desync frequency, report count) using time-decaying EWMA scores. Recent behavior weighs more than ancient history. This feeds into matchmaking preferences (D052) and the profile’s community standing display (D053) without requiring a separate scoring system.</p>
<h4 id="shared-pattern-key-management-as-reusable-infrastructure"><a class="header" href="#shared-pattern-key-management-as-reusable-infrastructure">Shared pattern: key management as reusable infrastructure</a></h4>
<p>The two-key architecture now appears in three contexts: community servers, relay servers, and Workshop (index + publishers). This suggests extracting it as a shared <code>ic-crypto</code> module (or section of <code>ic-protocol</code>) that provides:</p>
<ul>
<li><code>SigningKeypair</code> + <code>RecoveryKeypair</code> generation</li>
<li><code>KeyRotationRecord</code> creation and chain verification</li>
<li>Fingerprint computation and display formatting</li>
<li>Common serialization for the rotation chain</li>
</ul>
<p>All three consumers use Ed25519, the same rotation record format, and the same verification logic. The only difference is context (what the key signs). This is a Phase 2 deliverable — the crypto primitives must exist before community servers, relays, or Workshop servers use them.</p>
<hr>
<h2 id="d053--player-profile-system"><a class="header" href="#d053--player-profile-system">D053 — Player Profile System</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th></th><th></th></tr>
</thead>
<tbody>
<tr><td><strong>Status</strong></td><td>Accepted</td></tr>
<tr><td><strong>Driver</strong></td><td>Players need a persistent identity, social presence, and reputation display across lobbies, game browser, and community participation</td></tr>
<tr><td><strong>Depends on</strong></td><td>D034 (SQLite), D036 (Achievements), D042 (Behavioral Profiles), D046 (Premium Content), D050 (Workshop), D052 (Community Servers &amp; SCR)</td></tr>
</tbody>
</table>
</div>
<h3 id="problem"><a class="header" href="#problem">Problem</a></h3>
<p>Players in multiplayer games are more than a text name. They need to express their identity, showcase achievements, verify reputation, and build social connections. Without a proper profile system, lobbies feel anonymous and impersonal — players can’t distinguish veterans from newcomers, can’t build persistent friendships, and can’t verify who they’re playing against. Every major gaming platform (Steam, Xbox Live, PlayStation Network, Battle.net, Riot Games, Discord) has learned this: <strong>profiles are the social foundation of a gaming community.</strong></p>
<p>IC has a unique advantage: the Signed Credential Record (SCR) system from D052 means player reputation data (ratings, match counts, achievements) is <strong>cryptographically verified and portable</strong>. No other game has unforgeable, cross-community reputation badges. D053 builds the user-facing system that displays and manages this identity.</p>
<h3 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h3>
<p>Drawn from analysis of Steam, Xbox Live, PSN, Riot Games, Blizzard Battle.net, Discord, and OpenRA:</p>
<ol>
<li><strong>Identity expression without vanity bloat.</strong> Players should personalize their presence (avatar, name, bio) but the system shouldn’t become a cosmetic storefront that distracts from gameplay. Keep it clean and functional.</li>
<li><strong>Reputation is earned, not claimed.</strong> Ratings, achievements, and match counts come from signed SCRs — not self-reported. If a player claims to be 1800-rated, their profile proves (or disproves) it.</li>
<li><strong>Privacy by default.</strong> Every profile field has visibility controls. Players choose exactly what they share and with whom. Local behavioral data (D042) is never exposed in profiles.</li>
<li><strong>Portable across communities.</strong> A player’s profile works on any community server they join. Community-specific data (ratings, achievements) is signed by that community. Cross-community viewing shows aggregated identity with per-community verification badges.</li>
<li><strong>Offline-first.</strong> The profile is stored locally in SQLite (D034). Community-signed data is cached in the local credential store (D052). No server connection needed to view your own profile. Others’ profiles are fetched and cached on first encounter.</li>
<li><strong>Platform-integrated where possible.</strong> On Steam, friends lists and presence come from Steam’s API via <code>PlatformServices</code>. On standalone builds, IC provides its own social graph backed by community servers. Both paths converge at the same profile UI.</li>
</ol>
<h3 id="profile-structure"><a class="header" href="#profile-structure">Profile Structure</a></h3>
<p>A player profile contains these sections, each with its own visibility controls:</p>
<p><strong>1. Identity Core</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Description</th><th>Source</th><th>Max Size</th></tr>
</thead>
<tbody>
<tr><td>Display Name</td><td>Primary visible name</td><td>Player-set, locally stored</td><td>32 chars</td></tr>
<tr><td>Avatar</td><td>Profile image</td><td>Pre-built gallery or custom upload</td><td>128×128 PNG, max 64 KB</td></tr>
<tr><td>Banner</td><td>Profile background image</td><td>Pre-built gallery or custom upload</td><td>600×200 PNG, max 128 KB</td></tr>
<tr><td>Bio</td><td>Short self-description</td><td>Player-written</td><td>500 chars</td></tr>
<tr><td>Player Title</td><td>Earned or selected title (e.g., “Iron Commander”, “Mammoth Enthusiast”)</td><td>Achievement reward or community grant</td><td>48 chars</td></tr>
<tr><td>Faction Crest</td><td>Preferred faction emblem (displayed on profile card)</td><td>Player-selected from game module factions</td><td>Enum per game module</td></tr>
</tbody>
</table>
</div>
<p><strong>Display names</strong> are not globally unique. Uniqueness is per-community (the community server enforces its own name policy). In a lobby, players are identified by <code>display_name + community_badge</code> or <code>display_name + player_key_prefix</code> when no community is shared. This matches how Discord handles names post-2023 (display names are cosmetic, uniqueness is contextual).</p>
<p><strong>Avatar system:</strong></p>
<ul>
<li><strong>Pre-built gallery:</strong> Ships with ~60 avatars extracted from C&amp;C unit portraits, faction emblems, and structure icons (using game assets the player already owns — loaded by <code>ra-formats</code>, not distributed by IC). Each game module contributes its own set.</li>
<li><strong>Custom upload:</strong> Players can set any 128×128 PNG image (max 64 KB) as their avatar. The image is stored in the local profile. When joining a lobby, only the SHA-256 hash is transmitted (32 bytes). Other clients fetch the actual image on demand from the player (via the relay, same channel as P2P resource sharing from D052). Fetched avatars are cached locally.</li>
<li><strong>Content moderation:</strong> Custom avatars are not moderated by IC (no central server to moderate). Community servers can optionally enforce “gallery-only avatars” as a room policy. Players can report abusive avatars to community moderators via the same mechanism used for reporting cheaters (D052 revocation).</li>
<li><strong>Hash-based deduplication:</strong> Two players using the same custom avatar send the same hash. The image is fetched once and shared from cache. This also means pre-built gallery avatars never need network transfer — both clients have them locally.</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PlayerAvatar {
    pub source: AvatarSource,
    pub hash: [u8; 32],          // SHA-256 of the PNG data
}

pub enum AvatarSource {
    Gallery { module: GameModuleId, index: u16 },  // Pre-built
    Custom,                                          // Player-uploaded PNG
}
<span class="boring">}</span></code></pre>
<p><strong>2. Achievement Showcase</strong></p>
<p>Players can <strong>pin up to 6 achievements</strong> to their profile from their D036 achievement collection. Pinned achievements appear prominently on the profile card and in lobby hover tooltips.</p>
<pre><code>┌──────────────────────────────────────────────────────┐
│ ★ Achievements (3 pinned / 47 total)                 │
│  🏆 Iron Curtain           Survived 100 Ion Cannons  │
│  🎖️ Desert Fox             Win 50 Desert maps        │
│  ⚡ Blitz Commander         Win under 5 minutes       │
│                                                      │
│  [View All Achievements →]                           │
└──────────────────────────────────────────────────────┘
</code></pre>
<ul>
<li>Pinned achievements are verified: each has a backing SCR from the relevant community. Viewers can inspect the credential (signed by community X, earned on date Y).</li>
<li>Achievement rarity is shown when viewing the full achievement list: “Earned by 12% of players on this community.”</li>
<li>Mod-defined achievements (D036) appear in the profile just like built-in ones — they’re all SCRs.</li>
</ul>
<p><strong>3. Statistics Card</strong></p>
<p>A summary of the player’s competitive record, sourced from verified SCRs (D052). Statistics are <strong>per-community, per-game-module</strong> — a player might be 1800 in RA1 on Official IC but 1400 in TD on Clan Wolfpack.</p>
<pre><code>┌──────────────────────────────────────────────────────┐
│ 📊 Statistics — Official IC Community (RA1)          │
│                                                      │
│  Rating:    1823 ± 45 (Glicko-2)     Peak: 1891     │
│  Matches:   342 played  |  W: 198  L: 131  D: 13    │
│  Win Rate:  57.9%                                    │
│  Streak:    W4 (current)  |  Best: W11               │
│  Playtime:  ~412 hours                               │
│  Faction:   67% Soviet  |  28% Allied  |  5% Random  │
│                                                      │
│  [Match History →]  [Rating Graph →]                 │
│  [Switch Community ▾]  [Switch Game Module ▾]        │
└──────────────────────────────────────────────────────┘
</code></pre>
<ul>
<li><strong>Rating graph:</strong> Visual chart showing rating over time (last 50 matches). Rendered client-side from match SCR timestamps and rating deltas.</li>
<li><strong>Faction distribution:</strong> Calculated from match SCRs. Displayed as a simple bar or pie.</li>
<li><strong>Playtime:</strong> Estimated from match durations in local match history. Approximate — not a verified claim.</li>
<li><strong>Win streak:</strong> Current and best, calculated client-side from match SCRs.</li>
<li>All numbers come from signed credential records. If a player presents a 1800 rating badge, the viewer’s client cryptographically verifies it against the community’s public key. <strong>Fake ratings are mathematically impossible.</strong></li>
<li><strong>Verification badge:</strong> Each stat line shows which community signed it and whether the viewer’s client successfully verified the signature. A ✅ means “signature valid, community key recognized.” A ⚠️ means “signature valid, but community key not in your trusted list.” A ❌ means “signature verification failed — possible tampering.” This is visible in the detailed stats view, not the compact tooltip (to avoid visual clutter).</li>
<li><strong>Inspect credential:</strong> Any SCR-backed number in the profile is clickable. Clicking opens a verification detail panel showing: signing community name + public key fingerprint, SCR sequence number, signature timestamp, raw signed payload (hex-encoded), and verification result. This is the blockchain-style “prove it” button — except it’s just Ed25519 signatures, no blockchain needed.</li>
</ul>
<p><strong>4. Match History</strong></p>
<p>Scrollable list of recent matches, each showing:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Source</th></tr>
</thead>
<tbody>
<tr><td>Date &amp; time</td><td>Match SCR timestamp</td></tr>
<tr><td>Map name</td><td>Match SCR metadata</td></tr>
<tr><td>Players</td><td>Match SCR participant list</td></tr>
<tr><td>Result (Win/Loss/Draw)</td><td>Match SCR outcome</td></tr>
<tr><td>Rating change (+/- delta)</td><td>Computed from consecutive rating SCRs</td></tr>
<tr><td>Replay link</td><td>Local replay file if available</td></tr>
</tbody>
</table>
</div>
<p>Match history is stored locally (from the player’s credential SQLite file). Community servers do not host full match histories — they only issue rating/match SCRs. This is consistent with the local-first principle.</p>
<p><strong>5. Friends &amp; Social</strong></p>
<p>IC supports two complementary friend systems:</p>
<ul>
<li><strong>Platform friends (Steam, GOG, etc.):</strong> Retrieved via <code>PlatformServices::friends_list()</code>. These are the player’s existing social graph — no IC-specific action needed. Platform friends appear in the in-game friends list automatically. Presence information (online, in-game, in-lobby) is synced bidirectionally with the platform.</li>
<li><strong>IC friends (community-based):</strong> Players can add friends within a community by mutual friend request. Stored in the local credential file as a bidirectional relationship. Friend list is per-community (friend on Official IC ≠ friend on Clan Wolfpack), but the UI merges all community friends into one unified list with community labels.</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Stored in local SQLite — not a signed credential.
/// Friendships are social bookmarks, not reputation data.
pub struct FriendEntry {
    pub player_key: [u8; 32],
    pub display_name: String,         // cached, may be stale
    pub community: CommunityId,       // where the friendship was made
    pub added_at: u64,
    pub notes: Option&lt;String&gt;,        // private label (e.g., "met in tournament")
}
<span class="boring">}</span></code></pre>
<p><strong>Friends list UI:</strong></p>
<pre><code>┌──────────────────────────────────────────────────────┐
│ 👥 Friends (8 online / 23 total)                     │
│                                                      │
│  🟢 alice          In Lobby — Desert Arena    [Join] │
│  🟢 cmdrzod        In Game — RA1 1v1          [Spec] │
│  🟡 bob            Away (15m)                        │
│  🟢 carol          Online — Main Menu         [Inv]  │
│  ─── Offline ───                                     │
│  ⚫ dave           Last seen: 2 days ago             │
│  ⚫ eve            Last seen: 1 week ago             │
│                                                      │
│  [Add Friend]  [Pending (2)]  [Blocked (1)]          │
└──────────────────────────────────────────────────────┘
</code></pre>
<ul>
<li><strong>Presence states:</strong> Online, In Game, In Lobby, Away, Invisible, Offline. Synced through the community server (lightweight heartbeat), or through <code>PlatformServices::set_presence()</code> on Steam/GOG/etc.</li>
<li><strong>Join/Spectate/Invite:</strong> One-click actions from the friends list. “Join” puts you in their lobby. “Spec” joins as spectator if the match is in progress and allows it. “Invite” sends a lobby invite.</li>
<li><strong>Friend requests:</strong> Mutual-consent only. Player A sends request, Player B accepts or declines. No one-sided “following” (this prevents stalking).</li>
<li><strong>Block list:</strong> Blocked players are hidden from the friends list, their chat messages are filtered client-side (see Lobby Communication in D052), and they cannot send friend requests. Blocks are local-only — the blocked player is not notified.</li>
<li><strong>Notes:</strong> Private per-friend notes visible only to you. Useful for remembering context (“great teammate”, “met at tournament”).</li>
</ul>
<p><strong>6. Community Memberships</strong></p>
<p>Players can be members of multiple communities (D052). The profile displays which communities they belong to, with verification badges:</p>
<pre><code>┌──────────────────────────────────────────────────────┐
│ 🏛️ Communities                                       │
│                                                      │
│  ✅ Official IC Community     Member since 2027-01   │
│     Rating: 1823 (RA1)  |  342 matches               │
│  ✅ Clan Wolfpack             Member since 2027-03   │
│     Rating: 1456 (TD)   |  87 matches                │
│  ✅ RA Competitive League     Member since 2027-06   │
│     Tournament rank: #12                              │
│                                                      │
│  [Join Community...]                                 │
└──────────────────────────────────────────────────────┘
</code></pre>
<p>Each community membership is backed by a signed credential — the ✅ badge means the viewer’s client verified the SCR signature against the community’s public key. This is IC’s differentiator: <strong>community memberships are cryptographically proven, not self-claimed.</strong> When viewing another player’s profile, you can see exactly which communities vouch for them and their verified standing in each.</p>
<p><strong>Signed Profile Summary (“proof sheet”)</strong></p>
<p>When viewing another player’s full profile, a <strong>Verification Summary</strong> panel shows every community that has signed data for this player, what they’ve signed, and whether the signatures check out:</p>
<pre><code>┌──────────────────────────────────────────────────────────────────┐
│ 🔒 Profile Verification Summary                                 │
│                                                                  │
│  Community                Signed Data             Status         │
│  ─────────────────────────────────────────────────────────       │
│  Official IC Community    Rating (1823, RA1)      ✅ Verified    │
│                           342 matches             ✅ Verified    │
│                           23 achievements         ✅ Verified    │
│                           Member since 2027-01    ✅ Verified    │
│  Clan Wolfpack            Rating (1456, TD)       ✅ Verified    │
│                           87 matches              ✅ Verified    │
│                           Member since 2027-03    ✅ Verified    │
│  RA Competitive League    Tournament rank #12     ⚠️ Untrusted   │
│                           Member since 2027-06    ⚠️ Untrusted   │
│                                                                  │
│  ✅ = Signature verified, community in your trust list           │
│  ⚠️ = Signature valid, community NOT in your trust list          │
│  ❌ = Signature verification failed (possible tampering)         │
│                                                                  │
│  [Manage Trusted Communities...]                                 │
└──────────────────────────────────────────────────────────────────┘
</code></pre>
<p>This panel answers the question: <strong>“Can I trust what this player’s profile claims?”</strong> The answer is always cryptographically grounded — not trust-me-bro, not server-side-only, but locally verified Ed25519 signatures against community public keys the viewer explicitly trusts.</p>
<p><strong>How verification works (viewer-side flow):</strong></p>
<ol>
<li>Player B presents profile data to Player A.</li>
<li>Each SCR-backed field includes the raw SCR (payload + signature + community public key).</li>
<li>Player A’s client verifies: <code>Ed25519::verify(community_public_key, payload, signature)</code>.</li>
<li>Player A’s client checks: is <code>community_public_key</code> in my <code>trusted_communities</code> table?</li>
<li>If yes → ✅ Verified. If signature valid but community not trusted → ⚠️ Untrusted. If signature invalid → ❌ Failed.</li>
<li>All unsigned fields (bio, avatar, display name) are displayed as player-claimed — no verification badge.</li>
</ol>
<p>This means <strong>every number in the Statistics Card and every badge in Community Memberships is independently verifiable by any viewer</strong> without contacting any server. The verification is offline-capable — if a player has the community’s public key cached, they can verify another player’s profile on a plane with no internet.</p>
<p><strong>7. Workshop Creator Profile</strong></p>
<p>For players who publish mods, maps, or assets to the Workshop (D030/D050), the profile shows a creator section:</p>
<pre><code>┌──────────────────────────────────────────────────────┐
│ 🔧 Workshop Creator                                  │
│                                                      │
│  Published: 12 resources  |  Total downloads: 8,420  │
│  ★ Featured: alice/hd-sprites (4,200 downloads)      │
│  Latest: alice/desert-nights (uploaded 3 days ago)   │
│                                                      │
│  [View All Publications →]                           │
└──────────────────────────────────────────────────────┘
</code></pre>
<p>This section appears only for players who have published at least one Workshop resource. Download counts and publication metadata come from the Workshop registry index (D030). Creator tips (D035) link from here.</p>
<p><strong>8. Custom Profile Elements</strong></p>
<p>Optional fields that add personality without cluttering the default view:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Element</th><th>Description</th><th>Source</th></tr>
</thead>
<tbody>
<tr><td>Favorite Quote</td><td>One-liner (e.g., “Kirov reporting!”)</td><td>Player-written, 100 chars max</td></tr>
<tr><td>Favorite Unit</td><td>Displayed with unit portrait from game assets</td><td>Player-selected per game module</td></tr>
<tr><td>Replay Highlight</td><td>Link to one pinned replay</td><td>Local replay file</td></tr>
<tr><td>Social Links</td><td>External URLs (Twitch, YouTube, etc.)</td><td>Player-set, max 3 links</td></tr>
<tr><td>Country Flag</td><td>Optional nationality display</td><td>Player-selected from ISO 3166 list</td></tr>
</tbody>
</table>
</div>
<p>These fields are optional and hidden by default. Players who want a minimal profile show only the identity core and statistics. Players who want a rich social presence can fill in everything.</p>
<h3 id="profile-viewing-contexts"><a class="header" href="#profile-viewing-contexts">Profile Viewing Contexts</a></h3>
<p>The profile appears in different contexts with different levels of detail:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Context</th><th>What’s shown</th></tr>
</thead>
<tbody>
<tr><td><strong>Lobby player list</strong></td><td>Avatar (32×32), display name, rating badge, voice status, ready state</td></tr>
<tr><td><strong>Lobby hover tooltip</strong></td><td>Avatar (64×64), display name, bio (first line), top 3 pinned achievements, rating, win rate</td></tr>
<tr><td><strong>Profile card</strong> (click player name)</td><td>Full profile: all sections respecting the viewed player’s privacy settings</td></tr>
<tr><td><strong>Game browser</strong> (room list)</td><td>Host avatar + name, host rating badge</td></tr>
<tr><td><strong>In-game sidebar</strong></td><td>Player color, display name, faction crest</td></tr>
<tr><td><strong>Post-game scoreboard</strong></td><td>Avatar, display name, rating change (+/-), match stats</td></tr>
<tr><td><strong>Friends list</strong></td><td>Avatar, display name, presence state, community label</td></tr>
</tbody>
</table>
</div>
<h3 id="privacy-controls"><a class="header" href="#privacy-controls">Privacy Controls</a></h3>
<p>Every profile section has a visibility setting:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Visibility Level</th><th>Who can see it</th></tr>
</thead>
<tbody>
<tr><td><strong>Public</strong></td><td>Anyone who encounters your profile (lobby, game browser, post-game)</td></tr>
<tr><td><strong>Friends</strong></td><td>Only players on your friends list</td></tr>
<tr><td><strong>Community</strong></td><td>Only players who share at least one community membership with you</td></tr>
<tr><td><strong>Private</strong></td><td>Only you</td></tr>
</tbody>
</table>
</div>
<p>Defaults:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Section</th><th>Default Visibility</th></tr>
</thead>
<tbody>
<tr><td>Display Name</td><td>Public</td></tr>
<tr><td>Avatar</td><td>Public</td></tr>
<tr><td>Bio</td><td>Public</td></tr>
<tr><td>Player Title</td><td>Public</td></tr>
<tr><td>Faction Crest</td><td>Public</td></tr>
<tr><td>Achievement Showcase</td><td>Public</td></tr>
<tr><td>Statistics Card</td><td>Public</td></tr>
<tr><td>Match History</td><td>Friends</td></tr>
<tr><td>Friends List</td><td>Friends</td></tr>
<tr><td>Community Memberships</td><td>Public</td></tr>
<tr><td>Workshop Creator</td><td>Public</td></tr>
<tr><td>Custom Elements</td><td>Friends</td></tr>
<tr><td>Behavioral Profile (D042)</td><td><strong>Private (immutable — never exposed)</strong></td></tr>
</tbody>
</table>
</div>
<p>The behavioral profile from D042 (<code>PlayerStyleProfile</code>) is <strong>categorically excluded</strong> from the player profile. It’s local analytics data for AI training and self-improvement — not social data. This is a hard privacy boundary.</p>
<h3 id="profile-storage"><a class="header" href="#profile-storage">Profile Storage</a></h3>
<p>Local profile data is stored in the player’s SQLite database (D034):</p>
<pre><code class="language-sql">-- Core profile (locally authoritative)
CREATE TABLE profile (
    player_key      BLOB PRIMARY KEY,  -- own Ed25519 public key
    display_name    TEXT NOT NULL,
    bio             TEXT,
    title           TEXT,
    country_code    TEXT,              -- ISO 3166 alpha-2, nullable
    favorite_quote  TEXT,
    favorite_unit   TEXT,              -- "module:unit_id" format
    created_at      INTEGER NOT NULL,
    updated_at      INTEGER NOT NULL
);

-- Avatar and banner images (stored as blobs)
CREATE TABLE profile_images (
    image_hash      TEXT PRIMARY KEY,  -- SHA-256 hex
    image_type      TEXT NOT NULL,     -- 'avatar' or 'banner'
    image_data      BLOB NOT NULL,     -- PNG bytes
    width           INTEGER NOT NULL,
    height          INTEGER NOT NULL
);

-- Profile references (avatar, banner, highlight replay)
CREATE TABLE profile_refs (
    ref_type        TEXT PRIMARY KEY,  -- 'avatar', 'banner', 'highlight_replay'
    ref_value       TEXT NOT NULL      -- image_hash, or replay file path
);

-- Pinned achievements (up to 6)
CREATE TABLE pinned_achievements (
    slot            INTEGER PRIMARY KEY CHECK (slot BETWEEN 1 AND 6),
    achievement_id  TEXT NOT NULL,     -- references achievements table (D036)
    community_id    BLOB,             -- which community signed it (nullable for local)
    pinned_at       INTEGER NOT NULL
);

-- Friends list
CREATE TABLE friends (
    player_key      BLOB NOT NULL,
    community_id    BLOB NOT NULL,     -- community where friendship was established
    display_name    TEXT,              -- cached name (may be stale)
    notes           TEXT,
    added_at        INTEGER NOT NULL,
    PRIMARY KEY (player_key, community_id)
);

-- Block list
CREATE TABLE blocked_players (
    player_key      BLOB PRIMARY KEY,
    reason          TEXT,
    blocked_at      INTEGER NOT NULL
);

-- Privacy settings
CREATE TABLE privacy_settings (
    section         TEXT PRIMARY KEY,  -- 'bio', 'stats', 'match_history', etc.
    visibility      TEXT NOT NULL      -- 'public', 'friends', 'community', 'private'
);

-- Social links (max 3)
CREATE TABLE social_links (
    slot            INTEGER PRIMARY KEY CHECK (slot BETWEEN 1 AND 3),
    label           TEXT NOT NULL,     -- 'Twitch', 'YouTube', custom
    url             TEXT NOT NULL
);

-- Cached profiles of other players (fetched on encounter)
CREATE TABLE cached_profiles (
    player_key      BLOB PRIMARY KEY,
    display_name    TEXT,
    avatar_hash     TEXT,
    bio             TEXT,
    title           TEXT,
    last_seen       INTEGER,          -- timestamp of last encounter
    fetched_at      INTEGER NOT NULL
);

-- Trusted communities (for profile verification and matchmaking filtering)
CREATE TABLE trusted_communities (
    community_key   BLOB PRIMARY KEY,  -- Ed25519 public key of the community
    community_name  TEXT,              -- cached display name
    community_url   TEXT,              -- cached URL
    auto_trusted    INTEGER NOT NULL DEFAULT 0,  -- 1 if trusted because you're a member
    trusted_at      INTEGER NOT NULL
);

-- Cached community public keys (learned from encounters, not yet trusted)
CREATE TABLE known_communities (
    community_key   BLOB PRIMARY KEY,
    community_name  TEXT,
    community_url   TEXT,
    first_seen      INTEGER NOT NULL,  -- when we first encountered this key
    last_seen       INTEGER NOT NULL
);
</code></pre>
<p><strong>Cache eviction:</strong> Cached profiles of other players are evicted LRU after 1000 entries or 30 days since last encounter. Avatar images in <code>profile_images</code> are evicted if they’re not referenced by own profile or any cached profile.</p>
<h3 id="profile-synchronization"><a class="header" href="#profile-synchronization">Profile Synchronization</a></h3>
<p>Profiles are <strong>not centrally hosted</strong>. Each player owns their profile data locally. When a player enters a lobby or is viewed by another player, profile data is exchanged peer-to-peer (via the relay, same as resource sharing in D052).</p>
<p><strong>Flow when Player A views Player B’s profile:</strong></p>
<ol>
<li>Player A’s client checks <code>cached_profiles</code> for Player B’s key.</li>
<li>If cache miss or stale (&gt;24 hours), request profile from Player B via relay.</li>
<li>Player B’s client responds with profile data (respecting B’s privacy settings — only fields visible to A’s access level are included).</li>
<li>Player A’s client verifies any SCR-backed fields (ratings, achievements, community memberships) against known community public keys.</li>
<li>Player A’s client caches the profile.</li>
<li>If Player B’s avatar hash is unknown, Player A requests the avatar image. Cached locally after fetch.</li>
</ol>
<p><strong>Bandwidth:</strong> A full profile response is ~2 KB (excluding avatar image). Avatar image is max 64 KB, fetched once and cached. For a typical lobby of 8 players, initial profile loading is ~16 KB text + up to 512 KB avatars — negligible, and avatars are fetched only once per unique player.</p>
<h3 id="trusted-communities--trust-based-filtering"><a class="header" href="#trusted-communities--trust-based-filtering">Trusted Communities &amp; Trust-Based Filtering</a></h3>
<p>Players can configure a list of <strong>trusted communities</strong> — the communities whose signed credentials they consider authoritative. This is the trust anchor for everything in the profile system.</p>
<p><strong>Configuration:</strong></p>
<pre><code class="language-yaml"># settings.yaml — communities section
communities:
  joined:
    - name: "Official IC Community"
      url: "https://official.ironcurtain.gg"
      public_key: "ed25519:abc123..."  # cached on first join
    - name: "Clan Wolfpack"
      url: "https://wolfpack.example.com"
      public_key: "ed25519:def456..."
  
  trusted:
    # Communities whose signed credentials you trust for profile verification
    # and matchmaking filtering. You don't need to be a member to trust a community.
    - "ed25519:abc123..."   # Official IC Community
    - "ed25519:def456..."   # Clan Wolfpack
    - "ed25519:789ghi..."   # EU Competitive League (not a member, but trust their ratings)
</code></pre>
<p>Joined communities are automatically trusted (you trust the community you chose to join). Players can also trust communities they haven’t joined — e.g., “I’m not a member of the EU Competitive League, but I trust their ratings as legitimate.” Trust is granted by public key, so it survives community renames and URL changes.</p>
<p><strong>Trust levels displayed in profiles:</strong></p>
<p>When viewing another player’s profile, stats from trusted vs. untrusted communities are visually distinct:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Badge</th><th>Meaning</th><th>Display</th></tr>
</thead>
<tbody>
<tr><td>✅</td><td>Signature valid + community in your trust list</td><td>Full color, prominent</td></tr>
<tr><td>⚠️</td><td>Signature valid + community NOT in your trust list</td><td>Dimmed, italic, “Untrusted community” tooltip</td></tr>
<tr><td>❌</td><td>Signature verification failed</td><td>Red, strikethrough, “Verification failed” warning</td></tr>
<tr><td>—</td><td>No signed data (player-claimed)</td><td>Gray, no badge</td></tr>
</tbody>
</table>
</div>
<p>This lets players immediately distinguish between “1800 rated on a community I trust” and “1800 rated on some random community I’ve never heard of.” The profile doesn’t hide untrusted data — it shows it clearly labeled so the viewer can make their own judgment.</p>
<p><strong>Trust-based matchmaking and lobby filtering:</strong></p>
<p>Players can require that opponents have verified credentials from their trusted communities. This is configured per-queue and per-room:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Matchmaking preferences — sent to the community server when queuing.
pub struct MatchmakingPreferences {
    pub game_module: GameModuleId,
    pub rating_range: Option&lt;(i32, i32)&gt;,             // min/max rating
    pub require_trusted_profile: TrustRequirement,     // NEW
}

pub enum TrustRequirement {
    /// Match with anyone — no credential check. Default for casual.
    None,
    /// Opponent must have a verified profile from any community
    /// the matchmaking server itself trusts (server-side check).
    AnyCommunityVerified,
    /// Opponent must have a verified profile from at least one of
    /// these specific communities (by public key). Client sends
    /// the list; server filters accordingly.
    SpecificCommunities(Vec&lt;CommunityPublicKey&gt;),
}
<span class="boring">}</span></code></pre>
<p><strong>How it works in practice:</strong></p>
<ul>
<li><strong>Casual play (default):</strong> <code>TrustRequirement::None</code>. Anyone can join. Profile badges appear but aren’t gatekeeping. Maximum player pool, minimum friction.</li>
<li><strong>“Verified only” mode:</strong> <code>TrustRequirement::AnyCommunityVerified</code>. The matchmaking server checks that the opponent has at least one valid SCR from a community the <em>server</em> trusts. This filters out completely anonymous players without requiring specific community membership. Good for semi-competitive play.</li>
<li><strong>“Trusted community” mode:</strong> <code>TrustRequirement::SpecificCommunities([official_ic_key, wolfpack_key])</code>. The server matches you only with players who have valid SCRs from at least one of those specific communities. This is the strongest filter — effectively “I only play with people vouched for by communities I trust.”</li>
</ul>
<p><strong>Room-level trust requirements:</strong></p>
<p>Room hosts can set a trust requirement when creating a room:</p>
<pre><code>┌──────────────────────────────────────────────────────┐
│ Room Settings                                        │
│                                                      │
│  Trust Requirement: [Verified Only ▾]                │
│    ○ Anyone can join (no verification)               │
│    ● Verified profile required                       │
│    ○ Specific communities only:                      │
│      ☑ Official IC Community                         │
│      ☑ Clan Wolfpack                                 │
│      ☐ EU Competitive League                         │
│                                                      │
│  [Create Room]                                       │
└──────────────────────────────────────────────────────┘
</code></pre>
<p>When a player tries to join a room with a trust requirement they don’t meet, they see a clear rejection: “This room requires a verified profile from: Official IC Community or Clan Wolfpack. [Join Official IC Community…] [Join Clan Wolfpack…]”</p>
<p><strong>Game browser filtering:</strong></p>
<p>The game browser (Tier 3 in D052) gains a trust filter column:</p>
<pre><code>┌──────────────────────────────────────────────────────────────────────────┐
│  Game Browser                                              [Refresh]   │
├──────────┬──────┬─────────┬────────┬──────┬───────────────┬─────────────┤
│ Room     │ Host │ Players │ Map    │ Ping │ Trust         │ Mods        │
├──────────┼──────┼─────────┼────────┼──────┼───────────────┼─────────────┤
│ Ranked   │ cmdr │ 1/2     │ Arena  │ 23ms │ ✅ Official   │ none        │
│ HD Game  │ alice│ 3/4     │ Europe │ 45ms │ ⚠️ Any verified│ hd-pack 2.1 │
│ Open     │ bob  │ 2/6     │ Desert │ 67ms │ 🔓 Anyone     │ none        │
└──────────┴──────┴─────────┴────────┴──────┴───────────────┴─────────────┘
│  Filter: [☑ Show only rooms I can join]  [☑ Show trusted communities]   │
</code></pre>
<p>The <code>Show only rooms I can join</code> filter hides rooms whose trust requirements you don’t meet — so you don’t see rooms you’ll be rejected from. The <code>Show trusted communities</code> filter shows only rooms hosted on communities in your trust list.</p>
<p><strong>Why this matters:</strong></p>
<p>This solves the smurf/alt-account problem that plagues every competitive game. A player can’t create a fresh anonymous account and grief ranked lobbies — the room requires verified credentials from a trusted community, which means they need a real history of matches. It also solves the fake-rating problem: you can’t claim to be 1800 unless a community you trust has signed an SCR proving it.</p>
<p>But it’s <strong>not authoritarian</strong>. Players who want casual, open, unverified games can play freely. Trust requirements are opt-in per-room and per-matchmaking-queue. The default is open. The tools are there for communities that want stronger verification — they’re not forced on anyone.</p>
<p><strong>Anti-abuse considerations:</strong></p>
<ul>
<li><strong>Community collusion:</strong> A bad actor could create a community, sign fake credentials, and present them. But no one else would trust that community’s key. Trust is explicitly granted by each player. This is a feature, not a bug — it’s exactly how PGP/GPG web-of-trust works, minus the key-signing parties.</li>
<li><strong>Community ban evasion:</strong> If a player is banned from a community (D052 revocation), their SCRs from that community become unverifiable. They can’t present banned credentials. They’d need to join a different community and rebuild reputation from scratch.</li>
<li><strong>Privacy:</strong> The trust requirement reveals which communities a player is a member of (since they must present SCRs). Players uncomfortable with this can stick to <code>TrustRequirement::None</code> rooms. The privacy controls from D053 still apply — you choose which community memberships are visible on your profile, but if a room <em>requires</em> membership proof, you must present it to join.</li>
</ul>
<h3 id="relationship-to-existing-decisions-8"><a class="header" href="#relationship-to-existing-decisions-8">Relationship to Existing Decisions</a></h3>
<ul>
<li><strong>D034 (SQLite):</strong> Profile storage is SQLite. Cached profiles, friends, block lists — all local SQLite tables.</li>
<li><strong>D036 (Achievements):</strong> Pinned achievements on the profile reference D036 achievement records. Achievement verification uses D052 SCRs.</li>
<li><strong>D042 (Behavioral Profiles):</strong> Categorically separate. D042 is local AI training data. D053 is social-facing identity. They never merge. This is a hard privacy boundary.</li>
<li><strong>D046 (Premium Content):</strong> Cosmetic purchases (if any) are displayed in the profile (e.g., custom profile borders, title unlocks). But the core profile is always free and full-featured.</li>
<li><strong>D050 (Workshop):</strong> Workshop creator statistics feed the creator profile section.</li>
<li><strong>D052 (Community Servers &amp; SCR):</strong> The verification backbone. Every reputation claim in the profile (rating, achievements, community membership) is backed by a signed credential. D053 is the user-facing layer; D052 is the cryptographic foundation. Trusted Communities (D053) determine which SCR issuers the player considers authoritative — this feeds into profile display, lobby filtering, and matchmaking preferences.</li>
</ul>
<h3 id="alternatives-considered-11"><a class="header" href="#alternatives-considered-11">Alternatives Considered</a></h3>
<ul>
<li><strong>Central profile server</strong> (rejected — contradicts federation model, creates single point of failure, requires infrastructure IC doesn’t want to operate)</li>
<li><strong>Blockchain-based identity</strong> (rejected — massively overcomplicated, no user benefit over Ed25519 SCR, environmental concerns)</li>
<li><strong>Rich profile customization (themes, animations, music)</strong> (deferred — too much scope for initial implementation. May be added as Workshop cosmetic packs in Phase 6+)</li>
<li><strong>Full social network features (posts, feeds, groups)</strong> (rejected — out of scope. IC is a game, not a social network. Communities, friends, and profiles are sufficient. Players who want social features use Discord)</li>
<li><strong>Mandatory real name / identity verification</strong> (rejected — privacy violation, hostile to the gaming community’s norms, not IC’s business)</li>
</ul>
<h3 id="phase-5"><a class="header" href="#phase-5">Phase</a></h3>
<ul>
<li><strong>Phase 3:</strong> Basic profile (display name, avatar, bio, local storage, lobby display). Friends list (platform-backed via <code>PlatformServices</code>).</li>
<li><strong>Phase 5:</strong> Community-backed profiles (SCR-verified ratings, achievements, memberships). IC friends (community-based mutual friend requests). Presence system. Profile cards in lobby. Trusted communities configuration. Trust-based matchmaking filtering. Profile verification UI (signed proof sheet). Game browser trust filters.</li>
<li><strong>Phase 6a:</strong> Workshop creator profiles. Full achievement showcase. Custom profile elements. Privacy controls UI. Profile viewing in game browser. Cross-community trust discovery.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="08-ROADMAP.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="10-PERFORMANCE.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="08-ROADMAP.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="10-PERFORMANCE.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
