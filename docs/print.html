<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Iron Curtain — Design Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Design docs for a Rust-native Red Alert RTS engine">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-5b2ff5f5.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-ef8cba4b.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Iron Curtain — Design Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/DK26/iron-curtain-design-docs" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="iron-curtain--design-documentation"><a class="header" href="#iron-curtain--design-documentation">Iron Curtain — Design Documentation</a></h1>
<h2 id="project-rust-native-red-alert-rts-engine"><a class="header" href="#project-rust-native-red-alert-rts-engine">Project: Rust-Native Red Alert RTS Engine</a></h2>
<p><strong>Status:</strong> Pre-development (design phase)<br><strong>Date:</strong> 2026-02-06<br><strong>Codename:</strong> Iron Curtain<br><strong>Author:</strong> David Krasnitsky</p>
<h2 id="what-this-is"><a class="header" href="#what-this-is">What This Is</a></h2>
<p>A Rust-native RTS engine that supports OpenRA resource formats (<code>.mix</code>, <code>.shp</code>, <code>.pal</code>, YAML rules), reimagines internals with modern architecture, and aims to eventually supersede OpenRA by offering superior performance, modding, and portability. Not a clone or port — a genuine improvement with OpenRA mod compatibility as the migration path.</p>
<h2 id="document-index"><a class="header" href="#document-index">Document Index</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>#</th><th>Document</th><th>Purpose</th><th>Read When…</th></tr>
</thead>
<tbody>
<tr><td>01</td><td><code>01-VISION.md</code></td><td>Project goals, competitive landscape, why this should exist</td><td>You need to understand the project’s purpose and market position</td></tr>
<tr><td>02</td><td><code>02-ARCHITECTURE.md</code></td><td>Core architecture: crate structure, ECS, sim/render split, game loop</td><td>You need to make any structural or code-level decision</td></tr>
<tr><td>03</td><td><code>03-NETCODE.md</code></td><td>Network models, CS2 sub-tick insights, relay server, pluggable trait</td><td>You’re working on multiplayer, networking, or the sim/network boundary</td></tr>
<tr><td>04</td><td><code>04-MODDING.md</code></td><td>YAML rules, Lua scripting, WASM modules, templating</td><td>You’re working on data formats, scripting, or mod support</td></tr>
<tr><td>05</td><td><code>05-FORMATS.md</code></td><td>File formats, original source code insights, compatibility layer</td><td>You’re working on asset loading, ra-formats crate, or OpenRA interop</td></tr>
<tr><td>06</td><td><code>06-SECURITY.md</code></td><td>Threat model, vulnerabilities, mitigations for online play</td><td>You’re working on networking, modding sandbox, or anti-cheat</td></tr>
<tr><td>07</td><td><code>07-CROSS-ENGINE.md</code></td><td>Cross-engine compatibility, protocol adapters, reconciliation</td><td>You’re exploring OpenRA interop or multi-engine play</td></tr>
<tr><td>08</td><td><code>08-ROADMAP.md</code></td><td>36-month development plan with phased milestones</td><td>You need to plan work or understand phase dependencies</td></tr>
<tr><td>09</td><td><code>09-DECISIONS.md</code></td><td>Decision log with rationale for every major choice</td><td>You want to understand WHY a decision was made, or revisit one</td></tr>
<tr><td>10</td><td><code>10-PERFORMANCE.md</code></td><td>Efficiency-first performance philosophy, targets, profiling</td><td>You’re optimizing a system, choosing algorithms, or adding parallelism</td></tr>
</tbody>
</table>
</div>
<h2 id="key-architectural-invariants"><a class="header" href="#key-architectural-invariants">Key Architectural Invariants</a></h2>
<p>These are non-negotiable across the entire project:</p>
<ol>
<li><strong>Simulation is pure and deterministic.</strong> No I/O, no floats, no network awareness. Takes orders, produces state. Period.</li>
<li><strong>Network model is pluggable via trait.</strong> Game loop is generic over <code>NetworkModel</code>. Swapping lockstep for rollback touches zero sim code.</li>
<li><strong>Modding is tiered.</strong> YAML (data) → Lua (scripting) → WASM (power). Each tier is optional and sandboxed.</li>
<li><strong>Bevy as framework.</strong> ECS scheduling, rendering, asset pipeline, audio — Bevy handles infrastructure so we focus on game logic. Custom render passes and SIMD only where profiling justifies it.</li>
<li><strong>Efficiency-first performance.</strong> Better algorithms, cache-friendly ECS, zero-allocation hot paths, simulation LOD, amortized work — THEN multi-core as a bonus layer. A 2-core laptop must run 500 units smoothly.</li>
<li><strong>Real YAML, not MiniYAML.</strong> Standard <code>serde_yaml</code> with inheritance resolved at load time.</li>
<li><strong>OpenRA compatibility is at the data/community layer, not the simulation layer.</strong> Same mods, same maps, shared server browser — but not bit-identical simulation.</li>
<li><strong>Full resource compatibility with Red Alert and OpenRA.</strong> Every .mix, .shp, .pal, .aud, .oramap, and YAML rule file from the original game and OpenRA must load correctly. This is non-negotiable — the community’s existing work is sacred.</li>
<li><strong>Engine core is game-agnostic.</strong> No game-specific enums, resource types, or unit categories in engine core. Positions are 3D (<code>WorldPos { x, y, z }</code>). System pipeline is registered per game module, not hardcoded.</li>
<li><strong>Platform-agnostic by design.</strong> Input is abstracted behind <code>InputSource</code> trait. UI layout is responsive (adapts to screen size via <code>ScreenClass</code>). No raw <code>std::fs</code> — all assets go through Bevy’s asset system. Render quality is runtime-configurable.</li>
</ol>
<h2 id="crate-structure-overview"><a class="header" href="#crate-structure-overview">Crate Structure Overview</a></h2>
<pre><code>iron-curtain/
├── ra-formats     # .mix, .shp, .pal, YAML parsing, MiniYAML converter
├── ra-sim         # Deterministic simulation (Bevy FixedUpdate systems)
├── ra-protocol    # PlayerOrder, TimestampedOrder, OrderCodec trait
├── ra-net         # NetworkModel trait + implementations (Bevy plugins)
├── ra-render      # Isometric rendering, shaders, post-FX (Bevy plugin)
├── ra-ui          # Game chrome: sidebar, minimap, build queue (Bevy UI)
├── ra-audio       # .aud playback, EVA, music (Bevy audio plugin)
├── ra-script      # Lua + WASM mod runtimes
├── ra-ai          # Skirmish AI, mission scripting
├── ra-llm         # LLM mission/campaign generation, adaptive difficulty
└── ra-game        # Top-level Bevy App, ties all plugins together
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="foreword--why-im-building-this"><a class="header" href="#foreword--why-im-building-this">Foreword — Why I’m Building This</a></h1>
<p>I’ve been a Red Alert fan since the first game came out. I was a kid, playing at a friend’s house over what we’d now call a “LAN” — two ancient computers connected with a cable. I was hooked. The cutscenes, the music, building a base and watching your stuff fight. I would literally go to any friend’s house that could run this game just to play it.</p>
<p>That game is the reason I wanted to learn how computers work. Someone, somewhere, <em>built</em> that. I wanted to know how.</p>
<h2 id="growing-up"><a class="header" href="#growing-up">Growing Up</a></h2>
<p>I started programming at 12 — Pascal. Wrote little programs, thought it was amazing, and then looked at what it would actually take to make a game that looks and feels and plays real good. Yeah, that was going to take a while.</p>
<p>I went through a lot of jobs and technologies over the years. Network engineering, backend development, automations, cyber defense. I wrote Java for a while, then Python for many years. Each job taught me things I didn’t know I’d need later. I wasn’t chasing a goal — I was just building a career and getting better at making software.</p>
<p>Along the way I discovered Rust. It clicked. Most programming languages make you choose: either you get full control over your computer’s resources (but risk hard-to-find bugs and crashes), or you get safety (but give up performance). Rust gives you both. The language is designed so that entire categories of bugs — the kind that cause crashes, security holes, and impossible-to-reproduce errors — simply can’t happen. The compiler catches them before the program ever runs. You can write high-performance code and actually sleep at night.</p>
<p>I also found OpenRA around this time, and I was glad an open-source community had kept Red Alert alive for so long. I browsed through the C# codebase (I know C# well enough), enjoyed poking around the internals, but eventually real life pulled me away.</p>
<p>I did buy a Rust game dev book though. Took some Udemy courses. Played with prototypes. The idea of writing a game in Rust never quite left.</p>
<h2 id="the-other-games-that-mattered"><a class="header" href="#the-other-games-that-mattered">The Other Games That Mattered</a></h2>
<p>I was a gamer my whole life, and a few games shaped how I think about making games, not just playing them.</p>
<p><strong>Half-Life</strong> — I spent hours customizing levels and poking at its mechanics. Same for <strong>Deus Ex</strong> — pulling apart systems, seeing how things connected.</p>
<p>But the one that really got me was <strong>Operation Flashpoint: Cold War Crisis</strong> (now ArmA: Cold War Assault). OFP had a mission editor that was actually approachable. You could create scenarios in simple ways, dig through its resources and files, and build something that felt real. I spent more time editing missions, campaigns, and multiplayer scenarios for OFP than playing any other game. Recreating movie scenes, building tactical situations, making co-op missions for friends — that was my thing.</p>
<p>What OFP taught me is that the best games are the ones that give you tools and get out of your way. Games as platforms, not just products. That idea stuck with me for twenty years, and it’s a big part of why Iron Curtain works the way it does.</p>
<h2 id="how-this-actually-started"><a class="header" href="#how-this-actually-started">How This Actually Started</a></h2>
<p>Over five years, Rust became my main language. I built backend systems, contributed to open-source projects, and got to the point where I could think in Rust the way I used to think in Python. The idea kept nagging: what if I tried writing a Red Alert engine in Rust?</p>
<p>Then, separately, I got into LLMs and AI agents. I was between jobs and decided to learn the tooling by building real projects with it. Honestly, I hated it at first. The LLM would generate a bunch of code, and I’d spend all my time reviewing and correcting it. It got credit for the fun part.</p>
<p>But the tools got better, and so did I. What changed is that they made it realistic to take on big, complex solo projects with proper architecture. Break everything down, make each piece testable, follow best practices throughout. The tooling caught up with what I already knew how to do.</p>
<p>This project didn’t start as an attempt to replace OpenRA. I just wanted to test new technology — see if Rust, Bevy, and LLM-assisted development could come together into something real. A proof of concept. A learning exercise. But the more I thought about the design, the more I realized it could actually serve the community. That’s when I decided to take it seriously.</p>
<p>This project is also a research opportunity. I want to take LLM-assisted coding to the next level — not just throw prompts at a model and ship whatever comes back. I’m a developer who needs to understand what code does. When code is generated, I do my best to read through it, understand every part, and verify it. I use the best models available to cross-check, document, and maintain a consistent code style so the codebase stays reviewable by humans.</p>
<p>There’s a compounding effect here: as the framework and architecture become more solid, the rules for how the LLM creates and modifies code become more focused and restricted. The design docs, the invariants, the crate boundaries — they all constrain what the LLM can do, which reduces the chance of serious errors. On top of that, I’m a firm believer in verifying code with tests and benchmarks. If it’s not tested, it doesn’t count.</p>
<h2 id="what-bugged-me-about-the-alternatives"><a class="header" href="#what-bugged-me-about-the-alternatives">What Bugged Me About the Alternatives</a></h2>
<p>OpenRA is great for what it is. But I’ve felt the lag — not just in big battles, it’s random. Something feels off sometimes. The Remastered Collection has the same problem, which made me wonder if they went the C# route too — and it turns out they did. The original C++ engine runs as a DLL, but the networking and rendering layers are handled by a proprietary C# client. For me it comes down to raw performance: the original Red Alert was written in C, and it ran close to the hardware. C# doesn’t.</p>
<p>The Remastered Collection has the same performance issues. Modding is limited. Windows and Xbox only.</p>
<p>I kept thinking about what Rust brings to the table:</p>
<ul>
<li>Fast like C — runs close to the hardware, no garbage collector, predictable performance</li>
<li>Safe — the compiler prevents the kinds of bugs that cause crashes and security vulnerabilities in other languages</li>
<li>Built for multi-core — modern CPUs have many cores, and Rust makes it safe to use all of them without the concurrency bugs that plague other languages</li>
<li>Here to stay — it’s in the Linux kernel, backed by every major tech company, and growing fast</li>
</ul>
<h2 id="what-i-wanted-to-build"><a class="header" href="#what-i-wanted-to-build">What I Wanted to Build</a></h2>
<p>Once I committed, the ideas came fast.</p>
<p><strong>Bevy</strong> was the obvious engine choice. It’s the most popular community-driven Rust game engine, it uses a modern architecture that’s a natural fit for RTS games (where you need to efficiently manage thousands of units at once), and there’s a whole community of people working on it constantly. Building on top of Bevy means inheriting their progress instead of reinventing rendering, audio, and asset pipelines from scratch. And it means modders get access to a real modern rendering stack — imagine toggling between classic sprites and something with dynamic water, weather effects, proper lighting. Or just keeping it classic, but smooth.</p>
<p><strong>Cross-engine compatibility</strong> — I wanted OpenRA players and Iron Curtain players to coexist. My background includes a lot of work translating between different systems, and the same principles apply here.</p>
<p><strong>Switchable netcode</strong> — inspired by how CS2 does sub-tick processing and relay servers. If we pick the wrong networking model, or something better comes along, we should be able to swap it without touching the simulation code.</p>
<p><strong>Community independence</strong> — the game should never die because someone turns off a server. Self-hosted everything. Federated workshop. No single point of failure.</p>
<p><strong>Security done through architecture</strong> — not a kernel-level anti-cheat, but real defenses: order validation inside the simulation, signed replays, relay servers that own the clock. Stuff that comes from building backend systems and knowing how people cheat.</p>
<p><strong>LLM-generated missions</strong> — this is the part that excites me most. What if you could describe a scenario in plain English and get a playable mission? Like OFP’s mission editor, but you just tell it what you want. The output is standard YAML and Lua, fully editable. Infinite content.</p>
<h2 id="where-this-is-now"><a class="header" href="#where-this-is-now">Where This Is Now</a></h2>
<p>I put all of these ideas together and did a serious research phase to figure out what’s actually feasible. These design documents are the result. They cover architecture, networking, modding, security, performance, file format compatibility, cross-engine play, and a 36-month roadmap.</p>
<p>Every decision has a rationale. Every system has been thought through against the others. It’s designed to be built piece by piece, tested in isolation, and contributed to by anyone who cares to.</p>
<p>What started as “can I get this to work?” turned into “how do I make sure everything I build can serve the community?” That’s where I am now.</p>
<hr>
<p><em>— David Krasnitsky, February 2026</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="01--vision--competitive-landscape"><a class="header" href="#01--vision--competitive-landscape">01 — Vision &amp; Competitive Landscape</a></h1>
<h2 id="project-vision"><a class="header" href="#project-vision">Project Vision</a></h2>
<p>Build a Rust-native RTS engine that:</p>
<ul>
<li>Supports OpenRA resource formats (<code>.mix</code>, <code>.shp</code>, <code>.pal</code>, YAML rules)</li>
<li>Reimagines internals with modern architecture (not a port)</li>
<li>Offers superior performance, modding, portability, and multiplayer</li>
<li>Provides OpenRA mod compatibility as the zero-cost migration path</li>
<li>Is <strong>game-agnostic at the engine layer</strong> — Red Alert is the first game module; RA2, Tiberian Dawn, and original games are future modules on the same engine</li>
</ul>
<h2 id="why-this-deserves-to-exist"><a class="header" href="#why-this-deserves-to-exist">Why This Deserves to Exist</a></h2>
<h3 id="capabilities-beyond-openra-and-the-remastered-collection"><a class="header" href="#capabilities-beyond-openra-and-the-remastered-collection">Capabilities Beyond OpenRA and the Remastered Collection</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Capability</th><th>Remastered Collection</th><th>OpenRA</th><th>Iron Curtain</th></tr>
</thead>
<tbody>
<tr><td>Engine</td><td>Original C++ as DLL, proprietary C# client</td><td>C# / .NET (2007)</td><td>Rust + Bevy (2026)</td></tr>
<tr><td>Platforms</td><td>Windows, Xbox</td><td>Windows, macOS, Linux</td><td>All + Browser + Mobile</td></tr>
<tr><td>Max units (smooth)</td><td>Unknown (not benchmarked)</td><td>Community reports lag at 300-500 units</td><td>2000+ target</td></tr>
<tr><td>Modding</td><td>Steam Workshop maps, limited API</td><td>MiniYAML + C# (recompile for deep mods)</td><td>YAML + Lua + WASM (no recompile ever)</td></tr>
<tr><td>AI content</td><td>Fixed campaigns</td><td>Fixed campaigns + community missions</td><td>Branching campaigns + LLM-generated missions</td></tr>
<tr><td>Multiplayer</td><td>Proprietary networking (not open-sourced)</td><td>TCP lockstep, 135+ desync issues tracked</td><td>Relay server, desync diagnosis, signed replays</td></tr>
<tr><td>Competitive</td><td>No ranked, no anti-cheat</td><td>Community ladders via CnCNet</td><td>Ranked matchmaking, Glicko-2, relay-certified results</td></tr>
<tr><td>Graphics pipeline</td><td>HD sprites, proprietary renderer</td><td>Custom renderer with post-processing (since March 2025)</td><td>Bevy + wgpu: shaders, post-FX, dynamic lighting, particles</td></tr>
<tr><td>Source</td><td>C++ engine GPL; networking/rendering proprietary</td><td>Open (GPL)</td><td>Open (GPL)</td></tr>
<tr><td>Community assets</td><td>Separate ecosystem</td><td>18 years of maps/mods</td><td>Loads all OpenRA assets + migration tools</td></tr>
</tbody>
</table>
</div>
<h3 id="new-capabilities-not-found-elsewhere"><a class="header" href="#new-capabilities-not-found-elsewhere">New Capabilities Not Found Elsewhere</a></h3>
<p><strong>LLM-Generated Missions and Campaigns</strong></p>
<p>An in-game interface where players describe a scenario in natural language and receive a fully playable mission — map layout, objectives, enemy AI, triggers, briefing text. Generated content is standard YAML + Lua, fully editable and shareable.</p>
<p>Future extensions: multi-mission campaign generation, adaptive difficulty that responds to player style, cooperative scenario generation for multiplayer.</p>
<p>This transforms Red Alert from a game with finite content to a game with infinite content.</p>
<p><strong>Bevy Rendering Pipeline</strong></p>
<p>Building on Bevy’s modern rendering stack unlocks visual capabilities beyond what OpenRA or the Remastered Collection currently offer:</p>
<ul>
<li>Post-processing: bloom, color grading, screen-space reflections on water</li>
<li>Dynamic lighting: explosions illuminate surroundings, day/night cycles</li>
<li>GPU particle systems: smoke, fire, debris, weather (rain, snow, sandstorm, fog, blizzard)</li>
<li>Dynamic weather: real-time transitions (sunny → overcast → rain → storm), snow accumulation on terrain, puddle formation, seasonal effects — terrain textures respond to weather via palette tinting, overlay sprites, or shader blending (D022)</li>
<li>Shader effects: chrono-shift shimmer, iron curtain glow, tesla arcs, nuclear flash</li>
<li>Smooth camera: sub-pixel rendering, cinematic replay camera, smooth zoom</li>
<li>HD asset pipeline alongside classic sprites</li>
</ul>
<p>The visual goal: Red Alert as you remember it through rose-tinted glasses — classic aesthetic, modern polish.</p>
<p><strong>In-Engine Map Editor</strong></p>
<p>OpenRA’s map editor is a standalone tool. Our editor runs inside the game with live preview, instant testing, and direct publishing. Lower barrier to content creation.</p>
<h3 id="openras-limitations-what-we-improve-on"><a class="header" href="#openras-limitations-what-we-improve-on">OpenRA’s Limitations (what we improve on)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Area</th><th>OpenRA Today</th><th>Our Engine</th></tr>
</thead>
<tbody>
<tr><td>Runtime</td><td>C# / .NET — GC pauses, heavy runtime</td><td>Rust — no GC, predictable perf</td></tr>
<tr><td>Threading</td><td>Single-threaded game loop (verified)</td><td>Parallel systems via ECS</td></tr>
<tr><td>Modding</td><td>Powerful but requires C# for deep mods</td><td>YAML + Lua + WASM (no compile step)</td></tr>
<tr><td>Map editor</td><td>Separate tool, recently improved</td><td>In-engine editor (Phase 6)</td></tr>
<tr><td>Multiplayer</td><td>135+ desync issues tracked</td><td>Snapshottable sim enables desync pinpointing</td></tr>
<tr><td>Competitive</td><td>Community ladders via CnCNet</td><td>Ranked matchmaking, anti-cheat, tournament mode</td></tr>
<tr><td>Portability</td><td>Desktop only (Mono/.NET)</td><td>Native + WASM (browser) + mobile</td></tr>
<tr><td>Engine age</td><td>Started 2007, actively maintained</td><td>Clean-sheet modern design</td></tr>
<tr><td>Campaigns</td><td>Some incomplete (TD, Dune 2000)</td><td>Branching campaigns with persistent state (D021)</td></tr>
<tr><td>Mission flow</td><td>Manual mission selection between levels</td><td>Continuous flow: briefing → mission → debrief → next</td></tr>
</tbody>
</table>
</div>
<h3 id="what-makes-people-actually-switch"><a class="header" href="#what-makes-people-actually-switch">What Makes People Actually Switch</a></h3>
<ol>
<li><strong>Better performance</strong> — visible: bigger maps, more units, no stutters</li>
<li><strong>Better modding</strong> — WASM scripting, in-engine editor, hot reload</li>
<li><strong>Campaigns that flow</strong> — branching paths, persistent units, no menu between missions, failure continues the story</li>
<li><strong>Competitive infrastructure</strong> — ranked matchmaking, anti-cheat, tournaments, signed replays — OpenRA has none of this</li>
<li><strong>Runs everywhere</strong> — browser via WASM, mobile, Steam Deck natively</li>
<li><strong>Better multiplayer</strong> — desync debugging, smoother netcode, relay server</li>
<li><strong>OpenRA mod compatibility</strong> — existing community migrates without losing work</li>
</ol>
<p>Item 7 is the linchpin. If existing mods just work, migration cost drops to near zero.</p>
<h2 id="competitive-play"><a class="header" href="#competitive-play">Competitive Play</a></h2>
<p>Red Alert has a dedicated competitive community (primarily through OpenRA and CnCNet). CnCNet provides community ladders and tournament infrastructure, but there’s no integrated ranked system, no automated anti-cheat, and desyncs remain a persistent issue (135+ tracked in OpenRA’s issue tracker). This is a significant opportunity.</p>
<h3 id="ranked-matchmaking"><a class="header" href="#ranked-matchmaking">Ranked Matchmaking</a></h3>
<ul>
<li><strong>Rating system:</strong> Glicko-2 (improvement over Elo — accounts for rating volatility and inactivity, used by Lichess, FIDE, many modern games)</li>
<li><strong>Seasons:</strong> 3-month ranked seasons with placement matches (10 games), league tiers (Bronze → Silver → Gold → Platinum → Diamond → Master), end-of-season rewards</li>
<li><strong>Queues:</strong> 1v1 (primary), 2v2 (team), FFA (experimental). Separate ratings per queue</li>
<li><strong>Map pool:</strong> Curated competitive map pool per season, community-nominated and committee-voted. Ranked games use pool maps only</li>
<li><strong>Balance preset locked:</strong> Ranked play uses a fixed balance preset per season (prevents mid-season rule changes from invalidating results)</li>
<li><strong>Matchmaking server:</strong> Lightweight Rust service, same infra pattern as tracking/relay servers (containerized, self-hostable for community leagues)</li>
</ul>
<h3 id="leaderboards"><a class="header" href="#leaderboards">Leaderboards</a></h3>
<ul>
<li>Global, per-faction, per-map, per-game-module (RA1, TD, etc.)</li>
<li>Public player profiles: rating history, win rate, faction preference, match history</li>
<li>Replay links on every match entry — any ranked game is reviewable</li>
</ul>
<h3 id="tournament-support"><a class="header" href="#tournament-support">Tournament Support</a></h3>
<ul>
<li><strong>Observer mode:</strong> Spectators connect to relay server and receive tick orders with configurable delay
<ul>
<li><strong>No fog</strong> — for casters (sees everything)</li>
<li><strong>Player fog</strong> — fair spectating (sees what one player sees)</li>
<li><strong>Broadcast delay</strong> — 1-5 minute configurable delay to prevent stream sniping</li>
</ul>
</li>
<li><strong>Bracket integration:</strong> Tournament organizers can set up brackets via API; match results auto-report</li>
<li><strong>Relay-certified results:</strong> Every ranked and tournament match produces a <code>CertifiedMatchResult</code> signed by the relay server (see <code>06-SECURITY.md</code>). No result disputes.</li>
<li><strong>Replay archive:</strong> All ranked/tournament replays stored server-side for post-match analysis and community review</li>
</ul>
<h3 id="anti-cheat-architectural-not-intrusive"><a class="header" href="#anti-cheat-architectural-not-intrusive">Anti-Cheat (Architectural, Not Intrusive)</a></h3>
<p>Our anti-cheat emerges from the architecture — not from kernel drivers or invasive monitoring:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>Defense</th><th>Details</th></tr>
</thead>
<tbody>
<tr><td><strong>Maphack</strong></td><td>Fog-authoritative server (tournament)</td><td>Server sends only visible entities — <code>06-SECURITY.md</code> V1</td></tr>
<tr><td><strong>Order injection</strong></td><td>Deterministic validation in sim</td><td>Every order validated before execution — <code>06-SECURITY.md</code> V2</td></tr>
<tr><td><strong>Lag switch</strong></td><td>Relay server time authority</td><td>Miss the window → orders dropped — <code>06-SECURITY.md</code> V3</td></tr>
<tr><td><strong>Speed hack</strong></td><td>Relay owns tick cadence</td><td>Client clock is irrelevant — <code>06-SECURITY.md</code> V11</td></tr>
<tr><td><strong>Automation</strong></td><td>Behavioral analysis</td><td>APM patterns, reaction times, input entropy — <code>06-SECURITY.md</code> V12</td></tr>
<tr><td><strong>Result fraud</strong></td><td>Relay-signed match results</td><td>Only relay-certified results update rankings — <code>06-SECURITY.md</code> V13</td></tr>
<tr><td><strong>Replay tampering</strong></td><td>Ed25519 hash chain</td><td>Tampered replay fails signature verification — <code>06-SECURITY.md</code> V6</td></tr>
<tr><td><strong>WASM mod abuse</strong></td><td>Capability sandbox</td><td><code>get_visible_units()</code> only, no <code>get_all_units()</code> — <code>06-SECURITY.md</code> V5</td></tr>
</tbody>
</table>
</div>
<p><strong>Philosophy:</strong> No kernel-level anti-cheat (no Vanguard/EAC). We’re open-source and cross-platform — intrusive anti-cheat contradicts our values and doesn’t work on Linux/WASM. We accept that lockstep has inherent maphack risk in P2P modes. The fog-authoritative server is the real answer for high-stakes play.</p>
<h3 id="performance-as-competitive-advantage"><a class="header" href="#performance-as-competitive-advantage">Performance as Competitive Advantage</a></h3>
<p>Competitive play demands rock-solid performance — stutters during a crucial micro moment lose games:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Metric</th><th>Competitive Requirement</th><th>Our Target</th></tr>
</thead>
<tbody>
<tr><td>Tick time (500 units)</td><td>&lt; 16ms (60 FPS smooth)</td><td>&lt; 10ms (8-core desktop)</td></tr>
<tr><td>Render FPS</td><td>60+ sustained</td><td>144 target</td></tr>
<tr><td>Input latency</td><td>&lt; 1 frame</td><td>Sub-tick ordering (D008)</td></tr>
<tr><td>RAM (1000 units)</td><td>&lt; 200MB</td><td>&lt; 200MB</td></tr>
<tr><td>Per-tick allocation</td><td>0 (no GC stutter)</td><td>0 bytes (invariant)</td></tr>
<tr><td>Desync recovery</td><td>Automatic</td><td>Diagnosed to exact tick + entity</td></tr>
</tbody>
</table>
</div>
<h2 id="competitive-landscape"><a class="header" href="#competitive-landscape">Competitive Landscape</a></h2>
<h3 id="active-projects"><a class="header" href="#active-projects">Active Projects</a></h3>
<p><strong>OpenRA</strong> (C#) — The project to beat</p>
<ul>
<li>14.8k GitHub stars, actively maintained</li>
<li>Latest release: 20250330 (March 2025) — new map editor, HD asset support, post-processing</li>
<li>Mature community, mod ecosystem, server infrastructure</li>
<li>Multiplayer-first focus — single-player campaigns often incomplete (Dune 2000: only 1 of 3 campaigns fully playable; TD campaign also incomplete)</li>
<li>SDK supports non-Westwood games (KKND, Swarm Assault, Hard Vacuum, Dune II remake) — validates our multi-game extensibility approach (D018)</li>
</ul>
<p><strong>Vanilla Conquer</strong> (C++)</p>
<ul>
<li>Cross-platform builds of actual EA source code</li>
<li>Not reimagination — just making original compile on modern systems</li>
<li>Useful reference for original engine behavior</li>
</ul>
<p><strong>Chrono Divide</strong> (TypeScript)</p>
<ul>
<li>Red Alert 2 running in browser, working multiplayer</li>
<li>Proof that browser-based RTS is viable</li>
<li>Study their architecture for WASM target</li>
</ul>
<h3 id="deadarchived-projects-lessons-learned"><a class="header" href="#deadarchived-projects-lessons-learned">Dead/Archived Projects (lessons learned)</a></h3>
<p><strong>Chronoshift</strong> (C++) — Archived July 2020</p>
<ul>
<li>Binary-level reimplementation attempt, only English 3.03 beta patch</li>
<li>Never reached playable state</li>
<li><strong>Lesson:</strong> 1:1 binary compatibility is a dead end</li>
</ul>
<p><strong>OpenRedAlert</strong> (C++)</p>
<ul>
<li>Based on ancient FreeCNC/FreeRA, barely maintained</li>
<li><strong>Lesson:</strong> Building on old foundations doesn’t work long-term</li>
</ul>
<h3 id="key-finding"><a class="header" href="#key-finding">Key Finding</a></h3>
<p><strong>No Rust-based Red Alert or OpenRA ports exist.</strong> The field is completely open.</p>
<h2 id="ea-source-release-february-2025"><a class="header" href="#ea-source-release-february-2025">EA Source Release (February 2025)</a></h2>
<p>EA released original Red Alert source code under GPL v3. Benefits:</p>
<ul>
<li>Understand exactly how original game logic works (damage, pathfinding, AI)</li>
<li>Verify Rust implementation against original behavior</li>
<li>Combined with OpenRA’s 17 years of refinements: “how it originally worked” + “how it should work”</li>
</ul>
<p>Repository: https://github.com/electronicarts/CnC_Red_Alert</p>
<h2 id="reference-projects"><a class="header" href="#reference-projects">Reference Projects</a></h2>
<p>These are the projects we actively study. Each serves a different purpose — do not treat them as interchangeable.</p>
<h3 id="openra--httpsgithubcomopenraopenra"><a class="header" href="#openra--httpsgithubcomopenraopenra">OpenRA — https://github.com/OpenRA/OpenRA</a></h3>
<p><strong>What to study:</strong></p>
<ul>
<li><strong>Source code:</strong> Trait/component architecture, how they solved the same problems we’ll face (fog of war, build queues, harvester AI, naval combat). Our ECS component model maps directly from their traits.</li>
<li><strong>Issue tracker:</strong> Community pain points surface here. Recurring complaints = design opportunities for us. Pay attention to issues tagged with performance, pathfinding, modding, and multiplayer.</li>
<li><strong>UX/UI patterns:</strong> OpenRA has 17 years of UI iteration. Their command interface (attack-move, force-fire, waypoints, control groups, rally points) is excellent. <strong>Adopt their UX patterns for player interaction.</strong></li>
<li><strong>Mod ecosystem:</strong> Understand what modders actually build so our modding tiers serve real needs.</li>
</ul>
<p><strong>What NOT to copy:</strong></p>
<ul>
<li><strong>Unit balance.</strong> OpenRA deliberately rebalances units away from the original game toward competitive multiplayer fairness. This makes iconic units feel underwhelming (see Gameplay Philosophy below). We default to classic RA balance. This pattern repeats across every game they support — Dune 2000 units are also rebalanced away from originals.</li>
<li><strong>Simulation internals bug-for-bug.</strong> We’re not bit-identical — we’re better-algorithms-identical.</li>
<li><strong>Campaign neglect.</strong> OpenRA’s multiplayer-first culture has left single-player campaigns systematically incomplete across all supported games. Dune 2000 has only 1 of 3 campaigns playable; TD campaigns are also incomplete; there’s no automatic mission progression (players exit to menu between missions). <strong>Campaign completeness is a first-class goal for us</strong> — every shipped game module must have all original campaigns fully playable with continuous flow (D021). Beyond completeness, our campaign graph system enables what OpenRA can’t: branching outcomes (different mission endings lead to different next missions), persistent unit rosters (surviving units carry forward with veterancy), and failure that continues the story instead of forcing a restart — inspired by Operation Flashpoint.</li>
</ul>
<h3 id="ea-red-alert-source--httpsgithubcomelectronicartscnc_red_alert"><a class="header" href="#ea-red-alert-source--httpsgithubcomelectronicartscnc_red_alert">EA Red Alert Source — https://github.com/electronicarts/CnC_Red_Alert</a></h3>
<p><strong>What to study:</strong></p>
<ul>
<li><strong>Exact gameplay values.</strong> Damage tables, weapon ranges, unit speeds, fire rates, armor multipliers. This is the canonical source for “how Red Alert actually plays.” When OpenRA and EA source disagree on a value, <strong>EA source wins for our classic preset.</strong></li>
<li><strong>Order processing.</strong> The <code>OutList</code>/<code>DoList</code> pattern maps directly to our <code>PlayerOrder → TickOrders → apply_tick()</code> architecture.</li>
<li><strong>Integer math patterns.</strong> Original RA uses integer math throughout for determinism — validates our fixed-point approach.</li>
<li><strong>AI behavior.</strong> How the original skirmish AI makes decisions, builds bases, attacks. Reference for <code>ra-ai</code>.</li>
</ul>
<p><strong>Caution:</strong> The codebase is 1990s C++ — tangled, global state everywhere, no tests. Extract knowledge, don’t port patterns.</p>
<h3 id="ea-remastered-collection--httpsgithubcomelectronicartscnc_remastered_collection"><a class="header" href="#ea-remastered-collection--httpsgithubcomelectronicartscnc_remastered_collection">EA Remastered Collection — https://github.com/electronicarts/CnC_Remastered_Collection</a></h3>
<p><strong>What to study:</strong></p>
<ul>
<li><strong>UI/UX design.</strong> The Remastered Collection has the best UI/UX of any C&amp;C game. Clean, uncluttered, scales well to modern resolutions. <strong>This is our gold standard for UI layout and information density.</strong> Where OpenRA sometimes overwhelms with GUI elements, Remastered gets the density right.</li>
<li><strong>HD asset pipeline.</strong> How they upscaled and re-rendered classic assets while preserving the feel. Relevant for our rendering pipeline.</li>
<li><strong>Sidebar design.</strong> Classic sidebar with modern polish — study how they balanced information vs screen real estate.</li>
</ul>
<h3 id="ea-tiberian-dawn-source--httpsgithubcomelectronicartscnc_tiberian_dawn"><a class="header" href="#ea-tiberian-dawn-source--httpsgithubcomelectronicartscnc_tiberian_dawn">EA Tiberian Dawn Source — https://github.com/electronicarts/CnC_Tiberian_Dawn</a></h3>
<p><strong>What to study:</strong></p>
<ul>
<li><strong>Shared C&amp;C engine lineage.</strong> TD and RA share engine code. Cross-referencing both clarifies ambiguous behavior in either.</li>
<li><strong>Game module reference.</strong> When we build the Tiberian Dawn game module (D018), this is the authoritative source for TD-specific logic.</li>
<li><strong>Format compatibility.</strong> TD <code>.mix</code> files, terrain, and sprites share formats with RA — validation data for <code>ra-formats</code>.</li>
</ul>
<h3 id="chrono-divide--typescript-browser-based-ra2"><a class="header" href="#chrono-divide--typescript-browser-based-ra2">Chrono Divide — (TypeScript, browser-based RA2)</a></h3>
<p><strong>What to study:</strong></p>
<ul>
<li>Architecture reference for our WASM/browser target</li>
<li>Proof that browser-based RTS with real multiplayer is viable</li>
</ul>
<h2 id="gameplay-philosophy"><a class="header" href="#gameplay-philosophy">Gameplay Philosophy</a></h2>
<h3 id="classic-feel-modern-ux"><a class="header" href="#classic-feel-modern-ux">Classic Feel, Modern UX</a></h3>
<p>Iron Curtain’s default gameplay targets the <strong>original Red Alert experience</strong>, not OpenRA’s rebalanced version. This is a deliberate choice:</p>
<ul>
<li><strong>Units should feel powerful and distinct.</strong> Tanya kills soldiers from range, fast, and doesn’t die easily — she’s a special operative, not a fragile glass cannon. MiG attacks should be devastating. V2 rockets should be terrifying. Tesla coils should fry anything that comes close. <strong>If a unit was iconic in the original game, it should feel iconic here.</strong></li>
<li><strong>OpenRA’s competitive rebalancing</strong> makes units more “fair” for tournament play but can dilute the personality of iconic units. That’s a valid design choice for competitive players, but it’s not <em>our</em> default.</li>
<li><strong>OpenRA’s UX/UI innovations are genuinely excellent</strong> and we adopt them: attack-move, waypoint queuing, production queues, control group management, minimap interactions, build radius visualization. The Remastered Collection’s UI density and layout is our gold standard for visual design.</li>
</ul>
<h3 id="switchable-balance-presets-d019"><a class="header" href="#switchable-balance-presets-d019">Switchable Balance Presets (D019)</a></h3>
<p>Because reasonable people disagree on balance, the engine supports <strong>balance presets</strong> — switchable sets of unit values loaded from YAML at game start:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Preset</th><th>Source</th><th>Feel</th></tr>
</thead>
<tbody>
<tr><td><code>classic</code> (default)</td><td>EA source code values</td><td>Powerful iconic units, asymmetric fun</td></tr>
<tr><td><code>openra</code></td><td>OpenRA’s current balance</td><td>Competitive fairness, tournament-ready</td></tr>
<tr><td><code>remastered</code></td><td>Remastered Collection values</td><td>Slight tweaks to classic for QoL</td></tr>
<tr><td><code>custom</code></td><td>User-defined YAML overrides</td><td>Full modder control</td></tr>
</tbody>
</table>
</div>
<p>Presets are just YAML files in <code>rules/presets/</code>. Switching preset = loading a different set of unit/weapon/structure YAML. No code changes, no mod required. The lobby UI exposes preset selection.</p>
<p>This is not a modding feature — it’s a first-class game option. “Classic” vs “OpenRA” balance is a settings toggle, not a total conversion.</p>
<p>See <code>src/04-MODDING.md</code> § “Balance Presets” and D019 in <code>src/09-DECISIONS.md</code>.</p>
<h2 id="timing-assessment"><a class="header" href="#timing-assessment">Timing Assessment</a></h2>
<ul>
<li>EA source just released (fresh community interest)</li>
<li>Rust gamedev ecosystem mature (wgpu stable, ECS crates proven)</li>
<li>No competition in Rust RTS space</li>
<li>OpenRA showing architectural age despite active development</li>
<li>WASM/browser gaming increasingly viable</li>
<li>Multiple EA source releases provide unprecedented reference material</li>
</ul>
<p><strong>Verdict:</strong> Window of opportunity is open now.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="02--core-architecture"><a class="header" href="#02--core-architecture">02 — Core Architecture</a></h1>
<h2 id="decision-bevy"><a class="header" href="#decision-bevy">Decision: Bevy</a></h2>
<p><strong>Rationale (revised — see D002 in <code>src/09-DECISIONS.md</code>):</strong></p>
<ul>
<li>ECS <em>is</em> our architecture — Bevy gives it to us with scheduling, queries, and parallel system execution out of the box</li>
<li>Saves 2–4 months of engine plumbing (windowing, asset pipeline, audio, rendering scaffolding)</li>
<li>Plugin system maps naturally to pluggable networking (<code>NetworkModel</code> as a Bevy plugin)</li>
<li>Bevy’s 2D + 3D rendering pipeline covers both classic isometric sprites and future 3D mods</li>
<li><code>wgpu</code> is Bevy’s backend — we still get low-level control via custom render passes where profiling justifies it</li>
<li>Breaking API changes are manageable: pin Bevy version per development phase, upgrade between phases</li>
</ul>
<p><strong>Bevy provides:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Bevy Subsystem</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Windowing</td><td><code>bevy_winit</code></td><td>Cross-platform, handles lifecycle events</td></tr>
<tr><td>Rendering</td><td><code>bevy_render</code> + <code>wgpu</code></td><td>Custom isometric sprite passes + standard 3D pipeline</td></tr>
<tr><td>ECS</td><td><code>bevy_ecs</code></td><td>Archetypes, system scheduling, change detection</td></tr>
<tr><td>Asset I/O</td><td><code>bevy_asset</code></td><td>Hot-reloading, platform-agnostic (WASM/mobile-safe)</td></tr>
<tr><td>Audio</td><td><code>bevy_audio</code></td><td>Platform-routed; <code>ra-audio</code> wraps for .aud/.ogg/EVA</td></tr>
<tr><td>Dev tools</td><td><code>egui</code> via <code>bevy_egui</code></td><td>Immediate-mode debug overlays</td></tr>
<tr><td>Scripting</td><td><code>mlua</code> (Bevy resource)</td><td>Lua embedding, integrated as non-send resource</td></tr>
<tr><td>Mod runtime</td><td><code>wasmtime</code> / <code>wasmer</code></td><td>WASM sandboxed execution (Bevy system, not Bevy plugin)</td></tr>
</tbody>
</table>
</div>
<h2 id="simulation--render-split-critical-architecture"><a class="header" href="#simulation--render-split-critical-architecture">Simulation / Render Split (Critical Architecture)</a></h2>
<p>The simulation and renderer are completely decoupled from day one.</p>
<pre><code>┌─────────────────────────────────────────────┐
│             GameLoop&lt;N, I&gt;                  │
│                                             │
│  Input(I) → Network(N) → Sim (tick) → Render│
│                                             │
│  Sim runs at fixed tick rate (e.g., 15/sec) │
│  Renderer interpolates between sim states   │
│  Renderer can run at any FPS independently  │
└─────────────────────────────────────────────┘
</code></pre>
<h3 id="simulation-properties"><a class="header" href="#simulation-properties">Simulation Properties</a></h3>
<ul>
<li><strong>Deterministic:</strong> Same inputs → identical outputs on every platform</li>
<li><strong>Pure:</strong> No I/O, no floats in game logic, no network awareness</li>
<li><strong>Fixed-point math:</strong> <code>i32</code>/<code>i64</code> with known scale (never <code>f32</code>/<code>f64</code> in sim)</li>
<li><strong>Snapshottable:</strong> Full state serializable for replays, save games, desync debugging, rollback, campaign state persistence (D021)</li>
<li><strong>Headless-capable:</strong> Can run without renderer (dedicated servers, AI training, automated testing)</li>
</ul>
<h3 id="simulation-core-types"><a class="header" href="#simulation-core-types">Simulation Core Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// All sim-layer coordinates use fixed-point
pub type SimCoord = i32;  // 1 unit = 1/SCALE of a cell (see P002)

/// Position is 3D-aware from day one.
/// RA1 game module sets z = 0 everywhere (flat isometric).
/// RA2/TS game module uses z for terrain elevation, bridges, aircraft altitude.
pub struct WorldPos {
    pub x: SimCoord,
    pub y: SimCoord,
    pub z: SimCoord,  // 0 for flat games (RA1), meaningful for elevated terrain (RA2/TS)
}

/// Cell position on the grid — also 3D-aware.
pub struct CellPos {
    pub x: i32,
    pub y: i32,
    pub z: i32,  // layer / elevation level (0 for RA1)
}

/// The sim is a pure function: state + orders → new state
pub struct Simulation {
    world: World,          // ECS world (all entities + components)
    tick: u64,             // Current tick number
    rng: DeterministicRng, // Seeded, reproducible RNG
}

impl Simulation {
    /// THE critical function. Pure, deterministic, no I/O.
    pub fn apply_tick(&amp;mut self, orders: &amp;TickOrders) {
        // 1. Apply orders (sorted by sub-tick timestamp)
        for (player, order, timestamp) in orders.chronological() {
            self.execute_order(player, order);
        }
        // 2. Run systems: movement, combat, harvesting, AI, production
        self.run_systems();
        // 3. Advance tick
        self.tick += 1;
    }

    /// Snapshot for rollback / desync debugging / save games
    pub fn snapshot(&amp;self) -&gt; SimSnapshot { /* serialize everything */ }
    pub fn restore(&amp;mut self, snap: &amp;SimSnapshot) { /* deserialize */ }

    /// Hash for desync detection
    pub fn state_hash(&amp;self) -&gt; u64 { /* hash critical state */ }

    /// Surgical correction for cross-engine reconciliation
    pub fn apply_correction(&amp;mut self, correction: &amp;EntityCorrection) {
        // Directly set an entity's field — only used by reconciler
    }
}
<span class="boring">}</span></code></pre>
<h3 id="order-validation-inside-sim-deterministic"><a class="header" href="#order-validation-inside-sim-deterministic">Order Validation (inside sim, deterministic)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Simulation {
    fn execute_order(&amp;mut self, player: PlayerId, order: &amp;PlayerOrder) {
        match self.validate_order(player, order) {
            OrderValidity::Valid =&gt; self.apply_order(player, order),
            OrderValidity::Rejected(reason) =&gt; {
                self.record_suspicious_activity(player, reason);
                // All honest clients also reject → stays in sync
            }
        }
    }
    
    fn validate_order(&amp;self, player: PlayerId, order: &amp;PlayerOrder) -&gt; OrderValidity {
        // Every order type validated: ownership, affordability, prerequisites, placement
        // This is deterministic — all clients agree on what to reject
    }
}
<span class="boring">}</span></code></pre>
<h2 id="ecs-design"><a class="header" href="#ecs-design">ECS Design</a></h2>
<p>ECS is a natural fit for RTS: hundreds of units with composable behaviors.</p>
<h3 id="component-model-mirrors-openra-traits"><a class="header" href="#component-model-mirrors-openra-traits">Component Model (mirrors OpenRA Traits)</a></h3>
<p>OpenRA’s “traits” are effectively components. Map them directly. The table below shows the <strong>RA1 game module’s</strong> default components. Other game modules (RA2, TD) register additional components — the ECS is open for extension without modifying the engine core.</p>
<p><strong>OpenRA vocabulary compatibility (D023):</strong> OpenRA trait names are accepted as YAML aliases. <code>Armament</code> and <code>combat</code> both resolve to the same component. This means existing OpenRA YAML definitions load without renaming.</p>
<p><strong>Canonical enum names (D027):</strong> Locomotor types (<code>Foot</code>, <code>Wheeled</code>, <code>Tracked</code>, <code>Float</code>, <code>Fly</code>), armor types (<code>None</code>, <code>Light</code>, <code>Medium</code>, <code>Heavy</code>, <code>Wood</code>, <code>Concrete</code>), target types, damage states, and stances match OpenRA’s names exactly. Versus tables and weapon definitions copy-paste without translation.</p>
<p>| OpenRA Trait | ECS Component | Purpose |
| <code>Health</code> | <code>Health { current: i32, max: i32 }</code> | Hit points |
| <code>Mobile</code> | <code>Mobile { speed: i32, locomotor: LocomotorType }</code> | Can move |
| <code>Attackable</code> | <code>Attackable { armor: ArmorType }</code> | Can be damaged |
| <code>Armament</code> | <code>Armament { weapon: WeaponId, cooldown: u32 }</code> | Can attack |
| <code>Building</code> | <code>Building { footprint: Vec&lt;CellPos&gt; }</code> | Occupies cells |
| <code>Buildable</code> | <code>Buildable { cost: i32, time: u32, prereqs: Vec&lt;StructId&gt; }</code> | Can be built |
| <code>Selectable</code> | <code>Selectable { bounds: Rect, priority: u8 }</code> | Player can select |
| <code>Harvester</code> | <code>Harvester { capacity: i32, resource: ResourceType }</code> | Gathers ore |
| <code>Producible</code> | <code>Producible { queue: QueueType }</code> | Produced from building |</p>
<h3 id="system-execution-order-deterministic-configurable-per-game-module"><a class="header" href="#system-execution-order-deterministic-configurable-per-game-module">System Execution Order (deterministic, configurable per game module)</a></h3>
<p>The <strong>RA1 game module</strong> registers this system execution order:</p>
<pre><code>Per tick:
  1. apply_orders()        — Process all player commands
  2. production_system()   — Advance build queues
  3. harvester_system()    — Gather/deliver resources
  4. movement_system()     — Move all mobile entities
  5. combat_system()       — Resolve attacks, apply damage
  6. death_system()        — Remove destroyed entities
  7. trigger_system()      — Check mission/map triggers
  8. fog_system()          — Update visibility
</code></pre>
<p>Order is fixed <em>per game module</em> and documented. Changing it changes gameplay and breaks replay compatibility.</p>
<p>A different game module (e.g., RA2) can insert additional systems (garrison, mind control, prism forwarding) at defined points. The engine runs whatever systems the active game module registers, in the order it specifies. The engine itself doesn’t know which game is running — it just executes the registered system pipeline deterministically.</p>
<h2 id="game-loop"><a class="header" href="#game-loop">Game Loop</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GameLoop&lt;N: NetworkModel, I: InputSource&gt; {
    sim: Simulation,
    renderer: Renderer,
    network: N,
    input: I,
    local_player: PlayerId,
}

impl&lt;N: NetworkModel, I: InputSource&gt; GameLoop&lt;N, I&gt; {
    fn frame(&amp;mut self) {
        // 1. Gather local input with sub-tick timestamps
        for order in self.input.drain_orders() {
            self.network.submit_order(order);
        }

        // 2. Advance sim as far as confirmed orders allow
        while let Some(tick_orders) = self.network.poll_tick() {
            self.sim.apply_tick(&amp;tick_orders);
            self.network.report_sync_hash(
                self.sim.tick(),
                self.sim.state_hash(),
            );
        }

        // 3. Render always runs, interpolates between sim states
        self.renderer.draw(&amp;self.sim, self.interpolation_factor());
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Key property:</strong> <code>GameLoop</code> is generic over <code>N: NetworkModel</code> and <code>I: InputSource</code>. It has zero knowledge of whether it’s running single-player or multiplayer, or whether input comes from a mouse, touchscreen, or gamepad. This is the central architectural guarantee.</p>
<h2 id="pathfinding"><a class="header" href="#pathfinding">Pathfinding</a></h2>
<p><strong>Decision:</strong> Hierarchical A* or flowfields — leap ahead of OpenRA’s basic A*.</p>
<p>OpenRA uses standard A* which struggles with large unit groups. Hierarchical pathfinding or flowfields handle mass unit movement far better and are well-suited to the grid-based terrain.</p>
<h2 id="platform-portability"><a class="header" href="#platform-portability">Platform Portability</a></h2>
<p>The engine must not create obstacles for any platform. Desktop is the primary dev target, but every architectural choice must be portable to browser (WASM), mobile (Android/iOS), and consoles without rework.</p>
<h3 id="portability-design-rules"><a class="header" href="#portability-design-rules">Portability Design Rules</a></h3>
<ol>
<li>
<p><strong>Input is abstracted behind a trait.</strong> <code>InputSource</code> produces <code>PlayerOrder</code>s — it knows nothing about mice, keyboards, touchscreens, or gamepads. The game loop consumes orders, not raw input events. Each platform provides its own <code>InputSource</code> implementation.</p>
</li>
<li>
<p><strong>UI layout is responsive.</strong> No hardcoded pixel positions. The sidebar, minimap, and build queue use constraint-based layout that adapts to screen size and aspect ratio. Mobile/tablet may use a completely different layout (bottom bar instead of sidebar). <code>ra-ui</code> provides layout <em>profiles</em>, not a single fixed layout.</p>
</li>
<li>
<p><strong>Click-to-world is abstracted behind a trait.</strong> Isometric screen→cell (desktop), touch→cell (mobile), and raycast→cell (3D mod) all implement the same <code>ScreenToWorld</code> trait, producing a <code>CellPos</code>. No isometric math hardcoded in the game loop.</p>
</li>
<li>
<p><strong>Render quality is configurable per device.</strong> FPS cap, particle density, post-FX toggles, resolution scaling, shadow quality — all runtime-configurable. Mobile caps at 30fps; desktop targets 60-240fps. The renderer reads a <code>RenderSettings</code> resource, not compile-time constants. Four render quality tiers (Baseline → Standard → Enhanced → Ultra) are auto-detected from <code>wgpu::Adapter</code> capabilities at startup. Tier 0 (Baseline) targets GL 3.3 / WebGL2 hardware — no compute shaders, no post-FX, CPU particle fallback, palette tinting for weather. See <code>10-PERFORMANCE.md</code> § “GPU &amp; Hardware Compatibility” for tier definitions and hardware floor analysis.</p>
</li>
<li>
<p><strong>No raw filesystem I/O.</strong> All asset loading goes through Bevy’s asset system, never <code>std::fs</code> directly. Mobile and browser have sandboxed filesystems; WASM has no filesystem at all. Save games use platform-appropriate storage (e.g., <code>localStorage</code> on web, app sandbox on mobile).</p>
</li>
<li>
<p><strong>App lifecycle is handled.</strong> Mobile and consoles require suspend/resume/save-on-background. The snapshottable sim makes this trivial — <code>snapshot()</code> on suspend, <code>restore()</code> on resume. This must be an engine-level lifecycle hook, not an afterthought.</p>
</li>
<li>
<p><strong>Audio backend is abstracted.</strong> Bevy handles this, but no code should assume a specific audio API. Platform-specific audio routing (e.g., phone speaker vs headphones, console audio mixing policies) is Bevy’s concern.</p>
</li>
</ol>
<h3 id="platform-target-matrix"><a class="header" href="#platform-target-matrix">Platform Target Matrix</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Graphics API</th><th>Input Model</th><th>Key Challenge</th><th>Phase</th></tr>
</thead>
<tbody>
<tr><td>Windows / macOS / Linux</td><td>Vulkan / Metal / DX12</td><td>Mouse + keyboard</td><td>Primary target</td><td>1</td></tr>
<tr><td>Steam Deck</td><td>Vulkan (native Linux)</td><td>Gamepad + touchpad</td><td>Gamepad UI controls</td><td>3</td></tr>
<tr><td>Browser (WASM)</td><td>WebGPU / WebGL2</td><td>Mouse + keyboard + touch</td><td>Download size, no filesystem</td><td>7</td></tr>
<tr><td>Android / iOS</td><td>Vulkan / Metal (via wgpu)</td><td>Touch + on-screen controls</td><td>Touch RTS controls, battery, screen size</td><td>8+</td></tr>
<tr><td>Xbox</td><td>DX12 (via GDK)</td><td>Gamepad</td><td>NDA SDK, certification</td><td>8+</td></tr>
<tr><td>PlayStation</td><td>AGC (proprietary)</td><td>Gamepad</td><td>wgpu doesn’t support AGC yet, NDA SDK</td><td>Future</td></tr>
<tr><td>Nintendo Switch</td><td>NVN / Vulkan</td><td>Gamepad + touch (handheld)</td><td>NDA SDK, limited GPU</td><td>Future</td></tr>
</tbody>
</table>
</div>
<h3 id="input-abstraction"><a class="header" href="#input-abstraction">Input Abstraction</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Platform-agnostic input source. Each platform implements this.
pub trait InputSource {
    /// Drain pending player orders from whatever input device is active.
    fn drain_orders(&amp;mut self) -&gt; Vec&lt;TimestampedOrder&gt;;

    /// Optional: hint about input capabilities for UI adaptation.
    fn capabilities(&amp;self) -&gt; InputCapabilities;
}

pub struct InputCapabilities {
    pub has_mouse: bool,
    pub has_keyboard: bool,
    pub has_touch: bool,
    pub has_gamepad: bool,
    pub screen_size: ScreenClass,  // Phone, Tablet, Desktop, TV
}

pub enum ScreenClass {
    Phone,    // &lt; 7" — bottom bar UI, large touch targets
    Tablet,   // 7-13" — sidebar OK, touch targets
    Desktop,  // 13"+ — full sidebar, mouse precision
    TV,       // 40"+ — large text, gamepad radial menus
}
<span class="boring">}</span></code></pre>
<p><code>ra-ui</code> reads <code>InputCapabilities</code> to choose the appropriate layout profile. The sim never sees any of this.</p>
<h2 id="ui-theme-system-d032"><a class="header" href="#ui-theme-system-d032">UI Theme System (D032)</a></h2>
<p>The UI is split into two orthogonal concerns:</p>
<ul>
<li><strong>Layout profiles</strong> — <em>where</em> things go. Driven by <code>ScreenClass</code> (Phone, Tablet, Desktop, TV). Handles sidebar vs bottom bar, touch target sizes, minimap placement. One per screen class.</li>
<li><strong>Themes</strong> — <em>how</em> things look. Driven by player preference. Handles colors, chrome sprites, fonts, animations, menu backgrounds. Switchable at any time.</li>
</ul>
<h3 id="theme-architecture"><a class="header" href="#theme-architecture">Theme Architecture</a></h3>
<p>Themes are <strong>YAML + sprite sheets</strong> — Tier 1 mods, no code required.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct UiTheme {
    pub name: String,
    pub chrome: ChromeAssets,    // 9-slice panels, button states, scrollbar sprites
    pub colors: ThemeColors,     // primary, secondary, text, highlights
    pub fonts: ThemeFonts,       // menu, body, HUD
    pub main_menu: MainMenuConfig,  // background image or shellmap, music, button layout
    pub ingame: IngameConfig,    // sidebar style, minimap border, build queue chrome
    pub lobby: LobbyConfig,     // panel styling, slot layout
}
<span class="boring">}</span></code></pre>
<h3 id="built-in-themes"><a class="header" href="#built-in-themes">Built-in Themes</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Theme</th><th>Aesthetic</th><th>Inspired By</th></tr>
</thead>
<tbody>
<tr><td>Classic</td><td>Military minimalism — bare buttons, static title screen, Soviet palette</td><td>Original RA1 (1996)</td></tr>
<tr><td>Remastered</td><td>Clean modern military — HD panels, sleek chrome, reverent refinement</td><td>Remastered Collection (2020)</td></tr>
<tr><td>Modern</td><td>Full Bevy UI — dynamic panels, animated transitions, modern game launcher feel</td><td>IC’s own design</td></tr>
</tbody>
</table>
</div>
<p>All art assets are <strong>original creations</strong> — no assets copied from EA or OpenRA. These themes capture aesthetic philosophy, not specific artwork.</p>
<h3 id="shellmap-system"><a class="header" href="#shellmap-system">Shellmap System</a></h3>
<p>Main menu backgrounds can be <strong>live battles</strong> — a real game map with scripted AI running behind the menu UI:</p>
<ul>
<li>Per-theme configuration: Classic uses a static image (faithful to 1996), Remastered/Modern use shellmaps</li>
<li>Maps tagged <code>visibility: shellmap</code> are eligible — random selection on each launch</li>
<li>Shellmaps define camera paths (pan, orbit, or fixed)</li>
<li>Mods automatically get their own shellmaps</li>
</ul>
<h3 id="per-game-module-defaults"><a class="header" href="#per-game-module-defaults">Per-Game-Module Defaults</a></h3>
<p>Each <code>GameModule</code> provides a <code>default_theme()</code> — RA1 defaults to Classic, future modules default to whatever fits their aesthetic. Players override in settings. This pairs naturally with D019 (switchable balance presets): Classic balance + Classic theme = feels like 1996.</p>
<h3 id="community-themes"><a class="header" href="#community-themes">Community Themes</a></h3>
<ul>
<li>Publishable to workshop (D030) as standalone resources</li>
<li>Stack with gameplay mods — a WWII total conversion ships its own olive-drab theme</li>
<li>An “OpenRA-inspired” community theme is a natural contribution</li>
</ul>
<p>See <code>09-DECISIONS.md</code> § D032 for full rationale, YAML schema, and legal notes on asset sourcing.</p>
<h2 id="crate-dependency-graph"><a class="header" href="#crate-dependency-graph">Crate Dependency Graph</a></h2>
<pre><code>ra-protocol  (shared types: PlayerOrder, TimestampedOrder)
    ↑
    ├── ra-sim      (depends on: ra-protocol, ra-formats)
    ├── ra-net      (depends on: ra-protocol)
    ├── ra-formats  (standalone — .mix, .shp, .pal, YAML)
    ├── ra-render   (depends on: ra-sim for reading state)
    ├── ra-ui       (depends on: ra-sim, ra-render)
    ├── ra-audio    (depends on: ra-formats)
    ├── ra-script   (depends on: ra-sim, ra-protocol)
    ├── ra-ai       (depends on: ra-sim, ra-protocol)
    ├── ra-llm      (depends on: ra-sim, ra-script, ra-protocol)
    └── ra-game     (depends on: everything above)
</code></pre>
<p><strong>Critical boundary:</strong> <code>ra-sim</code> never imports from <code>ra-net</code>. <code>ra-net</code> never imports from <code>ra-sim</code>. They only share <code>ra-protocol</code>.</p>
<h2 id="multi-game-extensibility-game-modules"><a class="header" href="#multi-game-extensibility-game-modules">Multi-Game Extensibility (Game Modules)</a></h2>
<p>The engine is designed as a <strong>game-agnostic RTS framework</strong> with Red Alert as the first game module. The same engine should be able to run RA2, Tiberian Dawn, Dune 2000, or an original game as a different game module — like OpenRA runs TD, RA, and D2K on one engine.</p>
<h3 id="game-module-concept"><a class="header" href="#game-module-concept">Game Module Concept</a></h3>
<p>A game module is a bundle of:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Each supported game implements this trait.
pub trait GameModule {
    /// Register ECS components (unit types, mechanics) into the world.
    fn register_components(&amp;self, world: &amp;mut World);

    /// Return the ordered system pipeline for this game's simulation tick.
    fn system_pipeline(&amp;self) -&gt; Vec&lt;Box&lt;dyn System&gt;&gt;;

    /// Register format loaders (e.g., .vxl for RA2, .shp for RA1).
    fn register_format_loaders(&amp;self, registry: &amp;mut FormatRegistry);

    /// Register render backends (sprite renderer, voxel renderer, etc.).
    fn register_renderers(&amp;self, registry: &amp;mut RenderRegistry);

    /// YAML rule schema for this game's unit definitions.
    fn rule_schema(&amp;self) -&gt; RuleSchema;
}
<span class="boring">}</span></code></pre>
<h3 id="what-the-engine-provides-game-agnostic"><a class="header" href="#what-the-engine-provides-game-agnostic">What the engine provides (game-agnostic)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>Game-Agnostic</th><th>Game-Module-Specific</th></tr>
</thead>
<tbody>
<tr><td><strong>Sim core</strong></td><td><code>Simulation</code>, <code>apply_tick()</code>, <code>snapshot()</code>, state hashing, order validation pipeline</td><td>Components, systems, rules, resource types</td></tr>
<tr><td><strong>Positions</strong></td><td><code>WorldPos { x, y, z }</code>, <code>CellPos { x, y, z }</code>, pathfinding grid</td><td>Whether Z is used (RA1: flat, RA2: elevation)</td></tr>
<tr><td><strong>Networking</strong></td><td><code>NetworkModel</code> trait, relay server, lockstep, replays</td><td><code>PlayerOrder</code> variants (game-specific commands)</td></tr>
<tr><td><strong>Rendering</strong></td><td>Camera, sprite batching, post-FX pipeline, UI framework</td><td>Sprite renderer (RA1), voxel renderer (RA2), terrain elevation</td></tr>
<tr><td><strong>Modding</strong></td><td>YAML loader, Lua runtime, WASM sandbox, workshop</td><td>Rule schemas, API surface exposed to scripts</td></tr>
<tr><td><strong>Formats</strong></td><td><code>.mix</code> parser, archive loading</td><td><code>.shp</code> variant (RA1), <code>.vxl</code>/<code>.hva</code> (RA2), map format</td></tr>
</tbody>
</table>
</div>
<h3 id="ra2-extension-points"><a class="header" href="#ra2-extension-points">RA2 Extension Points</a></h3>
<p>RA2 / Tiberian Sun would add these to the existing engine without modifying the core:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Extension</th><th>What It Adds</th><th>Engine Change Required</th></tr>
</thead>
<tbody>
<tr><td>Voxel models (<code>.vxl</code>, <code>.hva</code>)</td><td>New format parsers</td><td>None — additive to <code>ra-formats</code></td></tr>
<tr><td>Terrain elevation</td><td>Z-axis in pathfinding, ramps, cliffs</td><td>None — <code>WorldPos.z</code> and <code>CellPos.z</code> are already there</td></tr>
<tr><td>Voxel rendering</td><td>GPU voxel-to-sprite at runtime</td><td>New render backend in <code>RenderRegistry</code></td></tr>
<tr><td>Garrison mechanic</td><td><code>Garrisonable</code>, <code>Garrisoned</code> components + system</td><td>New components + system in pipeline</td></tr>
<tr><td>Mind control</td><td><code>MindController</code>, <code>MindControlled</code> components + system</td><td>New components + system in pipeline</td></tr>
<tr><td>IFV weapon swap</td><td><code>WeaponOverride</code> component</td><td>New component</td></tr>
<tr><td>Prism forwarding</td><td><code>PrismForwarder</code> component + chain calculation system</td><td>New component + system</td></tr>
<tr><td>Bridges / tunnels</td><td>Layered pathing with Z transitions</td><td>Uses existing <code>CellPos.z</code></td></tr>
</tbody>
</table>
</div>
<h3 id="scope-boundary-the-isometric-cc-family"><a class="header" href="#scope-boundary-the-isometric-cc-family">Scope Boundary: The Isometric C&amp;C Family</a></h3>
<p>Multi-game extensibility targets the <strong>isometric C&amp;C family</strong>: Red Alert, Red Alert 2, Tiberian Sun, Tiberian Dawn, and Dune 2000 (plus expansions and total conversions in the same visual paradigm). These games share:</p>
<ul>
<li>Fixed isometric camera</li>
<li>Grid-based terrain (with optional elevation for TS/RA2)</li>
<li>Sprite and/or voxel-to-sprite rendering</li>
<li><code>.mix</code> archives and related format lineage</li>
<li>Discrete cell-based pathfinding (flowfields, hierarchical A*)</li>
</ul>
<p><strong>C&amp;C Generals and later 3D titles (C&amp;C3, RA3) are out of scope.</strong> They use free-rotating 3D cameras, mesh-based rendering, continuous-space pathfinding (navmesh), and completely unrelated file formats (<code>.big</code>, <code>.w3d</code>). Supporting them would require replacing ~60% of the engine (renderer, pathfinding, coordinate system, format parsers) — at that point it’s a separate project borrowing the sim core, not a game module.</p>
<p>If a Generals-class game is desired in the future, the correct approach is to extract the game-agnostic crates (<code>ra-sim</code>, <code>ra-protocol</code>, <code>ra-net</code>, <code>ra-script</code>) into a shared RTS framework library and build a 3D frontend independently. The <code>GameModule</code> trait and deterministic sim architecture make this feasible without forking.</p>
<h3 id="3d-rendering-as-a-mod-not-a-game-module"><a class="header" href="#3d-rendering-as-a-mod-not-a-game-module">3D Rendering as a Mod (Not a Game Module)</a></h3>
<p>While 3D C&amp;C titles are out of scope as <em>game modules</em>, the architecture explicitly supports <strong>3D rendering mods</strong> for isometric-family games. A “3D Red Alert” mod replaces the visual presentation while the simulation, networking, pathfinding, and rules are completely unchanged.</p>
<p>This works because the sim/render split is absolute — the sim has no concept of camera, sprites, or visual style. Bevy already ships a full 3D pipeline (PBR materials, GLTF loading, skeletal animation, dynamic lighting, shadows), so a 3D render mod leverages existing infrastructure.</p>
<p><strong>What changes vs. what doesn’t:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>3D Mod Changes?</th><th>Details</th></tr>
</thead>
<tbody>
<tr><td>Simulation</td><td>No</td><td>Same tick, same rules, same grid</td></tr>
<tr><td>Pathfinding</td><td>No</td><td>Grid-based flowfields still work (SC2 is 3D but uses grid pathing)</td></tr>
<tr><td>Networking</td><td>No</td><td>Orders are orders</td></tr>
<tr><td>Rules / YAML</td><td>No</td><td>Tank still costs 800, has 400 HP</td></tr>
<tr><td>Rendering</td><td>Yes</td><td>Sprites → GLTF meshes, isometric camera → free 3D camera</td></tr>
<tr><td>Input mapping</td><td>Yes</td><td>Click-to-world changes from isometric transform to 3D raycast</td></tr>
</tbody>
</table>
</div>
<p><strong>Architectural requirements to enable this:</strong></p>
<ol>
<li><strong><code>Renderable</code> trait is mod-swappable.</strong> A WASM Tier 3 mod can register a 3D render backend that replaces the default sprite renderer.</li>
<li><strong>Camera system is configurable.</strong> Default is fixed isometric; a 3D mod substitutes a free-rotating perspective camera. The camera is purely a render concern — the sim has no camera concept.</li>
<li><strong>Asset pipeline accepts 3D models.</strong> Bevy natively loads GLTF/GLB. The mod maps unit IDs to 3D model paths in YAML:</li>
</ol>
<pre><code class="language-yaml"># Classic 2D (default)
rifle_infantry:
  render:
    type: sprite
    sequences: e1

# 3D mod override
rifle_infantry:
  render:
    type: mesh
    model: models/infantry/rifle.glb
    animations:
      idle: Idle
      move: Run
      attack: Shoot
</code></pre>
<ol start="4">
<li><strong>Click-to-world abstracted behind trait.</strong> Isometric screen→cell is a linear transform. 3D perspective screen→cell is a raycast. Both produce a <code>CellPos</code>.</li>
<li><strong>Terrain rendering decoupled from terrain data.</strong> The sim’s grid is authoritative. A 3D mod provides visual terrain geometry that matches the grid layout.</li>
</ol>
<p><strong>Key benefits:</strong></p>
<ul>
<li><strong>Cross-view multiplayer.</strong> A player running 3D can play against a player running classic isometric — the sim is identical. Like StarCraft Remastered’s graphics toggle, but more radical.</li>
<li><strong>Cross-view replays.</strong> Watch any replay in 2D or 3D.</li>
<li><strong>Orthogonal to gameplay mods.</strong> A balance mod works in both views. A 3D graphics mod stacks with a gameplay mod.</li>
</ul>
<p>This is a <strong>Tier 3 (WASM) mod</strong> — it replaces a rendering backend, which is too deep for YAML or Lua. See <code>04-MODDING.md</code> for details.</p>
<h3 id="design-rules-for-multi-game-safety"><a class="header" href="#design-rules-for-multi-game-safety">Design Rules for Multi-Game Safety</a></h3>
<ol>
<li><strong>No game-specific enums in engine core.</strong> Don’t put <code>enum ResourceType { Ore, Gems }</code> in <code>ra-sim</code>. Resource types come from YAML rules / game module registration.</li>
<li><strong>Position is always 3D.</strong> <code>WorldPos</code> and <code>CellPos</code> carry Z. RA1 sets it to 0. The cost is one extra <code>i32</code> per position — negligible.</li>
<li><strong>System pipeline is data, not code.</strong> The game module returns its system list; the engine executes it. No hardcoded <code>harvester_system()</code> call in engine core.</li>
<li><strong>Render through <code>Renderable</code> trait.</strong> Sprites and voxels implement the same trait. The renderer doesn’t know what it’s drawing.</li>
<li><strong>Format loaders are pluggable.</strong> <code>ra-formats</code> provides parsers; the game module tells the asset pipeline which ones to use.</li>
<li><strong><code>PlayerOrder</code> is extensible.</strong> Use an enum with a <code>Custom(GameSpecificOrder)</code> variant, or make orders generic over the game module.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="03--network-architecture"><a class="header" href="#03--network-architecture">03 — Network Architecture</a></h1>
<h2 id="core-design-pluggable-network-model"><a class="header" href="#core-design-pluggable-network-model">Core Design: Pluggable Network Model</a></h2>
<p>The network layer is fully abstracted behind a trait. The simulation and game loop never know which network model is running.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait NetworkModel: Send + Sync {
    /// Local player submits an order
    fn submit_order(&amp;mut self, order: TimestampedOrder);
    /// Poll for the next tick's confirmed orders (None = not ready yet)
    fn poll_tick(&amp;mut self) -&gt; Option&lt;TickOrders&gt;;
    /// Report local sim hash for desync detection
    fn report_sync_hash(&amp;mut self, tick: u64, hash: u64);
    /// Connection/sync status
    fn status(&amp;self) -&gt; NetworkStatus;
    /// Diagnostic info (latency, packet loss, etc.)
    fn diagnostics(&amp;self) -&gt; NetworkDiagnostics;
}
<span class="boring">}</span></code></pre>
<h3 id="planned-implementations"><a class="header" href="#planned-implementations">Planned Implementations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Implementation</th><th>Use Case</th><th>Priority</th></tr>
</thead>
<tbody>
<tr><td><code>LocalNetwork</code></td><td>Single player, tests</td><td>Phase 2</td></tr>
<tr><td><code>ReplayPlayback</code></td><td>Watching replays</td><td>Phase 2</td></tr>
<tr><td><code>LockstepNetwork</code></td><td>OpenRA-style multiplayer</td><td>Phase 5</td></tr>
<tr><td><code>RelayLockstepNetwork</code></td><td>Relay server with time authority</td><td>Phase 5</td></tr>
<tr><td><code>FogAuthoritativeNetwork</code></td><td>Anti-maphack (server runs sim)</td><td>Future</td></tr>
<tr><td><code>RollbackNetwork</code></td><td>GGPO-style (requires sim snapshots)</td><td>Future</td></tr>
<tr><td><code>ProtocolAdapter&lt;N&gt;</code></td><td>Cross-engine compatibility wrapper</td><td>Future</td></tr>
</tbody>
</table>
</div>
<h3 id="benefits-of-trait-abstraction"><a class="header" href="#benefits-of-trait-abstraction">Benefits of Trait Abstraction</a></h3>
<ul>
<li>Sim never touches networking concerns</li>
<li>Full testability (run entire sim with <code>LocalNetwork</code>)</li>
<li>Community can contribute better netcode without understanding game logic</li>
<li>Players could choose network model in lobby (if both agree)</li>
<li>Cross-engine adapters wrap existing models transparently</li>
</ul>
<h2 id="shared-protocol-types"><a class="header" href="#shared-protocol-types">Shared Protocol Types</a></h2>
<p>Defined in <code>ra-protocol</code> crate — the ONLY shared dependency between sim and net:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Serialize, Deserialize, Hash)]
pub enum PlayerOrder {
    Move { unit_ids: Vec&lt;UnitId&gt;, target: CellPos },
    Attack { unit_ids: Vec&lt;UnitId&gt;, target: Target },
    Build { structure: StructureType, position: CellPos },
    SetRallyPoint { building: BuildingId, position: CellPos },
    Sell { building: BuildingId },
    // ... every possible player action
}

/// Sub-tick timestamp on every order (CS2-inspired)
#[derive(Clone, Serialize, Deserialize)]
pub struct TimestampedOrder {
    pub player: PlayerId,
    pub order: PlayerOrder,
    pub sub_tick_time: f64,  // fractional time within the tick window
}

pub struct TickOrders {
    pub tick: u64,
    pub orders: Vec&lt;TimestampedOrder&gt;,
}

impl TickOrders {
    /// CS2-style: process in chronological order within the tick
    pub fn chronological(&amp;self) -&gt; impl Iterator&lt;Item = &amp;TimestampedOrder&gt; {
        let mut sorted = self.orders.clone();
        sorted.sort_by(|a, b| a.sub_tick_time.partial_cmp(&amp;b.sub_tick_time).unwrap());
        sorted.into_iter()
    }
}
<span class="boring">}</span></code></pre>
<h2 id="cs2-sub-tick-what-we-borrow"><a class="header" href="#cs2-sub-tick-what-we-borrow">CS2 Sub-Tick: What We Borrow</a></h2>
<h3 id="what-cs2-does"><a class="header" href="#what-cs2-does">What CS2 Does</a></h3>
<p>Counter-Strike 2 introduced “sub-tick” architecture: instead of processing all actions at discrete tick boundaries, the client timestamps every input with sub-tick precision. The server collects inputs from all clients and processes them in chronological order within each tick window. The server still ticks at 64Hz, but events are ordered by their actual timestamps.</p>
<h3 id="whats-relevant-for-rts"><a class="header" href="#whats-relevant-for-rts">What’s Relevant for RTS</a></h3>
<p>The core idea — <strong>timestamped orders processed in chronological order within a tick</strong> — produces fairer results for edge cases:</p>
<ul>
<li>Two players grabbing the same crate → the one who clicked first gets it</li>
<li>Engineer vs engineer racing to capture a building → chronological winner</li>
<li>Simultaneous attack orders → processed in actual order, not arrival order</li>
</ul>
<h3 id="whats-not-relevant"><a class="header" href="#whats-not-relevant">What’s NOT Relevant</a></h3>
<p>CS2 is client-server authoritative with prediction and interpolation. An RTS with hundreds of units can’t afford server-authoritative simulation — the bandwidth would be enormous. We stay with deterministic lockstep (clients run identical sims), so CS2’s prediction/reconciliation doesn’t directly apply.</p>
<h2 id="network-model-details"><a class="header" href="#network-model-details">Network Model Details</a></h2>
<h3 id="model-1-lockstep-with-input-delay-starting-model"><a class="header" href="#model-1-lockstep-with-input-delay-starting-model">Model 1: Lockstep with Input Delay (starting model)</a></h3>
<pre><code>Local input at tick 50 → scheduled for tick 53 (3-tick delay)
Remote input has 3 ticks to arrive before we need it
Delay dynamically adjusted based on connection quality
</code></pre>
<p>This is what OpenRA and most RTS games use. The “lag” players feel is intentional input delay, not network stalling.</p>
<h3 id="model-2-relay-server-with-time-authority-recommended-default"><a class="header" href="#model-2-relay-server-with-time-authority-recommended-default">Model 2: Relay Server with Time Authority (recommended default)</a></h3>
<pre><code>┌────────┐         ┌──────────────┐         ┌────────┐
│Player A│────────▶│ Relay Server │◀────────│Player B│
│        │◀────────│  (timestamped│────────▶│        │
└────────┘         │   ordering)  │         └────────┘
                   └──────────────┘
</code></pre>
<p>The relay server does NOT run the sim. It:</p>
<ol>
<li>Receives timestamped orders from all players</li>
<li>Orders them chronologically (CS2 insight)</li>
<li>Broadcasts canonical tick order to all clients</li>
<li>Detects lag switches and cheating attempts</li>
<li>Handles NAT traversal (no port forwarding needed)</li>
</ol>
<p><strong>Anti-lag-switch mechanism:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl RelayServer {
    fn process_tick(&amp;mut self, tick: u64) {
        let deadline = Instant::now() + self.tick_deadline; // e.g., 120ms
        
        for player in &amp;self.players {
            match self.receive_orders_from(player, deadline) {
                Ok(orders) =&gt; self.tick_orders.add(player, orders),
                Err(Timeout) =&gt; {
                    // Missed deadline → strikes system
                    // Game never stalls for honest players
                    self.tick_orders.add(player, PlayerOrder::Idle);
                }
            }
        }
        self.broadcast_tick_orders(tick);
    }
}
<span class="boring">}</span></code></pre>
<h3 id="model-3-fog-authoritative-server-anti-maphack"><a class="header" href="#model-3-fog-authoritative-server-anti-maphack">Model 3: Fog-Authoritative Server (anti-maphack)</a></h3>
<p>Server runs full sim, sends each client only entities they should see. Breaks pure lockstep (clients run partial sims), requires server compute per game. See <code>06-SECURITY.md</code> for details.</p>
<h3 id="model-4-rollback--ggpo-style-experimental-future"><a class="header" href="#model-4-rollback--ggpo-style-experimental-future">Model 4: Rollback / GGPO-style (experimental future)</a></h3>
<p>Requires snapshottable sim (already designed). Client predicts with local input, rolls back on misprediction. Expensive for RTS (re-simulating hundreds of entities), but feasible with Rust’s performance. See GGPO documentation for reference implementation.</p>
<h2 id="input-responsiveness-why-our-model-feels-faster"><a class="header" href="#input-responsiveness-why-our-model-feels-faster">Input Responsiveness: Why Our Model Feels Faster</a></h2>
<p>Every lockstep RTS has inherent input delay — the game must wait for all players’ orders before advancing. This is <strong>architectural</strong>, not a bug. But how much delay, and who pays for it, varies dramatically.</p>
<h3 id="openras-stalling-model"><a class="header" href="#openras-stalling-model">OpenRA’s Stalling Model</a></h3>
<p>OpenRA uses TCP-based lockstep where the game advances only when ALL clients have submitted orders for the current net frame (<code>OrderManager.TryTick()</code> checks <code>pendingOrders.All(...)</code>):</p>
<pre><code>Tick 50: waiting for Player A's orders... ✓ (10ms)
         waiting for Player B's orders... ✓ (15ms)
         waiting for Player C's orders... ⏳ (280ms — bad WiFi)
         → ALL players frozen for 280ms. Everyone suffers.
</code></pre>
<p>Additionally (verified from source):</p>
<ul>
<li>Orders are batched every <code>NetFrameInterval</code> frames (not every tick), adding batching delay</li>
<li>The server adds <code>OrderLatency</code> frames to every order (default 1 for local, higher for MP game speeds)</li>
<li><code>OrderBuffer</code> dynamically adjusts per-player <code>TickScale</code> (up to 10% speedup) based on delivery timing</li>
<li>Even in <strong>single player</strong>, <code>EchoConnection</code> projects orders 1 frame forward</li>
<li>C# GC pauses add unpredictable jank on top of the architectural delay</li>
</ul>
<p>The perceived input lag when clicking units in OpenRA is estimated at ~100-200ms — a combination of intentional lockstep delay, order batching, and runtime overhead.</p>
<h3 id="our-relay-model-no-stalling"><a class="header" href="#our-relay-model-no-stalling">Our Relay Model: No Stalling</a></h3>
<p>The relay server owns the clock. It broadcasts tick orders on a fixed deadline — missed orders are replaced with <code>PlayerOrder::Idle</code>:</p>
<pre><code>Tick 50: relay deadline = 80ms
         Player A orders arrive at 10ms  → ✓ included
         Player B orders arrive at 15ms  → ✓ included  
         Player C orders arrive at 280ms → ✗ missed deadline → Idle
         → Relay broadcasts at 80ms. No stall. Player C's units idle.
</code></pre>
<p>Honest players on good connections always get responsive gameplay. A lagging player hurts only themselves.</p>
<h3 id="visual-prediction-cosmetic-not-sim"><a class="header" href="#visual-prediction-cosmetic-not-sim">Visual Prediction (Cosmetic, Not Sim)</a></h3>
<p>The render layer provides <strong>instant visual feedback</strong> on player input, before the order is confirmed by the network:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ra-render: immediate visual response to click
fn on_move_order_issued(click_pos: WorldPos, selected_units: &amp;[Entity]) {
    // Show move marker immediately
    spawn_move_marker(click_pos);
    
    // Start unit turn animation toward target (cosmetic only)
    for unit in selected_units {
        start_turn_preview(unit, click_pos);
    }
    
    // Selection acknowledgement sound plays instantly
    play_unit_response_audio(selected_units);
    
    // The actual sim order is still in the network pipeline.
    // Units will begin real movement when the order is confirmed next tick.
    // The visual prediction bridges the gap so the game feels instant.
}
<span class="boring">}</span></code></pre>
<p>This is purely cosmetic — the sim doesn’t advance until the confirmed order arrives. But it eliminates the <strong>perceived</strong> lag. The selection ring snaps, the unit rotates, the acknowledgment voice plays — all before the network round-trip completes.</p>
<h3 id="input-latency-comparison"><a class="header" href="#input-latency-comparison">Input Latency Comparison</a></h3>
<p><em>OpenRA values are from source code analysis, not runtime benchmarks. Tick processing times are estimates.</em></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Factor</th><th>OpenRA</th><th>Iron Curtain (Relay)</th><th>Improvement</th></tr>
</thead>
<tbody>
<tr><td>Waiting for slowest client</td><td>Yes — everyone freezes</td><td>No — relay drops late orders</td><td>Eliminates worst-case stalls entirely</td></tr>
<tr><td>Order batching interval</td><td>Every N frames (<code>NetFrameInterval</code>)</td><td>Every tick</td><td>No batching delay</td></tr>
<tr><td>Order scheduling delay</td><td>+<code>OrderLatency</code> ticks</td><td>+1 tick (next relay broadcast)</td><td>Fewer ticks of delay</td></tr>
<tr><td>Tick processing time</td><td>Estimated 30-60ms (limits tick rate)</td><td>~8ms (allows higher tick rate)</td><td>4-8x faster per tick</td></tr>
<tr><td>Achievable tick rate</td><td>~15 tps</td><td>30+ tps</td><td>2x shorter lockstep window</td></tr>
<tr><td>GC pauses during processing</td><td>C# GC characteristic</td><td>0ms</td><td>Eliminates unpredictable hitches</td></tr>
<tr><td>Visual feedback on click</td><td>Waits for order confirmation</td><td>Immediate (cosmetic prediction)</td><td>Perceived lag drops to near-zero</td></tr>
<tr><td>Single-player order delay</td><td>1 projected frame (~66ms at 15 tps)</td><td>0 frames (<code>LocalNetwork</code> = next tick)</td><td>Zero delay</td></tr>
<tr><td>Worst connection impact</td><td>Freezes all players</td><td>Only affects the lagging player</td><td>Architectural fairness</td></tr>
<tr><td>Future: rollback prediction</td><td>Not possible (no snapshots)</td><td>Possible (D010 enables GGPO)</td><td>Could eliminate all perceived MP delay</td></tr>
</tbody>
</table>
</div>
<h3 id="single-player-zero-delay"><a class="header" href="#single-player-zero-delay">Single-Player: Zero Delay</a></h3>
<p><code>LocalNetwork</code> processes orders on the very next tick with zero scheduling delay:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl NetworkModel for LocalNetwork {
    fn submit_order(&amp;mut self, order: TimestampedOrder) {
        // Order goes directly into the next tick — no delay, no projection
        self.pending.push(order);
    }
    
    fn poll_tick(&amp;mut self) -&gt; Option&lt;TickOrders&gt; {
        // Always ready — no waiting for other clients
        Some(TickOrders {
            tick: self.tick,
            orders: std::mem::take(&amp;mut self.pending),
        })
    }
}
<span class="boring">}</span></code></pre>
<p>At 30 tps, a click-to-move in single player is confirmed within ~33ms — imperceptible to humans (reaction time is ~200ms). Combined with visual prediction, the game feels <strong>instant</strong>.</p>
<h2 id="desync-detection--debugging"><a class="header" href="#desync-detection--debugging">Desync Detection &amp; Debugging</a></h2>
<p>Every <code>NetworkModel</code> must accept <code>report_sync_hash()</code>. The system works:</p>
<ol>
<li>Each client hashes their sim state after each tick</li>
<li>Hashes are compared (by relay server, or exchanged P2P)</li>
<li>On mismatch → desync detected at specific tick</li>
<li>Because sim is snapshottable, dump full state and diff to pinpoint exact divergence</li>
</ol>
<p>This is a <strong>killer feature</strong>. OpenRA has 135+ desync issues in their tracker — desyncs are a persistent, hard-to-debug problem. They hash game state per frame (via <code>[VerifySync]</code> attribute) and detect desyncs, but their sync report buffer is only 7 frames deep, which often isn’t enough to capture the divergence point. Our architecture makes desyncs both detectable AND diagnosable.</p>
<h2 id="ordercodec-wire-format-abstraction"><a class="header" href="#ordercodec-wire-format-abstraction">OrderCodec: Wire Format Abstraction</a></h2>
<p>For future cross-engine play and protocol versioning:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait OrderCodec: Send + Sync {
    fn encode(&amp;self, order: &amp;TimestampedOrder) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
    fn decode(&amp;self, bytes: &amp;[u8]) -&gt; Result&lt;TimestampedOrder&gt;;
    fn protocol_id(&amp;self) -&gt; ProtocolId;
}

/// Native format — fast, compact, versioned
pub struct NativeCodec { version: u32 }

/// Translates to/from OpenRA's wire format
pub struct OpenRACodec {
    order_map: OrderTranslationTable,
    coord_transform: CoordTransform,
}
<span class="boring">}</span></code></pre>
<p>See <code>07-CROSS-ENGINE.md</code> for full cross-engine compatibility design.</p>
<h2 id="replay-system"><a class="header" href="#replay-system">Replay System</a></h2>
<p>Replays are a natural byproduct of the architecture:</p>
<pre><code>Replay file = initial state + sequence of TickOrders
Playback = feed TickOrders through Simulation via ReplayPlayback NetworkModel
</code></pre>
<p>Replays are signed by the relay server for tamper-proofing (see <code>06-SECURITY.md</code>).</p>
<h2 id="connection-establishment"><a class="header" href="#connection-establishment">Connection Establishment</a></h2>
<p>Connection method is a concern <em>below</em> <code>NetworkModel</code>. By the time a <code>NetworkModel</code> is constructed, transport is already established. The discovery/connection flow:</p>
<pre><code>Discovery (tracking server / join code / direct IP / QR)
  → Connection establishment (hole-punch / direct TCP+UDP)
    → NetworkModel constructed (LockstepNetwork or RelayLockstepNetwork)
      → Game loop runs — sim doesn't know or care how connection happened
</code></pre>
<h3 id="direct-ip"><a class="header" href="#direct-ip">Direct IP</a></h3>
<p>Classic approach. Host shares <code>IP:port</code>, other player connects.</p>
<ul>
<li>Simplest to implement (TCP connect, done)</li>
<li>Requires host to have a reachable IP (port forwarding or same LAN)</li>
<li>Good for LAN parties, dedicated server setups, and power users</li>
</ul>
<h3 id="join-code-recommended-for-casual"><a class="header" href="#join-code-recommended-for-casual">Join Code (Recommended for Casual)</a></h3>
<p>Host contacts a lightweight rendezvous server. Server assigns a short code (e.g., <code>IRON-7K3M</code>). Joiner sends code to same server. Server brokers a UDP hole-punch between both players.</p>
<pre><code>┌────────┐     1. register     ┌──────────────┐     2. resolve    ┌────────┐
│  Host  │ ──────────────────▶ │  Rendezvous  │ ◀──────────────── │ Joiner │
│        │ ◀── code: IRON-7K3M│    Server     │  code: IRON-7K3M──▶       │
│        │     3. hole-punch   │  (stateless)  │  3. hole-punch   │        │
│        │ ◀═══════════════════╪══════════════════════════════════▶│        │
└────────┘    direct P2P conn  └──────────────┘                   └────────┘
</code></pre>
<ul>
<li>No port forwarding needed (UDP hole-punch works through most NATs)</li>
<li>Rendezvous server is stateless and trivial — it only brokers introductions, never sees game data</li>
<li>Codes are short-lived (expire after use or timeout)</li>
<li>Industry standard: Among Us, Deep Rock Galactic, It Takes Two</li>
</ul>
<h3 id="qr-code"><a class="header" href="#qr-code">QR Code</a></h3>
<p>Same as join code, encoded as QR. Player scans from phone → opens game client with code pre-filled. Ideal for couch play, LAN events, and streaming (viewers scan to join).</p>
<h3 id="via-relay-server"><a class="header" href="#via-relay-server">Via Relay Server</a></h3>
<p>When direct P2P fails (symmetric NAT, corporate firewalls), fall back to relay. The relay server is already designed for this (Model 2). Connection through relay also provides lag-switch protection and sub-tick ordering as a bonus.</p>
<h3 id="via-tracking-server"><a class="header" href="#via-tracking-server">Via Tracking Server</a></h3>
<p>Player browses public game listings, picks one, client connects directly to the host (or relay). See Tracking Servers section below.</p>
<h2 id="tracking-servers-game-browser"><a class="header" href="#tracking-servers-game-browser">Tracking Servers (Game Browser)</a></h2>
<p>A tracking server (also called master server) lets players discover and publish games. It is NOT a relay — no game data flows through it. It’s a directory.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Tracking server API — implemented by ra-net, consumed by ra-ui
pub trait TrackingServer: Send + Sync {
    /// Host publishes their game to the directory
    fn publish(&amp;self, listing: &amp;GameListing) -&gt; Result&lt;ListingId&gt;;
    /// Host updates their listing (player count, status)
    fn update(&amp;self, id: ListingId, listing: &amp;GameListing) -&gt; Result&lt;()&gt;;
    /// Host removes their listing (game started or cancelled)
    fn unpublish(&amp;self, id: ListingId) -&gt; Result&lt;()&gt;;
    /// Browser fetches current listings with optional filters
    fn browse(&amp;self, filter: &amp;BrowseFilter) -&gt; Result&lt;Vec&lt;GameListing&gt;&gt;;
}

pub struct GameListing {
    pub host: ConnectionInfo,     // IP:port, relay ID, or join code
    pub map: MapMeta,             // name, hash, player count
    pub rules: RulesMeta,         // mod, version, custom rules
    pub players: Vec&lt;PlayerInfo&gt;, // current players in lobby
    pub status: LobbyStatus,     // waiting, in_progress, full
    pub engine: EngineId,         // "iron-curtain" or "openra" (for cross-browser)
}
<span class="boring">}</span></code></pre>
<h3 id="official-tracking-server"><a class="header" href="#official-tracking-server">Official Tracking Server</a></h3>
<p>We run one. Games appear here by default. Free, community-operated, no account required to browse (account required to host, to prevent spam).</p>
<h3 id="custom-tracking-servers"><a class="header" href="#custom-tracking-servers">Custom Tracking Servers</a></h3>
<p>Communities, clans, and tournament organizers run their own. The client supports a list of tracking server URLs in settings. This is the Quake/Source master server model — decentralized, resilient.</p>
<pre><code class="language-yaml"># settings.yaml
tracking_servers:
  - url: "https://track.ironcurtain.gg"    # official
  - url: "https://rts.myclan.com/track"     # clan server
  - url: "https://openra.net/master"        # OpenRA shared browser (Level 0 compat)
</code></pre>
<h3 id="openra-shared-browser"><a class="header" href="#openra-shared-browser">OpenRA Shared Browser</a></h3>
<p>Implementing the OpenRA master server protocol means Iron Curtain games can appear in OpenRA’s game browser (and vice versa), tagged by engine. Players see the full community. This is the Level 0 cross-engine compatibility from <code>07-CROSS-ENGINE.md</code>.</p>
<h3 id="tracking-server-implementation"><a class="header" href="#tracking-server-implementation">Tracking Server Implementation</a></h3>
<p>The server itself is straightforward — a REST or WebSocket API backed by an in-memory store with TTL expiry. No database needed. Listings expire if the host stops sending heartbeats.</p>
<h2 id="backend-infrastructure-tracking--relay"><a class="header" href="#backend-infrastructure-tracking--relay">Backend Infrastructure (Tracking + Relay)</a></h2>
<p>Both the tracking server and relay server are <strong>standalone Rust binaries</strong>. The simplest deployment is running the executable on any computer — a home PC, a friend’s always-on machine, a €5 VPS, or a Raspberry Pi. No containers, no cloud, no special infrastructure required.</p>
<p>For larger-scale or production deployments, both services also ship as container images with docker-compose.yaml (one-command setup) and Helm charts (Kubernetes). But containers are an option, not a requirement.</p>
<p>There must never be a single point of failure that takes down the entire multiplayer ecosystem.</p>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<pre><code>                          ┌───────────────────────────────────┐
                          │         DNS / Load Balancer        │
                          │   (track.ironcurtain.gg)          │
                          └─────┬──────────┬──────────┬───────┘
                                │          │          │
                          ┌─────▼──┐ ┌─────▼──┐ ┌────▼───┐
                          │Tracking│ │Tracking│ │Tracking│   ← stateless replicas
                          │  Pod   │ │  Pod   │ │  Pod   │      (horizontal scale)
                          └────────┘ └────────┘ └────────┘
                                         │
                          ┌──────────────▼──────────────┐
                          │   Redis / in-memory store     │   ← game listings (ephemeral)
                          │   (TTL-based expiry)          │      no persistent DB needed
                          └───────────────────────────────┘

                          ┌───────────────────────────────────┐
                          │         DNS / Load Balancer        │
                          │   (relay.ironcurtain.gg)          │
                          └─────┬──────────┬──────────┬───────┘
                                │          │          │
                          ┌─────▼──┐ ┌─────▼──┐ ┌────▼───┐
                          │ Relay  │ │ Relay  │ │ Relay  │   ← stateless per-game
                          │  Pod   │ │  Pod   │ │  Pod   │      sessions (sticky)
                          └────────┘ └────────┘ └────────┘
</code></pre>
<h3 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h3>
<ol>
<li>
<p><strong>Just a binary.</strong> Each server is a single Rust executable with zero mandatory dependencies. Run it directly (<code>./tracking-server</code> or <code>./relay-server</code>), as a systemd service, in Docker, or in Kubernetes — whatever suits the operator. No database, no runtime, no JVM. Download, configure, run.</p>
</li>
<li>
<p><strong>Stateless processes.</strong> Each tracking server instance holds no critical state — for a single-instance deployment, listings live in memory with TTL expiry. For multi-instance deployments, listings are shared via Redis (or equivalent KV store). Killing the process loses nothing permanent. Relay servers hold per-game session state but games are short-lived; if a relay dies, the game reconnects or falls back to P2P.</p>
</li>
<li>
<p><strong>Community self-hosting is a first-class use case.</strong> A clan, tournament organizer, or hobbyist runs the same binary on their own machine. No cloud account needed. No Docker needed. The binary reads a config file or env vars and starts listening. For those who prefer containers, <code>docker-compose up</code> works too. For production scale, Helm charts are available.</p>
</li>
<li>
<p><strong>Federation, not centralization.</strong> The client aggregates listings from multiple tracking servers simultaneously (already designed — see <code>tracking_servers</code> list in settings). If the official server goes down, community servers still work. If all tracking servers go down, direct IP / join codes / QR still work. The architecture degrades gracefully, never fails completely.</p>
</li>
<li>
<p><strong>Relay servers are regional.</strong> Players connect to the nearest relay for lowest latency. The tracking server listing includes the relay region. Community relays in underserved regions improve the experience for everyone.</p>
</li>
<li>
<p><strong>Observable by default (D031).</strong> All servers emit structured telemetry via OpenTelemetry (OTEL): metrics (Prometheus-compatible), distributed traces (Jaeger/Zipkin), and structured logs (Loki/stdout). Every server exposes <code>/healthz</code>, <code>/readyz</code>, and <code>/metrics</code> endpoints. Self-hosters get pre-built Grafana dashboards for relay (active games, RTT, desync events), tracking (listings, heartbeats), and workshop (downloads, resolution times). Observability is optional but ships with the infrastructure — <code>docker-compose.observability.yaml</code> adds Grafana + Prometheus + Loki with one command.</p>
</li>
</ol>
<h3 id="deployment-options"><a class="header" href="#deployment-options">Deployment Options</a></h3>
<p><strong>Option 1: Just run the binary (simplest)</strong></p>
<pre><code class="language-bash"># Download and run — no Docker, no cloud, no dependencies
./tracking-server --port 8080 --heartbeat-ttl 30s
./relay-server --port 9090 --region home --max-games 50
</code></pre>
<p>Works on any machine: home PC, spare laptop, Raspberry Pi, VPS. The tracking server uses in-memory storage by default — no Redis needed for a single instance.</p>
<p><strong>Option 2: Docker Compose (one-command setup)</strong></p>
<pre><code class="language-yaml"># docker-compose.yaml (community self-hosting)
services:
  tracking:
    image: ghcr.io/iron-curtain/tracking-server:latest
    ports:
      - "8080:8080"
    environment:
      - STORE=memory           # or STORE=redis://redis:6379 for multi-instance
      - HEARTBEAT_TTL=30s
      - MAX_LISTINGS=1000
      - RATE_LIMIT=10/min      # per IP — anti-spam
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/healthz"]

  relay:
    image: ghcr.io/iron-curtain/relay-server:latest
    ports:
      - "9090:9090/udp"
      - "9090:9090/tcp"
    environment:
      - MAX_GAMES=100
      - MAX_PLAYERS_PER_GAME=16
      - TICK_TIMEOUT=5s         # drop orders after 5s — anti-lag-switch
      - REGION=eu-west          # reported to tracking server
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9091/healthz"]

  redis:
    image: redis:7-alpine       # only needed for multi-instance tracking
    profiles: ["scaled"]
</code></pre>
<p><strong>Option 3: Kubernetes / Helm (production scale)</strong></p>
<p>For the official deployment or large community servers that need horizontal scaling:</p>
<pre><code class="language-yaml"># helm/values.yaml (abbreviated)
tracking:
  replicas: 3
  resources:
    requests: { cpu: 100m, memory: 64Mi }
    limits: { cpu: 500m, memory: 128Mi }
  store: redis
  redis:
    url: redis://redis-master:6379

relay:
  replicas: 5                   # one pod per ~100 concurrent games
  resources:
    requests: { cpu: 200m, memory: 128Mi }
    limits: { cpu: 1000m, memory: 256Mi }
  sessionAffinity: ClientIP     # sticky sessions for relay game state
  regions:
    - name: eu-west
      replicas: 2
    - name: us-east
      replicas: 2
    - name: ap-southeast
      replicas: 1
</code></pre>
<h3 id="cost-profile"><a class="header" href="#cost-profile">Cost Profile</a></h3>
<p>Both services are lightweight — they forward small order packets, not game state:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Deployment</th><th>Cost</th><th>Serves</th><th>Requires</th></tr>
</thead>
<tbody>
<tr><td>Home PC / spare laptop</td><td>Free (electricity)</td><td>~50 concurrent games</td><td>Port forwarding</td></tr>
<tr><td>Raspberry Pi</td><td>~€50 one-time</td><td>~50 concurrent games</td><td>Port forwarding</td></tr>
<tr><td>Single VPS (community)</td><td>€5-10/month</td><td>~200 concurrent games</td><td>Nothing special</td></tr>
<tr><td>Small k8s cluster (official)</td><td>€30-50/month</td><td>~2000 concurrent games</td><td>Kubernetes knowledge</td></tr>
<tr><td>Scaled k8s (launch day spike)</td><td>€100-200/month</td><td>~10,000 concurrent games</td><td>Kubernetes + monitoring</td></tr>
</tbody>
</table>
</div>
<p>The relay server is the heavier service (per-game session state, UDP forwarding) but still tiny — each game session is a few KB of buffered orders. A single pod handles ~100 concurrent games easily.</p>
<h3 id="backend-language"><a class="header" href="#backend-language">Backend Language</a></h3>
<p>The tracking and relay servers are standalone Rust binaries (not Bevy — no ECS needed). They share <code>ra-protocol</code> for order serialization. The relay server implements the relay-side of <code>RelayLockstepNetwork</code>. Both are simple enough to be developed in Phase 5 alongside the multiplayer client code.</p>
<h3 id="failure-modes"><a class="header" href="#failure-modes">Failure Modes</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Failure</th><th>Impact</th><th>Recovery</th></tr>
</thead>
<tbody>
<tr><td>Tracking server dies</td><td>Browse requests fail; existing games unaffected</td><td>Restart process; multi-instance setups have other replicas</td></tr>
<tr><td>All tracking servers down</td><td>No game browser; existing games unaffected</td><td>Direct IP, join codes, QR still work</td></tr>
<tr><td>Relay server dies</td><td>Games on that instance disconnect</td><td>Clients reconnect to another instance or fall back to P2P</td></tr>
<tr><td>Official infra fully offline</td><td>Community tracking/relay servers still operational</td><td>Federation means no single operator is critical</td></tr>
</tbody>
</table>
</div>
<h2 id="multi-player-scaling-beyond-2-players"><a class="header" href="#multi-player-scaling-beyond-2-players">Multi-Player Scaling (Beyond 2 Players)</a></h2>
<p>The architecture supports N players with no structural changes. Every design element — deterministic lockstep, sub-tick ordering, relay server, desync detection — works for 2, 4, 8, or more players.</p>
<h3 id="how-each-component-scales"><a class="header" href="#how-each-component-scales">How Each Component Scales</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>2 players</th><th>N players</th><th>Bottleneck</th></tr>
</thead>
<tbody>
<tr><td><strong>Lockstep sim</strong></td><td>Both run identical sim</td><td>All N run identical sim</td><td>No change — sim processes <code>TickOrders</code> regardless of source count</td></tr>
<tr><td><strong>Sub-tick ordering</strong></td><td>Sort 2 players’ orders</td><td>Sort N players’ orders</td><td>Negligible — orders per tick is small (players issue ~0-5 orders/tick)</td></tr>
<tr><td><strong>Relay server</strong></td><td>Collects from 2, broadcasts to 2</td><td>Collects from N, broadcasts to N</td><td>Linear in N. Bandwidth is tiny (orders are small)</td></tr>
<tr><td><strong>Desync detection</strong></td><td>Compare 2 hashes</td><td>Compare N hashes</td><td>Trivial — one hash per player per tick</td></tr>
<tr><td><strong>Input delay</strong></td><td>Tuned to worst of 2 connections</td><td>Tuned to worst of N connections</td><td><strong>Real bottleneck</strong> — one laggy player affects everyone</td></tr>
<tr><td><strong>Direct P2P</strong></td><td>1 connection</td><td>N×(N-1)/2 mesh connections</td><td>Mesh doesn’t scale. Use star topology or relay for &gt;4 players</td></tr>
</tbody>
</table>
</div>
<h3 id="p2p-topology-for-multi-player"><a class="header" href="#p2p-topology-for-multi-player">P2P Topology for Multi-Player</a></h3>
<p>Direct P2P lockstep with 2-3 players uses a full mesh (everyone connects to everyone). Beyond that, use a star topology where one player acts as host:</p>
<pre><code>2-3 players: full mesh (every client sends to every other)
  A ↔ B ↔ C ↔ A

4+ players: star via host (one player collects and rebroadcasts)
  B → A ← C        A = host, collects orders, broadcasts canonical tick
      ↑
      D

4+ players: relay server (recommended)
  B → R ← C        R = relay, all benefits of Model 2
      ↑
      D
</code></pre>
<p>For 4+ players, the relay server is strongly recommended. It solves:</p>
<ul>
<li>NAT traversal for all players (not just host)</li>
<li>Lag-switch protection for all players (not just host-enforced)</li>
<li>No single player has hosting advantage (relay is neutral authority)</li>
<li>Sub-tick ordering is globally fair</li>
</ul>
<h3 id="the-real-scaling-limit-sim-cost-not-network"><a class="header" href="#the-real-scaling-limit-sim-cost-not-network">The Real Scaling Limit: Sim Cost, Not Network</a></h3>
<p>With N players, the sim has more units, more orders, and more state to process. This is a <strong>sim performance</strong> concern, not a network concern:</p>
<ul>
<li>2-player game: ~200-500 units typically</li>
<li>4-player FFA or 2v2: ~400-1000 units</li>
<li>8-player: ~800-2000 units</li>
</ul>
<p>The performance targets in <code>10-PERFORMANCE.md</code> already account for this. The efficiency pyramid (flowfields, spatial hash, sim LOD, amortized work) is designed for 2000+ units on mid-range hardware. An 8-player game is within budget.</p>
<h3 id="team-games-2v2-3v3-4v4"><a class="header" href="#team-games-2v2-3v3-4v4">Team Games (2v2, 3v3, 4v4)</a></h3>
<p>Team games work identically to FFA. Each player submits orders for their own units. The sim processes all orders from all players in sub-tick chronological order. Alliances, shared vision, and team chat are sim-layer and UI-layer concerns — the network model doesn’t distinguish between ally and enemy.</p>
<h3 id="observers--spectators"><a class="header" href="#observers--spectators">Observers / Spectators</a></h3>
<p>Observers receive <code>TickOrders</code> but never submit any. They run the sim locally (full state, all players’ perspective). In a relay server setup, the relay can optionally delay the observer feed by N ticks to prevent live coaching.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ObserverConnection {
    pub delay_ticks: u64,        // e.g., 30 ticks (~2 seconds) for anti-coaching
    pub receive_only: bool,      // true — observer never submits orders
}
<span class="boring">}</span></code></pre>
<h3 id="player-limits"><a class="header" href="#player-limits">Player Limits</a></h3>
<p>No hard architectural limit. Practical limits:</p>
<ul>
<li><strong>Lockstep input delay</strong> — scales with the worst connection among N players. Beyond ~8 players, the slowest player’s latency dominates everyone’s experience.</li>
<li><strong>Order volume</strong> — N players generating orders simultaneously. Still tiny bandwidth (orders are small structs, not state).</li>
<li><strong>Sim cost</strong> — more players = more units = more computation. The efficiency pyramid handles this up to the hardware’s limit.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="04--modding-system"><a class="header" href="#04--modding-system">04 — Modding System</a></h1>
<h2 id="three-tier-architecture"><a class="header" href="#three-tier-architecture">Three-Tier Architecture</a></h2>
<pre><code>Ease of use ▲
             │  ┌─────────────────────────┐
             │  │  YAML rules / data       │  ← 80% of mods (Tier 1)
             │  │  (units, weapons, maps)  │
             │  ├─────────────────────────┤
             │  │  Lua scripts             │  ← missions, AI, abilities (Tier 2)
             │  │  (event hooks, triggers) │
             │  ├─────────────────────────┤
             │  │  WASM modules            │  ← new mechanics, total conversions (Tier 3)
             │  │  (Rust/C/AssemblyScript) │
             │  └─────────────────────────┘
Power      ▼
</code></pre>
<p>Each tier is optional. A modder who wants to change tank cost never sees code. A modder building a total conversion uses WASM.</p>
<h2 id="tier-1-data-driven-yaml-rules"><a class="header" href="#tier-1-data-driven-yaml-rules">Tier 1: Data-Driven (YAML Rules)</a></h2>
<h3 id="decision-real-yaml-not-miniyaml"><a class="header" href="#decision-real-yaml-not-miniyaml">Decision: Real YAML, Not MiniYAML</a></h3>
<p>OpenRA uses “MiniYAML” — a custom dialect that uses tabs, has custom inheritance (<code>^</code>, <code>@</code>), and doesn’t comply with the YAML spec. Standard parsers choke on it.</p>
<p><strong>Our approach:</strong> Standard YAML with <code>serde_yaml</code>, inheritance resolved at load time.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li><code>serde</code> + <code>serde_yaml</code> → typed Rust struct deserialization for free</li>
<li>Every text editor has YAML support, linters, formatters</li>
<li>JSON-schema validation catches errors before the game loads</li>
<li>No custom parser to maintain</li>
</ul>
<h3 id="example-unit-definition"><a class="header" href="#example-unit-definition">Example Unit Definition</a></h3>
<pre><code class="language-yaml"># units/allies/infantry.yaml
units:
  rifle_infantry:
    inherits: _base_soldier
    display:
      name: "Rifle Infantry"
      icon: e1icon
      sequences: e1
    llm:
      summary: "Cheap expendable anti-infantry scout"
      role: [anti_infantry, scout, garrison]
      strengths: [cheap, fast_to_build, effective_vs_infantry]
      weaknesses: [fragile, useless_vs_armor, no_anti_air]
      tactical_notes: &gt;
        Best used in groups of 5+ for early harassment or
        garrisoning buildings. Not cost-effective against
        anything armored. Pair with anti-tank units.
      counters: [tank, apc, attack_dog]
      countered_by: [tank, flamethrower, grenadier]
    buildable:
      cost: 100
      time: 5.0
      queue: infantry
      prerequisites: [barracks]
    health:
      max: 50
      armor: none
    mobile:
      speed: 56
      locomotor: foot
    combat:
      weapon: m1_carbine
      attack_sequence: shoot
</code></pre>
<h3 id="inheritance-system"><a class="header" href="#inheritance-system">Inheritance System</a></h3>
<p>Templates use <code>_</code> prefix convention (not spawnable units):</p>
<pre><code class="language-yaml"># templates/_base_soldier.yaml
_base_soldier:
  mobile:
    locomotor: foot
    turn_speed: 5
  health:
    armor: none
  selectable:
    bounds: [12, 18]
    voice: generic_infantry
</code></pre>
<p>Inheritance is resolved at load time in Rust. Fields from <code>_base_soldier</code> are merged, then overridden by the child definition.</p>
<h3 id="balance-presets"><a class="header" href="#balance-presets">Balance Presets</a></h3>
<p>The same inheritance system powers <strong>switchable balance presets</strong> (D019). Presets are alternate YAML directories that override unit/weapon/structure values:</p>
<pre><code>rules/
├── units/              # base definitions (always loaded)
├── weapons/
├── structures/
└── presets/
    ├── classic/        # EA source code values (DEFAULT)
    │   ├── units/
    │   │   └── tanya.yaml    # cost: 1200, health: 125, weapon_range: 5, ...
    │   └── weapons/
    ├── openra/         # OpenRA competitive balance
    │   ├── units/
    │   │   └── tanya.yaml    # cost: 1400, health: 80, weapon_range: 3, ...
    │   └── weapons/
    └── remastered/     # Remastered Collection tweaks
        └── ...
</code></pre>
<p><strong>How it works:</strong></p>
<ol>
<li>Engine loads base definitions from <code>rules/</code></li>
<li>Engine loads the selected preset directory, overriding matching fields via inheritance</li>
<li>Preset YAML files only contain fields that differ — everything else falls through to base</li>
</ol>
<pre><code class="language-yaml"># rules/presets/openra/units/tanya.yaml
# Only overrides what OpenRA changes — rest inherits from base definition
tanya:
  inherits: _base_tanya       # base definition with display, sequences, AI metadata, etc.
  buildable:
    cost: 1400                 # OpenRA nerfed from 1200
  health:
    max: 80                    # OpenRA nerfed from 125
  combat:
    weapon: tanya_pistol_nerfed  # references an OpenRA-balanced weapon definition
</code></pre>
<p><strong>Lobby integration:</strong> Preset is selected in the game lobby alongside map and faction. All players in a multiplayer game use the same preset (enforced by the sim). The preset name is embedded in replays.</p>
<p>See D019 in <code>src/09-DECISIONS.md</code> for full rationale.</p>
<h3 id="rust-deserialization"><a class="header" href="#rust-deserialization">Rust Deserialization</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Deserialize)]
struct UnitDef {
    inherits: Option&lt;String&gt;,
    display: DisplayInfo,
    llm: Option&lt;LlmMeta&gt;,
    buildable: Option&lt;BuildableInfo&gt;,
    health: HealthInfo,
    mobile: Option&lt;MobileInfo&gt;,
    combat: Option&lt;CombatInfo&gt;,
}

/// LLM-readable metadata for any game resource.
/// Consumed by ra-llm (mission generation), ra-ai (skirmish AI),
/// and workshop search (semantic matching).
#[derive(Deserialize, Serialize)]
struct LlmMeta {
    summary: String,                    // one-line natural language description
    role: Vec&lt;String&gt;,                  // semantic tags: anti_infantry, scout, siege, etc.
    strengths: Vec&lt;String&gt;,             // what this unit is good at
    weaknesses: Vec&lt;String&gt;,            // what this unit is bad at
    tactical_notes: Option&lt;String&gt;,     // free-text tactical guidance for LLM
    counters: Vec&lt;String&gt;,              // unit types this is effective against
    countered_by: Vec&lt;String&gt;,          // unit types that counter this
}
<span class="boring">}</span></code></pre>
<h3 id="miniyaml-migration--runtime-loading"><a class="header" href="#miniyaml-migration--runtime-loading">MiniYAML Migration &amp; Runtime Loading</a></h3>
<p><strong>Converter tool:</strong> <code>ra-formats</code> includes a <code>miniyaml2yaml</code> CLI converter that translates existing OpenRA mod data to standard YAML. Available for permanent, clean migration.</p>
<p><strong>Runtime loading (D025):</strong> MiniYAML files also load directly at runtime — no pre-conversion required. When <code>ra-formats</code> detects tab-indented content with <code>^</code> inheritance or <code>@</code> suffixes, it auto-converts in memory. The result is identical to what the converter would produce. This means existing OpenRA mods can be dropped into IC and played immediately.</p>
<pre><code>┌─────────────────────────────────────────────────────────┐
│           MiniYAML Loading Pipeline                     │
│                                                         │
│  .yaml file ──→ Format detection                        │
│                   │                                     │
│                   ├─ Standard YAML → serde_yaml parse   │
│                   │                                     │
│                   └─ MiniYAML detected                  │
│                       │                                 │
│                       ├─ MiniYAML parser (tabs, ^, @)   │
│                       ├─ Intermediate tree              │
│                       ├─ Alias resolution (D023)        │
│                       └─ Typed Rust structs             │
│                                                         │
│  Both paths produce identical output.                   │
│  Runtime conversion adds ~10-50ms per mod (cached).     │
└─────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="openra-vocabulary-aliases-d023"><a class="header" href="#openra-vocabulary-aliases-d023">OpenRA Vocabulary Aliases (D023)</a></h3>
<p>OpenRA trait names are accepted as aliases for IC-native YAML keys. Both forms are valid:</p>
<pre><code class="language-yaml"># OpenRA-style (accepted via alias)
rifle_infantry:
    Armament:
        Weapon: M1Carbine
    Valued:
        Cost: 100

# IC-native style (preferred)
rifle_infantry:
    combat:
        weapon: m1_carbine
    buildable:
        cost: 100
</code></pre>
<p>The alias registry lives in <code>ra-formats</code> and maps all ~130 OpenRA trait names to IC components. When an alias is used, parsing succeeds with a deprecation warning: <code>"Armament" is accepted but deprecated; prefer "combat"</code>. Warnings can be suppressed per-mod.</p>
<h3 id="openra-mod-manifest-loading-d026"><a class="header" href="#openra-mod-manifest-loading-d026">OpenRA Mod Manifest Loading (D026)</a></h3>
<p>IC can parse OpenRA’s <code>mod.yaml</code> manifest format directly. Point IC at an existing OpenRA mod directory:</p>
<pre><code class="language-bash"># Run an OpenRA mod directly (auto-converts at load time)
ic mod run --openra-dir /path/to/openra-mod/

# Import for permanent migration
ic mod import /path/to/openra-mod/ --output ./my-ic-mod/
</code></pre>
<p>Sections like <code>Rules</code>, <code>Sequences</code>, <code>Weapons</code>, <code>Maps</code>, <code>Voices</code>, <code>Music</code> are mapped to IC equivalents. <code>Assemblies</code> (C# DLLs) are flagged as warnings — units using unavailable traits get placeholder rendering.</p>
<h3 id="why-not-toml--ron--json"><a class="header" href="#why-not-toml--ron--json">Why Not TOML / RON / JSON?</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Verdict</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>TOML</td><td>Reject</td><td>Awkward for deeply nested game data</td></tr>
<tr><td>RON</td><td>Reject</td><td>Modders won’t know it, thin editor support</td></tr>
<tr><td>JSON</td><td>Reject</td><td>Too verbose, no comments, miserable for hand-editing</td></tr>
<tr><td>YAML</td><td>Accept</td><td>Human-readable, universal tooling, serde integration</td></tr>
</tbody>
</table>
</div>
<h2 id="tier-2-lua-scripting"><a class="header" href="#tier-2-lua-scripting">Tier 2: Lua Scripting</a></h2>
<h3 id="decision-lua-over-python"><a class="header" href="#decision-lua-over-python">Decision: Lua over Python</a></h3>
<p><strong>Why Lua:</strong></p>
<ul>
<li>Tiny runtime (~200KB)</li>
<li>Designed for embedding — exists for this purpose</li>
<li>Deterministic (provide fixed-point math bindings, no floats)</li>
<li>Trivially sandboxable (control exactly what functions are available)</li>
<li>Industry standard: Factorio, WoW, Garry’s Mod, Dota 2, Roblox</li>
<li><code>mlua</code> or <code>rlua</code> crates are mature</li>
<li>Any modder can learn in an afternoon</li>
</ul>
<p><strong>Why NOT Python:</strong></p>
<ul>
<li>Floating-point non-determinism breaks lockstep multiplayer</li>
<li>GC pauses (reintroduces the problem Rust solves)</li>
<li>50-100x slower than native (hot paths run every tick for every unit)</li>
<li>Embedding CPython is heavy (~15-30MB)</li>
<li>Sandboxing is basically unsolvable — security disaster for community mods</li>
<li><code>import os; os.system("rm -rf /")</code> is one mod away</li>
</ul>
<h3 id="lua-api--strict-superset-of-openra-d024"><a class="header" href="#lua-api--strict-superset-of-openra-d024">Lua API — Strict Superset of OpenRA (D024)</a></h3>
<p>Iron Curtain’s Lua API is a <strong>strict superset</strong> of OpenRA’s 16 global objects. All OpenRA Lua missions run unmodified — same function names, same parameter signatures, same return types.</p>
<p><strong>OpenRA-compatible globals (all supported identically):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Global</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Actor</code></td><td>Create, query, manipulate actors</td></tr>
<tr><td><code>Map</code></td><td>Terrain, bounds, spatial queries</td></tr>
<tr><td><code>Trigger</code></td><td>Event hooks (OnKilled, AfterDelay)</td></tr>
<tr><td><code>Media</code></td><td>Audio, video, text display</td></tr>
<tr><td><code>Player</code></td><td>Player state, resources, diplomacy</td></tr>
<tr><td><code>Reinforcements</code></td><td>Spawn units at edges/drops</td></tr>
<tr><td><code>Camera</code></td><td>Pan, position, shake</td></tr>
<tr><td><code>DateTime</code></td><td>Game time queries</td></tr>
<tr><td><code>Objectives</code></td><td>Mission objective management</td></tr>
<tr><td><code>Lighting</code></td><td>Global lighting control</td></tr>
<tr><td><code>UserInterface</code></td><td>UI text, notifications</td></tr>
<tr><td><code>Utils</code></td><td>Math, random, table utilities</td></tr>
<tr><td><code>Beacon</code></td><td>Map beacon management</td></tr>
<tr><td><code>Radar</code></td><td>Radar ping control</td></tr>
<tr><td><code>HSLColor</code></td><td>Color construction</td></tr>
<tr><td><code>WDist</code></td><td>Distance unit conversion</td></tr>
</tbody>
</table>
</div>
<p><strong>IC-exclusive extensions (additive, no conflicts):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Global</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Campaign</code></td><td>Branching campaign state (D021)</td></tr>
<tr><td><code>Weather</code></td><td>Dynamic weather control (D022)</td></tr>
<tr><td><code>Workshop</code></td><td>Mod metadata queries</td></tr>
<tr><td><code>LLM</code></td><td>LLM integration hooks (Phase 7)</td></tr>
</tbody>
</table>
</div>
<p>Each actor reference exposes properties matching its components (<code>.Health</code>, <code>.Location</code>, <code>.Owner</code>, <code>.Move()</code>, <code>.Attack()</code>, <code>.Stop()</code>, <code>.Guard()</code>, <code>.Deploy()</code>, etc.) — identical to OpenRA’s actor property groups.</p>
<h3 id="lua-api-examples"><a class="header" href="#lua-api-examples">Lua API Examples</a></h3>
<pre><code class="language-lua">-- Mission scripting
function OnPlayerEnterArea(player, area)
  if area == "bridge_crossing" then
    SpawnReinforcements("allies", {"Tank", "Tank"}, "north")
    PlayEVA("reinforcements_arrived")
  end
end

-- Custom unit behavior
Hooks.OnUnitCreated("ChronoTank", function(unit)
  unit:AddAbility("chronoshift", {
    cooldown = 120,
    range = 15,
    onActivate = function(target_cell)
      PlayEffect("chrono_flash", unit.position)
      unit:Teleport(target_cell)
      PlayEffect("chrono_flash", target_cell)
    end
  })
end)
</code></pre>
<h3 id="lua-sandbox-rules"><a class="header" href="#lua-sandbox-rules">Lua Sandbox Rules</a></h3>
<ul>
<li>Only engine-provided functions available (no <code>io</code>, <code>os</code>, <code>require</code> from filesystem)</li>
<li>Fixed-point math provided via engine bindings (no raw floats)</li>
<li>Execution time limits per tick</li>
<li>Memory limits per mod</li>
</ul>
<h2 id="tier-3-wasm-modules"><a class="header" href="#tier-3-wasm-modules">Tier 3: WASM Modules</a></h2>
<h3 id="rationale"><a class="header" href="#rationale">Rationale</a></h3>
<ul>
<li>Near-native performance for complex mods</li>
<li>Perfectly sandboxed by design (WASM’s memory model)</li>
<li>Deterministic execution (critical for multiplayer)</li>
<li>Modders write in Rust, C, Go, AssemblyScript, or even Python compiled to WASM</li>
<li><code>wasmtime</code> or <code>wasmer</code> crates</li>
</ul>
<h3 id="wasm-host-api-security-boundary"><a class="header" href="#wasm-host-api-security-boundary">WASM Host API (Security Boundary)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The WASM host functions are the ONLY API mods can call.
// The API surface IS the security boundary.

#[wasm_host_fn]
fn get_unit_position(unit_id: u32) -&gt; Option&lt;(i32, i32)&gt; {
    let unit = sim.get_unit(unit_id)?;
    // CHECK: is this unit visible to the mod's player?
    if !sim.is_visible_to(mod_player, unit.position) {
        return None;  // Mod cannot see fogged units
    }
    Some(unit.position)
}

// There is no get_all_units() function.
// There is no get_enemy_state() function.
<span class="boring">}</span></code></pre>
<h3 id="mod-capabilities-system"><a class="header" href="#mod-capabilities-system">Mod Capabilities System</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ModCapabilities {
    pub read_own_state: bool,
    pub read_visible_state: bool,
    // Can NEVER read fogged state (API doesn't exist)
    pub issue_orders: bool,           // For AI mods
    pub filesystem: FileAccess,       // Usually None
    pub network: NetworkAccess,       // Usually None
}

pub enum NetworkAccess {
    None,                          // Most mods
    AllowList(Vec&lt;String&gt;),        // UI mods fetching assets
    // NEVER unrestricted
}
<span class="boring">}</span></code></pre>
<h3 id="3d-rendering-mods-tier-3-showcase"><a class="header" href="#3d-rendering-mods-tier-3-showcase">3D Rendering Mods (Tier 3 Showcase)</a></h3>
<p>The most powerful example of Tier 3 modding: replacing the entire visual presentation with 3D rendering. A “3D Red Alert” mod swaps sprites for GLTF meshes and the isometric camera for a free-rotating 3D camera — while the simulation, networking, pathfinding, and rules are completely unchanged.</p>
<p>This works because Bevy already ships a full 3D pipeline. The mod doesn’t build a 3D engine — it uses Bevy’s existing 3D renderer through the WASM mod API.</p>
<p><strong>A 3D render mod implements:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WASM mod: replaces the default sprite renderer
impl Renderable for MeshRenderer {
    fn render(&amp;self, entity: EntityId, state: &amp;RenderState, ctx: &amp;mut RenderContext) {
        let model = self.models.get(entity.unit_type);
        let animation = match state.activity {
            Activity::Idle =&gt; &amp;model.idle,
            Activity::Moving =&gt; &amp;model.walk,
            Activity::Attacking =&gt; &amp;model.attack,
        };
        ctx.draw_mesh(model.mesh, state.world_pos, state.facing, animation);
    }
}

impl CameraController for FreeCam3D {
    fn screen_to_cell(&amp;self, screen_pos: Vec2, terrain: &amp;TerrainData) -&gt; CellPos {
        // 3D raycast against terrain mesh → grid cell
        let ray = self.camera.screen_to_ray(screen_pos);
        terrain.raycast(ray).to_cell_pos()
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Assets are mapped in YAML (mod overrides unit render definitions):</strong></p>
<pre><code class="language-yaml"># 3d_mod/render_overrides.yaml
rifle_infantry:
  render:
    type: mesh
    model: models/infantry/rifle.glb
    animations:
      idle: Idle
      move: Run
      attack: Shoot
      death: Death

medium_tank:
  render:
    type: mesh
    model: models/vehicles/medium_tank.glb
    turret: models/vehicles/medium_tank_turret.glb
    animations:
      idle: Idle
      move: Drive
</code></pre>
<p><strong>Cross-view multiplayer is a natural consequence.</strong> Since the mod only changes rendering, a player using the 3D mod can play against a player using classic isometric sprites. The sim produces identical state; each client just draws it differently. Replays are viewable in either mode.</p>
<p>See <code>02-ARCHITECTURE.md</code> § “3D Rendering as a Mod” for the full architectural rationale.</p>
<h2 id="tera-templating-phase-6"><a class="header" href="#tera-templating-phase-6">Tera Templating (Phase 6)</a></h2>
<h3 id="tera-as-the-template-engine"><a class="header" href="#tera-as-the-template-engine">Tera as the Template Engine</a></h3>
<p>Tera is a Rust-native Jinja2-compatible template engine. <strong>All first-party IC content uses it</strong> — the default Red Alert campaign, built-in resource packs, and balance presets are all Tera-templated. This means the system is proven by the content that ships with the engine, not just an abstract capability.</p>
<p>For <strong>third-party content creators, Tera is entirely optional.</strong> Plain YAML is always valid and is the recommended starting point. Most community mods, resource packs, and maps work fine without any templating at all. Tera is there when you need it — not forced on you.</p>
<p>What Tera handles:</p>
<ol>
<li><strong>YAML/Lua generation</strong> — eliminates copy-paste when defining dozens of faction variants or bulk unit definitions</li>
<li><strong>Mission templates</strong> — parameterized, reusable mission blueprints</li>
<li><strong>Resource packs</strong> — switchable asset layers with configurable parameters (quality, language, platform)</li>
</ol>
<p>Inspired by Helm’s approach to parameterized configuration, but adapted to game content: parameters are defined in a <code>schema.yaml</code>, defaults are inline in the template, and user preferences are set through the in-game settings UI — not a separate values file workflow. The pattern stays practical to our use case rather than importing Helm’s full complexity.</p>
<p>Load-time only (zero runtime cost). Tera is the right fit because:</p>
<ul>
<li>Rust-native (<code>tera</code> crate), no external dependencies</li>
<li>Jinja2 syntax — widely known, documented, tooling exists</li>
<li>Supports loops, conditionals, includes, macros, filters, inheritance</li>
<li>Deterministic output (no randomness unless explicitly seeded via context)</li>
</ul>
<h3 id="unitrule-templating-original-use-case"><a class="header" href="#unitrule-templating-original-use-case">Unit/Rule Templating (Original Use Case)</a></h3>
<pre><code class="language-jinja">{% for faction in ["allies", "soviet"] %}
{% for tier in [1, 2, 3] %}
{{ faction }}_tank_t{{ tier }}:
  inherits: _base_tank
  health:
    max: {{ 200 + tier * 100 }}
  buildable:
    cost: {{ 500 + tier * 300 }}
{% endfor %}
{% endfor %}
</code></pre>
<h3 id="mission-templates-parameterized-missions"><a class="header" href="#mission-templates-parameterized-missions">Mission Templates (Parameterized Missions)</a></h3>
<p>A mission template is a reusable mission blueprint with parameterized values. The template defines the structure (map layout, objectives, triggers, enemy composition); the user (or LLM) supplies values to produce a concrete, playable mission.</p>
<p><strong>Template structure:</strong></p>
<pre><code>templates/
  bridge_defense/
    template.yaml        # Tera template for map + rules
    triggers.lua.tera    # Tera template for Lua trigger scripts
    schema.yaml          # Parameter definitions with inline defaults
    preview.png          # Thumbnail for workshop browser
    README.md            # Description, author, usage notes
</code></pre>
<p><strong>Schema (what parameters the template accepts):</strong></p>
<pre><code class="language-yaml"># schema.yaml — defines the knobs for this template
parameters:
  map_size:
    type: enum
    options: [small, medium, large]
    default: medium
    description: "Overall map dimensions"
  
  player_faction:
    type: enum
    options: [allies, soviet]
    default: allies
    description: "Player's faction"
  
  enemy_waves:
    type: integer
    min: 3
    max: 20
    default: 8
    description: "Number of enemy attack waves"
  
  difficulty:
    type: enum
    options: [easy, normal, hard, brutal]
    default: normal
    description: "Controls enemy unit count and AI aggression"
  
  reinforcement_type:
    type: enum
    options: [infantry, armor, air, mixed]
    default: mixed
    description: "What reinforcements the player receives"
  
  enable_naval:
    type: boolean
    default: false
    description: "Include river crossings and naval units"
</code></pre>
<p><strong>Template (references parameters):</strong></p>
<pre><code class="language-jinja">{# template.yaml — bridge defense mission #}
mission:
  name: "Bridge Defense — {{ difficulty | title }}"
  briefing: &gt;
    Commander, hold the {{ map_size }} bridge crossing against
    {{ enemy_waves }} waves of {{ "Soviet" if player_faction == "allies" else "Allied" }} forces.
    {% if enable_naval %}Enemy naval units will approach from the river.{% endif %}

map:
  size: {{ {"small": [64, 64], "medium": [96, 96], "large": [128, 128]}[map_size] }}

actors:
  player_base:
    faction: {{ player_faction }}
    units:
      {% for i in range(end={"easy": 8, "normal": 5, "hard": 3, "brutal": 2}[difficulty]) %}
      - type: {{ reinforcement_type }}_defender_{{ i }}
      {% endfor %}

waves:
  count: {{ enemy_waves }}
  escalation: {{ {"easy": 1.1, "normal": 1.3, "hard": 1.5, "brutal": 2.0}[difficulty] }}
</code></pre>
<p><strong>Rendering a template into a playable mission:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tera::{Tera, Context};

pub fn render_mission_template(
    template_dir: &amp;Path,
    values: &amp;HashMap&lt;String, Value&gt;,
) -&gt; Result&lt;RenderedMission&gt; {
    let schema = load_schema(template_dir.join("schema.yaml"))?;
    let merged = merge_with_defaults(values, &amp;schema)?;  // fill in defaults
    validate_values(&amp;merged, &amp;schema)?;                   // check types, ranges, enums

    let mut tera = Tera::new(template_dir.join("*.tera").to_str().unwrap())?;
    let mut ctx = Context::new();
    for (k, v) in &amp;merged {
        ctx.insert(k, v);
    }

    Ok(RenderedMission {
        map_yaml: tera.render("template.yaml", &amp;ctx)?,
        triggers_lua: tera.render("triggers.lua.tera", &amp;ctx)?,
        // Standard mission format — indistinguishable from hand-crafted
    })
}
<span class="boring">}</span></code></pre>
<h3 id="llm--templates"><a class="header" href="#llm--templates">LLM + Templates</a></h3>
<p>The LLM doesn’t need to generate everything from scratch. It can:</p>
<ol>
<li><strong>Select a template</strong> from the workshop based on the user’s description</li>
<li><strong>Fill in parameters</strong> — the LLM generates parameter values against the <code>schema.yaml</code>, not an entire mission</li>
<li><strong>Validate</strong> — schema constraints catch hallucinated values before rendering</li>
<li><strong>Compose</strong> — chain multiple scene and mission templates for campaigns (e.g., “3 missions: base building → bridge defense → final assault”)</li>
</ol>
<p>This is dramatically more reliable than raw generation. The template constrains the LLM’s output to valid parameter space, and the schema validates it. The LLM becomes a smart form-filler, not an unconstrained code generator.</p>
<h3 id="scene-templates-composable-building-blocks"><a class="header" href="#scene-templates-composable-building-blocks">Scene Templates (Composable Building Blocks)</a></h3>
<p>Inspired by Operation Flashpoint / ArmA’s mission editor: scene templates are <strong>sub-mission components</strong> — reusable, pre-scripted building blocks that snap together inside a mission. Each scene template has its own trigger logic, AI behavior, and Lua scripts already written and tested. The user or LLM only fills in parameters.</p>
<p><strong>Template hierarchy:</strong></p>
<pre><code>Scene Template    — a single scripted encounter or event
  ↓ composed into
Mission Template  — a full mission assembled from scenes + overall structure
  ↓ sequenced into
Campaign Graph    — branching mission graph with persistent state (not a linear sequence)
</code></pre>
<p><strong>Built-in scene template library (examples):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scene Template</th><th>Parameters</th><th>Pre-built Logic</th></tr>
</thead>
<tbody>
<tr><td><code>ambush</code></td><td>location, attacker_units, trigger_zone, delay</td><td>Units hide until player enters zone, then attack from cover</td></tr>
<tr><td><code>patrol</code></td><td>waypoints, unit_composition, alert_radius</td><td>Units cycle waypoints, engage if player detected within radius</td></tr>
<tr><td><code>convoy_escort</code></td><td>route, convoy_units, ambush_points[], escort_units</td><td>Convoy follows route, ambushes trigger at defined points</td></tr>
<tr><td><code>defend_position</code></td><td>position, waves[], interval, reinforcement_schedule</td><td>Enemies attack in waves with escalating strength</td></tr>
<tr><td><code>base_building</code></td><td>start_resources, available_structures, tech_tree_limit</td><td>Player builds base, unlocked structures based on tech level</td></tr>
<tr><td><code>timed_objective</code></td><td>target, time_limit, failure_trigger</td><td>Player must complete objective before timer expires</td></tr>
<tr><td><code>reinforcements</code></td><td>trigger, units, entry_point, delay</td><td>Units arrive from map edge when trigger fires</td></tr>
<tr><td><code>scripted_scene</code></td><td>actors[], dialogue[], camera_positions[]</td><td>Non-interactive cutscene or briefing with camera movement</td></tr>
<tr><td><code>video_playback</code></td><td>video_ref, trigger, display_mode, skippable</td><td>Play a video on trigger — see display modes below</td></tr>
<tr><td><code>weather</code></td><td>type, intensity, trigger, duration, sim_effects</td><td>Weather system — see weather effects below</td></tr>
<tr><td><code>extraction</code></td><td>pickup_zone, transport_type, signal_trigger</td><td>Player moves units to extraction zone, transport arrives</td></tr>
</tbody>
</table>
</div>
<p><strong><code>video_playback</code> display modes:</strong></p>
<p>The <code>display_mode</code> parameter controls <em>where</em> the video renders:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Behavior</th><th>Inspiration</th></tr>
</thead>
<tbody>
<tr><td><code>fullscreen</code></td><td>Pauses gameplay, fills screen. Classic FMV briefing between missions.</td><td>RA1 mission briefings</td></tr>
<tr><td><code>radar_comm</code></td><td>Video replaces the radar/minimap panel during gameplay. Game continues. RA2-style comm.</td><td>RA2 EVA / commander video calls</td></tr>
<tr><td><code>picture_in_picture</code></td><td>Small floating video overlay in a corner. Game continues. Dismissible.</td><td>Modern RTS cinematics</td></tr>
</tbody>
</table>
</div>
<p><code>radar_comm</code> is how RA2 handles in-mission conversations — the radar panel temporarily switches to a video feed of a character addressing the player, then returns to the minimap when the clip ends. The sidebar stays functional (build queues, power bar still visible). This creates narrative immersion without interrupting gameplay.</p>
<p>The LLM can use this in generated missions: a briefing video at mission start (<code>fullscreen</code>), a commander calling in mid-mission when a trigger fires (<code>radar_comm</code>), and a small notification video when reinforcements arrive (<code>picture_in_picture</code>).</p>
<p><strong><code>weather</code> scene template:</strong></p>
<p>Weather effects are GPU particle systems rendered by <code>ra-render</code>, with optional gameplay modifiers applied by <code>ra-sim</code>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Visual Effect</th><th>Optional Sim Effect (if <code>sim_effects: true</code>)</th></tr>
</thead>
<tbody>
<tr><td><code>rain</code></td><td>GPU particle rain, puddle reflections, darkened ambient lighting</td><td>Reduced visibility range (−20%), slower wheeled vehicles</td></tr>
<tr><td><code>snow</code></td><td>GPU particle snowfall, accumulation on terrain, white fog</td><td>Reduced movement speed (−15%), reduced visibility (−30%)</td></tr>
<tr><td><code>sandstorm</code></td><td>Dense particle wall, orange tint, reduced draw distance</td><td>Heavy visibility reduction (−50%), damage to exposed infantry</td></tr>
<tr><td><code>blizzard</code></td><td>Heavy snow + wind particles, near-zero visibility</td><td>Severe speed/visibility penalty, periodic cold damage</td></tr>
<tr><td><code>fog</code></td><td>Volumetric fog shader, reduced contrast at distance</td><td>Reduced visibility range (−40%), no other penalties</td></tr>
<tr><td><code>storm</code></td><td>Rain + lightning flashes + screen shake + thunder audio</td><td>Same as rain + random lightning strikes (cosmetic or damaging)</td></tr>
</tbody>
</table>
</div>
<p><strong>Key design principle:</strong> Weather is split into two layers:</p>
<ul>
<li><strong>Render layer</strong> (<code>ra-render</code>): Always active. GPU particles, shaders, post-FX, ambient audio changes. Pure cosmetic, zero sim impact. Particle density scales with <code>RenderSettings</code> for lower-end devices.</li>
<li><strong>Sim layer</strong> (<code>ra-sim</code>): Optional, controlled by <code>sim_effects</code> parameter. When enabled, weather modifies visibility ranges, movement speeds, and damage — deterministically, so multiplayer stays in sync. When disabled, weather is purely cosmetic eye candy.</li>
</ul>
<p>Weather can be set per-map (in map YAML), triggered mid-mission by Lua scripts, or composed via the <code>weather</code> scene template. An LLM generating a “blizzard defense” mission sets <code>type: blizzard, sim_effects: true</code> and gets both the visual atmosphere and the gameplay tension.</p>
<h3 id="dynamic-weather-system-d022"><a class="header" href="#dynamic-weather-system-d022">Dynamic Weather System (D022)</a></h3>
<p>The base weather system above covers static, per-mission weather. The <strong>dynamic weather system</strong> extends it with real-time weather transitions and terrain texture effects during gameplay — snow accumulates on the ground, rain darkens and wets surfaces, sunshine dries everything out.</p>
<h4 id="weather-state-machine"><a class="header" href="#weather-state-machine">Weather State Machine</a></h4>
<p>Weather transitions are modeled as a state machine running inside <code>ra-sim</code>. The machine is deterministic — same schedule + same tick = identical weather on every client.</p>
<pre><code>     ┌──────────┐      ┌───────────┐      ┌──────────┐
     │  Sunny   │─────▶│ Overcast  │─────▶│   Rain   │
     └──────────┘      └───────────┘      └──────────┘
          ▲                                     │
          │            ┌───────────┐            │
          └────────────│ Clearing  │◀───────────┘
                       └───────────┘            │
                            ▲           ┌──────────┐
                            └───────────│  Storm   │
                                        └──────────┘

     ┌──────────┐      ┌───────────┐      ┌──────────┐
     │  Clear   │─────▶│  Cloudy   │─────▶│   Snow   │
     └──────────┘      └───────────┘      └──────────┘
          ▲                                     │
          └─────────────────────────────────────┘
                    (melt / thaw)
</code></pre>
<p>Each weather type has an <strong>intensity</strong> (fixed-point <code>0..1024</code>) that ramps up during transitions and down during clearing. The sim tracks this as a <code>WeatherState</code> resource:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ra-sim: deterministic weather state
pub struct WeatherState {
    pub current: WeatherType,
    pub intensity: FixedPoint,       // 0 = clear, 1024 = full
    pub transitioning_to: Option&lt;WeatherType&gt;,
    pub transition_progress: FixedPoint,  // 0..1024
    pub ticks_in_current: u32,
}
<span class="boring">}</span></code></pre>
<h4 id="weather-schedule-yaml"><a class="header" href="#weather-schedule-yaml">Weather Schedule (YAML)</a></h4>
<p>Maps define a weather schedule — the rules for how weather evolves. Three modes:</p>
<pre><code class="language-yaml"># maps/winter_assault/map.yaml
weather:
  schedule:
    mode: cycle           # cycle | random | scripted
    default: sunny
    seed_from_match: true # random mode uses match seed (deterministic)

    states:
      sunny:
        min_duration: 300   # minimum ticks before transition
        max_duration: 600
        transitions:
          - to: overcast
            weight: 60      # relative probability
          - to: cloudy
            weight: 40

      overcast:
        min_duration: 120
        max_duration: 240
        transitions:
          - to: rain
            weight: 70
          - to: sunny
            weight: 30
        transition_time: 30  # ticks to blend between states

      rain:
        min_duration: 200
        max_duration: 500
        transitions:
          - to: storm
            weight: 20
          - to: clearing
            weight: 80
        sim_effects: true    # enables gameplay modifiers

      snow:
        min_duration: 300
        max_duration: 800
        transitions:
          - to: clearing
            weight: 100
        sim_effects: true

      clearing:
        min_duration: 60
        max_duration: 120
        transitions:
          - to: sunny
            weight: 100
        transition_time: 60

    surface:
      snow:
        accumulation_rate: 2    # fixed-point units per tick while snowing
        max_depth: 1024
        melt_rate: 1            # per tick when not snowing
      rain:
        wet_rate: 4             # per tick while raining
        dry_rate: 2             # per tick when not raining
      temperature:
        base: 512              # 0 = freezing, 1024 = hot
        sunny_warming: 1       # per tick
        snow_cooling: 2        # per tick
</code></pre>
<ul>
<li><strong><code>cycle</code></strong> — deterministic round-robin through states per the transition weights and durations.</li>
<li><strong><code>random</code></strong> — weighted random using the match seed. Same seed = same weather progression on all clients.</li>
<li><strong><code>scripted</code></strong> — no automatic transitions; weather changes only when Lua calls <code>Weather.transition_to()</code>.</li>
</ul>
<p>Lua can override the schedule at any time:</p>
<pre><code class="language-lua">-- Force a blizzard for dramatic effect at mission climax
Weather.transition_to("blizzard", 45)  -- 45-tick transition
Weather.set_intensity(900)             -- near-maximum

-- Query current state
local w = Weather.get_state()
print(w.current)     -- "blizzard"
print(w.intensity)   -- 900
print(w.surface.snow_depth)  -- per-map average
</code></pre>
<h4 id="terrain-surface-state-sim-layer"><a class="header" href="#terrain-surface-state-sim-layer">Terrain Surface State (Sim Layer)</a></h4>
<p>When <code>sim_effects</code> is enabled, the sim maintains a per-cell <code>TerrainSurfaceGrid</code> — a compact grid tracking how weather has physically altered the terrain. This is <strong>deterministic</strong> and affects gameplay.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ra-sim: per-cell surface condition
pub struct SurfaceCondition {
    pub snow_depth: FixedPoint,   // 0 = bare ground, 1024 = deep snow
    pub wetness: FixedPoint,      // 0 = dry, 1024 = waterlogged
}

/// Grid resource, one entry per map cell
pub struct TerrainSurfaceGrid {
    pub cells: Vec&lt;SurfaceCondition&gt;,
    pub width: u32,
    pub height: u32,
}
<span class="boring">}</span></code></pre>
<p>The <code>weather_surface_system</code> runs every tick (after weather state update, before movement):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Condition</th><th>Effect on Surface</th></tr>
</thead>
<tbody>
<tr><td>Snowing</td><td><code>snow_depth += accumulation_rate × intensity / 1024</code></td></tr>
<tr><td>Not snowing, sunny</td><td><code>snow_depth -= melt_rate</code> (clamped at 0)</td></tr>
<tr><td>Raining</td><td><code>wetness += wet_rate × intensity / 1024</code></td></tr>
<tr><td>Not raining</td><td><code>wetness -= dry_rate</code> (clamped at 0)</td></tr>
<tr><td>Snow melting</td><td><code>wetness += melt_rate</code> (meltwater)</td></tr>
<tr><td>Temperature &lt; threshold</td><td>Puddles freeze → wet cells become icy</td></tr>
</tbody>
</table>
</div>
<p><strong>Sim effects from surface state (when <code>sim_effects: true</code>):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Surface State</th><th>Gameplay Effect</th></tr>
</thead>
<tbody>
<tr><td>Deep snow (&gt; 512)</td><td>Infantry −20% speed, wheeled −30%, tracked −10%</td></tr>
<tr><td>Ice (frozen wetness)</td><td>Water tiles become passable; all ground units slide (−15% turn rate)</td></tr>
<tr><td>Wet ground (&gt; 256)</td><td>Wheeled −15% speed; no effect on tracked/infantry</td></tr>
<tr><td>Muddy (wet + warm)</td><td>Wheeled −25% speed, tracked −10%; infantry unaffected</td></tr>
<tr><td>Dry / sunny</td><td>No penalties; baseline movement</td></tr>
</tbody>
</table>
</div>
<p>These modifiers stack with the weather-type modifiers from the base weather table. A blizzard over deep snow is brutal.</p>
<p><strong>Snapshot compatibility:</strong> <code>TerrainSurfaceGrid</code> derives <code>Serialize, Deserialize</code> — surface state is captured in save games and snapshots per D010 (snapshottable sim state).</p>
<h4 id="terrain-texture-effects-render-layer"><a class="header" href="#terrain-texture-effects-render-layer">Terrain Texture Effects (Render Layer)</a></h4>
<p><code>ra-render</code> reads the sim’s <code>TerrainSurfaceGrid</code> and blends terrain visuals accordingly. This is <strong>purely cosmetic</strong> — it has no effect on the sim and runs at whatever quality the device supports.</p>
<p>Three rendering strategies, selectable via <code>RenderSettings</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Strategy</th><th>Quality</th><th>Cost</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Palette tinting</strong></td><td>Low</td><td>Near-zero</td><td>Shift terrain palette toward white (snow) or darker (wet). Authentic to original RA palette tech. No extra assets needed.</td></tr>
<tr><td><strong>Overlay sprites</strong></td><td>Medium</td><td>One pass</td><td>Draw semi-transparent snow/puddle/ice overlays on top of base terrain tiles. Requires overlay sprite sheets (shipped with engine or mod-provided).</td></tr>
<tr><td><strong>Shader blending</strong></td><td>High</td><td>GPU blend</td><td>Fragment shader blends between base texture and weather-variant texture per tile. Smoothest transitions, gradual accumulation. Requires variant texture sets.</td></tr>
</tbody>
</table>
</div>
<p>Default: <strong>palette tinting</strong> (works everywhere, zero asset requirements). Mods that ship weather-variant sprites get overlay or shader blending automatically.</p>
<p><strong>Accumulation visuals</strong> (shader blending mode):</p>
<ul>
<li>Snow doesn’t appear uniformly — it starts on tile edges, elevated features, and rooftops, then fills inward as <code>snow_depth</code> increases</li>
<li>Rain creates puddle sprites in low-lying cells first, then spreads to flat ground</li>
<li>Drying happens as a gradual desaturation back to base palette</li>
<li>Blend factor = <code>surface_condition_value / 1024</code> — smooth interpolation</li>
</ul>
<p><strong>Performance considerations:</strong></p>
<ul>
<li>Palette tinting: no extra draw calls, no extra textures, negligible GPU cost</li>
<li>Overlay sprites: one additional sprite draw per affected cell — batched via Bevy’s sprite batching</li>
<li>Shader blending: texture array per terrain type (base + snow + wet variants), single draw call per terrain chunk with per-vertex blend weights</li>
<li>Particle density for weather effects already scales with <code>RenderSettings</code> (existing design)</li>
<li>Surface texture updates are amortized: only cells near weather transitions or visible cells update their blend factors each frame</li>
</ul>
<h4 id="daynight-and-seasonal-integration"><a class="header" href="#daynight-and-seasonal-integration">Day/Night and Seasonal Integration</a></h4>
<p>Dynamic weather composes naturally with other environmental systems:</p>
<ul>
<li><strong>Day/night cycle:</strong> Ambient lighting shifts interact with weather — overcast days are darker, rain at night is nearly black with lightning flashes, sunny midday is brightest</li>
<li><strong>Seasonal maps:</strong> A map can set <code>temperature.base</code> low (winter map) so any rain becomes snow, or high (desert) where <code>sandstorm</code> replaces <code>rain</code> in the state machine</li>
<li><strong>Map-specific overrides:</strong> Arctic maps default to snow schedule; desert maps disable snow transitions; tropical maps always rain</li>
</ul>
<h4 id="modding-weather"><a class="header" href="#modding-weather">Modding Weather</a></h4>
<p>Weather is fully moddable at every tier:</p>
<ul>
<li><strong>Tier 1 (YAML):</strong> Define custom weather schedules, tune surface rates, adjust sim effect values, choose blend strategy, create seasonal presets</li>
<li><strong>Tier 2 (Lua):</strong> Trigger weather transitions at story moments, query surface state for mission objectives (“defend until the blizzard clears”), create weather-dependent triggers</li>
<li><strong>Tier 3 (WASM):</strong> Implement custom weather types (acid rain, ion storms, radiation clouds) with new particles, new sim effects, and custom surface state logic</li>
</ul>
<pre><code class="language-yaml"># Example: Tiberian Sun ion storm (custom weather type via mod)
weather_types:
  ion_storm:
    particles: ion_storm_particles.shp
    palette_tint: [0.2, 0.8, 0.3]  # green tint
    sim_effects:
      aircraft_grounded: true
      radar_disabled: true
      lightning_damage: 50
      lightning_interval: 120  # ticks between strikes
    surface:
      contamination_rate: 1
      max_contamination: 512
    render:
      strategy: shader_blend
      variant_suffix: "_ion"
</code></pre>
<p><strong>Scene template structure:</strong></p>
<pre><code>scenes/
  ambush/
    scene.lua.tera       # Tera-templated Lua trigger logic
    schema.yaml          # Parameters + inline defaults: location, units, trigger_zone, etc.
    README.md            # Usage, preview, notes
</code></pre>
<p><strong>Composing scenes into a mission template:</strong></p>
<pre><code class="language-yaml"># mission_templates/commando_raid/template.yaml
mission:
  name: "Behind Enemy Lines — {{ difficulty | title }}"
  briefing: &gt;
    Infiltrate the Soviet base. Destroy the radar, 
    then extract before reinforcements arrive.

scenes:
  - template: scripted_scene
    values:
      actors: [tanya]
      dialogue: ["Let's do this quietly..."]
      camera_positions: [{{ insertion_point }}]

  - template: patrol
    values:
      waypoints: {{ outer_patrol_route }}
      unit_composition: [guard, guard, dog]
      alert_radius: 5

  - template: ambush
    values:
      location: {{ radar_approach }}
      attacker_units: [guard, guard, grenadier]
      trigger_zone: { center: {{ radar_position }}, radius: 4 }

  - template: timed_objective
    values:
      target: radar_building
      time_limit: {{ {"easy": 300, "normal": 180, "hard": 120}[difficulty] }}
      failure_trigger: soviet_reinforcements_arrive

  - template: extraction
    values:
      pickup_zone: {{ extraction_point }}
      transport_type: chinook
      signal_trigger: radar_destroyed
</code></pre>
<p><strong>How this works at runtime:</strong></p>
<ol>
<li>Mission template engine resolves scene references</li>
<li>Each scene’s <code>schema.yaml</code> validates its parameters</li>
<li>Each scene’s <code>scene.lua.tera</code> is rendered with its values</li>
<li>All rendered Lua scripts are merged into a single mission trigger file with namespaced functions (e.g., <code>scene_1_ambush_on_trigger()</code>)</li>
<li>Output is a standard mission — indistinguishable from hand-crafted</li>
</ol>
<p><strong>For the LLM, this is transformative.</strong> Instead of generating raw Lua trigger code (hallucination-prone, hard to validate), the LLM:</p>
<ul>
<li>Picks scene templates by name from a known catalog</li>
<li>Fills in parameters that the schema validates</li>
<li>Composes scenes in sequence — the wiring logic is already built into the templates</li>
</ul>
<p>A “convoy escort with two ambushes and a base-building finale” is 3 scene template references with ~15 parameters total, not 200 lines of handwritten Lua.</p>
<h3 id="templates-as-workshop-resources"><a class="header" href="#templates-as-workshop-resources">Templates as Workshop Resources</a></h3>
<p>Scene templates and mission templates are both first-class workshop resource types — shared, rated, versioned, and downloadable like any other content. See the full resource category taxonomy in the <a href="#workshop-resource-registry--dependency-system-d030">Workshop Resource Registry</a> section below.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Contents</th><th>Examples</th></tr>
</thead>
<tbody>
<tr><td>Mods</td><td>YAML rules + Lua scripts + WASM modules</td><td>Total conversions, balance patches, new factions</td></tr>
<tr><td>Maps</td><td><code>.oramap</code> or native map format</td><td>Skirmish maps, campaign maps, tournament pools</td></tr>
<tr><td>Missions</td><td>YAML map + Lua triggers + briefing</td><td>Hand-crafted or LLM-generated scenarios</td></tr>
<tr><td><strong>Scene Templates</strong></td><td><strong>Tera-templated Lua + schema</strong></td><td><strong>Reusable sub-mission building blocks</strong></td></tr>
<tr><td><strong>Mission Templates</strong></td><td><strong>Tera templates + scene refs + schema</strong></td><td><strong>Full parameterized mission blueprints</strong></td></tr>
<tr><td>Campaigns</td><td>Ordered mission sets + narrative</td><td>Multi-mission storylines</td></tr>
<tr><td>Music</td><td>Audio tracks (<code>.ogg</code>, <code>.mp3</code>, <code>.flac</code>)</td><td>Custom soundtracks, faction themes, menu music</td></tr>
<tr><td>Sound Effects</td><td>Audio clips</td><td>Weapon sounds, ambient loops, UI feedback</td></tr>
<tr><td>Voice Lines</td><td>Audio clips + trigger metadata</td><td>EVA packs, unit responses, faction voice sets</td></tr>
<tr><td>Sprites</td><td><code>.shp</code>, <code>.png</code>, sprite sheets</td><td>HD unit packs, building sprites, effects packs</td></tr>
<tr><td>Textures</td><td>Terrain tiles, UI skins</td><td>Theater tilesets, seasonal terrain variants</td></tr>
<tr><td>Palettes</td><td><code>.pal</code> files</td><td>Theater palettes, faction colors, seasonal</td></tr>
<tr><td>Cutscenes / Video</td><td><code>.vqa</code>, <code>.mp4</code>, <code>.webm</code></td><td>Custom briefings, cinematics, narrative videos</td></tr>
<tr><td>UI Themes</td><td>Chrome layouts, fonts, cursors</td><td>Alternative sidebars, HD cursor packs</td></tr>
<tr><td>Balance Presets</td><td>YAML rule overrides</td><td>Competitive tuning, historical accuracy presets</td></tr>
</tbody>
</table>
</div>
<h2 id="resource-packs-switchable-asset-layers"><a class="header" href="#resource-packs-switchable-asset-layers">Resource Packs (Switchable Asset Layers)</a></h2>
<p>Resource packs are <strong>switchable asset override layers</strong> — the player selects which version of a resource category to use (cutscenes, sprites, music, voice lines, etc.), and the engine swaps to those assets without touching gameplay. Same concept as Minecraft’s resource packs or the Remastered Collection’s SD/HD toggle, but generalized to any asset type.</p>
<p>This falls naturally out of the architecture. Every asset is referenced by <strong>logical ID</strong> in YAML (e.g., <code>video: videos/allied-01-briefing.vqa</code>). A resource pack overrides those references — mapping the same IDs to different files. No code, no mods, no gameplay changes. Pure presentation layer.</p>
<h3 id="tera-templated-resource-packs-optional-for-complex-packs"><a class="header" href="#tera-templated-resource-packs-optional-for-complex-packs">Tera-Templated Resource Packs (Optional, for Complex Packs)</a></h3>
<p>Most community resource packs are plain YAML (see “Most Packs Are Plain YAML” below). But <strong>all first-party IC packs use Tera</strong> — the built-in cutscene, sprite, and music packs are templated with configurable quality, language, and content selection. This dogfoods the system and provides working examples for pack authors who want to go beyond flat mappings.</p>
<p>For packs that need <strong>configurable parameters</strong> — quality tiers, language selection, platform-aware defaults — Tera templates use a <code>schema.yaml</code> that defines the available knobs. Defaults are inline in the template; users configure through the in-game settings UI.</p>
<p><strong>Pack structure:</strong></p>
<pre><code>resource-packs/hd-cutscenes/
  pack.yaml.tera      # Tera template — generates the override map
  schema.yaml          # Parameter definitions with inline defaults
  assets/              # The actual replacement files
    videos/
      allied-01-briefing-720p.mp4
      allied-01-briefing-1080p.mp4
      allied-01-briefing-4k.mp4
      ...
</code></pre>
<p><strong>Schema (configurable knobs):</strong></p>
<pre><code class="language-yaml"># schema.yaml
parameters:
  quality:
    type: enum
    options: [720p, 1080p, 4k]
    default: 1080p
    description: "Video resolution — higher needs more disk space"

  language:
    type: enum
    options: [en, de, fr, ru, es, ja]
    default: en
    description: "Subtitle/dub language"

  include_victory_sequences:
    type: boolean
    default: true
    description: "Also replace victory/defeat cinematics"

  style:
    type: enum
    options: [upscaled, redrawn, ai_generated]
    default: upscaled
    description: "Visual style of replacement cutscenes"
</code></pre>
<p><strong>Tera template (generates the override map from parameters):</strong></p>
<pre><code class="language-jinja">{# pack.yaml.tera #}
resource_pack:
  name: "HD Cutscenes ({{ quality }}, {{ language }})"
  description: "{{ style | title }} briefing videos in {{ quality }}"
  category: cutscenes
  version: "2.0.0"

  assets:
    {% for mission in ["allied-01", "allied-02", "allied-03", "soviet-01", "soviet-02", "soviet-03"] %}
    videos/{{ mission }}-briefing.vqa: assets/videos/{{ mission }}-briefing-{{ quality }}.mp4
    {% endfor %}

    {% if include_victory_sequences %}
    {% for seq in ["allied-victory", "allied-defeat", "soviet-victory", "soviet-defeat"] %}
    videos/{{ seq }}.vqa: assets/videos/{{ seq }}-{{ quality }}.mp4
    {% endfor %}
    {% endif %}

    {# Language-specific subtitle tracks #}
    {% if language != "en" %}
    {% for mission in ["allied-01", "allied-02", "allied-03", "soviet-01", "soviet-02", "soviet-03"] %}
    subtitles/{{ mission }}.srt: assets/subtitles/{{ language }}/{{ mission }}.srt
    {% endfor %}
    {% endif %}
</code></pre>
<p><strong>User configuration (in-game settings, not CLI overrides):</strong></p>
<p>Players configure pack parameters through the Settings → Resource Packs UI. When a pack has a <code>schema.yaml</code>, the UI renders the appropriate controls (dropdowns for enums, checkboxes for booleans). The engine re-renders the Tera template whenever settings change, producing an updated override map. This is load-time only — zero runtime cost.</p>
<p>For CLI users, <code>ic resource-pack install hd-cutscenes</code> installs the pack with its defaults. Parameters are then adjusted in settings.</p>
<h3 id="why-tera-not-just-flat-mappings"><a class="header" href="#why-tera-not-just-flat-mappings">Why Tera (Not Just Flat Mappings)</a></h3>
<p>Flat override maps (<code>asset_a → asset_b</code>) work for simple cases, but fall apart when packs need to:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Need</th><th>Flat Mapping</th><th>Tera Template</th></tr>
</thead>
<tbody>
<tr><td>Quality tiers (720p/1080p/4k)</td><td>3 separate packs with 90% duplicated YAML</td><td>One pack, <code>quality</code> parameter</td></tr>
<tr><td>Language variants</td><td>One pack per language × quality = combinatorial explosion</td><td><code>{% if language != "en" %}</code> conditional</td></tr>
<tr><td>Faction-specific overrides</td><td>Manual enumeration of every faction’s assets</td><td><code>{% for faction in factions %}</code> loop</td></tr>
<tr><td>Optional components (victory sequences, tutorial videos)</td><td>Separate packs or monolithic everything-pack</td><td>Boolean parameters with <code>{% if %}</code></td></tr>
<tr><td>Platform-aware (mobile gets 720p, desktop gets 1080p)</td><td>Separate mobile/desktop packs</td><td><code>quality</code> defaults per <code>ScreenClass</code></td></tr>
<tr><td>Mod-aware (pack adapts to which game module is active)</td><td>One pack per game module</td><td><code>{% if game_module == "ra2" %}</code> conditional</td></tr>
</tbody>
</table>
</div>
<p>This is the same reason Helm uses Go templates instead of static YAML — real-world configuration has conditionals, loops, and user-specific values. Our approach is inspired by Helm’s parameterized templating, but the configuration surface is the in-game settings UI, not a CLI + values file workflow.</p>
<h3 id="most-packs-are-plain-yaml-no-templating"><a class="header" href="#most-packs-are-plain-yaml-no-templating">Most Packs Are Plain YAML (No Templating)</a></h3>
<p>The <strong>default and recommended</strong> way to create a resource pack is plain YAML — just list the files you’re replacing. No template syntax, no schema, no values file. This is what <code>ic mod init resource-pack</code> generates:</p>
<pre><code class="language-yaml"># resource-packs/retro-sounds/pack.yaml — plain YAML, no Tera
resource_pack:
  name: "Retro 8-bit Sound Effects"
  category: sound_effects
  version: "1.0.0"
  assets:
    sounds/explosion_large.wav: assets/explosion_large_8bit.wav
    sounds/rifle_fire.wav: assets/rifle_fire_8bit.wav
    sounds/tank_move.wav: assets/tank_move_8bit.wav
</code></pre>
<p>This covers the majority of resource packs. Someone replacing cutscenes, swapping in HD sprites, or providing an alternative soundtrack just lists the overrides — done.</p>
<p><strong>Tera templates are opt-in for complex packs</strong> that need parameters (quality tiers, language selection, conditional content). Rename <code>pack.yaml</code> to <code>pack.yaml.tera</code>, add a <code>schema.yaml</code>, and the engine renders the template at install time. But this is a power-user feature — most content creators never need it.</p>
<p>The engine detects <code>.tera</code> extension → renders template; plain <code>.yaml</code> → loads directly.</p>
<h3 id="resource-pack-categories"><a class="header" href="#resource-pack-categories">Resource Pack Categories</a></h3>
<p>Players can mix and match one pack per category:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>What It Overrides</th><th>Example Packs</th></tr>
</thead>
<tbody>
<tr><td>Cutscenes</td><td>Briefing videos, victory/defeat sequences, in-mission cinematics</td><td>Original <code>.vqa</code>, AI-upscaled HD, community remakes, humorous parodies</td></tr>
<tr><td>Sprites</td><td>Unit art, building art, effects, projectiles</td><td>Classic <code>.shp</code>, HD sprite pack, hand-drawn style</td></tr>
<tr><td>Music</td><td>Soundtrack, menu music, faction themes</td><td>Original, Frank Klepacki remastered, community compositions</td></tr>
<tr><td>Voice Lines</td><td>EVA announcements, unit responses</td><td>Original, alternative EVA voices, localized voice packs</td></tr>
<tr><td>Sound Effects</td><td>Weapon sounds, explosions, ambient</td><td>Original, enhanced audio, retro 8-bit</td></tr>
<tr><td>Terrain</td><td>Theater tilesets, terrain textures</td><td>Classic, HD, seasonal (winter/desert variants)</td></tr>
</tbody>
</table>
</div>
<h3 id="settings-ui"><a class="header" href="#settings-ui">Settings UI</a></h3>
<pre><code>Settings → Resource Packs
┌───────────────────────────────────────────────┐
│ Cutscenes:     [HD Upscaled ▾]     [⚙ Configure]
│                 Quality: [1080p ▾]            │
│                 Language: [English ▾]         │
│                 Victory sequences: [✓]        │
│                                               │
│ Music:         [Remastered ▾]                 │
│ Voice Lines:   [Original ▾]                   │
│ Sprites:       [HD Pack ▾]          [⚙ Configure]
│ Sound Effects: [Original ▾]                   │
│ Terrain:       [HD Pack ▾]                    │
└───────────────────────────────────────────────┘
</code></pre>
<p>The ⚙ Configure button appears when a pack has a <code>schema.yaml</code> with user-configurable parameters. Simple packs (no schema) just show the dropdown.</p>
<h3 id="relationship-to-existing-decisions"><a class="header" href="#relationship-to-existing-decisions">Relationship to Existing Decisions</a></h3>
<p>Resource packs generalize a pattern that already appears in several places:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Decision</th><th>What It Switches</th><th>Resource Pack Equivalent</th></tr>
</thead>
<tbody>
<tr><td>D019</td><td>Balance rule sets (Classic/OpenRA/Remastered)</td><td>Balance presets already work this way</td></tr>
<tr><td>D029</td><td>Classic/HD sprite rendering (dual asset)</td><td>Sprite resource packs supersede this; D029’s <code>classic:</code>/<code>hd:</code> YAML keys become the first two sprite packs</td></tr>
<tr><td>D032</td><td>UI chrome, menus, lobby (themes)</td><td>UI themes are resource packs for the chrome category</td></tr>
<tr><td>Tera templating</td><td>Mission/scene templates</td><td>Resource packs use the same <code>template.tera</code> + <code>schema.yaml</code> pattern — one templating system for everything</td></tr>
</tbody>
</table>
</div>
<p>The underlying mechanism is the same: <strong>YAML-level asset indirection with Tera rendering</strong>. The <code>template.tera</code> + <code>schema.yaml</code> pattern appears in three places:</p>
<pre><code>Mission Templates  → template.yaml.tera + schema.yaml = playable mission
Scene Templates    → triggers.lua.tera  + schema.yaml = scripted encounter
Resource Packs     → pack.yaml.tera     + schema.yaml = asset override layer
</code></pre>
<p>One templating engine (Tera), one pattern, three use cases. Defaults live inline in the schema. User preferences come from settings UI (resource packs) or from the LLM/user filling in parameters (mission templates). No separate values file needed in the common case.</p>
<h3 id="workshop-distribution-d030"><a class="header" href="#workshop-distribution-d030">Workshop Distribution (D030)</a></h3>
<p>Resource packs are publishable to the workshop like any other resource:</p>
<ul>
<li><code>ic mod init resource-pack</code> → scaffolds a pack with asset manifest</li>
<li><code>ic mod publish</code> → uploads to workshop</li>
<li>Players subscribe in-game or via CLI</li>
<li>Packs from multiple authors can coexist — one per category, player’s choice</li>
<li>Dependencies work: a mission pack can require a specific cutscene pack (<code>depends: alice/hd-cutscenes@^1.0</code>)</li>
</ul>
<h3 id="cutscenes-specifically"><a class="header" href="#cutscenes-specifically">Cutscenes Specifically</a></h3>
<p>Since cutscenes are what prompted this — the system is particularly powerful here:</p>
<ol>
<li><strong>Original <code>.vqa</code> files</strong> — ship with the game (from original RA install). Low-res but authentic.</li>
<li><strong>AI-upscaled HD</strong> — community or first-party pack running the originals through video upscaling. Same content, better resolution.</li>
<li><strong>Community remakes</strong> — fans re-creating briefings with modern tools, voice acting, or different artistic styles.</li>
<li><strong>AI-generated replacements</strong> — using video generation AI to create entirely new briefing sequences. Same narrative beats (referenced from campaign YAML), different visuals.</li>
<li><strong>Humorous/parody versions</strong> — because the community will absolutely do this, and we should make it easy.</li>
<li><strong>Localized versions</strong> — same briefings with translated subtitles or dubbed audio.</li>
</ol>
<p>The campaign system (D021) references cutscenes by logical ID in the <code>video:</code> field. Changing which pack is active changes which video plays — no campaign YAML edits needed.</p>
<h2 id="campaign-system-branching-persistent-continuous"><a class="header" href="#campaign-system-branching-persistent-continuous">Campaign System (Branching, Persistent, Continuous)</a></h2>
<p><em>Inspired by Operation Flashpoint: Cold War Crisis / Resistance. See D021.</em></p>
<p>OpenRA’s campaigns are disconnected: each mission is standalone, you exit to menu between them, there’s no flow. Our campaigns are <strong>continuous, branching, and stateful</strong> — a directed graph of missions with persistent state, multiple outcomes per mission, and no mandatory game-over screen.</p>
<h3 id="core-principles"><a class="header" href="#core-principles">Core Principles</a></h3>
<ol>
<li><strong>Campaign is a graph, not a list.</strong> Missions connect via named outcomes, forming branches, convergence points, and optional paths — not a linear sequence.</li>
<li><strong>Missions have multiple outcomes, not just win/lose.</strong> “Won with bridge intact” and “Won but bridge destroyed” are different outcomes that lead to different next missions.</li>
<li><strong>Failure doesn’t end the campaign.</strong> A “defeat” outcome is just another edge in the graph. The designer chooses: branch to a fallback mission, retry with fewer resources, or skip ahead with consequences. “No game over” campaigns are possible.</li>
<li><strong>State persists across missions.</strong> Surviving units, veterancy, captured equipment, story flags, resources — all carry forward based on designer-configured carryover rules.</li>
<li><strong>Continuous flow.</strong> Briefing → mission → debrief → next mission. No exit to menu between levels (unless the player explicitly quits).</li>
</ol>
<h3 id="campaign-definition-yaml"><a class="header" href="#campaign-definition-yaml">Campaign Definition (YAML)</a></h3>
<pre><code class="language-yaml"># campaigns/allied/campaign.yaml
campaign:
  id: allied_campaign
  title: "Allied Campaign"
  description: "Drive back the Soviet invasion across Europe"
  start_mission: allied_01

  # What persists between missions (campaign-wide defaults)
  persistent_state:
    unit_roster: true          # surviving units carry forward
    veterancy: true            # unit experience persists
    resources: false           # credits reset per mission
    equipment: true            # captured vehicles/crates persist
    custom_flags: {}           # arbitrary Lua-writable key-value state

  missions:
    allied_01:
      map: missions/allied-01
      briefing: briefings/allied-01.yaml
      video: videos/allied-01-briefing.vqa
      carryover:
        from_previous: none    # first mission — nothing carries
      outcomes:
        victory_bridge_intact:
          description: "Bridge secured intact"
          next: allied_02a
          debrief: briefings/allied-01-debrief-bridge.yaml
          state_effects:
            set_flag: { bridge_status: intact }
        victory_bridge_destroyed:
          description: "Won but bridge was destroyed"
          next: allied_02b
          state_effects:
            set_flag: { bridge_status: destroyed }
        defeat:
          description: "Base overrun"
          next: allied_01_fallback
          state_effects:
            set_flag: { retreat_count: +1 }

    allied_02a:
      map: missions/allied-02a    # different map — bridge crossing
      briefing: briefings/allied-02a.yaml
      carryover:
        units: surviving          # units from mission 01 appear
        veterancy: keep           # their experience carries
        equipment: keep           # captured Soviet tanks too
      conditions:                 # optional entry conditions
        require_flag: { bridge_status: intact }
      outcomes:
        victory:
          next: allied_03
        defeat:
          next: allied_02_fallback

    allied_02b:
      map: missions/allied-02b    # different map — river crossing without bridge
      briefing: briefings/allied-02b.yaml
      carryover:
        units: surviving
        veterancy: keep
      outcomes:
        victory:
          next: allied_03         # branches converge at mission 03
        defeat:
          next: allied_02_fallback

    allied_01_fallback:
      map: missions/allied-01-retreat
      briefing: briefings/allied-01-retreat.yaml
      carryover:
        units: surviving          # fewer units since you lost
        veterancy: keep
      outcomes:
        victory:
          next: allied_02b        # after retreating, you take the harder path
          state_effects:
            set_flag: { morale: low }

    allied_03:
      map: missions/allied-03
      # ...branches converge here regardless of path taken
</code></pre>
<h3 id="campaign-graph-visualization"><a class="header" href="#campaign-graph-visualization">Campaign Graph Visualization</a></h3>
<pre><code>                    ┌─────────────┐
                    │  allied_01  │
                    └──┬───┬───┬──┘
          bridge ok ╱   │       ╲ defeat
                  ╱     │         ╲
    ┌────────────┐  bridge   ┌─────────────────┐
    │ allied_02a │  destroyed│ allied_01_       │
    └─────┬──────┘      │   │ fallback         │
          │       ┌─────┴───┐└────────┬────────┘
          │       │allied_02b│        │
          │       └────┬─────┘        │
          │            │         joins 02b
          └─────┬──────┘
                │ converge
          ┌─────┴──────┐
          │  allied_03  │
          └─────────────┘
</code></pre>
<p>This is a <strong>directed acyclic graph</strong> (with optional cycles for retry loops). The engine validates campaign graphs at load time: no orphan nodes, all outcome targets exist, start mission is defined.</p>
<h3 id="unit-roster--persistence"><a class="header" href="#unit-roster--persistence">Unit Roster &amp; Persistence</a></h3>
<p>Inspired by Operation Flashpoint: Resistance — surviving units are precious resources that carry forward, creating emotional investment and strategic consequences.</p>
<p><strong>Unit Roster:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Persistent unit state that carries between campaign missions.
#[derive(Serialize, Deserialize, Clone)]
pub struct RosterUnit {
    pub unit_type: UnitTypeId,        // e.g., "medium_tank", "tanya"
    pub name: Option&lt;String&gt;,         // optional custom name
    pub veterancy: VeterancyLevel,    // rookie → veteran → elite → heroic
    pub kills: u32,                   // lifetime kill count
    pub missions_survived: u32,       // how many missions this unit has lived through
    pub equipment: Vec&lt;EquipmentId&gt;,  // OFP:R-style captured/found equipment
    pub custom_state: HashMap&lt;String, Value&gt;, // mod-extensible per-unit state
}
<span class="boring">}</span></code></pre>
<p><strong>Carryover modes</strong> (per campaign transition):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>none</code></td><td>Clean slate — the next mission provides its own units</td></tr>
<tr><td><code>surviving</code></td><td>All player units alive at mission end join the roster</td></tr>
<tr><td><code>extracted</code></td><td>Only units inside a designated extraction zone carry over (OFP-style “get to the evac”)</td></tr>
<tr><td><code>selected</code></td><td>Lua script explicitly picks which units carry over</td></tr>
<tr><td><code>custom</code></td><td>Full Lua control — script reads unit list, decides what persists</td></tr>
</tbody>
</table>
</div>
<p><strong>Veterancy across missions:</strong></p>
<ul>
<li>Units gain experience from kills and surviving missions</li>
<li>A veteran tank from mission 1 is still veteran in mission 5</li>
<li>Losing a veteran unit hurts — they’re irreplaceable until you earn new ones</li>
<li>Veterancy grants stat bonuses (configurable in YAML rules, per balance preset)</li>
</ul>
<p><strong>Equipment persistence (OFP: Resistance model):</strong></p>
<ul>
<li>Captured enemy vehicles at mission end go into the equipment pool</li>
<li>Found supply crates add to available equipment</li>
<li>Next mission’s starting loadout can draw from the equipment pool</li>
<li>Modders can define custom persistent items</li>
</ul>
<h3 id="campaign-state"><a class="header" href="#campaign-state">Campaign State</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Full campaign progress — serializable for save games.
#[derive(Serialize, Deserialize, Clone)]
pub struct CampaignState {
    pub campaign_id: CampaignId,
    pub current_mission: MissionId,
    pub completed_missions: Vec&lt;CompletedMission&gt;,
    pub unit_roster: Vec&lt;RosterUnit&gt;,
    pub equipment_pool: Vec&lt;EquipmentId&gt;,
    pub resources: i64,               // persistent credits (if enabled)
    pub flags: HashMap&lt;String, Value&gt;, // story flags set by Lua
    pub stats: CampaignStats,         // cumulative performance
    pub path_taken: Vec&lt;MissionId&gt;,   // breadcrumb trail for replay/debrief
}

pub struct CompletedMission {
    pub mission_id: MissionId,
    pub outcome: String,              // the named outcome key
    pub time_taken: Duration,
    pub units_lost: u32,
    pub units_gained: u32,
    pub score: i64,
}
<span class="boring">}</span></code></pre>
<p>Campaign state is fully serializable (D010 — snapshottable sim state). Save games capture the entire campaign progress. Replays can replay an entire campaign run, not just individual missions.</p>
<h3 id="lua-campaign-api"><a class="header" href="#lua-campaign-api">Lua Campaign API</a></h3>
<p>Mission scripts interact with campaign state through a sandboxed API:</p>
<pre><code class="language-lua">-- === Reading campaign state ===

-- Get the unit roster (surviving units from previous missions)
local roster = Campaign.get_roster()
for _, unit in ipairs(roster) do
    -- Spawn each surviving unit at a designated entry point
    local spawned = SpawnUnit(unit.type, entry_point)
    spawned:set_veterancy(unit.veterancy)
    spawned:set_name(unit.name)
end

-- Read story flags set by previous missions
if Campaign.get_flag("bridge_status") == "intact" then
    -- Bridge exists on this map — open the crossing
    bridge_actor:set_state("intact")
else
    -- Bridge was destroyed — it's rubble
    bridge_actor:set_state("destroyed")
end

-- Check cumulative stats
if Campaign.get_stat("total_units_lost") &gt; 50 then
    -- Player has been losing lots of units — offer reinforcements
    trigger_reinforcements()
end

-- === Writing campaign state ===

-- Signal mission completion with a named outcome
function OnObjectiveComplete()
    if bridge:is_alive() then
        Campaign.complete("victory_bridge_intact")
    else
        Campaign.complete("victory_bridge_destroyed")
    end
end

-- Set custom flags for future missions to read
Campaign.set_flag("captured_radar", true)
Campaign.set_flag("enemy_morale", "broken")

-- Update roster: mark which units survived
-- (automatic if carryover mode is "surviving" — manual if "selected")
function OnMissionEnd()
    local survivors = GetPlayerUnits():alive()
    for _, unit in ipairs(survivors) do
        Campaign.roster_add(unit)
    end
end

-- Add captured equipment to persistent pool
function OnEnemyVehicleCaptured(vehicle)
    Campaign.equipment_add(vehicle.type)
end

-- Failure doesn't mean game over — it's just another outcome
function OnPlayerBaseDestroyed()
    Campaign.complete("defeat")  -- campaign graph decides what happens next
end
</code></pre>
<h3 id="adaptive-difficulty-via-campaign-state"><a class="header" href="#adaptive-difficulty-via-campaign-state">Adaptive Difficulty via Campaign State</a></h3>
<p>Campaign state enables dynamic difficulty without an explicit slider:</p>
<pre><code class="language-yaml"># In a mission's carryover config:
adaptive:
  # If player lost the previous mission, give them extra resources
  on_previous_defeat:
    bonus_resources: 2000
    bonus_units: [medium_tank, medium_tank, rifle_infantry, rifle_infantry]
  # If player blitzed the previous mission, make this one harder
  on_previous_fast_victory:    # completed in &lt; 50% of par time
    extra_enemy_waves: 1
    enemy_veterancy_boost: 1
  # Scale to cumulative performance
  scaling:
    low_roster:                # &lt; 5 surviving units
      reinforcement_schedule: accelerated
    high_roster:               # &gt; 20 surviving units
      enemy_count_multiplier: 1.3
</code></pre>
<p>This is not AI-adaptive difficulty (that’s D016/<code>ra-llm</code>). This is <strong>designer-authored conditional logic</strong> expressed in YAML — the campaign reacts to the player’s cumulative performance without any LLM involvement.</p>
<h3 id="llm-campaign-generation"><a class="header" href="#llm-campaign-generation">LLM Campaign Generation</a></h3>
<p>The LLM (<code>ra-llm</code>) can generate entire campaign graphs, not just individual missions:</p>
<pre><code>User: "Create a 5-mission Soviet campaign where you invade Alaska.
       The player should be able to lose a mission and keep going
       with consequences. Units should carry over between missions."

LLM generates:
  → campaign.yaml (graph with 5+ nodes, branching on outcomes)
  → 5-7 mission files (main path + fallback branches)
  → Lua scripts with Campaign API calls
  → briefing text for each mission
  → carryover rules per transition
</code></pre>
<p>The template/scene system makes this tractable — the LLM composes from known building blocks rather than generating raw code. Campaign graphs are validated at load time (no orphan nodes, all outcomes have targets).</p>
<h3 id="configurable-workshop-server"><a class="header" href="#configurable-workshop-server">Configurable Workshop Server</a></h3>
<p>The Workshop is a <strong>universal artifact repository for game resources</strong> — an Artifactory-style federated registry (D030). The client aggregates listings from multiple sources simultaneously via a virtual repository view, with priority-based deduplication.</p>
<p>Just as JFrog Artifactory stores Maven, npm, Docker, and PyPI artifacts under one roof with unified metadata and federation, our Workshop stores music, sprites, maps, mods, and every other game asset type under one registry with semver, license tracking, integrity verification, and multi-source resolution.</p>
<h4 id="repository-types-artifactory-model"><a class="header" href="#repository-types-artifactory-model">Repository Types (Artifactory Model)</a></h4>
<p>The Workshop uses three repository types, directly inspired by Artifactory:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Repository Type</th><th>Artifactory Analog</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Local</strong></td><td>Local repository</td><td>A directory on disk following Workshop structure. Stores artifacts you create. Used for development, LAN parties, offline play, pre-publish testing.</td></tr>
<tr><td><strong>Remote</strong></td><td>Remote repository</td><td>A Workshop server (official or community-hosted). Artifacts are downloaded and cached locally on first access. Cache is used for subsequent requests — works offline after first pull.</td></tr>
<tr><td><strong>Virtual</strong></td><td>Virtual repository</td><td>The aggregated view across all configured sources. The <code>ic</code> CLI and in-game browser query the virtual repository — it merges listings from all local + remote sources, deduplicates by resource ID, and resolves version conflicts using priority ordering.</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-yaml"># settings.yaml
workshop:
  sources:
    - url: "https://workshop.ironcurtain.gg"     # remote: official (always included, default)
      priority: 1                                 # highest priority in virtual view
    - url: "https://mods.myclan.com/workshop"     # remote: community-hosted
      priority: 2
    - path: "C:/my-local-workshop"                # local: directory on disk
      priority: 3
  deduplicate: true               # same resource ID from multiple sources → highest priority wins
  cache_dir: "~/.ic/cache"        # local cache for remote artifacts
</code></pre>
<p><strong>Official server (remote):</strong> We host one. Default for all players. Curated categories, search, ratings, download counts.</p>
<p><strong>Community servers (remote):</strong> Anyone can host their own (open-source server binary, same Rust stack as relay/tracking servers). Clans, modding communities, tournament organizers. Useful for private content, regional servers, or alternative curation policies.</p>
<p><strong>Local directory (local):</strong> A folder on disk that follows the Workshop directory structure. Works fully offline. Ideal for mod developers testing before publishing, or LAN-party content distribution.</p>
<p><strong>Virtual view:</strong> The <code>ic</code> CLI and in-game browser always query the virtual repository — they never talk to raw servers directly. The virtual view merges all configured sources, handles deduplication, and respects priority ordering. This is transparent to the user.</p>
<h4 id="artifact-integrity"><a class="header" href="#artifact-integrity">Artifact Integrity</a></h4>
<p>Every published artifact includes cryptographic checksums for integrity verification:</p>
<ul>
<li><strong>SHA-256 checksum</strong> stored in the package manifest and on the Workshop server</li>
<li><code>ic mod install</code> verifies checksums after download — mismatch → abort + warning</li>
<li><code>ic.lock</code> records both version AND SHA-256 checksum for each dependency — guarantees byte-identical installs across machines</li>
<li>Protects against: corrupted downloads, CDN tampering, mirror drift</li>
<li>Workshop server computes checksums on upload; clients verify on download</li>
</ul>
<h4 id="promotion--maturity-channels"><a class="header" href="#promotion--maturity-channels">Promotion &amp; Maturity Channels</a></h4>
<p>Artifacts can be published to maturity channels, allowing staged releases:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Channel</th><th>Purpose</th><th>Visibility</th></tr>
</thead>
<tbody>
<tr><td><code>dev</code></td><td>Work-in-progress, local testing</td><td>Author only (local repos only)</td></tr>
<tr><td><code>beta</code></td><td>Pre-release, community testing</td><td>Opt-in (users enable beta flag)</td></tr>
<tr><td><code>release</code></td><td>Stable, production-ready</td><td>Default (everyone sees these)</td></tr>
</tbody>
</table>
</div>
<pre><code>ic mod publish --channel beta     # visible only to users who opt in to beta
ic mod publish                    # release channel (default)
ic mod promote 1.3.0-beta.1 release  # promote without re-upload
ic mod install --include-beta     # pull beta resources
</code></pre>
<h4 id="replication--mirroring"><a class="header" href="#replication--mirroring">Replication &amp; Mirroring</a></h4>
<p>Community Workshop servers can replicate from the official server (pull replication, Artifactory-style):</p>
<ul>
<li><strong>Pull replication:</strong> Community server periodically syncs popular artifacts from official. Reduces latency for regional players, provides redundancy.</li>
<li><strong>Selective sync:</strong> Community servers choose which categories/namespaces to replicate (e.g., replicate all Maps but not Mods)</li>
<li><strong>Offline bundles:</strong> <code>ic workshop export-bundle</code> creates a portable archive of selected resources for LAN parties or airgapped environments. <code>ic workshop import-bundle</code> loads them into a local repository.</li>
</ul>
<h3 id="workshop-resource-registry--dependency-system-d030"><a class="header" href="#workshop-resource-registry--dependency-system-d030">Workshop Resource Registry &amp; Dependency System (D030)</a></h3>
<p>The Workshop operates as a <strong>universal artifact repository for game resources</strong>. Any game asset — music, sprites, textures, cutscenes, maps, sound effects, voice lines, templates, balance presets — is individually publishable as a versioned, integrity-verified, licensed artifact. Others (including LLM agents) can discover, depend on, and pull resources automatically.</p>
<h4 id="resource-identity--versioning"><a class="header" href="#resource-identity--versioning">Resource Identity &amp; Versioning</a></h4>
<p>Every Workshop resource gets a globally unique identifier:</p>
<pre><code>Format:  namespace/name@version
Example: alice/soviet-march-music@1.2.0
         community-hd-project/allied-infantry-sprites@2.1.0
         bob/desert-tileset@1.0.3
</code></pre>
<ul>
<li><strong>Namespace</strong> = author username or organization</li>
<li><strong>Name</strong> = resource name, lowercase with hyphens</li>
<li><strong>Version</strong> = semantic versioning (semver)</li>
</ul>
<h4 id="dependency-declaration-in-modyaml"><a class="header" href="#dependency-declaration-in-modyaml">Dependency Declaration in <code>mod.yaml</code></a></h4>
<p>Mods and resources declare dependencies on other Workshop resources:</p>
<pre><code class="language-yaml"># mod.yaml
dependencies:
  - id: "community-project/hd-infantry-sprites"
    version: "^2.0"                    # semver range (cargo-style)
    source: workshop                   # workshop | local | url
  - id: "alice/soviet-march-music"
    version: "&gt;=1.0, &lt;3.0"
    source: workshop
    optional: true                     # soft dependency — mod works without it
  - id: "bob/desert-terrain-textures"
    version: "~1.4"                    # compatible with 1.4.x
    source: workshop
</code></pre>
<p>Dependencies are <strong>transitive</strong> — if resource A depends on B, and B depends on C, installing A pulls all three.</p>
<h4 id="dependency-resolution"><a class="header" href="#dependency-resolution">Dependency Resolution</a></h4>
<p>Cargo-inspired version solving with lockfile:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concept</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td>Semver ranges</td><td><code>^1.2</code> (&gt;=1.2.0, &lt;2.0.0), <code>~1.2</code> (&gt;=1.2.0, &lt;1.3.0), <code>&gt;=1.0, &lt;3.0</code>, exact <code>=1.2.3</code></td></tr>
<tr><td>Lockfile (<code>ic.lock</code>)</td><td>Records exact resolved versions + SHA-256 checksums for reproducible installs</td></tr>
<tr><td>Transitive resolution</td><td>Pulled automatically; diamond dependencies resolved to compatible version</td></tr>
<tr><td>Conflict detection</td><td>Two deps require incompatible versions → error with suggestions</td></tr>
<tr><td>Deduplication</td><td>Same resource from multiple dependents stored once in local cache</td></tr>
<tr><td>Optional dependencies</td><td><code>optional: true</code> — mod works without it; UI offers to install if available</td></tr>
<tr><td>Offline resolution</td><td>Once cached, all dependencies resolve from local cache — no network required</td></tr>
</tbody>
</table>
</div>
<h4 id="cli-commands-for-dependency-management"><a class="header" href="#cli-commands-for-dependency-management">CLI Commands for Dependency Management</a></h4>
<p>These extend the <code>ic</code> CLI (D020):</p>
<pre><code>ic mod resolve         # compute dependency graph, report conflicts
ic mod install         # download all dependencies to local cache (verifies SHA-256)
ic mod update          # update deps to latest compatible versions (respects semver)
ic mod tree            # display dependency tree (like `cargo tree`)
ic mod lock            # regenerate ic.lock from current mod.yaml
ic mod audit           # check dependency licenses for compatibility
ic mod promote         # promote artifact to a higher channel (beta → release)
ic workshop export-bundle  # export selected resources as portable offline archive
ic workshop import-bundle  # import offline archive into local repository
</code></pre>
<p>Example workflow:</p>
<pre><code>$ ic mod install
  Resolving dependencies...
  Downloading community-project/hd-infantry-sprites@2.1.0 (12.4 MB)
  Downloading alice/soviet-march-music@1.2.0 (4.8 MB)
  Downloading bob/desert-terrain-textures@1.4.1 (8.2 MB)
  3 resources installed, 25.4 MB total
  Lock file written: ic.lock

$ ic mod tree
  my-total-conversion@1.0.0
  ├── community-project/hd-infantry-sprites@2.1.0
  │   └── community-project/base-palettes@1.0.0
  ├── alice/soviet-march-music@1.2.0
  └── bob/desert-terrain-textures@1.4.1

$ ic mod audit
  ✓ All 4 dependencies have compatible licenses
  ✓ Your mod (CC-BY-SA-4.0) is compatible with:
    - hd-infantry-sprites (CC-BY-4.0) ✓
    - soviet-march-music (CC0-1.0) ✓
    - desert-terrain-textures (CC-BY-SA-4.0) ✓
    - base-palettes (CC0-1.0) ✓
</code></pre>
<h4 id="license-system"><a class="header" href="#license-system">License System</a></h4>
<p><strong>Every published Workshop resource MUST have a <code>license</code> field.</strong> Publishing without one is rejected by the Workshop server and by <code>ic mod publish</code>.</p>
<pre><code class="language-yaml"># In mod.yaml
mod:
  license: "CC-BY-SA-4.0"             # SPDX identifier (required for publishing)
</code></pre>
<ul>
<li>Uses <a href="https://spdx.org/licenses/">SPDX identifiers</a> for machine-readable classification</li>
<li>Workshop UI displays license prominently on every resource listing</li>
<li><code>ic mod audit</code> checks the full dependency tree for license compatibility</li>
<li>Common licenses for game assets:</li>
</ul>
<div class="table-wrapper">
<table>
<thead>
<tr><th>License</th><th>Allows commercial use</th><th>Requires attribution</th><th>Share-alike</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><code>CC0-1.0</code></td><td>✅</td><td>❌</td><td>❌</td><td>Public domain equivalent</td></tr>
<tr><td><code>CC-BY-4.0</code></td><td>✅</td><td>✅</td><td>❌</td><td>Most permissive with credit</td></tr>
<tr><td><code>CC-BY-SA-4.0</code></td><td>✅</td><td>✅</td><td>✅</td><td>Copyleft for creative works</td></tr>
<tr><td><code>CC-BY-NC-4.0</code></td><td>❌</td><td>✅</td><td>❌</td><td>Non-commercial only</td></tr>
<tr><td><code>MIT</code></td><td>✅</td><td>✅</td><td>❌</td><td>For code assets</td></tr>
<tr><td><code>GPL-3.0-only</code></td><td>✅</td><td>✅</td><td>✅</td><td>For code (EA source compat)</td></tr>
<tr><td><code>LicenseRef-Custom</code></td><td>varies</td><td>varies</td><td>varies</td><td>Link to full text required</td></tr>
</tbody>
</table>
</div>
<h4 id="publishing-workflow"><a class="header" href="#publishing-workflow">Publishing Workflow</a></h4>
<p>Publishing uses the existing <code>ic mod init</code> + <code>ic mod publish</code> flow — resources are packages with the appropriate <code>ResourceCategory</code>:</p>
<pre><code># Publish a single music track
ic mod init asset-pack
# Edit mod.yaml: set category to "Music", add license, add llm_meta
# Add audio files
ic mod check                   # validates license present, llm_meta recommended
ic mod publish                 # uploads to Workshop with dependency metadata
</code></pre>
<pre><code class="language-yaml"># Example: publishing a music pack
mod:
  id: alice/soviet-march-music
  title: "Soviet March — Original Composition"
  version: "1.2.0"
  authors: ["alice"]
  description: "An original military march composition for Soviet faction missions"
  license: "CC-BY-4.0"
  category: Music

assets:
  media: ["audio/soviet-march.ogg"]

llm:
  summary: "Military march music, Soviet theme, 2:30 duration, orchestral"
  purpose: "Background music for Soviet mission briefings or victory screens"
  gameplay_tags: [soviet, military, march, orchestral, briefing]
  composition_hints: "Pairs well with Soviet faction voice lines for immersive briefings"
</code></pre>
<h3 id="llm-driven-resource-discovery-d030"><a class="header" href="#llm-driven-resource-discovery-d030">LLM-Driven Resource Discovery (D030)</a></h3>
<p>The <code>ra-llm</code> crate can search the Workshop programmatically and incorporate discovered resources into generated content:</p>
<p><strong>Discovery pipeline:</strong></p>
<pre><code>  ┌─────────────────────────────────────────────────────────────────┐
  │ LLM generates mission concept                                  │
  │ ("Soviet ambush in snowy forest with dramatic briefing")        │
  └──────────────┬──────────────────────────────────────────────────┘
                 │
                 ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │ Identify needed assets                                          │
  │ → winter terrain textures                                       │
  │ → Soviet voice lines                                            │
  │ → ambush/tension music                                          │
  │ → briefing video (optional)                                     │
  └──────────────┬──────────────────────────────────────────────────┘
                 │
                 ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │ Search Workshop via WorkshopClient                              │
  │ → query="winter terrain", tags=["snow", "forest"]              │
  │ → query="Soviet voice lines", tags=["soviet", "military"]     │
  │ → query="tension music", tags=["ambush", "suspense"]          │
  └──────────────┬──────────────────────────────────────────────────┘
                 │
                 ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │ Evaluate candidates via llm_meta                                │
  │ → Read summary, purpose, composition_hints                      │
  │ → Filter by license compatibility                               │
  │ → Rank by gameplay_tags match score                             │
  └──────────────┬──────────────────────────────────────────────────┘
                 │
                 ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │ Add discovered resources as dependencies in generated mod.yaml │
  │ → Generated mission references assets by resource ID            │
  │ → Dependencies resolved at install time via `ic mod install`   │
  └─────────────────────────────────────────────────────────────────┘
</code></pre>
<p>The LLM sees workshop resources through their <code>llm_meta</code> fields. A music track tagged <code>summary: "Military march, Soviet theme, orchestral, 2:30"</code> and <code>composition_hints: "Pairs well with Soviet faction voice lines"</code> lets the LLM intelligently select and compose assets for a coherent mission experience.</p>
<p><strong>License-aware generation:</strong> The LLM filters by license compatibility — if generating content for a CC-BY mod, it only pulls CC-BY-compatible resources (<code>CC0-1.0</code>, <code>CC-BY-4.0</code>), excluding <code>CC-BY-NC-4.0</code> or <code>CC-BY-SA-4.0</code> unless the mod’s own license is compatible.</p>
<h3 id="workshop-api"><a class="header" href="#workshop-api">Workshop API</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait WorkshopClient: Send + Sync {
    fn browse(&amp;self, filter: &amp;ResourceFilter) -&gt; Result&lt;Vec&lt;ResourceListing&gt;&gt;;
    fn download(&amp;self, id: &amp;ResourceId, version: &amp;VersionReq) -&gt; Result&lt;ResourcePackage&gt;;
    fn publish(&amp;self, package: &amp;ResourcePackage) -&gt; Result&lt;ResourceId&gt;;
    fn rate(&amp;self, id: &amp;ResourceId, rating: Rating) -&gt; Result&lt;()&gt;;
    fn search(&amp;self, query: &amp;str, category: ResourceCategory) -&gt; Result&lt;Vec&lt;ResourceListing&gt;&gt;;
    fn resolve(&amp;self, deps: &amp;[Dependency]) -&gt; Result&lt;DependencyGraph&gt;;   // D030: dep resolution
    fn audit_licenses(&amp;self, graph: &amp;DependencyGraph) -&gt; Result&lt;LicenseReport&gt;; // D030: license check
    fn promote(&amp;self, id: &amp;ResourceId, to_channel: Channel) -&gt; Result&lt;()&gt;; // D030: channel promotion
    fn replicate(&amp;self, filter: &amp;ResourceFilter, target: &amp;str) -&gt; Result&lt;ReplicationReport&gt;; // D030: pull replication
}

/// Globally unique resource identifier: "namespace/name@version"
pub struct ResourceId {
    pub namespace: String,
    pub name: String,
    pub version: Version,             // semver
}

pub struct Dependency {
    pub id: String,                   // "namespace/name"
    pub version: VersionReq,          // semver range
    pub source: DependencySource,     // Workshop, Local, Url
    pub optional: bool,
}

pub struct ResourcePackage {
    pub id: ResourceId,               // globally unique identifier
    pub meta: ResourceMeta,           // title, author, description, tags
    pub license: String,              // SPDX identifier (REQUIRED)
    pub llm_meta: Option&lt;LlmResourceMeta&gt;, // LLM-readable description
    pub category: ResourceCategory,   // Music, Sprites, Map, Mod, etc.
    pub files: Vec&lt;PackageFile&gt;,      // the actual content
    pub checksum: Sha256Hash,         // artifact integrity (computed on publish)
    pub channel: Channel,             // dev | beta | release
    pub dependencies: Vec&lt;Dependency&gt;,// other workshop items this requires
    pub compatibility: VersionInfo,   // engine version + game module this targets
}

/// LLM-readable metadata for workshop resources.
/// Enables intelligent browsing, selection, and composition by ra-llm.
pub struct LlmResourceMeta {
    pub summary: String,              // one-line: "A 4-player desert skirmish map with limited ore"
    pub purpose: String,              // when/why to use this: "Best for competitive 2v2 with scarce resources"
    pub gameplay_tags: Vec&lt;String&gt;,   // semantic: ["desert", "2v2", "competitive", "scarce_resources"]
    pub difficulty: Option&lt;String&gt;,   // for missions/campaigns: "hard", "beginner-friendly"
    pub composition_hints: Option&lt;String&gt;, // how this combines with other resources
}

pub struct DependencyGraph {
    pub resolved: Vec&lt;ResolvedDependency&gt;, // all deps with exact versions
    pub conflicts: Vec&lt;DependencyConflict&gt;, // incompatible version requirements
}

pub struct LicenseReport {
    pub compatible: bool,
    pub issues: Vec&lt;LicenseIssue&gt;,    // e.g., "CC-BY-NC dep in CC-BY mod"
}
<span class="boring">}</span></code></pre>
<h2 id="mod-sdk--developer-experience"><a class="header" href="#mod-sdk--developer-experience">Mod SDK &amp; Developer Experience</a></h2>
<p><em>Inspired by studying the <a href="https://github.com/OpenRA/OpenRAModSDK">OpenRA Mod SDK</a> — see D020.</em></p>
<h3 id="lessons-from-the-openra-mod-sdk"><a class="header" href="#lessons-from-the-openra-mod-sdk">Lessons from the OpenRA Mod SDK</a></h3>
<p>The OpenRA Mod SDK is a template repository that modders fork. It includes:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>OpenRA SDK Feature</th><th>What’s Good</th><th>Our Improvement</th></tr>
</thead>
<tbody>
<tr><td>Fork-the-repo template</td><td>Zero-config starting point</td><td><code>cargo-generate</code> template — same UX, better tooling</td></tr>
<tr><td><code>mod.config</code> (engine version pin)</td><td>Reproducible builds</td><td><code>mod.yaml</code> manifest with typed schema + semver</td></tr>
<tr><td><code>fetch-engine.sh</code> (auto-download engine)</td><td>Modders never touch engine source</td><td>Engine ships as a binary crate, not compiled from source</td></tr>
<tr><td><code>Makefile</code> / <code>make.cmd</code></td><td>Cross-platform build</td><td><code>ic</code> CLI tool — Rust binary, works everywhere</td></tr>
<tr><td><code>packaging/</code> (Win/Mac/Linux installers)</td><td>Full distribution pipeline</td><td>Workshop publish + <code>cargo-dist</code> for standalone</td></tr>
<tr><td><code>utility.sh --check-yaml</code></td><td>Catches YAML errors</td><td><code>ic mod check</code> — validates YAML, Lua syntax, WASM integrity</td></tr>
<tr><td><code>launch-dedicated.sh</code></td><td>Dedicated server for mods</td><td><code>ic mod server</code> — first-class CLI command</td></tr>
<tr><td><code>mod.yaml</code> manifest</td><td>Single entry point for mod composition</td><td>Real YAML manifest with typed <code>serde</code> deserialization</td></tr>
<tr><td>Standardized directory layout</td><td>Convention-based — chrome/, rules/, maps/</td><td>Adapted for our three-tier model</td></tr>
<tr><td><code>.vscode/</code> included</td><td>IDE support out of the box</td><td>Full VS Code extension with YAML schema + Lua LSP</td></tr>
<tr><td>C# DLL for custom traits</td><td><strong>Pain point:</strong> requires .NET toolchain, IDE, compilation</td><td>Our YAML/Lua/WASM tiers eliminate this entirely</td></tr>
<tr><td>GPL license on mod code</td><td><strong>Pain point:</strong> all mod code must be GPL-compatible</td><td>WASM sandbox + permissive engine license = modder’s choice</td></tr>
<tr><td>MiniYAML format</td><td><strong>Pain point:</strong> no tooling, no validation</td><td>Real YAML with JSON Schema, serde, linting</td></tr>
<tr><td>No workshop/distribution</td><td><strong>Pain point:</strong> manual file sharing, forum posts</td><td>Built-in workshop with <code>ic mod publish</code></td></tr>
<tr><td>No hot-reload</td><td><strong>Pain point:</strong> recompile engine+mod for every change</td><td>Lua + YAML hot-reload during development</td></tr>
</tbody>
</table>
</div>
<h3 id="the-ic-cli-tool"><a class="header" href="#the-ic-cli-tool">The <code>ic</code> CLI Tool</a></h3>
<p>A single Rust binary that replaces OpenRA’s grab-bag of shell scripts:</p>
<pre><code>ic mod init [template]     # scaffold a new mod from a template
ic mod check               # validate YAML rules, Lua syntax, WASM module integrity
ic mod test                # run mod in headless test harness (smoke test)
ic mod run                 # launch game with this mod loaded
ic mod server              # launch dedicated server for this mod
ic mod package             # build distributable packages (workshop or standalone)
ic mod publish             # publish to workshop
ic mod update-engine       # update engine version in mod.yaml
ic mod lint                # style/convention checks + llm: metadata completeness
ic mod watch               # hot-reload mode: watches files, reloads YAML/Lua on change
</code></pre>
<p><strong>Why a CLI, not just scripts:</strong></p>
<ul>
<li>Single binary — no Python, .NET, or shell dependencies</li>
<li>Cross-platform (Windows, macOS, Linux) from one codebase</li>
<li>Rich error messages with fix suggestions</li>
<li>Integrates with the workshop API</li>
<li>Can be embedded in CI/CD pipelines</li>
</ul>
<h3 id="mod-manifest-modyaml"><a class="header" href="#mod-manifest-modyaml">Mod Manifest (<code>mod.yaml</code>)</a></h3>
<p>Every mod has a <code>mod.yaml</code> at its root — the single source of truth for mod identity and composition. Inspired by OpenRA’s <code>mod.yaml</code> but using real YAML with typed deserialization:</p>
<pre><code class="language-yaml"># mod.yaml
mod:
  id: my-total-conversion
  title: "Red Apocalypse"
  version: "1.2.0"
  authors: ["ModderName"]
  description: "A total conversion set in an alternate timeline"
  website: "https://example.com/red-apocalypse"
  license: "CC-BY-SA-4.0"            # modder's choice — no GPL requirement

engine:
  version: "^0.3.0"                  # semver — compatible with 0.3.x
  game_module: "ra1"                 # which GameModule this mod targets

assets:
  rules: ["rules/**/*.yaml"]
  maps: ["maps/"]
  missions: ["missions/"]
  scripts: ["scripts/**/*.lua"]
  wasm_modules: ["wasm/*.wasm"]
  media: ["media/"]
  chrome: ["chrome/**/*.yaml"]
  sequences: ["sequences/**/*.yaml"]

dependencies:                        # other mods/workshop items required
  - id: "community-hd-sprites"
    version: "^2.0"
    source: workshop

balance_preset: classic              # default balance preset for this mod

llm:
  summary: "Alternate-timeline total conversion with new factions and units"
  gameplay_tags: [total_conversion, alternate_history, new_factions]
</code></pre>
<h3 id="standardized-mod-directory-layout"><a class="header" href="#standardized-mod-directory-layout">Standardized Mod Directory Layout</a></h3>
<pre><code>my-mod/
├── mod.yaml                  # manifest (required)
├── rules/                    # Tier 1: YAML data
│   ├── units/
│   │   ├── infantry.yaml
│   │   └── vehicles.yaml
│   ├── structures/
│   ├── weapons/
│   ├── terrain/
│   └── presets/              # balance preset overrides
├── maps/                     # map files (.oramap or native)
├── missions/                 # campaign missions
│   ├── allied-01.yaml
│   └── allied-01.lua
├── scripts/                  # Tier 2: Lua scripts
│   ├── abilities/
│   └── triggers/
├── wasm/                     # Tier 3: WASM modules
│   └── custom_mechanics.wasm
├── media/                    # videos, cutscenes
├── chrome/                   # UI layout definitions
├── sequences/                # sprite sequence definitions
├── cursors/                  # custom cursor definitions
├── audio/                    # music, SFX, voice lines
├── templates/                # Tera mission/scene templates
└── README.md                 # human-readable mod description
</code></pre>
<h3 id="mod-templates-via-cargo-generate"><a class="header" href="#mod-templates-via-cargo-generate">Mod Templates (via <code>cargo-generate</code>)</a></h3>
<p><code>ic mod init</code> uses <code>cargo-generate</code>-style templates. Built-in templates:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Template</th><th>Creates</th><th>For</th></tr>
</thead>
<tbody>
<tr><td><code>data-mod</code></td><td>mod.yaml + rules/ + empty maps/</td><td>Simple balance/cosmetic mods (Tier 1 only)</td></tr>
<tr><td><code>scripted-mod</code></td><td>Above + scripts/ + missions/</td><td>Mission packs, custom game modes (Tier 1+2)</td></tr>
<tr><td><code>total-conversion</code></td><td>Full directory layout including wasm/</td><td>Total conversions (all tiers)</td></tr>
<tr><td><code>map-pack</code></td><td>mod.yaml + maps/</td><td>Map collections</td></tr>
<tr><td><code>asset-pack</code></td><td>mod.yaml + media/ + sequences/</td><td>Sprite/sound/video packs</td></tr>
</tbody>
</table>
</div>
<p>Community can publish custom templates to the workshop.</p>
<h3 id="development-workflow"><a class="header" href="#development-workflow">Development Workflow</a></h3>
<pre><code>1. ic mod init scripted-mod          # scaffold
2. Edit YAML rules, write Lua scripts
3. ic mod watch                      # hot-reload mode
4. ic mod check                      # validate everything
5. ic mod test                       # headless smoke test
6. ic mod publish                    # push to workshop
</code></pre>
<p>Compare to OpenRA’s workflow: install .NET SDK → fork SDK repo → edit MiniYAML → write C# DLL → <code>make</code> → <code>launch-game.sh</code> → manually package → upload to forum.</p>
<h2 id="llm-readable-resource-metadata"><a class="header" href="#llm-readable-resource-metadata">LLM-Readable Resource Metadata</a></h2>
<p>Every game resource — units, weapons, structures, maps, mods, templates — carries structured metadata designed for consumption by LLMs and AI systems. This is not documentation for humans (that’s <code>display.name</code> and README files). This is <strong>machine-readable semantic context</strong> that enables AI to reason about game content.</p>
<h3 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h3>
<p>Traditional game data is structured for the engine: cost, health, speed, damage. An LLM reading <code>cost: 100, health: 50, speed: 56, weapon: m1_carbine</code> can parse the numbers but cannot infer <em>purpose</em>. It doesn’t know that rifle infantry is a cheap scout, that it’s useless against tanks, or that it should be built in groups of 5+.</p>
<p>The <code>llm:</code> metadata block bridges this gap. It gives LLMs the strategic and tactical context that experienced players carry in their heads.</p>
<h3 id="what-consumes-it"><a class="header" href="#what-consumes-it">What Consumes It</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Consumer</th><th>How It Uses <code>llm:</code> Metadata</th></tr>
</thead>
<tbody>
<tr><td><strong><code>ra-llm</code> (mission generation)</strong></td><td>Selects appropriate units for scenarios. “A hard mission” → picks units with <code>role: siege</code> and high counters. “A stealth mission” → picks units with <code>role: scout, infiltrator</code>.</td></tr>
<tr><td><strong><code>ra-ai</code> (skirmish AI)</strong></td><td>Reads <code>counters</code>/<code>countered_by</code> for build decisions. Knows to build anti-air when enemy has <code>role: air</code>. Reads <code>tactical_notes</code> for positioning hints.</td></tr>
<tr><td><strong>Workshop search</strong></td><td>Semantic search: “a map for beginners” matches <code>difficulty: beginner-friendly</code>. “Something for a tank rush” matches <code>gameplay_tags: ["open_terrain", "abundant_resources"]</code>.</td></tr>
<tr><td><strong>Future in-game AI advisor</strong></td><td>“What should I build?” → reads enemy composition’s <code>countered_by</code>, suggests units with matching <code>role</code>.</td></tr>
<tr><td><strong>Mod compatibility analysis</strong></td><td>Detects when a mod changes a unit’s <code>role</code> or <code>counters</code> in ways that affect balance.</td></tr>
</tbody>
</table>
</div>
<h3 id="metadata-format-on-game-resources"><a class="header" href="#metadata-format-on-game-resources">Metadata Format (on game resources)</a></h3>
<p>The <code>llm:</code> block is optional on every resource type. It follows a consistent schema:</p>
<pre><code class="language-yaml"># On units / weapons / structures:
llm:
  summary: "One-line natural language description"
  role: [semantic, tags, for, classification]
  strengths: [what, this, excels, at]
  weaknesses: [what, this, is, bad, at]
  tactical_notes: "Free-text tactical guidance for LLM reasoning"
  counters: [unit_types, this, beats]
  countered_by: [unit_types, that, beat, this]

# On maps:
llm:
  summary: "4-player island map with contested center bridge"
  gameplay_tags: [islands, naval, chokepoint, 4player]
  tactical_notes: "Control the center bridge for resource access. Naval early game is critical."

# On weapons:
llm:
  summary: "Long-range anti-structure artillery"
  role: [siege, anti_structure]
  strengths: [long_range, high_structure_damage, area_of_effect]
  weaknesses: [slow_fire_rate, inaccurate_vs_moving, minimum_range]
</code></pre>
<h3 id="metadata-format-on-workshop-resources"><a class="header" href="#metadata-format-on-workshop-resources">Metadata Format (on workshop resources)</a></h3>
<p>Workshop resources carry <code>LlmResourceMeta</code> in their package manifest:</p>
<pre><code class="language-yaml"># workshop manifest for a mission template
llm_meta:
  summary: "Defend a bridge against 5 waves of Soviet armor"
  purpose: "Good for practicing defensive tactics with limited resources"
  gameplay_tags: [defense, bridge, waves, armor, intermediate]
  difficulty: "intermediate"
  composition_hints: "Pairs well with the 'reinforcements' scene template for a harder variant"
</code></pre>
<p>This metadata is indexed by the workshop server for semantic search. When an LLM needs to find “a scene template for an ambush in a forest,” it searches <code>gameplay_tags</code> and <code>summary</code>, not filenames.</p>
<h3 id="design-rules"><a class="header" href="#design-rules">Design Rules</a></h3>
<ol>
<li><strong><code>llm:</code> is always optional.</strong> Resources work without it. Legacy content and OpenRA imports won’t have it initially — it can be added incrementally, by humans or by LLMs.</li>
<li><strong>Human-written is preferred, LLM-generated is acceptable.</strong> When a modder publishes to the workshop without <code>llm_meta</code>, the system can offer to auto-generate it from the resource’s data (unit stats, map layout, etc.). The modder reviews and approves.</li>
<li><strong>Tags use a controlled vocabulary.</strong> <code>role</code>, <code>strengths</code>, <code>weaknesses</code>, <code>counters</code>, and <code>gameplay_tags</code> draw from a published tag dictionary (extensible by mods). This prevents tag drift where the same concept has five spellings.</li>
<li><strong><code>tactical_notes</code> is free-text.</strong> This is the field where nuance lives. “Build 5+ to be cost-effective” or “Position behind walls for maximum effectiveness” — advice that can’t be captured in tags.</li>
<li><strong>Metadata is part of the YAML spec, not a sidecar.</strong> It lives in the same file as the resource definition. No separate metadata files to lose or desync.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="05--file-formats--original-source-insights"><a class="header" href="#05--file-formats--original-source-insights">05 — File Formats &amp; Original Source Insights</a></h1>
<h2 id="formats-to-support-ra-formats-crate"><a class="header" href="#formats-to-support-ra-formats-crate">Formats to Support (ra-formats crate)</a></h2>
<h3 id="binary-formats-from-original-game--openra"><a class="header" href="#binary-formats-from-original-game--openra">Binary Formats (from original game / OpenRA)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Purpose</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><code>.mix</code></td><td>Archive container</td><td>Flat archive, hash-based file lookup, no compression</td></tr>
<tr><td><code>.shp</code></td><td>Sprite sheets</td><td>Frame-based, palette-indexed</td></tr>
<tr><td><code>.tmp</code></td><td>Terrain tiles</td><td>Isometric tile data</td></tr>
<tr><td><code>.pal</code></td><td>Color palettes</td><td>256-color palettes, multiple per scenario</td></tr>
<tr><td><code>.aud</code></td><td>Audio</td><td>Westwood’s audio format, IMA ADPCM compressed</td></tr>
<tr><td><code>.vqa</code></td><td>Video</td><td>Cutscenes (VQ vector quantization)</td></tr>
</tbody>
</table>
</div>
<h3 id="text-formats"><a class="header" href="#text-formats">Text Formats</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Purpose</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><code>.ini</code> (original)</td><td>Game rules</td><td>Original Red Alert format</td></tr>
<tr><td>MiniYAML (OpenRA)</td><td>Game rules, maps, manifests</td><td>Custom dialect, needs converter</td></tr>
<tr><td>YAML (ours)</td><td>Game rules, maps, manifests</td><td>Standard spec-compliant YAML</td></tr>
<tr><td><code>.oramap</code></td><td>OpenRA map package</td><td>ZIP archive containing map.yaml + terrain + actors</td></tr>
</tbody>
</table>
</div>
<h3 id="ra-formats-crate-goals"><a class="header" href="#ra-formats-crate-goals">ra-formats Crate Goals</a></h3>
<ol>
<li>Parse all above formats reliably</li>
<li>Extensive tests against known-good OpenRA data</li>
<li><code>miniyaml2yaml</code> converter tool</li>
<li>CLI tool to dump/inspect/validate RA assets</li>
<li>Useful as standalone crate (builds project credibility)</li>
<li>Released open source early (Phase 0 deliverable)</li>
</ol>
<h2 id="insights-from-eas-original-source-code"><a class="header" href="#insights-from-eas-original-source-code">Insights from EA’s Original Source Code</a></h2>
<p>Repository: https://github.com/electronicarts/CnC_Red_Alert (GPL v3, archived Feb 2025)</p>
<h3 id="code-statistics"><a class="header" href="#code-statistics">Code Statistics</a></h3>
<ul>
<li>290 C++ header files, 296 implementation files, 14 x86 assembly files</li>
<li>~222,000 lines of C++ code</li>
<li>430+ <code>#ifdef WIN32</code> checks (no other platform implemented)</li>
<li>Built with Watcom C/C++ v10.6 and Borland Turbo Assembler v4.0</li>
</ul>
<h3 id="keep-eventorder-queue-system"><a class="header" href="#keep-eventorder-queue-system">Keep: Event/Order Queue System</a></h3>
<p>The original uses <code>OutList</code> (local player commands) and <code>DoList</code> (confirmed orders from all players), both containing <code>EventClass</code> objects:</p>
<pre><code class="language-cpp">// From CONQUER.CPP
OutList.Add(EventClass(EventClass::IDLE, TargetClass(tech)));
</code></pre>
<p>Player actions → events → queue → deterministic processing each tick. This is the same pattern as our <code>PlayerOrder → TickOrders → Simulation::apply_tick()</code> pipeline. Westwood validated this in 1996.</p>
<h3 id="keep-integer-math-for-determinism"><a class="header" href="#keep-integer-math-for-determinism">Keep: Integer Math for Determinism</a></h3>
<p>The original uses integer math everywhere for game logic — positions, damage, timing. No floats in the simulation. This is why multiplayer worked. Our <code>FixedPoint</code> / <code>SimCoord</code> approach mirrors this.</p>
<h3 id="keep-data-driven-rules-ini--miniyaml--yaml"><a class="header" href="#keep-data-driven-rules-ini--miniyaml--yaml">Keep: Data-Driven Rules (INI → MiniYAML → YAML)</a></h3>
<p>Original reads unit stats and game rules from <code>.ini</code> files at runtime. This data-driven philosophy is what made C&amp;C so moddable. The lineage: <code>INI → MiniYAML → YAML</code> — each step more expressive, same philosophy.</p>
<h3 id="keep-mix-archive-concept"><a class="header" href="#keep-mix-archive-concept">Keep: MIX Archive Concept</a></h3>
<p>Simple flat archive with hash-based lookup. No compression in the archive itself (individual files may be compressed). For <code>ra-formats</code>: read MIX as-is for compatibility; native format can modernize.</p>
<h3 id="keep-compression-flexibility"><a class="header" href="#keep-compression-flexibility">Keep: Compression Flexibility</a></h3>
<p>Original implements LCW, LZO, and LZW compression. LZO was settled on for save games:</p>
<pre><code class="language-cpp">// From SAVELOAD.CPP
LZOPipe pipe(LZOPipe::COMPRESS, SAVE_BLOCK_SIZE);
// LZWPipe pipe(LZWPipe::COMPRESS, SAVE_BLOCK_SIZE);  // tried, abandoned
// LCWPipe pipe(LCWPipe::COMPRESS, SAVE_BLOCK_SIZE);   // tried, abandoned
</code></pre>
<h3 id="leave-behind-session-type-branching"><a class="header" href="#leave-behind-session-type-branching">Leave Behind: Session Type Branching</a></h3>
<p>Original code is riddled with network-type checks embedded in game logic:</p>
<pre><code class="language-cpp">if (Session.Type == GAME_IPX || Session.Type == GAME_INTERNET) { ... }
</code></pre>
<p>This is the anti-pattern our <code>NetworkModel</code> trait eliminates. Separate code paths for IPX, Westwood Online, MPlayer, TEN, modem — all interleaved with <code>#ifdef</code>. The developer disliked the Westwood Online API enough to write a complete wrapper around it.</p>
<h3 id="leave-behind-platform-specific-rendering"><a class="header" href="#leave-behind-platform-specific-rendering">Leave Behind: Platform-Specific Rendering</a></h3>
<p>DirectDraw surface management with comments like “Aaaarrgghh!” when hardware allocation fails. Manual VGA mode detection. Custom command-line parsing. <code>wgpu</code> solves all of this.</p>
<h3 id="leave-behind-manual-memory-checking"><a class="header" href="#leave-behind-manual-memory-checking">Leave Behind: Manual Memory Checking</a></h3>
<p>The game allocates 13MB and checks if it succeeds. Checks that <code>sleep(1000)</code> actually advances the system clock. Checks free disk space. None of this translates to modern development.</p>
<h3 id="interesting-historical-details"><a class="header" href="#interesting-historical-details">Interesting Historical Details</a></h3>
<ul>
<li>Code path for 640x400 display mode with special VGA fallback</li>
<li><code>#ifdef FIXIT_CSII</code> for Aftermath expansion — comment explains they broke the ability to build vanilla Red Alert executables and had to fix it later</li>
<li>Developer comments reference “Counterstrike” in VCS headers (<code>$Header: /CounterStrike/...</code>)</li>
<li>MPEG movie playback code exists but is disabled</li>
<li>Game refuses to start if launched from <code>f:\projects\c&amp;c0</code> (the network share)</li>
</ul>
<h2 id="coordinate-system-translation"><a class="header" href="#coordinate-system-translation">Coordinate System Translation</a></h2>
<p>For cross-engine compatibility, coordinate transforms must be explicit:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CoordTransform {
    pub our_scale: i32,       // our subdivisions per cell
    pub openra_scale: i32,    // 1024 for OpenRA (WDist/WPos)
    pub original_scale: i32,  // original game's lepton system
}

impl CoordTransform {
    pub fn to_wpos(&amp;self, pos: &amp;CellPos) -&gt; (i32, i32) {
        ((pos.x * self.openra_scale) / self.our_scale,
         (pos.y * self.openra_scale) / self.our_scale)
    }
    pub fn from_wpos(&amp;self, x: i32, y: i32) -&gt; CellPos {
        CellPos {
            x: (x * self.our_scale) / self.openra_scale,
            y: (y * self.our_scale) / self.openra_scale,
        }
    }
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="06--security--threat-model"><a class="header" href="#06--security--threat-model">06 — Security &amp; Threat Model</a></h1>
<h2 id="fundamental-constraint"><a class="header" href="#fundamental-constraint">Fundamental Constraint</a></h2>
<p>In deterministic lockstep, every client runs the full simulation. Every player has <strong>complete game state in memory</strong> at all times. This shapes every vulnerability and mitigation.</p>
<h2 id="threat-matrix-by-network-model"><a class="header" href="#threat-matrix-by-network-model">Threat Matrix by Network Model</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>Pure P2P Lockstep</th><th>Relay Server Lockstep</th><th>Authoritative Fog Server</th></tr>
</thead>
<tbody>
<tr><td>Maphack</td><td><strong>OPEN</strong></td><td><strong>OPEN</strong></td><td><strong>BLOCKED</strong> ✓</td></tr>
<tr><td>Order injection</td><td>Sim rejects</td><td>Server rejects</td><td>Server rejects</td></tr>
<tr><td>Lag switch</td><td><strong>OPEN</strong></td><td><strong>BLOCKED</strong> ✓</td><td><strong>BLOCKED</strong> ✓</td></tr>
<tr><td>Desync exploit</td><td>Possible</td><td>Server-only analysis</td><td>N/A</td></tr>
<tr><td>Replay tampering</td><td><strong>OPEN</strong></td><td>Signed ✓</td><td>Signed ✓</td></tr>
<tr><td>WASM mod cheating</td><td>Sandbox</td><td>Sandbox</td><td>Sandbox</td></tr>
<tr><td>Reconciler abuse</td><td>N/A</td><td>N/A</td><td>Bounded + signed ✓</td></tr>
<tr><td>Join code brute-force</td><td>Rate limit + expiry</td><td>Rate limit + expiry</td><td>Rate limit + expiry</td></tr>
<tr><td>Tracking server abuse</td><td>Rate limit + validation</td><td>Rate limit + validation</td><td>Rate limit + validation</td></tr>
<tr><td>Version mismatch</td><td>Handshake ✓</td><td>Handshake ✓</td><td>Handshake ✓</td></tr>
</tbody>
</table>
</div>
<p><strong>Recommendation:</strong> Relay server is the minimum for ranked/competitive play. Fog-authoritative server for high-stakes tournaments.</p>
<h2 id="vulnerability-1-maphack-architectural-limit"><a class="header" href="#vulnerability-1-maphack-architectural-limit">Vulnerability 1: Maphack (Architectural Limit)</a></h2>
<h3 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h3>
<p>Both clients must simulate everything (enemy movement, production, harvesting), so all game state exists in process memory. Fog of war is a rendering filter — the data is always there.</p>
<p>Every lockstep RTS has this problem: OpenRA, StarCraft, Age of Empires.</p>
<h3 id="mitigations-partial-not-solutions"><a class="header" href="#mitigations-partial-not-solutions">Mitigations (partial, not solutions)</a></h3>
<p><strong>Memory obfuscation</strong> (raises bar for casual cheats):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ObfuscatedWorld {
    inner: World,
    xor_key: u64,  // rotated every N ticks
}
<span class="boring">}</span></code></pre>
<p><strong>Partitioned memory</strong> (harder to scan):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PartitionedWorld {
    visible: World,              // Normal memory
    hidden: ObfuscatedStore,     // Encrypted, scattered, decoy entries
}
<span class="boring">}</span></code></pre>
<p><strong>Actual solution: Fog-Authoritative Server</strong>
Server runs full sim, sends each client only entities they can see. Breaks pure lockstep. Requires server compute per game.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FogAuthoritativeNetwork {
    known_entities: HashSet&lt;EntityId&gt;,
}
impl NetworkModel for FogAuthoritativeNetwork {
    fn poll_tick(&amp;mut self) -&gt; Option&lt;TickOrders&gt; {
        // Returns orders AND visibility deltas:
        // "Entity 47 entered your vision at (30, 8)"
        // "Entity 23 left your vision"
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Trade-off:</strong> Relay server (just forwards orders) = cheap VPS handles thousands of games. Authoritative sim server = real CPU per game.</p>
<h2 id="vulnerability-2-order-injection--spoofing"><a class="header" href="#vulnerability-2-order-injection--spoofing">Vulnerability 2: Order Injection / Spoofing</a></h2>
<h3 id="the-problem-1"><a class="header" href="#the-problem-1">The Problem</a></h3>
<p>Malicious client sends impossible orders (build without resources, control enemy units).</p>
<h3 id="mitigation-deterministic-validation-in-sim"><a class="header" href="#mitigation-deterministic-validation-in-sim">Mitigation: Deterministic Validation in Sim</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn validate_order(&amp;self, player: PlayerId, order: &amp;PlayerOrder) -&gt; OrderValidity {
    match order {
        PlayerOrder::Build { structure, position } =&gt; {
            let house = self.player_state(player);
            if house.credits &lt; structure.cost() { return Rejected(InsufficientFunds); }
            if !house.has_prerequisite(structure) { return Rejected(MissingPrerequisite); }
            if !self.can_place_building(player, structure, position) { return Rejected(InvalidPlacement); }
            Valid
        }
        PlayerOrder::Move { unit_ids, .. } =&gt; {
            for id in unit_ids {
                if self.unit_owner(*id) != Some(player) { return Rejected(NotOwner); }
            }
            Valid
        }
        // Every order type validated
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Key:</strong> Validation is deterministic and inside the sim. All clients run the same validation → all agree on rejections → no desync. Relay server also validates before broadcasting (defense in depth).</p>
<h2 id="vulnerability-3-lag-switch-timing-manipulation"><a class="header" href="#vulnerability-3-lag-switch-timing-manipulation">Vulnerability 3: Lag Switch (Timing Manipulation)</a></h2>
<h3 id="the-problem-2"><a class="header" href="#the-problem-2">The Problem</a></h3>
<p>Player deliberately delays packets → opponent’s game stalls → attacker gets extra thinking time.</p>
<h3 id="mitigation-relay-server-with-time-authority"><a class="header" href="#mitigation-relay-server-with-time-authority">Mitigation: Relay Server with Time Authority</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl RelayServer {
    fn process_tick(&amp;mut self, tick: u64) {
        let deadline = Instant::now() + self.tick_deadline;
        for player in &amp;self.players {
            match self.receive_orders_from(player, deadline) {
                Ok(orders) =&gt; self.tick_orders.add(player, orders),
                Err(Timeout) =&gt; {
                    self.player_budgets[player].strikes += 1;
                    if strikes &gt; 3 {
                        // Drop or use last known orders
                        self.tick_orders.add(player, PlayerOrder::RepeatLast);
                    } else {
                        self.tick_orders.add(player, PlayerOrder::Idle);
                    }
                }
            }
        }
        // Game never stalls for honest players
        self.broadcast_tick_orders(tick);
    }
}
<span class="boring">}</span></code></pre>
<p>Server owns the clock. Miss the window → your orders are dropped. Lag switch only punishes the attacker.</p>
<h2 id="vulnerability-4-desync-exploit-for-information-gathering"><a class="header" href="#vulnerability-4-desync-exploit-for-information-gathering">Vulnerability 4: Desync Exploit for Information Gathering</a></h2>
<h3 id="the-problem-3"><a class="header" href="#the-problem-3">The Problem</a></h3>
<p>Cheating client intentionally causes desync, then analyzes desync report to extract hidden state.</p>
<h3 id="mitigation-server-side-only-desync-analysis"><a class="header" href="#mitigation-server-side-only-desync-analysis">Mitigation: Server-Side Only Desync Analysis</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DesyncReport {
    pub tick: u64,
    pub player_hashes: HashMap&lt;PlayerId, u64&gt;,
    // Full state diffs are SERVER-SIDE ONLY
    // Never transmitted to clients
}
<span class="boring">}</span></code></pre>
<p>Never send full state dumps to clients. Clients only learn “desync detected at tick N.” Admins can review server-side diffs.</p>
<h2 id="vulnerability-5-wasm-mod-as-attack-vector"><a class="header" href="#vulnerability-5-wasm-mod-as-attack-vector">Vulnerability 5: WASM Mod as Attack Vector</a></h2>
<h3 id="the-problem-4"><a class="header" href="#the-problem-4">The Problem</a></h3>
<p>Malicious mod reads entity positions, sends data to external overlay, or subtly modifies local sim.</p>
<h3 id="mitigation-capability-based-api-design"><a class="header" href="#mitigation-capability-based-api-design">Mitigation: Capability-Based API Design</a></h3>
<p>The WASM host API surface IS the security boundary:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ModCapabilities {
    pub read_own_state: bool,
    pub read_visible_state: bool,
    // read_fogged_state doesn't exist as a capability — the API function doesn't exist
    pub issue_orders: bool,
    pub filesystem: FileAccess,    // Usually None
    pub network: NetworkAccess,    // Usually None
}

pub enum NetworkAccess {
    None,
    AllowList(Vec&lt;String&gt;),
    // Never unrestricted
}
<span class="boring">}</span></code></pre>
<p><strong>Key principle:</strong> Don’t expose <code>get_all_units()</code> or <code>get_enemy_state()</code>. Only expose <code>get_visible_units()</code> which checks fog. Mods literally cannot request hidden data because the function doesn’t exist.</p>
<h2 id="vulnerability-6-replay-tampering"><a class="header" href="#vulnerability-6-replay-tampering">Vulnerability 6: Replay Tampering</a></h2>
<h3 id="the-problem-5"><a class="header" href="#the-problem-5">The Problem</a></h3>
<p>Modified replay files to fake tournament results.</p>
<h3 id="mitigation-signed-hash-chain"><a class="header" href="#mitigation-signed-hash-chain">Mitigation: Signed Hash Chain</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SignedReplay {
    pub data: ReplayData,
    pub server_signature: Ed25519Signature,
    pub hash_chain: Vec&lt;(u64, u64)&gt;,  // tick, cumulative_hash
}

impl SignedReplay {
    pub fn verify(&amp;self, server_public_key: &amp;PublicKey) -&gt; bool {
        // 1. Verify server signature
        // 2. Verify hash chain integrity (tampering any tick invalidates all subsequent)
    }
}
<span class="boring">}</span></code></pre>
<h2 id="vulnerability-7-reconciler-as-attack-surface"><a class="header" href="#vulnerability-7-reconciler-as-attack-surface">Vulnerability 7: Reconciler as Attack Surface</a></h2>
<h3 id="the-problem-6"><a class="header" href="#the-problem-6">The Problem</a></h3>
<p>If the client accepts “corrections” from an external authority (cross-engine reconciler), a fake server could send malicious corrections.</p>
<h3 id="mitigation-bounded-and-authenticated-corrections"><a class="header" href="#mitigation-bounded-and-authenticated-corrections">Mitigation: Bounded and Authenticated Corrections</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_sane_correction(&amp;self, c: &amp;EntityCorrection) -&gt; bool {
    match &amp;c.field {
        CorrectionField::Position(new_pos) =&gt; {
            let current = self.sim.entity_position(c.entity);
            let max_drift = MAX_UNIT_SPEED * self.ticks_since_sync;
            current.distance_to(new_pos) &lt;= max_drift
        }
        CorrectionField::Credits(amount) =&gt; {
            *amount &gt;= 0 &amp;&amp; 
            (*amount - self.last_known_credits).abs() &lt;= MAX_CREDIT_DELTA
        }
    }
}
<span class="boring">}</span></code></pre>
<p>All corrections must be: signed by the authority, bounded to physically possible values, and rejectable if suspicious.</p>
<h2 id="vulnerability-8-join-code-brute-forcing"><a class="header" href="#vulnerability-8-join-code-brute-forcing">Vulnerability 8: Join Code Brute-Forcing</a></h2>
<h3 id="the-problem-7"><a class="header" href="#the-problem-7">The Problem</a></h3>
<p>Join codes (e.g., <code>IRON-7K3M</code>) enable NAT-friendly P2P connections via a rendezvous server. If codes are short, an attacker can brute-force codes to join games uninvited — griefing lobbies or extracting connection info.</p>
<p>A 4-character alphanumeric code has ~1.7 million combinations. At 1000 requests/second, exhausted in ~28 minutes. Shorter codes are worse.</p>
<h3 id="mitigation-length--rate-limiting--expiry"><a class="header" href="#mitigation-length--rate-limiting--expiry">Mitigation: Length + Rate Limiting + Expiry</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct JoinCode {
    pub code: String,          // 6-8 chars, alphanumeric, no ambiguous chars (0/O, 1/I/l)
    pub created_at: Instant,
    pub expires_at: Instant,   // TTL: 5 minutes (enough to share, too short to brute-force)
    pub uses_remaining: u32,   // 1 for private, N for party invites
}

impl RendezvousServer {
    fn resolve_code(&amp;mut self, code: &amp;str, requester_ip: IpAddr) -&gt; Result&lt;ConnectionInfo&gt; {
        // Rate limit: max 5 resolve attempts per IP per minute
        if self.rate_limiter.check(requester_ip).is_err() {
            return Err(RateLimited);
        }
        // Lookup and consume
        match self.codes.get(code) {
            Some(entry) if entry.expires_at &gt; Instant::now() =&gt; Ok(entry.connection_info()),
            _ =&gt; Err(InvalidCode),  // Don't distinguish "expired" from "nonexistent"
        }
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Key choices:</strong></p>
<ul>
<li>6+ characters from a 32-char alphabet (no ambiguous chars) = ~1 billion combinations</li>
<li>Rate limit resolves per IP (5/minute blocks brute-force, legitimate users never hit it)</li>
<li>Codes expire after 5 minutes (limits attack window)</li>
<li>Invalid vs expired returns the same error (no information leakage)</li>
</ul>
<h2 id="vulnerability-9-tracking-server-abuse"><a class="header" href="#vulnerability-9-tracking-server-abuse">Vulnerability 9: Tracking Server Abuse</a></h2>
<h3 id="the-problem-8"><a class="header" href="#the-problem-8">The Problem</a></h3>
<p>The tracking server is a public API. Abuse vectors:</p>
<ul>
<li><strong>Spam listings</strong> — flood with fake games, burying real ones</li>
<li><strong>Phishing redirects</strong> — listing points to a malicious IP that mimics a game server but captures client info</li>
<li><strong>DDoS</strong> — overwhelm the server to deny game discovery for everyone</li>
</ul>
<p>OpenRA’s master server has been DDoSed before. Any public game directory faces this.</p>
<h3 id="mitigation-standard-api-hardening"><a class="header" href="#mitigation-standard-api-hardening">Mitigation: Standard API Hardening</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TrackingServerConfig {
    pub max_listings_per_ip: u32,        // 3 — one IP rarely needs more
    pub heartbeat_interval: Duration,    // 30s — listing expires if missed
    pub listing_ttl: Duration,           // 2 minutes without heartbeat → removed
    pub browse_rate_limit: u32,          // 30 requests/minute per IP
    pub publish_rate_limit: u32,         // 5 requests/minute per IP
    pub require_valid_game_port: bool,   // Server verifies the listed port is reachable
}
<span class="boring">}</span></code></pre>
<p><strong>Spam prevention:</strong> Limit listings per IP. Require heartbeats (real games send them, spam bots must sustain effort). Optionally verify the listed port actually responds to a game protocol handshake.</p>
<p><strong>Phishing prevention:</strong> Client validates the game protocol handshake before showing the lobby. A non-game server at the listed IP fails handshake and is silently dropped from the browser.</p>
<p><strong>DDoS:</strong> Standard infrastructure — CDN/reverse proxy for the browse API, rate limiting, geographic distribution. The tracking server is stateless and trivially horizontally scalable (it’s just a filtered list in memory).</p>
<h2 id="vulnerability-10-client-version-mismatch"><a class="header" href="#vulnerability-10-client-version-mismatch">Vulnerability 10: Client Version Mismatch</a></h2>
<h3 id="the-problem-9"><a class="header" href="#the-problem-9">The Problem</a></h3>
<p>Players with different client versions join the same game. Even minor differences in sim code (bug fix, balance patch) cause immediate desyncs. This looks like a bug to users, destroys trust, and wastes time. Age of Empires 2 DE had years of desync issues partly caused by version mismatches.</p>
<h3 id="mitigation-version-handshake-at-connection"><a class="header" href="#mitigation-version-handshake-at-connection">Mitigation: Version Handshake at Connection</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct VersionInfo {
    pub engine_version: SemVer,        // e.g., 0.3.1
    pub sim_hash: u64,                 // hash of compiled sim logic (catches patched binaries)
    pub mod_manifest_hash: u64,        // hash of loaded mod rules (catches different mod versions)
    pub protocol_version: u32,         // wire protocol version
}

impl GameLobby {
    fn accept_player(&amp;self, remote: &amp;VersionInfo) -&gt; Result&lt;()&gt; {
        if remote.protocol_version != self.host.protocol_version {
            return Err(IncompatibleProtocol);
        }
        if remote.sim_hash != self.host.sim_hash {
            return Err(SimVersionMismatch);
        }
        if remote.mod_manifest_hash != self.host.mod_manifest_hash {
            return Err(ModMismatch);
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Key:</strong> Check version during lobby join, not after game starts. The relay server and tracking server listings both include <code>VersionInfo</code> so incompatible games are filtered from the browser entirely.</p>
<h2 id="vulnerability-11-speed-hack--clock-manipulation"><a class="header" href="#vulnerability-11-speed-hack--clock-manipulation">Vulnerability 11: Speed Hack / Clock Manipulation</a></h2>
<h3 id="the-problem-10"><a class="header" href="#the-problem-10">The Problem</a></h3>
<p>A cheating client runs the local simulation faster than real time—either by manipulating the system clock or by feeding artificial timing into the game loop. In a pure P2P lockstep model, every client agrees on a tick cadence, so a faster client could potentially submit orders slightly sooner, giving a micro-advantage in reaction time.</p>
<h3 id="mitigation-relay-server-owns-the-clock"><a class="header" href="#mitigation-relay-server-owns-the-clock">Mitigation: Relay Server Owns the Clock</a></h3>
<p>In <code>RelayLockstepNetwork</code>, the relay server is the sole time authority. It advances the game by broadcasting canonical tick boundaries. The client’s local clock is irrelevant—a client that “runs faster” just finishes processing sooner and waits for the next server tick. Orders submitted before the tick window opens are discarded.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl RelayServer {
    fn tick_loop(&amp;mut self) {
        loop {
            let tick_start = Instant::now();
            let tick_end = tick_start + self.tick_interval;

            // Collect orders only within the valid window
            let orders = self.collect_orders_until(tick_end);

            // Orders with timestamps outside the current tick window are rejected
            for order in &amp;orders {
                if order.timestamp &lt; self.current_tick_start
                    || order.timestamp &gt; tick_end
                {
                    self.flag_suspicious(order.player, "out-of-window order");
                    continue;
                }
            }

            self.broadcast_tick_orders(self.current_tick, &amp;orders);
            self.current_tick += 1;
            self.current_tick_start = tick_end;
        }
    }
}
<span class="boring">}</span></code></pre>
<p><strong>For pure P2P (no relay):</strong> Speed hacks are harder to exploit because all clients must synchronize at each tick barrier — a client that runs faster simply idles. However, a desynced clock can cause subtle timing issues. This is another reason relay server is the recommended default for competitive play.</p>
<h2 id="vulnerability-12-automation--scripting-botting"><a class="header" href="#vulnerability-12-automation--scripting-botting">Vulnerability 12: Automation / Scripting (Botting)</a></h2>
<h3 id="the-problem-11"><a class="header" href="#the-problem-11">The Problem</a></h3>
<p>External tools (macros, overlays, input injectors) automate micro-management with superhuman precision: perfect unit splitting, instant reaction to enemy attacks, pixel-perfect targeting at 10,000+ APM. This is indistinguishable from a skilled player at a protocol level — the client sends valid orders at valid times.</p>
<h3 id="mitigation-behavioral-analysis-relay-side"><a class="header" href="#mitigation-behavioral-analysis-relay-side">Mitigation: Behavioral Analysis (Relay-Side)</a></h3>
<p>The relay server observes order patterns without needing access to game state:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PlayerBehaviorProfile {
    pub orders_per_tick: RingBuffer&lt;u32&gt;,          // rolling APM
    pub reaction_times: RingBuffer&lt;Duration&gt;,       // time from event to order
    pub order_precision: f64,                       // how tightly clustered targeting is
    pub sustained_apm_peak: Duration,               // how long max APM sustained
    pub pattern_entropy: f64,                        // randomness of input timing
}

impl RelayServer {
    fn analyze_behavior(&amp;self, player: PlayerId) -&gt; SuspicionScore {
        let profile = &amp;self.profiles[player];
        let mut score = 0.0;

        // Sustained inhuman APM (&gt;600 for extended periods)
        if profile.sustained_apm_above(600, Duration::from_secs(30)) {
            score += 0.4;
        }

        // Perfectly periodic input (bots often have metronomic timing)
        if profile.pattern_entropy &lt; HUMAN_ENTROPY_FLOOR {
            score += 0.3;
        }

        // Reaction times consistently under human minimum (~150ms)
        if profile.avg_reaction_time() &lt; Duration::from_millis(100) {
            score += 0.3;
        }

        SuspicionScore(score)
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Key design choices:</strong></p>
<ul>
<li><strong>Detection, not prevention.</strong> We can’t conclusively prove automation from order patterns alone. The system flags suspicion for review, not automatic bans.</li>
<li><strong>Relay-side only.</strong> Analysis happens on the server — cheating clients can’t detect or adapt to the analysis.</li>
<li><strong>Replay-based post-hoc analysis.</strong> Tournament replays can be analyzed after the fact with more sophisticated models (timing distribution analysis, reaction-to-fog-reveal correlation).</li>
<li><strong>Community reporting.</strong> Player reports feed into suspicion scoring — a player flagged by both the system and opponents warrants review.</li>
</ul>
<p><strong>What we deliberately DON’T do:</strong></p>
<ul>
<li>No kernel-level anti-cheat (Vanguard, EAC-style). We’re an open-source game — intrusive anti-cheat contradicts our values and doesn’t work on Linux/WASM anyway.</li>
<li>No input rate limiting. Capping APM punishes legitimate high-skill players. Detection, not restriction.</li>
</ul>
<h2 id="vulnerability-13-match-result-fraud"><a class="header" href="#vulnerability-13-match-result-fraud">Vulnerability 13: Match Result Fraud</a></h2>
<h3 id="the-problem-12"><a class="header" href="#the-problem-12">The Problem</a></h3>
<p>In competitive/ranked play, match results determine ratings. A dishonest client could claim a false result, or colluding players could submit fake results to manipulate rankings.</p>
<h3 id="mitigation-relay-certified-match-results"><a class="header" href="#mitigation-relay-certified-match-results">Mitigation: Relay-Certified Match Results</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CertifiedMatchResult {
    pub match_id: MatchId,
    pub players: Vec&lt;PlayerId&gt;,
    pub result: MatchOutcome,          // winner(s), losers, draw, disconnect
    pub final_tick: u64,
    pub duration: Duration,
    pub final_state_hash: u64,         // hash of sim state at game end
    pub replay_hash: [u8; 32],         // SHA-256 of the full replay data
    pub server_signature: Ed25519Signature, // relay server signs the result
}

impl RankingService {
    fn submit_result(&amp;mut self, result: &amp;CertifiedMatchResult) -&gt; Result&lt;()&gt; {
        // Only accept results signed by a trusted relay server
        if !self.verify_relay_signature(result) {
            return Err(UntrustedSource);
        }
        // Cross-check: if any player also submitted a replay, verify hashes match
        self.update_ratings(result);
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Key:</strong> Only relay-server-signed results update rankings. Direct P2P games can be played for fun but don’t affect ranked standings.</p>
<h2 id="competitive-integrity-summary"><a class="header" href="#competitive-integrity-summary">Competitive Integrity Summary</a></h2>
<p>Iron Curtain’s anti-cheat is <strong>architectural, not bolted on.</strong> Every defense emerges from design decisions made for other reasons:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Threat</th><th>Defense</th><th>Source</th></tr>
</thead>
<tbody>
<tr><td>Maphack</td><td>Fog-authoritative server</td><td>Network model architecture</td></tr>
<tr><td>Order injection</td><td>Deterministic validation in sim</td><td>Sim purity (invariant #1)</td></tr>
<tr><td>Lag switch</td><td>Relay server owns the clock</td><td>Relay architecture (D007)</td></tr>
<tr><td>Speed hack</td><td>Relay tick authority</td><td>Same as above</td></tr>
<tr><td>Replay tampering</td><td>Ed25519 signed hash chain</td><td>Replay system design</td></tr>
<tr><td>Automation</td><td>Behavioral analysis + community reports</td><td>Relay-side observability</td></tr>
<tr><td>Result fraud</td><td>Relay-certified match results</td><td>Relay architecture</td></tr>
<tr><td>Version mismatch</td><td>Protocol handshake</td><td>Lobby system</td></tr>
<tr><td>WASM mod abuse</td><td>Capability-based sandbox</td><td>Modding architecture (D005)</td></tr>
<tr><td>Desync exploit</td><td>Server-side only analysis</td><td>Security by design</td></tr>
</tbody>
</table>
</div>
<p><strong>No kernel-level anti-cheat.</strong> Open-source, cross-platform, no ring-0 drivers. We accept that lockstep RTS will always have a maphack risk in P2P/relay modes — the fog-authoritative server is the real answer for high-stakes play.</p>
<p><strong>Performance as anti-cheat.</strong> Our tick-time targets (&lt; 10ms on 8-core desktop) mean the relay server can run games at full speed with headroom for behavioral analysis. Stuttery servers with 40ms ticks can’t afford real-time order analysis — we can.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="07--cross-engine-compatibility"><a class="header" href="#07--cross-engine-compatibility">07 — Cross-Engine Compatibility</a></h1>
<h2 id="the-three-layers-of-compatibility"><a class="header" href="#the-three-layers-of-compatibility">The Three Layers of Compatibility</a></h2>
<pre><code>Layer 3:  Protocol compatibility    (can they talk?)          → Achievable
Layer 2:  Simulation compatibility  (do they agree on state?) → Hard wall
Layer 1:  Data compatibility        (do they load same rules?)→ Very achievable
</code></pre>
<h2 id="layer-1-data-compatibility-do-this"><a class="header" href="#layer-1-data-compatibility-do-this">Layer 1: Data Compatibility (DO THIS)</a></h2>
<p>Load the same YAML rules, maps, unit definitions, weapon stats as OpenRA.</p>
<ul>
<li><code>ra-formats</code> crate parses MiniYAML and converts to standard YAML</li>
<li>Same maps work on both engines</li>
<li>Existing mod data migrates automatically</li>
<li><strong>Status:</strong> Core part of Phase 0, already planned</li>
</ul>
<h2 id="layer-2-simulation-compatibility-the-hard-wall"><a class="header" href="#layer-2-simulation-compatibility-the-hard-wall">Layer 2: Simulation Compatibility (THE HARD WALL)</a></h2>
<p>For lockstep multiplayer, both engines must produce <strong>bit-identical</strong> results every tick. This is nearly impossible because:</p>
<ul>
<li><strong>Pathfinding order:</strong> Tie resolution depends on internal data structures (C# <code>Dictionary</code> vs Rust <code>HashMap</code> iteration order)</li>
<li><strong>Fixed-point details:</strong> OpenRA uses <code>WDist</code>/<code>WPos</code>/<code>WAngle</code> with 1024 subdivisions. Must match exactly — same rounding, same overflow</li>
<li><strong>System execution order:</strong> Does movement resolve before combat? OpenRA’s <code>World.Tick()</code> has a specific order</li>
<li><strong>RNG:</strong> Must use identical algorithm, same seed, advanced same number of times in same order</li>
<li><strong>Language-level edge cases:</strong> Integer division rounding, overflow behavior between C# and Rust</li>
</ul>
<p><strong>Conclusion:</strong> Achieving bit-identical simulation requires bug-for-bug reimplementation of OpenRA in Rust. That’s a port, not our own engine.</p>
<h2 id="layer-3-protocol-compatibility-achievable-but-pointless-alone"><a class="header" href="#layer-3-protocol-compatibility-achievable-but-pointless-alone">Layer 3: Protocol Compatibility (ACHIEVABLE BUT POINTLESS ALONE)</a></h2>
<p>OpenRA’s network protocol is open source — simple TCP, frame-based lockstep, <code>Order</code> objects. Could implement it. But protocol compatibility without simulation compatibility → connect, start, desync in seconds.</p>
<h2 id="realistic-strategy-progressive-compatibility-levels"><a class="header" href="#realistic-strategy-progressive-compatibility-levels">Realistic Strategy: Progressive Compatibility Levels</a></h2>
<h3 id="level-0-shared-lobby-separate-games-phase-5"><a class="header" href="#level-0-shared-lobby-separate-games-phase-5">Level 0: Shared Lobby, Separate Games (Phase 5)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait CommunityBridge {
    fn publish_game(&amp;self, game: &amp;GameLobby) -&gt; Result&lt;()&gt;;
    fn browse_games(&amp;self) -&gt; Result&lt;Vec&lt;GameListing&gt;&gt;;
    fn fetch_map(&amp;self, hash: &amp;str) -&gt; Result&lt;MapData&gt;;
    fn share_replay(&amp;self, replay: &amp;ReplayData) -&gt; Result&lt;()&gt;;
}
<span class="boring">}</span></code></pre>
<p>Implement OpenRA’s master server protocol. Games show up in same browser. Your-engine players play your-engine players. Same community, different executables.</p>
<h3 id="level-1-replay-compatibility-phase-5-6"><a class="header" href="#level-1-replay-compatibility-phase-5-6">Level 1: Replay Compatibility (Phase 5-6)</a></h3>
<p>Decode OpenRA replay files via <code>OpenRACodec</code>, feed through your sim. They’ll desync eventually, but can watch most of a replay before drift. Useful and shippable.</p>
<h3 id="level-2-casual-cross-play-with-periodic-resync-future"><a class="header" href="#level-2-casual-cross-play-with-periodic-resync-future">Level 2: Casual Cross-Play with Periodic Resync (Future)</a></h3>
<p>Both engines run their sim. Every N ticks, authoritative checkpoint broadcast. On desync, reconciler snaps entities to authoritative positions. Visible as slight rubber-banding. Acceptable for casual play.</p>
<h3 id="level-3-competitive-cross-play-via-embedded-authority-future"><a class="header" href="#level-3-competitive-cross-play-via-embedded-authority-future">Level 3: Competitive Cross-Play via Embedded Authority (Future)</a></h3>
<p>Your client embeds a headless OpenRA sim process. OpenRA sim is the authority. Your Rust sim runs ahead for prediction and smooth rendering. Reconciler corrects drift. Like FPS client-side prediction, but for RTS.</p>
<h3 id="level-4-true-lockstep-cross-play-probably-never"><a class="header" href="#level-4-true-lockstep-cross-play-probably-never">Level 4: True Lockstep Cross-Play (Probably Never)</a></h3>
<p>Requires bit-identical sim. Effectively a port. Architecture doesn’t prevent it, but not worth pursuing.</p>
<h2 id="architecture-for-compatibility"><a class="header" href="#architecture-for-compatibility">Architecture for Compatibility</a></h2>
<h3 id="ordercodec-wire-format-translation"><a class="header" href="#ordercodec-wire-format-translation">OrderCodec: Wire Format Translation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait OrderCodec: Send + Sync {
    fn encode(&amp;self, order: &amp;TimestampedOrder) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
    fn decode(&amp;self, bytes: &amp;[u8]) -&gt; Result&lt;TimestampedOrder&gt;;
    fn protocol_id(&amp;self) -&gt; ProtocolId;
}

pub struct OpenRACodec {
    order_map: OrderTranslationTable,
    coord_transform: CoordTransform,
}

impl OrderCodec for OpenRACodec {
    fn encode(&amp;self, order: &amp;TimestampedOrder) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
        match &amp;order.order {
            PlayerOrder::Move { unit_ids, target } =&gt; {
                let wpos = self.coord_transform.to_wpos(target);
                openra_wire::encode_move(unit_ids, wpos)
            }
            // ... other order types
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="simreconciler-external-state-correction"><a class="header" href="#simreconciler-external-state-correction">SimReconciler: External State Correction</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait SimReconciler: Send + Sync {
    fn check(&amp;mut self, local_tick: u64, local_hash: u64) -&gt; ReconcileAction;
    fn receive_authority_state(&amp;mut self, state: AuthState);
}

pub enum ReconcileAction {
    InSync,                              // Authority agrees
    Correct(Vec&lt;EntityCorrection&gt;),      // Minor drift — patch entities
    Resync(SimSnapshot),                 // Major divergence — reload snapshot
    Autonomous,                          // No authority — local sim is truth
}
<span class="boring">}</span></code></pre>
<h3 id="protocoladapter-transparent-network-wrapping"><a class="header" href="#protocoladapter-transparent-network-wrapping">ProtocolAdapter: Transparent Network Wrapping</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ProtocolAdapter&lt;N: NetworkModel&gt; {
    inner: N,
    codec: Box&lt;dyn OrderCodec&gt;,
    reconciler: Option&lt;Box&lt;dyn SimReconciler&gt;&gt;,
}

impl&lt;N: NetworkModel&gt; NetworkModel for ProtocolAdapter&lt;N&gt; {
    // Wraps any NetworkModel to speak a foreign protocol
    // GameLoop has no idea it's talking to OpenRA
}
<span class="boring">}</span></code></pre>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Native play — nothing special
let game = GameLoop::new(sim, renderer, LockstepNetwork::new(server));

// OpenRA-compatible play — just wrap the network
let adapted = ProtocolAdapter {
    inner: OpenRALockstepNetwork::new(openra_server),
    codec: Box::new(OpenRACodec::new()),
    reconciler: Some(Box::new(OpenRAReconciler::new())),
};
let game = GameLoop::new(sim, renderer, adapted);
// GameLoop is identical. Zero changes.
<span class="boring">}</span></code></pre>
<h2 id="what-to-build-now-phase-0-to-keep-the-door-open"><a class="header" href="#what-to-build-now-phase-0-to-keep-the-door-open">What to Build Now (Phase 0) to Keep the Door Open</a></h2>
<p>Costs almost nothing today, enables everything later:</p>
<ol>
<li><strong><code>OrderCodec</code> trait</strong> in <code>ra-protocol</code> — orders are wire-format-agnostic from day one</li>
<li><strong><code>CoordTransform</code></strong> in <code>ra-formats</code> — coordinate systems are explicit, not implicit</li>
<li><strong><code>Simulation::snapshot()</code>/<code>restore()</code>/<code>apply_correction()</code></strong> — sim is correctable from outside</li>
<li><strong><code>ProtocolAdapter</code> slot</strong> in <code>NetworkModel</code> trait — network layer is wrappable</li>
</ol>
<p>None of these add complexity to the sim or game loop. They’re just ensuring the right seams exist.</p>
<h2 id="what-not-to-chase"><a class="header" href="#what-not-to-chase">What NOT to Chase</a></h2>
<ul>
<li>Don’t try to match OpenRA’s sim behavior bit-for-bit</li>
<li>Don’t try to connect to OpenRA game servers for actual gameplay</li>
<li>Don’t compromise your architecture for cross-engine edge cases</li>
<li>Focus on making switching easy and the experience better, not on co-existing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="08--development-roadmap-36-months"><a class="header" href="#08--development-roadmap-36-months">08 — Development Roadmap (36 Months)</a></h1>
<h2 id="phase-dependencies"><a class="header" href="#phase-dependencies">Phase Dependencies</a></h2>
<pre><code>Phase 0 (Foundation)
  └→ Phase 1 (Rendering + Bevy visual pipeline)
       └→ Phase 2 (Simulation) ← CRITICAL MILESTONE
            ├→ Phase 3 (Game Chrome)
            │    └→ Phase 4 (AI &amp; Single Player)
            │         └→ Phase 5 (Multiplayer)
            │              └→ Phase 6 (Modding &amp; Ecosystem)
            │                   └→ Phase 7 (LLM Missions + Polish)
            └→ [Test infrastructure, CI, headless sim tests]
</code></pre>
<h2 id="phase-0-foundation--format-literacy-months-13"><a class="header" href="#phase-0-foundation--format-literacy-months-13">Phase 0: Foundation &amp; Format Literacy (Months 1–3)</a></h2>
<p><strong>Goal:</strong> Read everything OpenRA reads, produce nothing visible yet.</p>
<h3 id="deliverables"><a class="header" href="#deliverables">Deliverables</a></h3>
<ul>
<li><code>ra-formats</code> crate: parse <code>.mix</code> archives, SHP/TMP sprites, <code>.aud</code> audio, <code>.pal</code> palettes, <code>.vqa</code> video</li>
<li>Parse OpenRA YAML manifests, map format, rule definitions</li>
<li><code>miniyaml2yaml</code> converter tool</li>
<li><strong>Runtime MiniYAML loading (D025):</strong> MiniYAML files load directly at runtime — auto-converts in memory, no pre-conversion required</li>
<li><strong>OpenRA vocabulary alias registry (D023):</strong> Accept OpenRA trait names (<code>Armament</code>, <code>Valued</code>, etc.) as YAML key aliases alongside IC-native names</li>
<li><strong>OpenRA mod manifest parser (D026):</strong> Parse OpenRA <code>mod.yaml</code> manifests, map directory layout to IC equivalents</li>
<li>CLI tool to dump/inspect/validate RA assets</li>
<li>Extensive tests against known-good OpenRA data</li>
</ul>
<h3 id="key-architecture-work"><a class="header" href="#key-architecture-work">Key Architecture Work</a></h3>
<ul>
<li>Define <code>PlayerOrder</code> enum in <code>ra-protocol</code> crate</li>
<li>Define <code>OrderCodec</code> trait (for future cross-engine compatibility)</li>
<li>Define <code>CoordTransform</code> (coordinate system translation)</li>
<li>Study OpenRA architecture: Game loop, World/Actor/Trait hierarchy, OrderManager, mod manifest system</li>
</ul>
<h3 id="release"><a class="header" href="#release">Release</a></h3>
<p>Open source <code>ra-formats</code> early. Useful standalone, builds credibility and community interest.</p>
<h3 id="exit-criteria"><a class="header" href="#exit-criteria">Exit Criteria</a></h3>
<ul>
<li>Can parse any OpenRA mod’s YAML rules into typed Rust structs</li>
<li>Can parse any OpenRA mod’s MiniYAML rules into typed Rust structs (runtime conversion, D025)</li>
<li>Can load an OpenRA mod directory via <code>mod.yaml</code> manifest (D026)</li>
<li>OpenRA trait name aliases resolve correctly to IC components (D023)</li>
<li>Can extract and display sprites from .mix archives</li>
<li>Can convert MiniYAML to standard YAML losslessly</li>
</ul>
<h2 id="phase-1-rendering-slice-months-36"><a class="header" href="#phase-1-rendering-slice-months-36">Phase 1: Rendering Slice (Months 3–6)</a></h2>
<p><strong>Goal:</strong> Render a map with units standing on it. No gameplay. Demonstrate Bevy’s visual capabilities.</p>
<h3 id="deliverables-1"><a class="header" href="#deliverables-1">Deliverables</a></h3>
<ul>
<li>Bevy-based isometric tile renderer with palette-aware shading</li>
<li>Sprite animation system (idle, move, attack frames)</li>
<li>Shroud/fog-of-war rendering</li>
<li>Camera: smooth scroll, zoom, minimap</li>
<li>Load OpenRA map, render correctly</li>
<li>Basic post-processing: bloom on explosions, color grading</li>
<li>Shader prototypes: chrono-shift shimmer, tesla coil glow (visual showcase)</li>
</ul>
<h3 id="key-architecture-work-1"><a class="header" href="#key-architecture-work-1">Key Architecture Work</a></h3>
<ul>
<li>Bevy plugin structure: <code>ra-render</code> as a Bevy plugin reading from sim state</li>
<li>Interpolation between sim ticks for smooth animation at arbitrary FPS</li>
<li>HD asset pipeline: support high-res sprites alongside classic 8-bit assets</li>
</ul>
<h3 id="release-1"><a class="header" href="#release-1">Release</a></h3>
<p>“Red Alert map rendered in Rust at 4K 144fps with modern post-processing” — visual showcase generates buzz.</p>
<h3 id="exit-criteria-1"><a class="header" href="#exit-criteria-1">Exit Criteria</a></h3>
<ul>
<li>Can load and render any OpenRA Red Alert map</li>
<li>Sprites animate correctly (idle loops)</li>
<li>Camera controls feel responsive</li>
<li>Maintains 144fps at 4K on mid-range hardware</li>
</ul>
<h2 id="phase-2-simulation-core-months-612--critical"><a class="header" href="#phase-2-simulation-core-months-612--critical">Phase 2: Simulation Core (Months 6–12) — CRITICAL</a></h2>
<p><strong>Goal:</strong> Units move, shoot, die. The engine exists.</p>
<h3 id="deliverables-2"><a class="header" href="#deliverables-2">Deliverables</a></h3>
<ul>
<li>ECS-based simulation layer (<code>ra-sim</code>)</li>
<li>Components mirroring OpenRA traits: Mobile, Health, Attackable, Armament, Building, Buildable, Harvester</li>
<li><strong>Canonical enum names matching OpenRA (D027):</strong> Locomotor (<code>Foot</code>, <code>Wheeled</code>, <code>Tracked</code>, <code>Float</code>, <code>Fly</code>), Armor (<code>None</code>, <code>Light</code>, <code>Medium</code>, <code>Heavy</code>, <code>Wood</code>, <code>Concrete</code>), Target types, Damage states, Stances</li>
<li><strong>Condition system (D028):</strong> <code>Conditions</code> component, <code>GrantConditionOn*</code> YAML traits, <code>requires:</code>/<code>disabled_by:</code> on any component field</li>
<li><strong>Multiplier system (D028):</strong> <code>StatModifiers</code> per-entity modifier stack, fixed-point multiplication, applicable to speed/damage/range/reload/cost/sight</li>
<li><strong>Full damage pipeline (D028):</strong> Armament → Projectile entity → travel → Warhead(s) → Versus table → DamageMultiplier → Health</li>
<li><strong>Cross-game component library (D029):</strong> Mind control, carrier/spawner, teleport networks, shield system, upgrade system, delayed weapons (7 first-party systems)</li>
<li>Fixed-point coordinate system (no floats in sim)</li>
<li>Deterministic RNG</li>
<li>Pathfinding: Hierarchical A* or flowfields</li>
<li>Order system: Player inputs → Orders → deterministic sim application</li>
<li><code>LocalNetwork</code> and <code>ReplayPlayback</code> NetworkModel implementations</li>
<li>Sim snapshot/restore for save games and future rollback</li>
</ul>
<h3 id="key-architecture-work-2"><a class="header" href="#key-architecture-work-2">Key Architecture Work</a></h3>
<ul>
<li><strong>Sim/network boundary enforced:</strong> <code>ra-sim</code> has zero imports from <code>ra-net</code></li>
<li><strong><code>NetworkModel</code> trait defined and proven</strong> with at least <code>LocalNetwork</code> implementation</li>
<li><strong>System execution order documented and fixed</strong></li>
<li><strong>State hashing for desync detection</strong></li>
<li><strong>Engine telemetry foundation (D031):</strong> <code>tracing</code> span instrumentation on sim systems; per-system tick timing; gameplay event stream (<code>GameplayEvent</code> enum) behind <code>telemetry</code> feature flag; zero-cost when disabled</li>
</ul>
<h3 id="release-2"><a class="header" href="#release-2">Release</a></h3>
<p>Units moving, shooting, dying — headless sim + rendered. Record replay file. Play it back.</p>
<h3 id="exit-criteria-2"><a class="header" href="#exit-criteria-2">Exit Criteria</a></h3>
<ul>
<li>Can run 1000-unit battle headless at &gt; 60 ticks/second</li>
<li>Replay file records and plays back correctly (bit-identical)</li>
<li>State hash matches between two independent runs with same inputs</li>
<li>Condition system operational: YAML <code>requires:</code>/<code>disabled_by:</code> fields affect component behavior at runtime</li>
<li>Multiplier system operational: veterancy/terrain/crate modifiers stack and resolve correctly via fixed-point math</li>
<li>Full damage pipeline: projectile entities travel, warheads apply composable effects, Versus table resolves armor-weapon interactions</li>
<li>All 7 cross-game components functional: mind control, carriers, teleport networks, shields, upgrades, delayed weapons, dual asset rendering</li>
<li>OpenRA canonical enum names used for locomotors, armor types, target types, stances (D027)</li>
</ul>
<h2 id="phase-3-game-chrome-months-1216"><a class="header" href="#phase-3-game-chrome-months-1216">Phase 3: Game Chrome (Months 12–16)</a></h2>
<p><strong>Goal:</strong> It feels like Red Alert.</p>
<h3 id="deliverables-3"><a class="header" href="#deliverables-3">Deliverables</a></h3>
<ul>
<li>Sidebar UI: build queues, power bar, credits display, radar minimap</li>
<li>Radar panel as multi-mode display: minimap (default), comm video feed (RA2-style), tactical overlay</li>
<li>Unit selection: box select, ctrl-groups, tab cycling</li>
<li>Build placement with validity checking</li>
<li>Audio: EVA voice lines, unit responses, ambient, music (<code>.aud</code> playback)</li>
<li>Custom UI layer on <code>wgpu</code> for game HUD</li>
<li><code>egui</code> for dev tools/debug overlays</li>
<li><strong>UI theme system (D032):</strong> YAML-driven switchable themes (Classic, Remastered, Modern); chrome sprite sheets, color palettes, font configuration; shellmap live menu backgrounds; first-launch theme picker</li>
<li><strong>Per-game-module default theme:</strong> RA1 module defaults to Classic theme</li>
</ul>
<h3 id="exit-criteria-3"><a class="header" href="#exit-criteria-3">Exit Criteria</a></h3>
<ul>
<li>Single-player skirmish against scripted dummy AI (first “playable” milestone)</li>
<li>Feels like Red Alert to someone who’s played it before</li>
</ul>
<h2 id="phase-4-ai--single-player-months-1620"><a class="header" href="#phase-4-ai--single-player-months-1620">Phase 4: AI &amp; Single Player (Months 16–20)</a></h2>
<p><strong>Goal:</strong> Complete campaign support and skirmish AI. Unlike OpenRA, single-player is a first-class deliverable, not an afterthought.</p>
<h3 id="deliverables-4"><a class="header" href="#deliverables-4">Deliverables</a></h3>
<ul>
<li>Lua-based scripting for mission scripts</li>
<li>WASM mod runtime (basic)</li>
<li>Basic skirmish AI: harvest, build, attack patterns</li>
<li>Campaign mission loading (OpenRA mission format)</li>
<li><strong>Branching campaign graph engine (D021):</strong> campaigns as directed graphs of missions with named outcomes, multiple paths, and convergence points</li>
<li><strong>Persistent campaign state:</strong> unit roster carryover, veterancy across missions, equipment persistence, story flags — serializable for save games</li>
<li><strong>Lua Campaign API:</strong> <code>Campaign.complete()</code>, <code>Campaign.get_roster()</code>, <code>Campaign.get_flag()</code>, <code>Campaign.set_flag()</code>, etc.</li>
<li><strong>Continuous campaign flow:</strong> briefing → mission → debrief → next mission (no exit-to-menu between levels)</li>
<li><strong>Campaign select and mission map UI:</strong> visualize campaign graph, show current position, replay completed missions</li>
<li><strong>Adaptive difficulty via campaign state:</strong> designer-authored conditional bonuses/penalties based on cumulative performance</li>
<li><strong>FMV cutscene playback</strong> between missions (original <code>.vqa</code> briefings and victory/defeat sequences)</li>
<li><strong>Full Allied and Soviet campaigns</strong> for Red Alert, playable start to finish</li>
</ul>
<h3 id="key-architecture-work-3"><a class="header" href="#key-architecture-work-3">Key Architecture Work</a></h3>
<ul>
<li>Lua sandbox with engine bindings</li>
<li>WASM host API with capability system (see <code>06-SECURITY.md</code>)</li>
<li>Campaign graph loader + validator: parse YAML campaign definitions, validate graph connectivity (no orphan nodes, all outcome targets exist)</li>
<li><code>CampaignState</code> serialization: roster, flags, equipment, path taken — full snapshot support</li>
<li>Unit carryover system: 5 modes (<code>none</code>, <code>surviving</code>, <code>extracted</code>, <code>selected</code>, <code>custom</code>)</li>
<li>Veterancy persistence across missions</li>
<li>Mission select UI with campaign graph visualization and difficulty indicators</li>
<li><strong><code>ic</code> CLI prototype:</strong> <code>ic mod init</code>, <code>ic mod check</code>, <code>ic mod run</code> — early tooling for Lua script development (full SDK in Phase 6)</li>
</ul>
<h3 id="exit-criteria-4"><a class="header" href="#exit-criteria-4">Exit Criteria</a></h3>
<ul>
<li>Can play through <strong>all</strong> Allied and Soviet campaign missions start to finish</li>
<li>Campaign branches work: different mission outcomes lead to different next missions</li>
<li>Unit roster persists across missions (surviving units, veterancy, equipment)</li>
<li>Save/load works mid-campaign with full state preservation</li>
<li>Skirmish AI provides a basic challenge</li>
</ul>
<h2 id="phase-5-multiplayer-months-2026"><a class="header" href="#phase-5-multiplayer-months-2026">Phase 5: Multiplayer (Months 20–26)</a></h2>
<p><strong>Goal:</strong> Deterministic lockstep multiplayer with competitive infrastructure. Not just “multiplayer works” — multiplayer that’s worth switching from OpenRA for.</p>
<h3 id="deliverables-5"><a class="header" href="#deliverables-5">Deliverables</a></h3>
<ul>
<li><code>LockstepNetwork</code> implementation (input delay model)</li>
<li><code>RelayLockstepNetwork</code> implementation (relay server with time authority)</li>
<li>Desync detection and server-side debugging tools (killer feature)</li>
<li>Lobby system, game browser, NAT traversal via relay</li>
<li>Replay system (already enabled by Phase 2 architecture)</li>
<li><code>CommunityBridge</code> for shared server browser with OpenRA</li>
<li><strong>Ranked matchmaking:</strong> Glicko-2 rating system, placement matches, league tiers, 3-month seasons</li>
<li><strong>Leaderboards:</strong> global, per-faction, per-map — with public profiles and replay links</li>
<li><strong>Observer/spectator mode:</strong> connect to relay with configurable fog (full/player/none) and broadcast delay</li>
<li><strong>Tournament mode:</strong> bracket API, relay-certified <code>CertifiedMatchResult</code>, server-side replay archive</li>
<li><strong>Competitive map pool:</strong> curated per-season, community-nominated</li>
<li><strong>Anti-cheat:</strong> relay-side behavioral analysis (APM, reaction time, pattern entropy), suspicion scoring, community reports</li>
</ul>
<h3 id="key-architecture-work-4"><a class="header" href="#key-architecture-work-4">Key Architecture Work</a></h3>
<ul>
<li>Sub-tick timestamped orders (CS2 insight)</li>
<li>Relay server anti-lag-switch mechanism</li>
<li>Signed replay chain</li>
<li>Order validation in sim (anti-cheat)</li>
<li>Matchmaking service (lightweight Rust binary, same infra as tracking/relay servers)</li>
<li><code>CertifiedMatchResult</code> with Ed25519 relay signatures</li>
<li>Spectator feed: relay forwards tick orders to observers with configurable delay</li>
<li>Behavioral analysis pipeline on relay server</li>
<li><strong>Backend OTEL telemetry (D031):</strong> relay + tracking + workshop servers emit metrics/traces/logs via OpenTelemetry; <code>/healthz</code>, <code>/readyz</code>, <code>/metrics</code> endpoints; distributed trace IDs for desync debugging across clients and relay; pre-built Grafana dashboards; optional <code>docker-compose.observability.yaml</code> overlay for self-hosters</li>
</ul>
<h3 id="exit-criteria-5"><a class="header" href="#exit-criteria-5">Exit Criteria</a></h3>
<ul>
<li>Two players can play a full game over the internet</li>
<li>Desync, if it occurs, is automatically diagnosed to specific tick and entity</li>
<li>Games appear in shared server browser alongside OpenRA games</li>
<li>Ranked 1v1 queue functional with ratings, placement, and leaderboard</li>
<li>Spectator can watch a live game with broadcast delay</li>
</ul>
<h2 id="phase-6-modding--ecosystem-months-2632"><a class="header" href="#phase-6-modding--ecosystem-months-2632">Phase 6: Modding &amp; Ecosystem (Months 26–32)</a></h2>
<p><strong>Goal:</strong> This is where you win long-term.</p>
<h3 id="deliverables-6"><a class="header" href="#deliverables-6">Deliverables</a></h3>
<ul>
<li>Full OpenRA YAML rule compatibility (existing mods load)</li>
<li>WASM mod scripting with full capability system</li>
<li>In-engine map editor (OpenRA’s biggest UX gap)</li>
<li>Asset hot-reloading for mod development</li>
<li>Mod manager + workshop-style distribution</li>
<li>Tera templating for YAML generation (nice-to-have)</li>
<li><strong><code>ic</code> CLI tool (full release):</strong> <code>ic mod init/check/test/run/server/package/publish/watch/lint</code> — complete mod development workflow (D020)</li>
<li><strong>Mod templates:</strong> <code>data-mod</code>, <code>scripted-mod</code>, <code>total-conversion</code>, <code>map-pack</code>, <code>asset-pack</code> via <code>ic mod init</code></li>
<li><strong><code>mod.yaml</code> manifest</strong> with typed schema, semver engine version pinning, dependency declarations</li>
<li><strong>VS Code extension</strong> for mod development: YAML schema validation, Lua LSP, <code>ic</code> integration</li>
<li><strong>Workshop resource registry (D030):</strong> Federated multi-source workshop server with crates.io-style dependency resolution</li>
<li><strong>Dependency management CLI:</strong> <code>ic mod resolve/install/update/tree/lock/audit</code> — full dependency lifecycle</li>
<li><strong>License enforcement:</strong> Every published resource requires SPDX license; <code>ic mod audit</code> checks dependency tree compatibility</li>
<li><strong>Individual resource publishing:</strong> Music, sprites, textures, voice lines, cutscenes, palettes, UI themes — all publishable as independent versioned resources</li>
<li><strong>Lockfile system:</strong> <code>ic.lock</code> for reproducible dependency resolution across machines</li>
</ul>
<h3 id="exit-criteria-6"><a class="header" href="#exit-criteria-6">Exit Criteria</a></h3>
<ul>
<li>Someone ports an existing OpenRA mod (Tiberian Dawn, Dune 2000) and it runs</li>
<li>In-engine map editor is more capable than OpenRA’s standalone tool</li>
<li>A mod can declare 3+ Workshop resource dependencies and <code>ic mod install</code> resolves, downloads, and caches them correctly</li>
<li><code>ic mod audit</code> correctly identifies license incompatibilities in a dependency tree</li>
<li>An individual resource (e.g., a music track) can be published to and pulled from the Workshop independently</li>
</ul>
<h2 id="phase-7-ai-content--polish-months-3236"><a class="header" href="#phase-7-ai-content--polish-months-3236">Phase 7: AI Content &amp; Polish (Months 32–36+)</a></h2>
<p><strong>Goal:</strong> LLM-generated missions, visual polish, and feature parity.</p>
<h3 id="deliverables--ai-content-generation"><a class="header" href="#deliverables--ai-content-generation">Deliverables — AI Content Generation</a></h3>
<ul>
<li><code>ra-llm</code> crate: LLM integration for mission generation</li>
<li>In-game mission generator UI: describe scenario → playable mission</li>
<li>Generated output: standard YAML map + Lua trigger scripts + briefing text</li>
<li>Difficulty scaling: same scenario at different challenge levels</li>
<li>Mission sharing: rate, remix, publish generated missions</li>
<li>Campaign generation: connected multi-mission storylines (experimental)</li>
<li>Adaptive difficulty: AI observes playstyle, generates targeted challenges (experimental)</li>
<li><strong>LLM-driven Workshop resource discovery (D030):</strong> LLM searches Workshop by <code>llm_meta</code> tags, evaluates fitness, auto-pulls resources as dependencies for generated content; license-aware filtering</li>
<li><strong>AI training data pipeline (D031):</strong> gameplay event stream → OTEL collector → Parquet/Arrow columnar format → ML training; build order learning, engagement patterns, balance analysis from aggregated match telemetry</li>
</ul>
<h3 id="deliverables--visual-polish-bevy-rendering"><a class="header" href="#deliverables--visual-polish-bevy-rendering">Deliverables — Visual Polish (Bevy Rendering)</a></h3>
<ul>
<li>Full post-processing pipeline: bloom, color grading, ambient occlusion</li>
<li>Dynamic lighting: explosions, muzzle flash, day/night cycle (optional game mode)</li>
<li>GPU particle systems: smoke trails, fire propagation, weather effects (rain, snow, sandstorm, fog, blizzard, storm — see <code>04-MODDING.md</code> § “weather scene template”)</li>
<li>Weather system: per-map or trigger-based, render-only or with optional sim effects (visibility, speed modifiers)</li>
<li>Polished shader effects: chrono-shift, iron curtain, gap generator, nuke flash</li>
<li>Cinematic replay camera with smooth interpolation</li>
</ul>
<h3 id="deliverables--platform--ecosystem"><a class="header" href="#deliverables--platform--ecosystem">Deliverables — Platform &amp; Ecosystem</a></h3>
<ul>
<li>Feature parity checklist vs OpenRA</li>
<li>Web build via WASM (play in browser)</li>
<li>Mobile touch controls</li>
<li>Accessibility features</li>
<li>Community infrastructure: website, mod registry, matchmaking server</li>
</ul>
<h3 id="exit-criteria-7"><a class="header" href="#exit-criteria-7">Exit Criteria</a></h3>
<ul>
<li>A competitive OpenRA player can switch and feel at home</li>
<li>LLM mission generator produces varied, fun, playable missions</li>
<li>Browser version is playable</li>
<li>At least one total conversion mod exists on the platform</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="09--decision-log"><a class="header" href="#09--decision-log">09 — Decision Log</a></h1>
<p>Every major design decision, with rationale and alternatives considered. Reference this when revisiting or challenging a decision.</p>
<hr>
<h2 id="d001-language--rust"><a class="header" href="#d001-language--rust">D001: Language — Rust</a></h2>
<p><strong>Decision:</strong> Build the engine in Rust.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>No GC pauses (C# / .NET is OpenRA’s known weakness in large battles)</li>
<li>Memory safety without runtime cost</li>
<li>Fearless concurrency for parallel ECS systems</li>
<li>First-class WASM compilation target (browser, modding sandbox)</li>
<li>Modern tooling (cargo, crates.io, clippy, miri)</li>
<li>No competition in Rust RTS space — wide open field</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>C++ (manual memory management, no safety guarantees, build system pain)</li>
<li>C# (would just be another OpenRA — no differentiation)</li>
<li>Zig (too immature ecosystem for this scope)</li>
</ul>
<hr>
<h2 id="d002-framework--bevy-revised-from-original-no-bevy-decision"><a class="header" href="#d002-framework--bevy-revised-from-original-no-bevy-decision">D002: Framework — Bevy (REVISED from original “No Bevy” decision)</a></h2>
<p><strong>Decision:</strong> Use Bevy as the game framework.</p>
<p><strong>Original decision:</strong> Custom library stack (winit + wgpu + hecs). This was overridden.</p>
<p><strong>Why the reversal:</strong></p>
<ul>
<li>The 2-4 months building engine infrastructure (sprite batching, cameras, audio, input, asset pipeline, hot reload) is time NOT spent on the sim, netcode, and modding — the things that differentiate this project</li>
<li>Bevy’s ECS IS our architecture — no “fighting two systems.” OpenRA traits map directly to Bevy components</li>
<li><code>FixedUpdate</code> + <code>.chain()</code> gives deterministic sim scheduling natively</li>
<li>Bevy’s plugin system makes pluggable networking cleaner than the original trait-based design</li>
<li>Headless mode (<code>MinimalPlugins</code>) for dedicated servers is built in</li>
<li>WASM/browser target is tested by community</li>
<li><code>bevy_reflect</code> enables advanced modding capabilities</li>
<li>Breaking API changes are manageable: pin version per phase, upgrade between phases</li>
</ul>
<p><strong>Risk mitigation:</strong></p>
<ul>
<li>Breaking changes → version pinning per development phase</li>
<li>Not isometric-specific → build isometric layer on Bevy’s 2D (still less work than raw wgpu)</li>
<li>Performance concerns → Bevy uses rayon internally, <code>par_iter()</code> for data parallelism, and allows custom render passes and SIMD where needed</li>
</ul>
<hr>
<h2 id="d003-data-format--real-yaml-not-miniyaml"><a class="header" href="#d003-data-format--real-yaml-not-miniyaml">D003: Data Format — Real YAML, Not MiniYAML</a></h2>
<p><strong>Decision:</strong> Use standard spec-compliant YAML with <code>serde_yaml</code>. Not OpenRA’s MiniYAML.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Standard YAML parsers, linters, formatters, editor support all work</li>
<li><code>serde_yaml</code> → typed Rust struct deserialization for free</li>
<li>JSON-schema validation catches errors before game loads</li>
<li>No custom parser to maintain</li>
<li>Inheritance resolved at load time as a processing pass, not a parser feature</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>MiniYAML as-is (rejected — custom parser, no tooling support, not spec-compliant)</li>
<li>TOML (rejected — awkward for deeply nested game data)</li>
<li>RON (rejected — modders won’t know it, thin editor support)</li>
<li>JSON (rejected — too verbose, no comments)</li>
</ul>
<p><strong>Migration:</strong> <code>miniyaml2yaml</code> converter tool in <code>ra-formats</code> crate.</p>
<hr>
<h2 id="d004-modding--lua-not-python-for-scripting"><a class="header" href="#d004-modding--lua-not-python-for-scripting">D004: Modding — Lua (Not Python) for Scripting</a></h2>
<p><strong>Decision:</strong> Use Lua for Tier 2 scripting. Do NOT use Python.</p>
<p><strong>Rationale against Python:</strong></p>
<ul>
<li>Floating-point non-determinism breaks lockstep multiplayer</li>
<li>GC pauses (reintroduces the problem Rust solves)</li>
<li>50-100x slower than native (hot paths run every tick for every unit)</li>
<li>Embedding CPython is heavy (~15-30MB)</li>
<li>Sandboxing is unsolvable — security disaster for community mods</li>
</ul>
<p><strong>Rationale for Lua:</strong></p>
<ul>
<li>Tiny runtime (~200KB), designed for embedding</li>
<li>Deterministic (provide fixed-point bindings, avoid floats)</li>
<li>Trivially sandboxable (control available functions)</li>
<li>Industry standard: Factorio, WoW, Dota 2, Roblox</li>
<li><code>mlua</code>/<code>rlua</code> crates are mature</li>
<li>Any modder can learn in an afternoon</li>
</ul>
<hr>
<h2 id="d005-modding--wasm-for-power-users-tier-3"><a class="header" href="#d005-modding--wasm-for-power-users-tier-3">D005: Modding — WASM for Power Users (Tier 3)</a></h2>
<p><strong>Decision:</strong> WASM modules via <code>wasmtime</code>/<code>wasmer</code> for advanced mods.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Near-native performance</li>
<li>Perfectly sandboxed by design</li>
<li>Deterministic execution (critical for multiplayer)</li>
<li>Modders can write in Rust, C, Go, AssemblyScript, or Python-to-WASM</li>
<li>Leapfrogs OpenRA (requires C# for deep mods)</li>
</ul>
<hr>
<h2 id="d006-networking--pluggable-via-trait"><a class="header" href="#d006-networking--pluggable-via-trait">D006: Networking — Pluggable via Trait</a></h2>
<p><strong>Decision:</strong> Abstract all networking behind a <code>NetworkModel</code> trait. Game loop is generic over it.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Sim never touches networking concerns (clean boundary)</li>
<li>Full testability (run sim with <code>LocalNetwork</code>)</li>
<li>Community can contribute netcode without understanding game logic</li>
<li>Enables future models: rollback, client-server, cross-engine adapters</li>
<li>Players could choose model in lobby</li>
</ul>
<p><strong>Key invariant:</strong> <code>ra-sim</code> has zero imports from <code>ra-net</code>. They only share <code>ra-protocol</code>.</p>
<hr>
<h2 id="d007-networking--relay-server-as-default"><a class="header" href="#d007-networking--relay-server-as-default">D007: Networking — Relay Server as Default</a></h2>
<p><strong>Decision:</strong> Default multiplayer uses relay server with time authority, not pure P2P.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Blocks lag switches (server owns the clock)</li>
<li>Enables sub-tick chronological ordering (CS2 insight)</li>
<li>Handles NAT traversal (no port forwarding)</li>
<li>Enables order validation before broadcast (anti-cheat)</li>
<li>Signed replays</li>
<li>Cheap to run (doesn’t run sim, just forwards orders)</li>
</ul>
<p><strong>Alternatives available:</strong> Pure P2P lockstep, fog-authoritative server, rollback — all implementable as <code>NetworkModel</code> variants.</p>
<hr>
<h2 id="d008-sub-tick-timestamps-on-orders"><a class="header" href="#d008-sub-tick-timestamps-on-orders">D008: Sub-Tick Timestamps on Orders</a></h2>
<p><strong>Decision:</strong> Every order carries a sub-tick timestamp. Orders within a tick are processed in chronological order.</p>
<p><strong>Rationale (inspired by CS2):</strong></p>
<ul>
<li>Fairer results for edge cases (two players competing for same resource/building)</li>
<li>Trivial to implement (just attach timestamp at input layer)</li>
<li>Network model preserves but doesn’t depend on timestamps</li>
<li>If a future model ignores timestamps, no breakage</li>
</ul>
<hr>
<h2 id="d009-simulation--fixed-point-math-no-floats"><a class="header" href="#d009-simulation--fixed-point-math-no-floats">D009: Simulation — Fixed-Point Math, No Floats</a></h2>
<p><strong>Decision:</strong> All sim-layer calculations use integer/fixed-point arithmetic. Floats allowed only for rendering interpolation.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Required for deterministic lockstep (floats can produce different results across platforms)</li>
<li>Original Red Alert used integer math — proven approach</li>
<li>OpenRA uses <code>WDist</code>/<code>WPos</code>/<code>WAngle</code> with 1024 subdivisions — same principle</li>
</ul>
<hr>
<h2 id="d010-simulation--snapshottable-state"><a class="header" href="#d010-simulation--snapshottable-state">D010: Simulation — Snapshottable State</a></h2>
<p><strong>Decision:</strong> Full sim state must be serializable/deserializable at any tick.</p>
<p><strong>Rationale enables:</strong></p>
<ul>
<li>Save games (trivially)</li>
<li>Replay system (initial state + orders)</li>
<li>Desync debugging (diff snapshots between clients at divergence point)</li>
<li>Rollback netcode (restore state N frames back, replay with corrected inputs)</li>
<li>Cross-engine reconciliation (restore from authoritative checkpoint)</li>
<li>Automated testing (load known state, apply inputs, verify result)</li>
</ul>
<hr>
<h2 id="d011-cross-engine-play--community-layer-not-sim-layer"><a class="header" href="#d011-cross-engine-play--community-layer-not-sim-layer">D011: Cross-Engine Play — Community Layer, Not Sim Layer</a></h2>
<p><strong>Decision:</strong> Cross-engine compatibility targets data/community layer. NOT bit-identical simulation.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Bit-identical sim requires bug-for-bug reimplementation (that’s a port, not our engine)</li>
<li>Community interop is valuable and achievable: shared server browser, maps, mod format</li>
<li>Architecture keeps the door open for deeper interop later (OrderCodec, SimReconciler, ProtocolAdapter)</li>
<li>Progressive levels: shared lobby → replay viewing → casual cross-play → competitive cross-play</li>
</ul>
<hr>
<h2 id="d012-security--validate-orders-in-sim"><a class="header" href="#d012-security--validate-orders-in-sim">D012: Security — Validate Orders in Sim</a></h2>
<p><strong>Decision:</strong> Every order is validated inside the simulation before execution. Validation is deterministic.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>All clients run same validation → agree on rejections → no desync</li>
<li>Defense in depth with relay server validation</li>
<li>Repeated rejections indicate cheating (loggable)</li>
<li>No separate “anti-cheat” system — validation IS anti-cheat</li>
</ul>
<hr>
<h2 id="d013-pathfinding--hierarchical-a-or-flowfields"><a class="header" href="#d013-pathfinding--hierarchical-a-or-flowfields">D013: Pathfinding — Hierarchical A* or Flowfields</a></h2>
<p><strong>Decision:</strong> Use advanced pathfinding (hierarchical A* or flowfields), not basic A*.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>OpenRA uses basic A* which struggles with large unit groups</li>
<li>Hierarchical/flowfield pathfinding handles mass movement far better</li>
<li>Well-suited to grid-based terrain</li>
<li>One of the visible performance improvements that makes people switch</li>
</ul>
<hr>
<h2 id="d014-templating--tera-in-phase-6-nice-to-have"><a class="header" href="#d014-templating--tera-in-phase-6-nice-to-have">D014: Templating — Tera in Phase 6 (Nice-to-Have)</a></h2>
<p><strong>Decision:</strong> Add Tera template engine for YAML/Lua generation. Phase 6. Not foundational.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Eliminates copy-paste for faction variants, bulk unit generation</li>
<li>Load-time only (zero runtime cost)</li>
<li>~50 lines to integrate</li>
<li>Optional — no mod depends on it</li>
</ul>
<hr>
<h2 id="d015-performance--efficiency-first-not-thread-first"><a class="header" href="#d015-performance--efficiency-first-not-thread-first">D015: Performance — Efficiency-First, Not Thread-First</a></h2>
<p><strong>Decision:</strong> Performance is achieved through algorithmic efficiency, cache-friendly data layout, adaptive workload, zero allocation, and amortized computation. Multi-core scaling is a bonus layer on top, not the foundation.</p>
<p><strong>Principle:</strong> The engine must run a 500-unit battle smoothly on a 2-core, 4GB machine from 2012. Multi-core machines get higher unit counts as a natural consequence of the work-stealing scheduler.</p>
<p><strong>The Efficiency Pyramid (ordered by impact):</strong></p>
<ol>
<li>Algorithmic efficiency (flowfields, spatial hash, hierarchical pathfinding)</li>
<li>Cache-friendly ECS layout (hot/warm/cold component separation)</li>
<li>Simulation LOD (skip work that doesn’t affect the outcome)</li>
<li>Amortized work (stagger expensive systems across ticks)</li>
<li>Zero-allocation hot paths (pre-allocated scratch buffers)</li>
<li>Work-stealing parallelism (rayon via Bevy — bonus, not foundation)</li>
</ol>
<p><strong>Inspired by:</strong> Datadog Vector’s pipeline efficiency, Tokio’s work-stealing runtime. These systems are fast because they waste nothing, not because they use more hardware.</p>
<p><strong>Anti-pattern rejected:</strong> “Just parallelize it” as the default answer. Parallelism without algorithmic efficiency is adding lanes to a highway with broken traffic lights.</p>
<p>See <code>10-PERFORMANCE.md</code> for full details, targets, and implementation patterns.</p>
<hr>
<h2 id="d016-llm-generated-missions-and-campaigns"><a class="header" href="#d016-llm-generated-missions-and-campaigns">D016: LLM-Generated Missions and Campaigns</a></h2>
<p><strong>Decision:</strong> Integrate LLM-powered mission generation as a first-class feature (Phase 7), with an in-game UI for describing scenarios in natural language.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Transforms Red Alert from finite content to infinite content</li>
<li>Generated output is standard YAML + Lua — fully editable, shareable, learnable</li>
<li>No other RTS (Red Alert or otherwise) offers this capability</li>
<li>LLM quality is sufficient for terrain layout, objective design, AI behavior scripting</li>
<li>Modular: <code>ra-llm</code> crate is optional, game works without it</li>
</ul>
<p><strong>Scope:</strong></p>
<ul>
<li>Phase 7: single mission generation (terrain, objectives, enemy composition, triggers, briefing)</li>
<li>Future: multi-mission campaigns, adaptive difficulty, cooperative scenario design</li>
</ul>
<p><strong>Implementation approach:</strong></p>
<ul>
<li>LLM generates YAML map definition + Lua trigger scripts</li>
<li>Same format as hand-crafted missions — no special runtime</li>
<li>Validation pass ensures generated content is playable (valid unit types, reachable objectives)</li>
<li>Can use local models or API-based models (user choice)</li>
</ul>
<p><strong>Bring-Your-Own-LLM (BYOLLM) architecture:</strong></p>
<ul>
<li><code>ra-llm</code> defines a <code>LlmProvider</code> trait — any backend that accepts a prompt and returns structured text</li>
<li>Built-in providers: OpenAI-compatible API, local Ollama/llama.cpp, Anthropic API</li>
<li>Users configure their provider in settings (API key, endpoint, model name)</li>
<li>The engine never ships or requires a specific model — the user chooses</li>
<li>Provider is a runtime setting, not a compile-time dependency</li>
<li>All prompts and responses are logged (opt-in) for debugging and sharing</li>
<li>Offline mode: pre-generated content works without any LLM connection</li>
</ul>
<hr>
<h2 id="d017-bevy-rendering-pipeline-for-visual-enhancement"><a class="header" href="#d017-bevy-rendering-pipeline-for-visual-enhancement">D017: Bevy Rendering Pipeline for Visual Enhancement</a></h2>
<p><strong>Decision:</strong> Leverage Bevy’s modern rendering pipeline (wgpu, shaders, post-processing) to deliver visual quality beyond both OpenRA and the Remastered Collection while maintaining the classic isometric aesthetic.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>OpenRA’s renderer has evolved (post-processing added in March 2025) but remains limited by its C#/.NET architecture</li>
<li>Remastered Collection has HD sprites but the renderer is proprietary and not extensible by modders</li>
<li>Bevy + wgpu enables: bloom, color grading, dynamic lighting, GPU particles, custom shaders</li>
<li>Classic aesthetic preserved — these are enhancements, not a style change</li>
<li>Shader effects bring special abilities to life: chrono-shift shimmer, tesla arcs, nuclear flash</li>
</ul>
<p><strong>Scope:</strong></p>
<ul>
<li>Phase 1: basic post-processing prototypes (bloom, color grading)</li>
<li>Phase 3: polished effects for game chrome</li>
<li>Phase 7: full visual pipeline (dynamic lighting, particles, weather, cinematic camera)</li>
</ul>
<p><strong>Design principle:</strong> The game should look like Red Alert remembered through rose-tinted glasses. Better than you remember, but unmistakably Red Alert.</p>
<hr>
<h2 id="d018-multi-game-extensibility-game-modules"><a class="header" href="#d018-multi-game-extensibility-game-modules">D018: Multi-Game Extensibility (Game Modules)</a></h2>
<p><strong>Decision:</strong> Design the engine as a game-agnostic RTS framework. Red Alert is the first “game module”; RA2, Tiberian Dawn, and original games should be addable as additional modules without modifying core engine code.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>OpenRA already proves this works — runs TD, RA, and D2K on one engine via different trait/component sets</li>
<li>The ECS architecture naturally supports this (composable components, pluggable systems)</li>
<li>Prevents RA1 assumptions from hardening into architectural constraints that require rewrites later</li>
<li>Broadens the project’s audience and contributor base</li>
<li>RA2 is the most-requested extension — community interest is proven (Chrono Divide exists)</li>
</ul>
<p><strong>Concrete changes (baked in from Phase 0):</strong></p>
<ol>
<li><code>WorldPos</code> and <code>CellPos</code> carry a Z coordinate from day one (RA1 sets z=0)</li>
<li>System execution order is registered per game module, not hardcoded in engine</li>
<li>No game-specific enums in engine core — resource types, unit categories come from YAML / module registration</li>
<li>Renderer uses a <code>Renderable</code> trait — sprite and voxel backends implement it equally</li>
<li><code>GameModule</code> trait bundles component registration, system pipeline, format loaders, and render backends</li>
<li><code>PlayerOrder</code> is extensible to game-specific commands</li>
</ol>
<p><strong>What this does NOT mean:</strong></p>
<ul>
<li>We don’t build RA2 support now. Red Alert is the sole focus until it ships.</li>
<li>We don’t add speculative abstractions. Only the six concrete changes above.</li>
<li>We don’t rename crates from <code>ra-*</code> — the project identity is Red Alert. Game modules extend it.</li>
</ul>
<p><strong>Scope boundary — the isometric C&amp;C family:</strong>
Game module extensibility targets: Red Alert, RA2, Tiberian Sun, Tiberian Dawn, Dune 2000. These share the isometric camera, grid-based terrain, sprite/voxel rendering, and <code>.mix</code> format lineage. <strong>3D titles (Generals, C&amp;C3, RA3) are out of scope as game modules</strong> — they require free-rotating cameras, mesh rendering, navmesh pathfinding, and unrelated formats. ~60% of the engine wouldn’t carry over. If desired later, extract the game-agnostic sim core into a shared RTS framework crate and build a 3D frontend independently.</p>
<p>However, <strong>3D rendering mods for isometric-family games are explicitly supported.</strong> A “3D Red Alert” Tier 3 mod can replace sprites with GLTF meshes and the isometric camera with a free 3D camera — without changing the sim, networking, or pathfinding. Bevy’s built-in 3D pipeline makes this feasible. Cross-view multiplayer (2D vs 3D players in the same game) works because the sim is view-agnostic. See <code>02-ARCHITECTURE.md</code> § “3D Rendering as a Mod”.</p>
<p><strong>Phase:</strong> Baked into architecture from Phase 0. RA2 module is a potential Phase 8+ project.</p>
<hr>
<h2 id="d019-switchable-balance-presets-classic-ra-vs-openra"><a class="header" href="#d019-switchable-balance-presets-classic-ra-vs-openra">D019: Switchable Balance Presets (Classic RA vs OpenRA)</a></h2>
<p><strong>Decision:</strong> Ship multiple balance presets as first-class YAML rule sets. Default to classic Red Alert values from the EA source code. OpenRA balance available as an alternative preset. Selectable per-game in lobby.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Original Red Alert’s balance makes units feel <strong>powerful and iconic</strong> — Tanya, MiGs, Tesla Coils, V2 rockets are devastating. This is what made the game memorable.</li>
<li>OpenRA rebalances toward competitive fairness, which can dilute the personality of iconic units. Valid for tournaments, wrong as a default.</li>
<li>The community is split on this. Rather than picking a side, expose it as a choice.</li>
<li>Presets are just alternate YAML files loaded at game start — zero engine complexity. The modding system already supports this via inheritance and overrides.</li>
<li>The Remastered Collection made its own subtle balance tweaks — worth capturing as a third preset.</li>
</ul>
<p><strong>Implementation:</strong></p>
<ul>
<li><code>rules/presets/classic/</code> — unit/weapon/structure values from EA source code (default)</li>
<li><code>rules/presets/openra/</code> — values matching OpenRA’s current balance</li>
<li><code>rules/presets/remastered/</code> — values matching the Remastered Collection</li>
<li>Preset selection exposed in lobby UI and stored in game settings</li>
<li>Presets use YAML inheritance: only override fields that differ from <code>classic</code></li>
<li>Multiplayer: all players must use the same preset (enforced by lobby, validated by sim)</li>
<li>Custom presets: modders can create new presets as additional YAML directories</li>
</ul>
<p><strong>What this is NOT:</strong></p>
<ul>
<li>Not a “difficulty setting” — both presets play at normal difficulty</li>
<li>Not a mod — it’s a first-class game option, no workshop download required</li>
<li>Not just multiplayer — applies to skirmish and campaign too</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Only ship classic values (rejected — alienates OpenRA competitive community)</li>
<li>Only ship OpenRA values (rejected — loses the original game’s personality)</li>
<li>Let mods handle it (rejected — too important to bury in the modding system; should be one click in settings)</li>
</ul>
<p><strong>Phase:</strong> Phase 2 (balance values extracted during simulation implementation).</p>
<hr>
<h3 id="d020--mod-sdk-with-ic-cli-tool"><a class="header" href="#d020--mod-sdk-with-ic-cli-tool">D020 — Mod SDK with <code>ic</code> CLI Tool</a></h3>
<p><strong>Decision:</strong> Ship a Mod SDK as a <code>cargo-generate</code> template + an <code>ic</code> CLI tool, inspired by (and improving on) the <a href="https://github.com/OpenRA/OpenRAModSDK">OpenRA Mod SDK</a>.</p>
<p><strong>Context:</strong> The OpenRA Mod SDK is a template repository modders fork. It bundles shell scripts (<code>fetch-engine.sh</code>, <code>launch-game.sh</code>, <code>utility.sh</code>), a <code>Makefile</code>/<code>make.cmd</code> build system, and a <code>packaging/</code> directory with per-platform installer scripts. The approach works — it’s the standard way to create OpenRA mods. But it has significant friction: requires .NET SDK, custom C# DLLs for anything beyond data changes, MiniYAML with no validation tooling, GPL contamination on mod code, and no distribution system beyond manual file sharing.</p>
<p><strong>What we adapt:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concept</th><th>OpenRA SDK</th><th>Iron Curtain</th></tr>
</thead>
<tbody>
<tr><td>Starting point</td><td>Fork a template repo</td><td><code>ic mod init [template]</code> via <code>cargo-generate</code></td></tr>
<tr><td>Engine version pin</td><td><code>ENGINE_VERSION</code> in <code>mod.config</code></td><td><code>engine.version</code> in <code>mod.yaml</code> with semver</td></tr>
<tr><td>Engine management</td><td><code>fetch-engine.sh</code> downloads + compiles from source</td><td>Engine ships as binary crate, auto-resolved</td></tr>
<tr><td>Build/run</td><td><code>Makefile</code> + shell scripts (requires Python, .NET)</td><td><code>ic</code> CLI — single Rust binary, zero dependencies</td></tr>
<tr><td>Mod manifest</td><td><code>mod.yaml</code> in MiniYAML</td><td><code>mod.yaml</code> in real YAML with typed serde schema</td></tr>
<tr><td>Validation</td><td><code>utility.sh --check-yaml</code></td><td><code>ic mod check</code> — YAML + Lua + WASM validation</td></tr>
<tr><td>Packaging</td><td><code>packaging/</code> shell scripts → .exe/.app/.AppImage</td><td><code>ic mod package</code> + workshop publish</td></tr>
<tr><td>Dedicated server</td><td><code>launch-dedicated.sh</code></td><td><code>ic mod server</code></td></tr>
<tr><td>Directory layout</td><td>Convention-based (chrome/, rules/, maps/, etc.)</td><td>Adapted for three-tier model</td></tr>
<tr><td>IDE support</td><td><code>.vscode/</code> in repo</td><td>VS Code extension with YAML schema + Lua LSP</td></tr>
</tbody>
</table>
</div>
<p><strong>What we don’t adapt (pain points we solve differently):</strong></p>
<ul>
<li>C# DLLs for custom traits → our Lua + WASM tiers are strictly better (no compilation, sandboxed, polyglot)</li>
<li>GPL license contamination → WASM sandbox means mod code is isolated; engine license doesn’t infect mods</li>
<li>MiniYAML → real YAML with <code>serde_yaml</code>, JSON Schema, standard linters</li>
<li>No hot-reload → Lua and YAML hot-reload during <code>ic mod watch</code></li>
<li>No workshop → built-in workshop with <code>ic mod publish</code></li>
</ul>
<p><strong>The <code>ic</code> CLI tool:</strong>
A single Rust binary replacing OpenRA’s shell scripts + Makefile + Python dependencies:</p>
<pre><code>ic mod init [template]     # scaffold from template
ic mod check               # validate all mod content
ic mod test                # headless smoke test
ic mod run                 # launch game with mod
ic mod server              # dedicated server
ic mod package             # build distributables
ic mod publish             # workshop upload
ic mod watch               # hot-reload dev mode
ic mod lint                # convention + llm: metadata checks
ic mod update-engine       # bump engine version
</code></pre>
<p><strong>Mod templates (built-in):</strong></p>
<ul>
<li><code>data-mod</code> — YAML-only balance/cosmetic mods</li>
<li><code>scripted-mod</code> — missions and custom game modes (YAML + Lua)</li>
<li><code>total-conversion</code> — full layout with WASM scaffolding</li>
<li><code>map-pack</code> — map collections</li>
<li><code>asset-pack</code> — sprites, sounds, video packs</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li>OpenRA’s SDK validates the template-project approach — modders want a turnkey starting point</li>
<li>Engine version pinning is essential — mods break when engine updates; semver solves this cleanly</li>
<li>A CLI tool is more portable, discoverable, and maintainable than shell scripts + Makefiles</li>
<li>Workshop integration from the CLI closes the “last mile” — OpenRA modders must manually distribute their work</li>
<li>The three-tier modding system means most modders never compile anything — <code>ic mod init data-mod</code> gives you a working mod instantly</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Shell scripts like OpenRA (rejected — cross-platform pain, Python/shell dependencies, fragile)</li>
<li>Cargo workspace (rejected — mods aren’t Rust crates; YAML/Lua mods have nothing to compile)</li>
<li>In-engine mod editor only (rejected — power users want filesystem access and version control)</li>
<li>No SDK, just documentation (rejected — OpenRA proves that a template project dramatically lowers the barrier)</li>
</ul>
<p><strong>Phase:</strong> Phase 6 (Modding &amp; Ecosystem). CLI prototype in Phase 4 (for Lua scripting development).</p>
<hr>
<h3 id="d021--branching-campaign-system-with-persistent-state"><a class="header" href="#d021--branching-campaign-system-with-persistent-state">D021 — Branching Campaign System with Persistent State</a></h3>
<p><strong>Decision:</strong> Campaigns are directed graphs of missions with named outcomes, branching paths, persistent unit rosters, and continuous flow — not linear sequences with binary win/lose. Failure doesn’t end the campaign; it branches to a different path. Unit state, equipment, and story flags persist across missions.</p>
<p><strong>Context:</strong> OpenRA’s campaigns are disconnected — each mission is standalone, you exit to menu after completion, there’s no sense of flow or consequence. The original Red Alert had linear progression with FMV briefings but no branching or state persistence. Games like Operation Flashpoint: Cold War Crisis showed that branching outcomes create dramatically more engaging campaigns, and OFP: Resistance proved that persistent unit rosters (surviving soldiers, captured equipment, accumulated experience) create deep emotional investment.</p>
<p><strong>Key design points:</strong></p>
<ol>
<li>
<p><strong>Campaign graph:</strong> Missions are nodes in a directed graph. Each mission has named outcomes (not just win/lose). Each outcome maps to a next-mission node, forming branches and convergences. The graph is defined in YAML and validated at load time.</p>
</li>
<li>
<p><strong>Named outcomes:</strong> Lua scripts signal completion with a named key: <code>Campaign.complete("victory_bridge_intact")</code>. The campaign YAML maps each outcome to the next mission. This enables rich branching: “Won cleanly” → easy path, “Won with heavy losses” → harder path, “Failed” → fallback mission.</p>
</li>
<li>
<p><strong>Failure continues the game:</strong> A <code>defeat</code> outcome is just another edge in the graph. The campaign designer decides what happens: retry with fewer resources, branch to a retreating mission, skip ahead with consequences, or even “no game over” campaigns where the story always continues.</p>
</li>
<li>
<p><strong>Persistent unit roster (OFP: Resistance model):</strong></p>
<ul>
<li>Surviving units carry forward between missions (configurable per transition)</li>
<li>Units accumulate veterancy across missions — a veteran tank from mission 1 stays veteran in mission 5</li>
<li>Dead units are gone permanently — losing veterans hurts</li>
<li>Captured enemy equipment joins a persistent equipment pool</li>
<li>Five carryover modes: <code>none</code>, <code>surviving</code>, <code>extracted</code> (only units in evac zone), <code>selected</code> (Lua picks), <code>custom</code> (full Lua control)</li>
</ul>
</li>
<li>
<p><strong>Story flags:</strong> Arbitrary key-value state writable from Lua, readable in subsequent missions. Enables conditional content: “If the radar was captured in mission 2, it provides intel in mission 4.”</p>
</li>
<li>
<p><strong>Campaign state is serializable:</strong> Fits D010 (snapshottable sim state). Save games capture full campaign progress including roster, flags, and path taken. Replays can replay entire campaign runs.</p>
</li>
<li>
<p><strong>Continuous flow:</strong> Briefing → mission → debrief → next mission. No exit to menu between levels unless the player explicitly quits.</p>
</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>OpenRA’s disconnected missions are its single biggest single-player UX failure — universally cited in community feedback</li>
<li>OFP proved persistent rosters create investment: players restart missions to save a veteran soldier</li>
<li>Branching eliminates the frustration of replaying the same mission on failure — the campaign adapts</li>
<li>YAML graph definition is accessible to modders (Tier 1) and LLM-generable</li>
<li>Lua campaign API enables complex state logic while staying sandboxed</li>
<li>The same system works for hand-crafted campaigns, modded campaigns, and LLM-generated campaigns</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Linear mission sequence like RA1 (rejected — primitive, no replayability, failure is frustrating)</li>
<li>Disconnected missions like OpenRA (rejected — the specific problem we’re solving)</li>
<li>Full open-world (rejected — scope too large, not appropriate for RTS)</li>
<li>Only branching on win/lose (rejected — named outcomes are trivially more expressive with no added complexity)</li>
<li>No unit persistence (rejected — OFP: Resistance proves this is the feature that creates campaign investment)</li>
</ul>
<p><strong>Phase:</strong> Phase 4 (AI &amp; Single Player). Campaign graph engine and Lua Campaign API are core Phase 4 deliverables.</p>
<hr>
<h3 id="d022--dynamic-weather-with-terrain-surface-effects"><a class="header" href="#d022--dynamic-weather-with-terrain-surface-effects">D022 — Dynamic Weather with Terrain Surface Effects</a></h3>
<p><strong>Decision:</strong> Weather transitions dynamically during gameplay via a deterministic state machine, and terrain textures visually respond to weather — snow accumulates on the ground, rain darkens/wets surfaces, sunshine dries them out. Terrain surface state optionally affects gameplay (movement penalties on snow/ice/mud).</p>
<p><strong>Context:</strong> The base weather system (static per-mission, GPU particles + sim modifiers) provides atmosphere but doesn’t evolve. Real-world weather changes. A mission that starts sunny and ends in a blizzard is vastly more dramatic — and strategically different — than one where weather is set-and-forget.</p>
<p><strong>Key design points:</strong></p>
<ol>
<li>
<p><strong>Weather state machine (sim-side):</strong> <code>WeatherState</code> resource tracks current type, intensity (fixed-point <code>0..1024</code>), and transition progress. Three schedule modes: <code>cycle</code> (deterministic round-robin), <code>random</code> (seeded from match, deterministic), <code>scripted</code> (Lua-driven only). State machine graph and transition weights defined in map YAML.</p>
</li>
<li>
<p><strong>Terrain surface state (sim-side):</strong> <code>TerrainSurfaceGrid</code> — a per-cell grid of <code>SurfaceCondition { snow_depth, wetness }</code>. Updated every tick by <code>weather_surface_system</code>. Fully deterministic, derives <code>Serialize, Deserialize</code> for snapshots. When <code>sim_effects: true</code>, surface state modifies movement: deep snow slows infantry/vehicles, ice makes water passable, mud bogs wheeled units.</p>
</li>
<li>
<p><strong>Terrain texture effects (render-side):</strong> Three quality tiers — palette tinting (free, no assets needed), overlay sprites (moderate, one extra pass), shader blending (GPU blend between base + weather variant textures). Selectable via <code>RenderSettings</code>. Accumulation is gradual and spatially non-uniform (snow appears on edges/roofs first, puddles in low cells first).</p>
</li>
<li>
<p><strong>Composes with day/night and seasons:</strong> Overcast days are darker, rain at night is near-black with lightning flashes. Map <code>temperature.base</code> controls whether precipitation is rain or snow. Arctic/desert/tropical maps set different defaults.</p>
</li>
<li>
<p><strong>Fully moddable:</strong> YAML defines schedules and surface rates (Tier 1). Lua triggers transitions and queries surface state (Tier 2). WASM adds custom weather types like ion storms (Tier 3).</p>
</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>No other C&amp;C engine has dynamic weather that affects terrain visuals — unique differentiator</li>
<li>Deterministic state machine preserves lockstep (same seed = same weather progression on all clients)</li>
<li>Sim/render split respected: surface state is sim (deterministic), visual blending is render (cosmetic)</li>
<li>Palette tinting tier ensures even low-end devices and WASM can show weather effects</li>
<li>Gameplay effects are optional per-map — purely cosmetic weather is valid</li>
<li>Surface state fits the snapshot system (D010) for save games and replays</li>
<li>Weather schedules are LLM-generable — “generate a mission where weather gets progressively worse”</li>
</ul>
<p><strong>Performance:</strong></p>
<ul>
<li>Palette tinting: zero extra draw calls, negligible GPU cost</li>
<li>Surface state grid: ~2 bytes per cell (compact fixed-point) — a 128×128 map is 32KB</li>
<li><code>weather_surface_system</code> is O(cells) but amortizable (update every 4 ticks for non-visible cells)</li>
<li>Follows efficiency pyramid: algorithmic (grid lookup) → cache-friendly (contiguous array) → amortized</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Static weather only (rejected — misses dramatic potential, no terrain response)</li>
<li>Client-side random weather (rejected — breaks deterministic sim, desync risk)</li>
<li>Full volumetric weather simulation (rejected — overkill, performance cost, not needed for isometric RTS)</li>
<li>Always-on sim effects (rejected — weather-as-decoration is valid for casual/modded games)</li>
</ul>
<p><strong>Phase:</strong> Phase 3 (visual effects) for render-side; Phase 2 (sim implementation) for weather state machine and surface grid.</p>
<hr>
<h3 id="d023--openra-vocabulary-compatibility-layer"><a class="header" href="#d023--openra-vocabulary-compatibility-layer">D023 — OpenRA Vocabulary Compatibility Layer</a></h3>
<p><strong>Decision:</strong> Accept OpenRA trait names and YAML keys as aliases in our YAML parser. Both OpenRA-style names (e.g., <code>Armament</code>, <code>Valued</code>, <code>Buildable</code>) and IC-native names (e.g., <code>combat</code>, <code>buildable.cost</code>) resolve to the same ECS components. Unconverted OpenRA YAML loads with a deprecation warning.</p>
<p><strong>Context:</strong> The biggest migration barrier for the 80% YAML tier isn’t missing features — it’s naming divergence. Every renamed concept multiplies across thousands of mod files. OpenRA modders have years of muscle memory with trait names and YAML keys. Forcing renames creates friction that discourages adoption.</p>
<p><strong>Key design points:</strong></p>
<ol>
<li><strong>Alias registry:</strong> <code>ra-formats</code> maintains a compile-time map of OpenRA trait names to IC component names. <code>Armament</code> → <code>combat</code>, <code>Valued</code> → <code>buildable.cost</code>, <code>AttackOmni</code> → <code>combat.mode: omni</code>, etc.</li>
<li><strong>Bi-directional:</strong> The alias registry is used during YAML parsing (OpenRA names accepted) and by the <code>miniyaml2yaml</code> converter (produces IC-native names). Both representations are valid.</li>
<li><strong>Deprecation warnings:</strong> When an OpenRA alias is used, the parser emits a warning: <code>"Armament" is accepted but deprecated; prefer "combat"</code>. Warnings can be suppressed per-mod via <code>mod.yaml</code> setting.</li>
<li><strong>No runtime cost:</strong> Aliases resolve during YAML deserialization (load time only). The ECS never sees alias names — only canonical IC component types.</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>Reduces the YAML migration from “convert everything” to “drop in and play, clean up later”</li>
<li>Respects invariant #8 (“the community’s existing work is sacred”) at the data vocabulary layer, not just binary formats</li>
<li>Zero runtime cost — purely a deserialization convenience</li>
<li>Makes <code>miniyaml2yaml</code> output immediately usable even without manual cleanup</li>
<li>Modders can learn IC-native names gradually as they edit files</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>IC-native names only (rejected — unnecessary migration barrier for thousands of existing mod files)</li>
<li>Adopt OpenRA’s names wholesale (rejected — some OpenRA names are poorly chosen or C#-specific; IC benefits from cleaner naming)</li>
<li>Converter handles everything (rejected — modders still need to re-learn names for new content; aliases let them use familiar names forever)</li>
</ul>
<p><strong>Phase:</strong> Phase 0 (alias registry built alongside <code>ra-formats</code> YAML parser). Phase 6 (deprecation warnings configurable in <code>mod.yaml</code>).</p>
<hr>
<h3 id="d024--lua-api-superset-of-openra"><a class="header" href="#d024--lua-api-superset-of-openra">D024 — Lua API Superset of OpenRA</a></h3>
<p><strong>Decision:</strong> Iron Curtain’s Lua scripting API is a strict superset of OpenRA’s 16 global objects. Same function names, same parameter signatures, same return types. OpenRA Lua missions run unmodified. IC then extends with additional functionality.</p>
<p><strong>Context:</strong> OpenRA has a mature Lua API used in hundreds of campaign missions across all C&amp;C game mods. Combined Arms alone has 34 Lua-scripted missions. The mod migration doc (12-MOD-MIGRATION.md) identified “API compatibility shim” as a migration requirement — this decision elevates it from “nice to have” to “hard requirement.”</p>
<p><strong>OpenRA’s 16 globals (all must work identically in IC):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Global</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Actor</code></td><td>Create, query, manipulate actors</td></tr>
<tr><td><code>Map</code></td><td>Terrain, bounds, spatial queries</td></tr>
<tr><td><code>Trigger</code></td><td>Event hooks (OnKilled, AfterDelay)</td></tr>
<tr><td><code>Media</code></td><td>Audio, video, text display</td></tr>
<tr><td><code>Player</code></td><td>Player state, resources, diplomacy</td></tr>
<tr><td><code>Reinforcements</code></td><td>Spawn units at edges/drops</td></tr>
<tr><td><code>Camera</code></td><td>Pan, position, shake</td></tr>
<tr><td><code>DateTime</code></td><td>Game time queries</td></tr>
<tr><td><code>Objectives</code></td><td>Mission objective management</td></tr>
<tr><td><code>Lighting</code></td><td>Global lighting control</td></tr>
<tr><td><code>UserInterface</code></td><td>UI text, notifications</td></tr>
<tr><td><code>Utils</code></td><td>Math, random, table utilities</td></tr>
<tr><td><code>Beacon</code></td><td>Map beacon management</td></tr>
<tr><td><code>Radar</code></td><td>Radar ping control</td></tr>
<tr><td><code>HSLColor</code></td><td>Color construction</td></tr>
<tr><td><code>WDist</code></td><td>Distance unit conversion</td></tr>
</tbody>
</table>
</div>
<p><strong>IC extensions (additions, not replacements):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Global</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Campaign</code></td><td>Branching campaign state (D021)</td></tr>
<tr><td><code>Weather</code></td><td>Dynamic weather control (D022)</td></tr>
<tr><td><code>Workshop</code></td><td>Mod metadata queries</td></tr>
<tr><td><code>LLM</code></td><td>LLM integration hooks (Phase 7)</td></tr>
</tbody>
</table>
</div>
<p><strong>Actor properties also match:</strong> Each actor reference exposes properties matching OpenRA’s property groups (<code>.Health</code>, <code>.Location</code>, <code>.Owner</code>, <code>.Move()</code>, <code>.Attack()</code>, <code>.Stop()</code>, <code>.Guard()</code>, <code>.Deploy()</code>, etc.) with identical semantics.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>CA’s 34 missions + hundreds of community missions work on day one — no porting effort</li>
<li>Reduces Lua migration from “moderate effort” to “zero effort” for standard missions</li>
<li>IC’s extensions are additive — no conflicts, no breaking changes</li>
<li>Modders who know OpenRA Lua immediately know IC Lua</li>
<li>Future OpenRA missions created by the community are automatically IC-compatible</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Design our own API, provide shim (rejected — shim is always leaky, creates two mental models)</li>
<li>Partial compatibility (rejected — partial breaks are worse than full breaks; either missions work or they don’t)</li>
<li>No Lua compatibility (rejected — throws away hundreds of community missions for no gain)</li>
</ul>
<p><strong>Phase:</strong> Phase 4 (Lua scripting implementation). API surface documented during Phase 2 planning.</p>
<hr>
<h3 id="d025--runtime-miniyaml-loading"><a class="header" href="#d025--runtime-miniyaml-loading">D025 — Runtime MiniYAML Loading</a></h3>
<p><strong>Decision:</strong> Support loading MiniYAML directly at runtime as a fallback format in <code>ra-formats</code>. When the engine encounters tab-indented files with <code>^</code> inheritance or <code>@</code> suffixes, it auto-converts in memory. The <code>miniyaml2yaml</code> CLI converter still exists for permanent migration, but is no longer a prerequisite for loading mods.</p>
<p><strong>Revision of D003:</strong> D003 (“Real YAML, not MiniYAML”) remains the canonical format. All IC-native content uses standard YAML. D025 adds a compatibility loader — it does not change what IC produces, only what it accepts.</p>
<p><strong>Key design points:</strong></p>
<ol>
<li><strong>Format detection:</strong> <code>ra-formats</code> checks the first few lines of each file. Tab-indented content with no YAML indicators triggers the MiniYAML parser path.</li>
<li><strong>In-memory conversion:</strong> MiniYAML is parsed to an intermediate tree, then resolved to standard YAML structs. The result is identical to what <code>miniyaml2yaml</code> would produce.</li>
<li><strong>Combined with D023:</strong> OpenRA trait name aliases (D023) apply after MiniYAML parsing — so the full chain is: MiniYAML → intermediate tree → alias resolution → typed Rust structs.</li>
<li><strong>Performance:</strong> Conversion adds ~10-50ms per mod at load time (one-time cost). Cached after first load.</li>
<li><strong>Warning output:</strong> Console logs <code>"Loaded MiniYAML file rules.yaml — consider converting to standard YAML with 'ic mod convert'"</code>.</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>Turns “migrate then play” into “play immediately, migrate when ready”</li>
<li>Existing OpenRA mods become testable on IC within minutes, not hours</li>
<li>Respects invariant #8 — the community’s existing work is sacred, including their file formats</li>
<li>The converter CLI still exists for modders who want clean IC-native files</li>
<li>No performance impact after initial load (conversion result is cached)</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Require pre-conversion (original plan — rejected as unnecessary friction; the converter runs in memory just as well as on disk)</li>
<li>Support MiniYAML as a first-class format permanently (rejected — standard YAML is strictly better for tooling, validation, and editor support)</li>
<li>Only support converted files (rejected — blocks quick experimentation and casual mod testing)</li>
</ul>
<p><strong>Phase:</strong> Phase 0 (MiniYAML parser already needed for <code>miniyaml2yaml</code>; making it a runtime loader is minimal additional work).</p>
<hr>
<h3 id="d026--openra-mod-manifest-compatibility"><a class="header" href="#d026--openra-mod-manifest-compatibility">D026 — OpenRA Mod Manifest Compatibility</a></h3>
<p><strong>Decision:</strong> <code>ra-formats</code> can parse OpenRA’s <code>mod.yaml</code> manifest format and auto-map it to IC’s mod structure at load time. Combined with D023 (aliases), D024 (Lua API), and D025 (MiniYAML loading), this means a modder can point IC at an existing OpenRA mod directory and it loads — no restructuring needed.</p>
<p><strong>Key design points:</strong></p>
<ol>
<li><strong>Manifest parsing:</strong> OpenRA’s <code>mod.yaml</code> declares <code>Packages</code>, <code>Rules</code>, <code>Sequences</code>, <code>Cursors</code>, <code>Chrome</code>, <code>Assemblies</code>, <code>ChromeLayout</code>, <code>Weapons</code>, <code>Voices</code>, <code>Notifications</code>, <code>Music</code>, <code>Translations</code>, <code>MapFolders</code>, <code>SoundFormats</code>, <code>SpriteFormats</code>. IC maps each section to its equivalent concept.</li>
<li><strong>Directory convention mapping:</strong> OpenRA mods use <code>rules/</code>, <code>maps/</code>, <code>sequences/</code> etc. IC maps these to its own layout at load time without copying files.</li>
<li><strong>Unsupported sections flagged:</strong> <code>Assemblies</code> (C# DLLs) cannot load — these are flagged as warnings listing which custom traits are unavailable and what WASM alternatives exist.</li>
<li><strong>Partial loading:</strong> A mod with unsupported C# traits still loads — units using those traits get a visual placeholder and a “missing trait” debug overlay. The mod is playable with reduced functionality.</li>
<li><strong><code>ic mod import</code>:</strong> CLI command that reads an OpenRA mod directory and generates an IC-native <code>mod.yaml</code> with proper structure, converting files to standard YAML and flagging C# dependencies for WASM migration.</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>Combined with D023/D024/D025, this completes the “zero-friction import” pipeline</li>
<li>Modders can evaluate IC as a target without committing to migration</li>
<li>Partial loading means even mods with C# dependencies are partially testable</li>
<li>The <code>ic mod import</code> command provides a clean migration path when the modder is ready</li>
<li>Validates our claim that “the community’s existing work is sacred”</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Require manual mod restructuring (rejected — unnecessary friction, blocks adoption)</li>
<li>Only support IC mod format (rejected — makes evaluation impossible without migration effort)</li>
<li>Full C# trait loading via .NET interop (rejected — violates D001/D002, reintroduces the problems Rust solves)</li>
</ul>
<p><strong>Phase:</strong> Phase 0 (manifest parsing) + Phase 6 (full <code>ic mod import</code> workflow).</p>
<hr>
<h3 id="d027--canonical-enum-compatibility-with-openra"><a class="header" href="#d027--canonical-enum-compatibility-with-openra">D027 — Canonical Enum Compatibility with OpenRA</a></h3>
<p><strong>Decision:</strong> Use OpenRA’s canonical enum names for locomotor types, armor types, target types, damage states, and other enumerated values — or accept both OpenRA and IC-native names via the alias system (D023).</p>
<p><strong>Specific enums aligned:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Enum Type</th><th>OpenRA Names</th><th>IC Accepts</th></tr>
</thead>
<tbody>
<tr><td>Locomotor</td><td><code>Foot</code>, <code>Wheeled</code>, <code>Tracked</code>, <code>Float</code>, <code>Fly</code></td><td>Same (canonical)</td></tr>
<tr><td>Armor</td><td><code>None</code>, <code>Light</code>, <code>Medium</code>, <code>Heavy</code>, <code>Wood</code>, <code>Concrete</code></td><td>Same (canonical)</td></tr>
<tr><td>Target Type</td><td><code>Ground</code>, <code>Air</code>, <code>Water</code>, <code>Underground</code></td><td>Same (canonical)</td></tr>
<tr><td>Damage State</td><td><code>Undamaged</code>, <code>Light</code>, <code>Medium</code>, <code>Heavy</code>, <code>Critical</code>, <code>Dead</code></td><td>Same (canonical)</td></tr>
<tr><td>Stance</td><td><code>AttackAnything</code>, <code>Defend</code>, <code>ReturnFire</code>, <code>HoldFire</code></td><td>Same (canonical)</td></tr>
<tr><td>UnitType</td><td><code>Building</code>, <code>Infantry</code>, <code>Vehicle</code>, <code>Aircraft</code>, <code>Ship</code></td><td>Same (canonical)</td></tr>
</tbody>
</table>
</div>
<p><strong>Why this matters:</strong> The <code>Versus</code> damage table — which modders spend 80% of their balance time tuning — uses armor type names as keys. Locomotor types determine pathfinding behavior. Target types control weapon targeting. If these don’t match, every single weapon definition, armor table, and locomotor reference needs translation. By matching names, these definitions copy-paste directly.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Eliminates an entire category of conversion mapping</li>
<li>Versus tables, weapon definitions, locomotor configs — all transfer without renaming</li>
<li>OpenRA’s names are reasonable and well-known in the community</li>
<li>No technical reason to rename these — they describe the same concepts</li>
<li>Where IC needs additional values (e.g., <code>Hover</code>, <code>Amphibious</code>), they extend the enum without conflicting</li>
</ul>
<p><strong>Phase:</strong> Phase 2 (when enum types are formally defined in <code>ra-sim</code>).</p>
<hr>
<h3 id="d028--condition-and-multiplier-systems-as-phase-2-requirements"><a class="header" href="#d028--condition-and-multiplier-systems-as-phase-2-requirements">D028 — Condition and Multiplier Systems as Phase 2 Requirements</a></h3>
<p><strong>Decision:</strong> The condition system and multiplier system identified as P0 critical gaps in <code>11-OPENRA-FEATURES.md</code> are promoted to hard Phase 2 exit criteria. Phase 2 cannot ship without both systems implemented and tested.</p>
<p><strong>What this adds to Phase 2:</strong></p>
<ol>
<li>
<p><strong>Condition system:</strong></p>
<ul>
<li><code>Conditions</code> component: <code>HashMap&lt;ConditionId, u32&gt;</code> (ref-counted named conditions per entity)</li>
<li>Condition sources: <code>GrantConditionOnMovement</code>, <code>GrantConditionOnDamageState</code>, <code>GrantConditionOnDeploy</code>, <code>GrantConditionOnAttack</code>, <code>GrantConditionOnTerrain</code>, <code>GrantConditionOnVeterancy</code> — exposed in YAML</li>
<li>Condition consumers: any component field can declare <code>requires:</code> or <code>disabled_by:</code> conditions</li>
<li>Runtime: systems check <code>conditions.is_active("deployed")</code> via fast bitset or hash lookup</li>
</ul>
</li>
<li>
<p><strong>Multiplier system:</strong></p>
<ul>
<li><code>StatModifiers</code> component: per-entity stack of <code>(source, stat, modifier_value, condition)</code></li>
<li>Every numeric stat (speed, damage, range, reload, build time, build cost, sight range, etc.) resolves through the modifier stack</li>
<li>Modifiers from: veterancy, terrain, crates, conditions, player handicaps</li>
<li>Fixed-point multiplication (no floats)</li>
<li>YAML-configurable: modders add multipliers without code</li>
</ul>
</li>
<li>
<p><strong>Full damage pipeline:</strong></p>
<ul>
<li>Armament → Projectile entity → travel → impact → Warhead(s) → armor-versus-weapon table → DamageMultiplier resolution → Health reduction</li>
<li>Composable warheads: each weapon can trigger multiple warheads (damage + condition + terrain effect)</li>
</ul>
</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li>Without conditions, 80% of OpenRA YAML mods cannot express their behavior at all — conditions are the fundamental modding primitive</li>
<li>Without multipliers, veterancy/crates/terrain bonuses don’t work — critical gameplay systems are broken</li>
<li>Without the full damage pipeline, weapons are simplistic and balance modding is impossible</li>
<li>These three systems are the foundation that P1–P3 features build on (stealth, veterancy, transport, support powers all use conditions and multipliers)</li>
<li>Promoting from “identified gap” to “exit criteria” ensures they’re not deferred</li>
</ul>
<p><strong>Phase:</strong> Phase 2 (hard exit criteria — no Phase 3 starts without these).</p>
<hr>
<h3 id="d029--cross-game-component-library-as-phase-2-deliverables"><a class="header" href="#d029--cross-game-component-library-as-phase-2-deliverables">D029 — Cross-Game Component Library as Phase 2 Deliverables</a></h3>
<p><strong>Decision:</strong> The seven first-party component systems identified in <code>12-MOD-MIGRATION.md</code> (from Combined Arms and Remastered case studies) are Phase 2 deliverables, not aspirational future work.</p>
<p><strong>The seven systems:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>System</th><th>Needed For</th><th>Phase 2 Scope</th></tr>
</thead>
<tbody>
<tr><td><strong>Mind Control</strong></td><td>CA (Yuri), RA2 game module, Scrin</td><td>Controller/controllable components, capacity limits, override</td></tr>
<tr><td><strong>Carrier/Spawner</strong></td><td>CA, RA2 (Aircraft Carrier, Kirov drones)</td><td>Master/slave with respawn, recall, autonomous attack</td></tr>
<tr><td><strong>Teleport Networks</strong></td><td>CA, Nod tunnels (TD/TS), Chronosphere</td><td>Multi-node network with primary exit designation</td></tr>
<tr><td><strong>Shield System</strong></td><td>CA, RA2 force shields, Scrin</td><td>Absorb-before-health, recharge timer, depletion</td></tr>
<tr><td><strong>Upgrade System</strong></td><td>CA, C&amp;C3 game module</td><td>Per-unit tech research via building, condition grants</td></tr>
<tr><td><strong>Delayed Weapons</strong></td><td>CA (radiation, poison), RA2 (terror drones)</td><td>Timer-attached effects on targets</td></tr>
<tr><td><strong>Dual Asset Rendering</strong></td><td>Remastered recreation, HD mod packs</td><td>Runtime-switchable asset quality per entity (in <code>ra-render</code>). Generalized by the Resource Pack system — see <code>04-MODDING.md</code> § “Resource Packs”</td></tr>
</tbody>
</table>
</div>
<p><strong>Rationale:</strong></p>
<ul>
<li>These aren’t CA-specific — they’re needed for RA2 (the likely second game module). Building them in Phase 2 means they’re available when RA2 development starts.</li>
<li>CA can migrate to IC the moment the engine is playable, rather than waiting for Phase 6</li>
<li>Without these as built-in components, CA modders would need to write WASM for basic mechanics like mind control — unacceptable for adoption</li>
<li>The seven systems cover ~60% of CA’s custom C# code — collapsing the WASM tier from ~15% to ~5% of migration effort</li>
<li>Each system is independently useful and well-scoped (2-5 days engineering each)</li>
</ul>
<p><strong>Impact on migration estimates:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Migration Tier</th><th>Before D029</th><th>After D029</th></tr>
</thead>
<tbody>
<tr><td>Tier 1 (YAML)</td><td>~40%</td><td>~45%</td></tr>
<tr><td>Built-in</td><td>~30%</td><td>~40%</td></tr>
<tr><td>Tier 2 (Lua)</td><td>~15%</td><td>~10%</td></tr>
<tr><td>Tier 3 (WASM)</td><td>~15%</td><td>~5%</td></tr>
</tbody>
</table>
</div>
<p><strong>Phase:</strong> Phase 2 (sim-side components) + Phase 1 (dual asset rendering in <code>ra-render</code>).</p>
<hr>
<h2 id="d030-workshop-resource-registry--dependency-system"><a class="header" href="#d030-workshop-resource-registry--dependency-system">D030: Workshop Resource Registry &amp; Dependency System</a></h2>
<p><strong>Decision:</strong> The Workshop operates as a crates.io-style resource registry where any game asset — music, sprites, textures, cutscenes, maps, sound effects, palettes, voice lines, UI themes, templates — is publishable as an independent, versioned, licensable resource that others (including LLM agents) can discover, depend on, and pull automatically.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>OpenRA has no resource sharing infrastructure — modders copy-paste files, share on forums, lose attribution</li>
<li>Individual resources (a single music track, one sprite sheet) should be as easy to publish and consume as full mods</li>
<li>A dependency system eliminates duplication: five mods that need the same HD sprite pack declare it as a dependency instead of each bundling 200MB of sprites</li>
<li>License metadata protects community creators and enables automated compatibility checking</li>
<li>LLM agents generating missions need a way to discover and pull community assets without human intervention</li>
<li>The mod ecosystem grows faster when building blocks are reusable — this is why npm/crates.io/pip changed their respective ecosystems</li>
</ul>
<p><strong>Key Design Elements:</strong></p>
<h3 id="resource-identity--versioning-1"><a class="header" href="#resource-identity--versioning-1">Resource Identity &amp; Versioning</a></h3>
<p>Every Workshop resource gets a globally unique identifier: <code>namespace/name@version</code>.</p>
<ul>
<li><strong>Namespace</strong> = author username or organization (e.g., <code>alice</code>, <code>community-hd-project</code>)</li>
<li><strong>Name</strong> = resource name, lowercase with hyphens (e.g., <code>soviet-march-music</code>, <code>allied-infantry-hd</code>)</li>
<li><strong>Version</strong> = semver (e.g., <code>1.2.0</code>)</li>
<li>Full ID example: <code>alice/soviet-march-music@1.2.0</code></li>
</ul>
<h3 id="resource-categories-expanded"><a class="header" href="#resource-categories-expanded">Resource Categories (Expanded)</a></h3>
<p>Resources aren’t limited to mod-sized packages. Granularity is flexible:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Granularity Examples</th></tr>
</thead>
<tbody>
<tr><td>Music</td><td>Single track, album, soundtrack</td></tr>
<tr><td>Sound Effects</td><td>Weapon sound pack, ambient loops, UI sounds</td></tr>
<tr><td>Voice Lines</td><td>EVA pack, unit response set, faction voice pack</td></tr>
<tr><td>Sprites</td><td>Single unit sheet, building sprites, effects pack</td></tr>
<tr><td>Textures</td><td>Terrain tileset, UI skin, palette-indexed sprites</td></tr>
<tr><td>Palettes</td><td>Theater palette, faction palette, seasonal palette</td></tr>
<tr><td>Maps</td><td>Single map, map pack, tournament map pool</td></tr>
<tr><td>Missions</td><td>Single mission, mission chain</td></tr>
<tr><td>Campaign Chapters</td><td>Story arc with persistent state</td></tr>
<tr><td>Scene Templates</td><td>Tera scene template for LLM composition</td></tr>
<tr><td>Mission Templates</td><td>Tera mission template for LLM composition</td></tr>
<tr><td>Cutscenes / Video</td><td>Briefing video, in-game cinematic, tutorial clip</td></tr>
<tr><td>UI Themes</td><td>Sidebar layout, font pack, cursor set</td></tr>
<tr><td>Balance Presets</td><td>Tuned unit/weapon stats as a selectable preset</td></tr>
<tr><td>Resource Packs</td><td>Switchable asset layer for any category — see <code>04-MODDING.md</code> § “Resource Packs”</td></tr>
<tr><td>Full Mods</td><td>Traditional mod (may depend on individual resources)</td></tr>
</tbody>
</table>
</div>
<p>A published resource is just a <code>ResourcePackage</code> with the appropriate <code>ResourceCategory</code>. The existing <code>asset-pack</code> template and <code>ic mod publish</code> flow handle this natively — no separate command needed.</p>
<h3 id="dependency-declaration"><a class="header" href="#dependency-declaration">Dependency Declaration</a></h3>
<p><code>mod.yaml</code> already has a <code>dependencies:</code> section. D030 formalizes the resolution semantics:</p>
<pre><code class="language-yaml"># mod.yaml
dependencies:
  - id: "community-project/hd-infantry-sprites"
    version: "^2.0"                    # semver range (cargo-style)
    source: workshop                   # workshop | local | url
  - id: "alice/soviet-march-music"
    version: "&gt;=1.0, &lt;3.0"
    source: workshop
    optional: true                     # soft dependency — mod works without it
  - id: "bob/desert-terrain-textures"
    version: "~1.4"                    # compatible with 1.4.x
    source: workshop
</code></pre>
<p>Resource packages can also declare dependencies on other resources (transitive):</p>
<pre><code class="language-yaml"># A mission pack depends on a sprite pack and a music track
dependencies:
  - id: "community-project/hd-sprites"
    version: "^2.0"
    source: workshop
  - id: "alice/briefing-videos"
    version: "^1.0"
    source: workshop
</code></pre>
<h3 id="repository-types-artifactory-model-1"><a class="header" href="#repository-types-artifactory-model-1">Repository Types (Artifactory Model)</a></h3>
<p>The Workshop uses three repository types, directly inspired by Artifactory’s local/remote/virtual model:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Repository Type</th><th>Artifactory Analog</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Local</strong></td><td>Local repository</td><td>A directory on disk following Workshop structure. Stores artifacts you create. Used for development, LAN parties, offline play, pre-publish testing.</td></tr>
<tr><td><strong>Remote</strong></td><td>Remote repository</td><td>A Workshop server (official or community-hosted). Artifacts are downloaded and cached locally on first access. Cache is used for subsequent requests — works offline after first pull.</td></tr>
<tr><td><strong>Virtual</strong></td><td>Virtual repository</td><td>The aggregated view across all configured sources. The <code>ic</code> CLI and in-game browser query the virtual repository — it merges listings from all local + remote sources, deduplicates by resource ID, and resolves version conflicts using priority ordering.</td></tr>
</tbody>
</table>
</div>
<p>The <code>settings.yaml</code> <code>sources:</code> list defines which local and remote repositories compose the virtual repository. This is the federation model — the client never queries raw servers directly, it queries its virtual repository.</p>
<h3 id="artifact-integrity-1"><a class="header" href="#artifact-integrity-1">Artifact Integrity</a></h3>
<p>Every published artifact includes cryptographic checksums for integrity verification:</p>
<ul>
<li><strong>SHA-256 checksum</strong> stored in the package manifest and on the Workshop server</li>
<li><code>ic mod install</code> verifies checksums after download — mismatch → abort + warning</li>
<li><code>ic.lock</code> records both version AND checksum for each dependency — guarantees byte-identical installs across machines</li>
<li>Protects against: corrupted downloads, CDN tampering, mirror drift</li>
<li>Workshop server computes checksums on upload; clients verify on download. Trust but verify.</li>
</ul>
<h3 id="promotion--maturity-channels-1"><a class="header" href="#promotion--maturity-channels-1">Promotion &amp; Maturity Channels</a></h3>
<p>Artifacts can be published to maturity channels, allowing staged releases:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Channel</th><th>Purpose</th><th>Visibility</th></tr>
</thead>
<tbody>
<tr><td><code>dev</code></td><td>Work-in-progress, local testing</td><td>Author only (local repos only)</td></tr>
<tr><td><code>beta</code></td><td>Pre-release, community testing</td><td>Opt-in (users enable beta flag)</td></tr>
<tr><td><code>release</code></td><td>Stable, production-ready</td><td>Default (everyone sees these)</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-yaml"># mod.yaml
mod:
  version: "1.3.0-beta.1"            # semver pre-release tag
  channel: beta                       # publish to beta channel
</code></pre>
<ul>
<li><code>ic mod publish --channel beta</code> → visible only to users who opt in to beta resources</li>
<li><code>ic mod publish</code> (no flag) → release channel by default</li>
<li><code>ic mod install</code> pulls from release channel unless <code>--include-beta</code> is specified</li>
<li>Promotion: <code>ic mod promote 1.3.0-beta.1 release</code> → moves artifact to release channel without re-upload</li>
</ul>
<h3 id="replication--mirroring-1"><a class="header" href="#replication--mirroring-1">Replication &amp; Mirroring</a></h3>
<p>Community Workshop servers can replicate from the official server (pull replication, Artifactory-style):</p>
<ul>
<li><strong>Pull replication:</strong> Community server periodically syncs popular artifacts from official. Reduces latency for regional players, provides redundancy.</li>
<li><strong>Selective sync:</strong> Community servers choose which categories/namespaces to replicate (e.g., replicate all Maps but not Mods)</li>
<li><strong>Offline bundles:</strong> <code>ic workshop export-bundle</code> creates a portable archive of selected resources for LAN parties or airgapped environments. <code>ic workshop import-bundle</code> loads them into a local repository.</li>
</ul>
<h3 id="dependency-resolution-1"><a class="header" href="#dependency-resolution-1">Dependency Resolution</a></h3>
<p>Cargo-inspired version solving:</p>
<ul>
<li><strong>Semver ranges:</strong> <code>^1.2</code> (&gt;=1.2.0, &lt;2.0.0), <code>~1.2</code> (&gt;=1.2.0, &lt;1.3.0), <code>&gt;=1.0, &lt;3.0</code>, exact <code>=1.2.3</code></li>
<li><strong>Lockfile:</strong> <code>ic.lock</code> records exact resolved versions + SHA-256 checksums for reproducible installs</li>
<li><strong>Transitive resolution:</strong> If mod A depends on resource B which depends on resource C, all three are resolved</li>
<li><strong>Conflict detection:</strong> Two dependencies requiring incompatible versions of the same resource → error with resolution suggestions</li>
<li><strong>Deduplication:</strong> Same resource pulled by multiple dependents is stored once in local cache</li>
<li><strong>Offline resolution:</strong> Once cached, all dependencies resolve from local cache — no network required</li>
</ul>
<h3 id="cli-extensions"><a class="header" href="#cli-extensions">CLI Extensions</a></h3>
<pre><code>ic mod resolve         # compute dependency graph, report conflicts
ic mod install         # download all dependencies to local cache
ic mod update          # update deps to latest compatible versions (respects semver)
ic mod tree            # display dependency tree (like `cargo tree`)
ic mod lock            # regenerate ic.lock from current mod.yaml
ic mod audit           # check dependency licenses for compatibility
</code></pre>
<p>These extend the existing <code>ic</code> CLI (D020), not replace it. <code>ic mod publish</code> already exists — it now also uploads dependency metadata and validates license presence.</p>
<h3 id="license-system-1"><a class="header" href="#license-system-1">License System</a></h3>
<p><strong>Every published Workshop resource MUST have a <code>license</code> field.</strong> Publishing without one is rejected.</p>
<pre><code class="language-yaml"># In mod.yaml or resource manifest
mod:
  license: "CC-BY-SA-4.0"             # SPDX identifier (required for publishing)
</code></pre>
<ul>
<li>Uses <a href="https://spdx.org/licenses/">SPDX identifiers</a> for machine-readable license classification</li>
<li>Workshop UI displays license prominently on every resource listing</li>
<li><code>ic mod audit</code> checks the full dependency tree for license compatibility (e.g., CC-BY-NC dep in a CC-BY mod → warning)</li>
<li>Common licenses for game assets: <code>CC-BY-4.0</code>, <code>CC-BY-SA-4.0</code>, <code>CC-BY-NC-4.0</code>, <code>CC0-1.0</code>, <code>MIT</code>, <code>GPL-3.0-only</code>, <code>LicenseRef-Custom</code> (with link to full text)</li>
<li>Resources with incompatible licenses can coexist in the Workshop but <code>ic mod audit</code> warns when combining them</li>
</ul>
<h3 id="llm-driven-resource-discovery"><a class="header" href="#llm-driven-resource-discovery">LLM-Driven Resource Discovery</a></h3>
<p><code>ra-llm</code> can search the Workshop programmatically and incorporate discovered resources into generated content:</p>
<pre><code>Pipeline:
  1. LLM generates mission concept ("Soviet ambush in snowy forest")
  2. Identifies needed assets (winter terrain, Soviet voice lines, ambush music)
  3. Searches Workshop: query="winter terrain textures", tags=["snow", "forest"]
  4. Evaluates candidates via llm_meta (summary, purpose, composition_hints)
  5. Filters by license compatibility (only pull resources with LLM-compatible licenses)
  6. Adds discovered resources as dependencies in generated mod.yaml
  7. Generated mission references assets by resource ID — resolved at install time
</code></pre>
<p>This turns the Workshop into a composable asset library that both humans and AI agents can draw from.</p>
<h3 id="workshop-server-resolution-resolves-p007"><a class="header" href="#workshop-server-resolution-resolves-p007">Workshop Server Resolution (resolves P007)</a></h3>
<p><strong>Decision: Federated multi-source with merge.</strong> The Workshop client can aggregate listings from multiple sources:</p>
<pre><code class="language-yaml"># settings.yaml
workshop:
  sources:
    - url: "https://workshop.ironcurtain.gg"     # official (always included)
      priority: 1
    - url: "https://mods.myclan.com/workshop"     # community server
      priority: 2
    - path: "C:/my-local-workshop"                # local directory
      priority: 3
  deduplicate: true               # same resource ID from multiple sources → highest priority wins
</code></pre>
<p>Rationale: Single-source is too limiting for a resource registry. Crates.io has mirrors; npm has registries. A dependency system inherently benefits from federation — tournament organizers publish to their server, LAN parties use local directories, the official server is the default. Deduplication by resource ID + priority ordering handles conflicts.</p>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Single source only (simpler but doesn’t scale for a registry model — what happens when the official server is down?)</li>
<li>Full decentralization with no official server (too chaotic for discoverability)</li>
<li>Git-based distribution like Go modules (too complex for non-developer modders)</li>
<li>Steam Workshop only (platform lock-in, no WASM/browser target, no self-hosting)</li>
</ul>
<p><strong>Phase:</strong> Phase 6 (Workshop infrastructure), with preparatory work in Phase 3 (manifest format finalized) and Phase 4 (LLM integration).</p>
<hr>
<h2 id="d031-observability--telemetry--otel-across-engine-servers-and-ai-pipeline"><a class="header" href="#d031-observability--telemetry--otel-across-engine-servers-and-ai-pipeline">D031: Observability &amp; Telemetry — OTEL Across Engine, Servers, and AI Pipeline</a></h2>
<p><strong>Decision:</strong> All backend servers (relay, tracking, workshop) and the game engine itself emit structured telemetry via OpenTelemetry (OTEL), enabling operational monitoring, gameplay debugging, state inspection, and AI/LLM training data collection — all from a single, unified instrumentation layer.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li>Backend servers (relay, tracking, workshop) are production infrastructure — they need health metrics, latency histograms, error rates, and distributed traces, just like any microservice</li>
<li>The game engine already has rich internal state (per-tick <code>state_hash()</code>, snapshots, system execution times) but no structured way to export it for analysis</li>
<li>Replay files capture <em>what happened</em> but not <em>why</em> — telemetry captures the engine’s decision-making process (pathfinding time, order validation outcomes, combat resolution details) that replays miss</li>
<li>Behavioral analysis (V12 anti-cheat) already collects APM, reaction times, and input entropy on the relay — OTEL is the natural export format for this data</li>
<li>AI/LLM development needs training data: game telemetry (unit movements, build orders, engagement outcomes) is exactly the training corpus for <code>ra-ai</code> and <code>ra-llm</code></li>
<li>Bevy already integrates with Rust’s <code>tracing</code> crate — OTEL export is a natural extension, not a foreign addition</li>
<li>Desync debugging needs cross-client correlation — distributed tracing (trace IDs) lets you follow an order from input → network → sim → render across multiple clients and the relay server</li>
<li>A single instrumentation approach (OTEL) avoids the mess of ad-hoc logging, custom metrics files, separate debug protocols, and incompatible formats</li>
</ul>
<p><strong>Key Design Elements:</strong></p>
<h3 id="three-telemetry-signals-otel-standard"><a class="header" href="#three-telemetry-signals-otel-standard">Three Telemetry Signals (OTEL Standard)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Signal</th><th>What It Captures</th><th>Export Format</th></tr>
</thead>
<tbody>
<tr><td>Metrics</td><td>Counters, histograms, gauges — numeric time series</td><td>OTLP → Prometheus</td></tr>
<tr><td>Traces</td><td>Distributed request flows — an order’s journey through the system</td><td>OTLP → Jaeger/Zipkin</td></tr>
<tr><td>Logs</td><td>Structured events with severity, context, correlation IDs</td><td>OTLP → Loki/stdout</td></tr>
</tbody>
</table>
</div>
<h3 id="backend-server-telemetry-relay-tracking-workshop"><a class="header" href="#backend-server-telemetry-relay-tracking-workshop">Backend Server Telemetry (Relay, Tracking, Workshop)</a></h3>
<p>Standard operational observability — same patterns used by any production Rust service:</p>
<p><strong>Relay server metrics:</strong></p>
<pre><code>relay.games.active                    # gauge: concurrent games
relay.games.total                     # counter: total games hosted
relay.orders.received                 # counter: orders received per tick
relay.orders.forwarded                # counter: orders broadcast
relay.orders.dropped                  # counter: orders missed (lag switch)
relay.tick.latency_ms                 # histogram: tick processing time
relay.player.rtt_ms                   # histogram: per-player round-trip time
relay.player.suspicion_score          # gauge: behavioral analysis score (V12)
relay.desync.detected                 # counter: desync events
relay.match.completed                 # counter: matches finished
relay.match.duration_s                # histogram: match duration
</code></pre>
<p><strong>Tracking server metrics:</strong></p>
<pre><code>tracking.listings.active              # gauge: current game listings
tracking.heartbeats.received          # counter: heartbeats processed
tracking.heartbeats.expired           # counter: listings expired (TTL)
tracking.queries.total                # counter: browse/search requests
tracking.queries.latency_ms           # histogram: query latency
</code></pre>
<p><strong>Workshop server metrics:</strong></p>
<pre><code>workshop.artifacts.total              # gauge: total published resources
workshop.artifacts.downloads          # counter: download events
workshop.artifacts.publishes          # counter: publish events
workshop.resolve.latency_ms           # histogram: dependency resolution time
workshop.resolve.conflicts            # counter: version conflicts detected
workshop.search.latency_ms            # histogram: search query time
</code></pre>
<p><strong>Distributed traces:</strong> A multiplayer game session gets a trace ID. Every order, tick, and desync event references this trace ID. Debug a desync by searching for the game’s trace ID in Jaeger and seeing the exact sequence of events across all participants.</p>
<p><strong>Health endpoints:</strong> Every server exposes <code>/healthz</code> (already designed) and <code>/readyz</code>. Prometheus scrape endpoint at <code>/metrics</code>. These are standard and compose with existing k8s deployment (Helm charts already designed in <code>03-NETCODE.md</code>).</p>
<h3 id="game-engine-telemetry-client-side"><a class="header" href="#game-engine-telemetry-client-side">Game Engine Telemetry (Client-Side)</a></h3>
<p>The engine emits structured telemetry for debugging, profiling, and AI training — but only when enabled. <strong>Hot paths remain zero-cost when telemetry is disabled</strong> (compile-time feature flag <code>telemetry</code>).</p>
<h4 id="performance-instrumentation"><a class="header" href="#performance-instrumentation">Performance Instrumentation</a></h4>
<p>Per-tick system timing, already needed for the benchmark suite (<code>10-PERFORMANCE.md</code>), exported as OTEL metrics when enabled:</p>
<pre><code>sim.tick.duration_us                  # histogram: total tick time
sim.system.apply_orders_us            # histogram: per-system time
sim.system.production_us
sim.system.harvesting_us
sim.system.movement_us
sim.system.combat_us
sim.system.death_us
sim.system.triggers_us
sim.system.fog_us
sim.entities.total                    # gauge: entity count
sim.entities.by_type                  # gauge: per-component-type count
sim.memory.scratch_bytes              # gauge: TickScratch buffer usage
sim.pathfinding.requests              # counter: pathfinding queries per tick
sim.pathfinding.cache_hits            # counter: flowfield cache reuse
sim.pathfinding.duration_us           # histogram: pathfinding computation time
</code></pre>
<h4 id="gameplay-event-stream"><a class="header" href="#gameplay-event-stream">Gameplay Event Stream</a></h4>
<p>Structured events emitted during simulation — the raw material for AI training and replay enrichment:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Gameplay events emitted by the sim when telemetry is enabled.
/// These are structured, not printf-style — each field is queryable.
pub enum GameplayEvent {
    UnitCreated { tick: u64, entity: EntityId, unit_type: String, owner: PlayerId },
    UnitDestroyed { tick: u64, entity: EntityId, killer: Option&lt;EntityId&gt;, cause: DeathCause },
    CombatEngagement { tick: u64, attacker: EntityId, target: EntityId, weapon: String, damage: i32, remaining_hp: i32 },
    BuildingPlaced { tick: u64, entity: EntityId, structure_type: String, owner: PlayerId, position: WorldPos },
    HarvestDelivered { tick: u64, harvester: EntityId, resource_type: String, amount: i32, total_credits: i32 },
    OrderIssued { tick: u64, player: PlayerId, order: PlayerOrder, validated: bool, rejection_reason: Option&lt;String&gt; },
    PathfindingCompleted { tick: u64, entity: EntityId, from: WorldPos, to: WorldPos, path_length: u32, compute_time_us: u32 },
    DesyncDetected { tick: u64, expected_hash: u64, actual_hash: u64, player: PlayerId },
    StateSnapshot { tick: u64, state_hash: u64, entity_count: u32 },
}
<span class="boring">}</span></code></pre>
<p>These events are:</p>
<ul>
<li><strong>Emitted as OTEL log records</strong> with structured attributes (not free-text — every field is filterable)</li>
<li><strong>Collected locally</strong> into a gameplay event log alongside replays (enriched replays)</li>
<li><strong>Optionally exported</strong> to a collector for batch analysis (tournament servers, AI training pipelines)</li>
</ul>
<h4 id="state-inspection-development--debugging"><a class="header" href="#state-inspection-development--debugging">State Inspection (Development &amp; Debugging)</a></h4>
<p>A debug overlay (via <code>bevy_egui</code>, already in the architecture) that reads live telemetry:</p>
<ul>
<li>Per-system tick time breakdown (bar chart)</li>
<li>Entity count by type</li>
<li>Network: RTT, order latency, jitter</li>
<li>Memory: scratch buffer usage, component storage</li>
<li>Pathfinding: active flowfields, cache hit rate</li>
<li>Fog: cells updated this tick, stagger bucket</li>
<li>Sim state hash (for manual desync comparison)</li>
</ul>
<p>This is the “game engine equivalent of a Kubernetes dashboard” — operators of tournament servers or mod developers can inspect the engine’s internal state in real-time.</p>
<h3 id="ai--llm-training-data-pipeline"><a class="header" href="#ai--llm-training-data-pipeline">AI / LLM Training Data Pipeline</a></h3>
<p>The gameplay event stream is the foundation for AI development:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Consumer</th><th>Data Source</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>ra-ai</code> (skirmish AI)</td><td>Gameplay events from human games</td><td>Learn build orders, engagement timing, micro patterns</td></tr>
<tr><td><code>ra-llm</code> (missions)</td><td>Gameplay events + enriched replays</td><td>Learn what makes missions fun (engagement density, pacing, flow)</td></tr>
<tr><td>Behavioral analysis</td><td>Relay-side player profiles</td><td>APM, reaction time, input entropy → suspicion scoring (V12)</td></tr>
<tr><td>Balance analysis</td><td>Aggregated match outcomes</td><td>Win rates by faction/map/preset → balance tuning</td></tr>
<tr><td>Adaptive difficulty</td><td>Per-player gameplay patterns</td><td>Build speed, APM, unit composition → difficulty calibration</td></tr>
<tr><td>Community analytics</td><td>Workshop + match metadata</td><td>Popular resources, play patterns, mod adoption → recommendations</td></tr>
</tbody>
</table>
</div>
<p><strong>Privacy:</strong> Gameplay events are associated with anonymized player IDs (hashed). No PII in telemetry. Players opt in to telemetry export (default: local-only for debugging). Tournament/ranked play may require telemetry for anti-cheat and certified results. See <code>06-SECURITY.md</code>.</p>
<p><strong>Data format:</strong> Gameplay events export as structured OTEL log records → can be collected into Parquet/Arrow columnar format for batch ML training. The LLM training pipeline reads events, not raw replay bytes.</p>
<h3 id="architecture-where-telemetry-lives"><a class="header" href="#architecture-where-telemetry-lives">Architecture: Where Telemetry Lives</a></h3>
<pre><code>                  ┌──────────────────────────────────────────┐
                  │              OTEL Collector               │
                  │  (receives all signals, routes to sinks)  │
                  └──┬──────────┬──────────┬─────────────────┘
                     │          │          │
              ┌──────▼──┐ ┌────▼────┐ ┌───▼─────────────┐
              │Prometheus│ │ Jaeger  │ │ Loki / Storage  │
              │(metrics) │ │(traces) │ │(logs / events)  │
              └──────────┘ └─────────┘ └───────┬─────────┘
                                               │
                                        ┌──────▼──────┐
                                        │ AI Training  │
                                        │ Pipeline     │
                                        │ (Parquet→ML) │
                                        └─────────────┘

  Emitters:
  ┌─────────┐  ┌─────────┐  ┌──────────┐  ┌──────────┐
  │  Relay  │  │Tracking │  │ Workshop │  │  Game    │
  │ Server  │  │ Server  │  │  Server  │  │ Engine   │
  └─────────┘  └─────────┘  └──────────┘  └──────────┘
</code></pre>
<p>No emitter talks directly to Prometheus/Jaeger/Loki — everything goes through the OTEL Collector. This means:</p>
<ul>
<li>Emitters don’t know or care about the backend storage</li>
<li>Self-hosters can route to whatever they want (Grafana Cloud, Datadog, or just stdout)</li>
<li>The collector handles sampling, batching, and export — emitters stay lightweight</li>
</ul>
<h3 id="implementation-approach"><a class="header" href="#implementation-approach">Implementation Approach</a></h3>
<p><strong>Rust ecosystem:</strong></p>
<ul>
<li><code>tracing</code> crate — Bevy already uses this; add structured fields and span instrumentation</li>
<li><code>opentelemetry</code> + <code>opentelemetry-otlp</code> crates — OTEL SDK for Rust</li>
<li><code>tracing-opentelemetry</code> — bridges <code>tracing</code> spans to OTEL traces</li>
<li><code>metrics</code> crate — lightweight counters/histograms, exported via OTEL</li>
</ul>
<p><strong>Zero-cost when disabled:</strong> The <code>telemetry</code> feature flag gates all instrumentation behind <code>#[cfg(feature = "telemetry")]</code>. When disabled (default for release builds), all telemetry calls compile to no-ops. No runtime cost, no allocations, no branches. This respects invariant #5 (efficiency-first performance).</p>
<p><strong>Build configurations:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Build</th><th>Telemetry</th><th>Use case</th></tr>
</thead>
<tbody>
<tr><td><code>release</code></td><td>Off</td><td>Player-facing builds — zero overhead</td></tr>
<tr><td><code>release-telemetry</code></td><td>On</td><td>Tournament servers, AI training, debugging</td></tr>
<tr><td><code>debug</code></td><td>On</td><td>Development — full instrumentation</td></tr>
</tbody>
</table>
</div>
<h3 id="self-hosting-observability"><a class="header" href="#self-hosting-observability">Self-Hosting Observability</a></h3>
<p>Community server operators get observability for free. The docker-compose.yaml (already designed in <code>03-NETCODE.md</code>) can optionally include a Grafana + Prometheus + Loki stack:</p>
<pre><code class="language-yaml"># docker-compose.observability.yaml (optional overlay)
services:
  otel-collector:
    image: otel/opentelemetry-collector:latest
    ports:
      - "4317:4317"    # OTLP gRPC
  prometheus:
    image: prom/prometheus:latest
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"    # dashboards
  loki:
    image: grafana/loki:latest
</code></pre>
<p>Pre-built Grafana dashboards ship with the project:</p>
<ul>
<li><strong>Relay Dashboard:</strong> active games, player RTT, orders/sec, desync events, suspicion scores</li>
<li><strong>Tracking Dashboard:</strong> listings, heartbeats, query rates</li>
<li><strong>Workshop Dashboard:</strong> downloads, publishes, dependency resolution times</li>
<li><strong>Engine Dashboard:</strong> tick times, entity counts, system breakdown, pathfinding stats</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Custom metrics format (less work initially, but no ecosystem — no Grafana, no alerting, no community tooling)</li>
<li>StatsD (simpler but metrics-only — no traces, no structured logs, no distributed correlation)</li>
<li>No telemetry (leaves operators blind and AI training without data)</li>
<li>Always-on telemetry (violates performance invariant — must be zero-cost when disabled)</li>
</ul>
<p><strong>Phase:</strong> Backend server telemetry in Phase 5 (multiplayer). Engine telemetry in Phase 2 (sim) and Phase 3 (chrome/debug overlay). AI training pipeline in Phase 7 (LLM).</p>
<hr>
<h2 id="d032-switchable-ui-themes-main-menu-chrome-lobby"><a class="header" href="#d032-switchable-ui-themes-main-menu-chrome-lobby">D032: Switchable UI Themes (Main Menu, Chrome, Lobby)</a></h2>
<p><strong>Decision:</strong> Ship a YAML-driven UI theme system with multiple built-in presets. Players pick their preferred visual style for the main menu, in-game chrome (sidebar, minimap, build queue), and lobby. Mods and community can create and publish custom themes.</p>
<p><strong>Motivation:</strong></p>
<p>The Remastered Collection nailed its main menu — it respects the original Red Alert’s military aesthetic while modernizing the presentation. OpenRA went a completely different direction: functional, data-driven, but with a generic feel that doesn’t evoke the same nostalgia. Both approaches have merit for different audiences. Rather than pick one style, let the player choose.</p>
<p>This also mirrors D019 (switchable balance presets). Just as players choose between Classic, OpenRA, and Remastered balance rules in the lobby, they should be able to choose their visual experience the same way.</p>
<p><strong>Built-in themes (original art, not copied assets):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Theme</th><th>Inspired By</th><th>Aesthetic</th><th>Default For</th></tr>
</thead>
<tbody>
<tr><td>Classic</td><td>Original RA1 (1996)</td><td>Military minimalism — bare buttons over a static title screen, Soviet-era propaganda palette, utilitarian layout, Hell March on startup</td><td>RA1 game module</td></tr>
<tr><td>Remastered</td><td>Remastered Collection (2020)</td><td>Clean modern military — HD polish, sleek panels, reverent to the original but refined, jukebox integration</td><td>—</td></tr>
<tr><td>Modern</td><td>Iron Curtain’s own design</td><td>Full Bevy UI capabilities — dynamic panels, animated transitions, modern game launcher feel</td><td>New game modules</td></tr>
</tbody>
</table>
</div>
<p><strong>Important legal note:</strong> All theme art assets are <strong>original creations</strong> inspired by these design languages — no assets are copied from EA’s Remastered Collection (those are proprietary) or from OpenRA. The themes capture the <em>aesthetic philosophy</em> (palette, layout structure, design mood) but use entirely IC-created sprite sheets, fonts, and layouts. This is standard “inspired by” in game development — layout and color choices are not copyrightable, only specific artistic expression is.</p>
<p><strong>Theme structure (YAML-defined):</strong></p>
<pre><code class="language-yaml"># themes/classic.yaml
theme:
  name: Classic
  description: "Inspired by the original Red Alert — military minimalism"

  # Chrome sprite sheet — 9-slice panels, button states, scrollbars
  chrome:
    sprite_sheet: themes/classic/chrome.png
    panel: { top_left: [0, 0, 8, 8], ... }  # 9-slice regions
    button:
      normal: [0, 32, 118, 9]
      hover: [0, 41, 118, 9]
      pressed: [0, 50, 118, 9]
      disabled: [0, 59, 118, 9]

  # Color palette
  colors:
    primary: "#c62828"       # Soviet red
    secondary: "#1a1a2e"     # Dark navy
    text: "#e0e0e0"
    text_highlight: "#ffd600"
    panel_bg: "#0d0d1a"
    panel_border: "#4a4a5a"

  # Typography
  fonts:
    menu: { family: "military-stencil", size: 14 }
    body: { family: "default", size: 12 }
    hud: { family: "monospace", size: 11 }

  # Main menu layout
  main_menu:
    background: themes/classic/title.png     # static image
    shellmap: null                            # no live battle (faithfully minimal)
    music: THEME_INTRO                       # Hell March intro
    button_layout: vertical_center           # stacked buttons, centered
    show_version: true

  # In-game chrome
  ingame:
    sidebar: right                           # classic RA sidebar position
    minimap: top_right
    build_queue: sidebar_tabs
    resource_bar: top_center

  # Lobby
  lobby:
    style: compact                           # minimal chrome, functional
</code></pre>
<p><strong>Shellmap system (live menu backgrounds):</strong></p>
<p>Like OpenRA’s signature feature — a real game map with scripted AI battles running behind the main menu. But better:</p>
<ul>
<li><strong>Per-theme shellmaps.</strong> Each theme can specify its own shellmap, or none (Classic theme faithfully uses a static image).</li>
<li><strong>Multiple shellmaps with random selection.</strong> The Remastered and Modern themes can ship with several shellmaps — a random one plays each launch.</li>
<li><strong>Shellmaps are regular maps</strong> tagged with <code>visibility: shellmap</code> in YAML. The engine loads them with a scripted AI that stages dramatic battles. Mods automatically get their own shellmaps.</li>
<li><strong>Orbiting/panning camera.</strong> Shellmaps can define camera paths — slow pan across a battlefield, orbiting around a base, or fixed view.</li>
</ul>
<p><strong>Per-game-module default themes:</strong></p>
<p>Each game module registers its own default theme that matches its aesthetic:</p>
<ul>
<li><strong>RA1 module:</strong> Classic theme (red/black Soviet palette)</li>
<li><strong>TD module:</strong> GDI theme (green/black Nod palette) — community or first-party</li>
<li><strong>RA2 module:</strong> Remastered-style with RA2 color palette — community or first-party</li>
</ul>
<p>The game module provides a <code>default_theme()</code> in its <code>GameModule</code> trait implementation. Players override this in settings.</p>
<p><strong>Integration with existing UI architecture:</strong></p>
<p>The theme system layers on top of <code>ra-ui</code>’s existing responsive layout profiles (D002, <code>02-ARCHITECTURE.md</code>):</p>
<ul>
<li><strong>Layout profiles</strong> handle <em>where</em> UI elements go (sidebar vs bottom bar, phone vs desktop) — driven by <code>ScreenClass</code></li>
<li><strong>Themes</strong> handle <em>how</em> UI elements look (colors, chrome sprites, fonts, animations) — driven by player preference</li>
<li>Orthogonal concerns. A player on mobile gets the Phone layout profile + their chosen theme. A player on desktop gets the Desktop layout profile + their chosen theme.</li>
</ul>
<p><strong>Community themes:</strong></p>
<ul>
<li>Themes are Tier 1 mods (YAML + sprite sheets) — no code required</li>
<li>Publishable to the workshop (D030) as a standalone resource</li>
<li>Players subscribe to themes independently of gameplay mods — themes and gameplay mods stack</li>
<li>An “OpenRA-inspired” theme would be a natural community contribution</li>
<li>Total conversion mod developers create matching themes for their mods</li>
</ul>
<p><strong>What this enables:</strong></p>
<ol>
<li><strong>Day-one nostalgia choice.</strong> First launch asks: do you want Classic, Remastered, or Modern? Sets the mood immediately.</li>
<li><strong>Mod-matched chrome.</strong> A WWII mod ships its own olive-drab theme. A sci-fi mod ships neon blue chrome. The theme changes with the mod.</li>
<li><strong>Cross-view consistency with D019.</strong> Classic balance + Classic theme = feels like 1996. Remastered balance + Remastered theme = feels like 2020. Players configure the full experience.</li>
<li><strong>Live backgrounds without code.</strong> Shellmaps are regular maps — anyone can create one with the map editor.</li>
</ol>
<p><strong>Alternatives considered:</strong></p>
<ul>
<li>Hardcoded single theme (OpenRA approach) — forces one aesthetic on everyone; misses the emotional connection different players have to different eras of C&amp;C</li>
<li>Copy Remastered Collection assets — illegal; proprietary EA art</li>
<li>CSS-style theming (web-engine approach) — overengineered for a game; YAML is simpler and Bevy-native</li>
<li>Theme as a full WASM mod — overkill; theming is data, not behavior; Tier 1 YAML is sufficient</li>
</ul>
<p><strong>Phase:</strong> Phase 3 (Game Chrome). Theme system is part of the <code>ra-ui</code> crate. Built-in themes ship with the engine. Community themes available in Phase 6 (workshop).</p>
<hr>
<h2 id="pending-decisions"><a class="header" href="#pending-decisions">PENDING DECISIONS</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ID</th><th>Topic</th><th>Needs Resolution By</th></tr>
</thead>
<tbody>
<tr><td>P001</td><td><del>ECS crate choice</del> — RESOLVED: Bevy’s built-in ECS</td><td>Resolved</td></tr>
<tr><td>P002</td><td>Fixed-point scale (256? 1024? match OpenRA’s 1024?)</td><td>Phase 2 start</td></tr>
<tr><td>P003</td><td>Audio library choice</td><td>Phase 3 start</td></tr>
<tr><td>P004</td><td>Lobby/matchmaking protocol specifics</td><td>Phase 5 start</td></tr>
<tr><td>P005</td><td>Map editor architecture (in-engine vs separate process)</td><td>Phase 6 start</td></tr>
<tr><td>P006</td><td>License choice (GPL v3 to match EA source? MIT? Apache?)</td><td>Phase 0 start</td></tr>
<tr><td>P007</td><td><del>Workshop: single source vs multi-source</del> — RESOLVED: Federated multi-source (D030)</td><td>Resolved</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="10--performance-philosophy--strategy"><a class="header" href="#10--performance-philosophy--strategy">10 — Performance Philosophy &amp; Strategy</a></h1>
<h2 id="core-principle-efficiency-not-brute-force"><a class="header" href="#core-principle-efficiency-not-brute-force">Core Principle: Efficiency, Not Brute Force</a></h2>
<p><strong>Performance goal: a 2012 laptop with 2 cores and 4GB RAM runs a 500-unit battle smoothly. A modern machine handles 3000 units without sweating.</strong></p>
<p>We don’t achieve this by throwing threads at the problem. We achieve it by wasting almost nothing — like Datadog Vector’s pipeline or Tokio’s runtime. Every cycle does useful work. Every byte of memory is intentional. Multi-core is a bonus that emerges naturally, not a crutch the engine depends on.</p>
<p>This is a first-class project goal and a primary differentiator over OpenRA.</p>
<h2 id="the-efficiency-pyramid"><a class="header" href="#the-efficiency-pyramid">The Efficiency Pyramid</a></h2>
<p>Ordered by impact. Each layer works on a single core. Only the top layer requires multiple cores.</p>
<pre><code>                    ┌──────────────┐
                    │ Work-stealing │  Bonus: scales to N cores
                    │ (rayon/Bevy)  │  (automatic, zero config)
                  ┌─┴──────────────┴─┐
                  │  Zero-allocation  │  No heap churn in hot paths
                  │  hot paths        │  (scratch buffers, reuse)
                ┌─┴──────────────────┴─┐
                │  Amortized work       │  Spread cost across ticks
                │  (staggered updates)  │  (1/4 of units per tick)
              ┌─┴──────────────────────┴─┐
              │  Simulation LOD           │  Skip work that doesn't
              │  (adaptive detail)        │  affect the outcome
            ┌─┴──────────────────────────┴─┐
            │  Cache-friendly ECS layout    │  Data access patterns
            │  (hot/warm/cold separation)   │  that respect the hardware
          ┌─┴──────────────────────────────┴─┐
          │  Algorithmic efficiency            │  Better algorithms beat
          │  (O(n) beats O(n²) on any CPU)    │  more cores every time
          └────────────────────────────────────┘
              ▲ MOST IMPACT — start here
</code></pre>
<h2 id="layer-1-algorithmic-efficiency"><a class="header" href="#layer-1-algorithmic-efficiency">Layer 1: Algorithmic Efficiency</a></h2>
<p>Better algorithms on one core beat bad algorithms on eight cores. This is where 90% of the performance comes from.</p>
<h3 id="pathfinding-flowfields-replace-per-unit-a"><a class="header" href="#pathfinding-flowfields-replace-per-unit-a">Pathfinding: Flowfields Replace Per-Unit A*</a></h3>
<p>When 50 units move to the same area, OpenRA computes 50 separate A* paths.</p>
<pre><code>OpenRA (per-unit A*):
  50 units × ~200 nodes explored × ~10 ops/node = ~100,000 operations

Flowfield:
  1 field × ~2000 cells × ~5 ops/cell              = ~10,000 operations
  50 units × 1 lookup each                          =       50 operations
  Total                                             = ~10,050 operations

10x reduction. No threading involved.
</code></pre>
<p>The 51st unit ordered to the same area costs zero — the field already exists. Flowfields amortize across all units sharing a destination.</p>
<h3 id="spatial-indexing-grid-hash-replaces-brute-force-range-checks"><a class="header" href="#spatial-indexing-grid-hash-replaces-brute-force-range-checks">Spatial Indexing: Grid Hash Replaces Brute-Force Range Checks</a></h3>
<p>“Which enemies are in range of this turret?”</p>
<pre><code>Brute force: 1000 units × 1000 units = 1,000,000 distance checks/tick
Spatial hash: 1000 units × ~8 nearby   =     8,000 distance checks/tick

125x reduction. No threading involved.
</code></pre>
<p>A spatial hash grid divides the map into cells. Each entity registers in its cell. Range queries only check nearby cells. O(1) lookup per cell, O(k) per query where k is the number of nearby entities (typically &lt; 20).</p>
<h3 id="hierarchical-pathfinding-coarse-then-fine"><a class="header" href="#hierarchical-pathfinding-coarse-then-fine">Hierarchical Pathfinding: Coarse Then Fine</a></h3>
<p>Break the map into ~32x32 cell chunks. Path between chunks first (few nodes, fast), then path within the current chunk only. Most of the map is never pathfinded at all. Units approaching a new chunk compute the next fine-grained path just before entering.</p>
<h2 id="layer-2-cache-friendly-data-layout"><a class="header" href="#layer-2-cache-friendly-data-layout">Layer 2: Cache-Friendly Data Layout</a></h2>
<h3 id="ecs-archetype-storage-bevy-provides-this"><a class="header" href="#ecs-archetype-storage-bevy-provides-this">ECS Archetype Storage (Bevy provides this)</a></h3>
<pre><code>OOP (cache-hostile, typical C# pattern):
  Unit objects on heap: [pos, health, vel, name, sprite, audio, ...]
  Iterating 1000 positions touches 1000 scattered memory locations
  Cache miss rate: high — each unit object spans multiple cache lines

ECS archetype storage (cache-friendly):
  Positions:  [p0, p1, p2, ... p999]   ← 8KB contiguous, fits in L1 cache
  Healths:    [h0, h1, h2, ... h999]   ← 4KB contiguous, fits in L1 cache
  Movement system reads positions sequentially → perfect cache utilization
</code></pre>
<p>1000 units × 8-byte positions = 8KB. L1 cache on any CPU since ~2008 is at least 32KB. The entire position array fits in L1. Movement for 1000 units runs from the fastest memory on the chip.</p>
<h3 id="hot--warm--cold-separation"><a class="header" href="#hot--warm--cold-separation">Hot / Warm / Cold Separation</a></h3>
<pre><code>HOT (every tick, must be contiguous):
  Position (8B), Velocity (8B), Health (4B), SimLOD (1B), FogVisible (1B)
  → ~22 bytes per entity × 1000 = 22KB — fits in L1

WARM (some ticks, when relevant):
  Armament (16B), PathState (32B), BuildQueue (24B), HarvesterCargo (8B)
  → Separate archetype arrays, pulled into cache only when needed

COLD (rarely accessed, lives in Resources):
  UnitDef (name, icon, prereqs), SpriteSheet refs, AudioClip refs
  → Loaded once, referenced by ID, never iterated in hot loops
</code></pre>
<p>Design components to be small. A Position is 2 integers, not a struct with name, description, and sprite reference. The movement system pulls only positions and velocities — 16 bytes per entity, 16KB for 1000 units, pure L1.</p>
<h2 id="layer-3-simulation-lod-adaptive-detail"><a class="header" href="#layer-3-simulation-lod-adaptive-detail">Layer 3: Simulation LOD (Adaptive Detail)</a></h2>
<p>Not all units need full processing every tick. A harvester driving across an empty map with no enemies nearby doesn’t need per-tick pathfinding, collision detection, or animation state updates.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum SimLOD {
    /// Full processing: pathfinding, collision, precise targeting
    Full,
    /// Reduced: simplified pathing, broadphase collision only
    Reduced,
    /// Minimal: advance along pre-computed path, check arrival
    Minimal,
}

fn assign_sim_lod(
    unit_pos: CellPos,
    in_combat: bool,
    near_enemy: bool,
    near_friendly_base: bool,  // deterministic — same on all clients
) -&gt; SimLOD {
    if in_combat || near_enemy { SimLOD::Full }
    else if near_friendly_base { SimLOD::Reduced }
    else { SimLOD::Minimal }
}
<span class="boring">}</span></code></pre>
<p><strong>Determinism requirement:</strong> LOD assignment must be based on game state (not camera position), so all clients assign the same LOD. “Near enemy” and “near base” are deterministic queries.</p>
<p><strong>Impact:</strong> In a typical game, only 20-30% of units are in active combat at any moment. The other 70-80% use Reduced or Minimal processing. Effective per-tick cost drops proportionally.</p>
<h2 id="layer-4-amortized-work-staggered-updates"><a class="header" href="#layer-4-amortized-work-staggered-updates">Layer 4: Amortized Work (Staggered Updates)</a></h2>
<p>Expensive systems don’t need to process all entities every tick. Spread the cost evenly.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pathfinding_system(
    tick: Res&lt;CurrentTick&gt;,
    query: Query&lt;(Entity, &amp;Position, &amp;MoveTarget, &amp;SimLOD), With&lt;NeedsPath&gt;&gt;,
    nav: Res&lt;NavMesh&gt;,
) {
    let group = tick.0 % 4;  // 4 groups, each updated every 4 ticks
    
    for (entity, pos, target, lod) in &amp;query {
        let should_update = match lod {
            SimLOD::Full    =&gt; entity.index() % 4 == group,    // every 4 ticks
            SimLOD::Reduced =&gt; entity.index() % 8 == (group * 2) % 8,  // every 8 ticks
            SimLOD::Minimal =&gt; false,  // never replan, just follow existing path
        };
        
        if should_update {
            recompute_path(entity, pos, target, &amp;nav);
        }
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Result:</strong> Pathfinding cost per tick drops 75% for Full-LOD units, 87.5% for Reduced, 100% for Minimal. Combined with SimLOD, a 1000-unit game might recompute ~50 paths per tick instead of 1000.</p>
<h3 id="stagger-schedule"><a class="header" href="#stagger-schedule">Stagger Schedule</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>System</th><th>Full LOD</th><th>Reduced LOD</th><th>Minimal LOD</th></tr>
</thead>
<tbody>
<tr><td>Pathfinding replan</td><td>Every 4 ticks</td><td>Every 8 ticks</td><td>Never (follow path)</td></tr>
<tr><td>Fog visibility</td><td>Every tick</td><td>Every 2 ticks</td><td>Every 4 ticks</td></tr>
<tr><td>AI re-evaluation</td><td>Every 2 ticks</td><td>Every 4 ticks</td><td>Every 8 ticks</td></tr>
<tr><td>Collision detection</td><td>Every tick</td><td>Every 2 ticks</td><td>Broadphase only</td></tr>
</tbody>
</table>
</div>
<p><strong>Determinism preserved:</strong> The stagger schedule is based on entity ID and tick number — deterministic on all clients.</p>
<h2 id="layer-5-zero-allocation-hot-paths"><a class="header" href="#layer-5-zero-allocation-hot-paths">Layer 5: Zero-Allocation Hot Paths</a></h2>
<p>Heap allocation is expensive: the allocator touches cold memory, fragments the heap, and (in C#) creates GC pressure. Rust eliminates GC, but allocation itself still costs cache misses.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Pre-allocated scratch space reused every tick
/// Initialized once at game start, never reallocated
pub struct TickScratch {
    damage_events: Vec&lt;DamageEvent&gt;,       // capacity: 4096
    path_open_set: BinaryHeap&lt;PathNode&gt;,   // capacity: 8192
    path_closed_set: HashSet&lt;CellPos&gt;,     // capacity: 8192
    visible_cells: BitVec,                 // capacity: map_width × map_height
    validated_orders: Vec&lt;ValidatedOrder&gt;,  // capacity: 256
    combat_pairs: Vec&lt;(Entity, Entity)&gt;,   // capacity: 2048
}

impl TickScratch {
    fn reset(&amp;mut self) {
        // .clear() sets length to 0 but keeps allocated memory
        // Zero bytes allocated on heap during the hot loop
        self.damage_events.clear();
        self.path_open_set.clear();
        self.path_closed_set.clear();
        self.visible_cells.fill(false);
        self.validated_orders.clear();
        self.combat_pairs.clear();
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Per-tick allocation target: zero bytes.</strong> All temporary data goes into pre-allocated scratch buffers. <code>clear()</code> resets without deallocating. The hot loop touches only warm memory.</p>
<p>This is a fundamental advantage of Rust over C# for games. Idiomatic C# allocates many small objects per tick (iterators, LINQ results, temporary collections, event args), each of which contributes to GC pressure. Our engine targets zero per-tick allocations.</p>
<h2 id="layer-6-work-stealing-parallelism-bonus-scaling"><a class="header" href="#layer-6-work-stealing-parallelism-bonus-scaling">Layer 6: Work-Stealing Parallelism (Bonus Scaling)</a></h2>
<p>After layers 1-5, the engine is already fast on a single core. Parallelism scales it further on better hardware.</p>
<h3 id="how-bevy--rayon-work-stealing-operates"><a class="header" href="#how-bevy--rayon-work-stealing-operates">How Bevy + rayon Work-Stealing Operates</a></h3>
<p>Rayon (used internally by Bevy) creates exactly one thread per CPU core. No more, no less. Work is distributed via lock-free work-stealing queues:</p>
<pre><code>2-core laptop:
  Thread 0: [pathfind units 0-499]
  Thread 1: [pathfind units 500-999]
  → Both busy, no waste

8-core desktop:
  Thread 0: [pathfind units 0-124]
  Thread 1: [pathfind units 125-249]
  ...
  Thread 7: [pathfind units 875-999]
  → All busy, 4x faster than laptop

16-core workstation:
  → Same code, 16 threads, even faster
  → No configuration change
</code></pre>
<p>No thread is ever idle if work exists. No thread is ever created or destroyed during gameplay. This is the Tokio/Vector model applied to CPU-bound game logic.</p>
<h3 id="where-parallelism-actually-helps"><a class="header" href="#where-parallelism-actually-helps">Where Parallelism Actually Helps</a></h3>
<p>Only systems where per-entity work is independent and costly:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// YES — pathfinding is expensive and independent per unit
fn pathfinding_system(query: Query&lt;...&gt;, nav: Res&lt;NavMesh&gt;) {
    let results: Vec&lt;_&gt; = query.par_iter()
        .filter(|(_, _, _, lod)| lod.should_update_path(tick))
        .map(|(entity, pos, target, _)| {
            (entity, nav.find_path(pos, &amp;target.dest))
        })
        .collect();
    
    // Sort for determinism, then apply sequentially
    apply_sorted(results);
}

// NO — movement is cheap per unit, parallelism overhead not worth it
fn movement_system(mut query: Query&lt;(&amp;mut Position, &amp;Velocity)&gt;) {
    // Just iterate. Adding and subtracting integers.
    // Parallelism overhead would exceed the computation itself.
    for (mut pos, vel) in &amp;mut query {
        pos.x += vel.dx;
        pos.y += vel.dy;
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Rule of thumb:</strong> Only parallelize systems where per-entity work exceeds ~1 microsecond. Simple arithmetic on components is faster to iterate sequentially than to distribute.</p>
<h2 id="performance-targets"><a class="header" href="#performance-targets">Performance Targets</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Metric</th><th>Weak Machine (2 core, 4GB)</th><th>Mid Machine (8 core, 16GB)</th><th>Strong Machine (16 core, 32GB)</th><th>Mobile (phone/tablet)</th><th>Browser (WASM)</th></tr>
</thead>
<tbody>
<tr><td>Smooth battle size</td><td>500 units</td><td>2000 units</td><td>3000+ units</td><td>200 units</td><td>300 units</td></tr>
<tr><td>Tick time budget</td><td>66ms (15 tps)</td><td>66ms (15 tps)</td><td>33ms (30 tps)</td><td>66ms (15 tps)</td><td>66ms (15 tps)</td></tr>
<tr><td>Actual tick time (target)</td><td>&lt; 40ms</td><td>&lt; 10ms</td><td>&lt; 5ms</td><td>&lt; 50ms</td><td>&lt; 40ms</td></tr>
<tr><td>Render framerate</td><td>60fps</td><td>144fps</td><td>240fps</td><td>30fps</td><td>60fps</td></tr>
<tr><td>RAM usage (1000 units)</td><td>&lt; 150MB</td><td>&lt; 200MB</td><td>&lt; 200MB</td><td>&lt; 100MB</td><td>&lt; 100MB</td></tr>
<tr><td>Startup to menu</td><td>&lt; 3 seconds</td><td>&lt; 1 second</td><td>&lt; 1 second</td><td>&lt; 5 seconds</td><td>&lt; 8 seconds (incl. download)</td></tr>
<tr><td>Per-tick heap allocation</td><td>0 bytes</td><td>0 bytes</td><td>0 bytes</td><td>0 bytes</td><td>0 bytes</td></tr>
</tbody>
</table>
</div>
<h2 id="performance-vs-c-rts-engines-projected"><a class="header" href="#performance-vs-c-rts-engines-projected">Performance vs. C# RTS Engines (Projected)</a></h2>
<p><em>These are projected comparisons based on architectural analysis, not benchmarks. C# numbers are estimates for a typical C#/.NET single-threaded game loop with GC.</em></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>What</th><th>Typical C# RTS (e.g., OpenRA)</th><th>Our Engine</th><th>Why</th></tr>
</thead>
<tbody>
<tr><td>500 unit tick</td><td>Estimated 30-60ms (single thread + GC spikes)</td><td>~8ms (algorithmic + cache)</td><td>Flowfields, spatial hash, ECS layout</td></tr>
<tr><td>Memory per unit</td><td>Estimated ~2-4KB (C# objects + GC metadata)</td><td>~200-400 bytes (ECS packed)</td><td>No GC metadata, no vtable, no boxing</td></tr>
<tr><td>GC pause</td><td>5-50ms unpredictable spikes (C# characteristic)</td><td>0ms (doesn’t exist)</td><td>Rust ownership + zero-alloc hot paths</td></tr>
<tr><td>Pathfinding 50 units</td><td>50 × A* = ~2ms</td><td>1 flowfield + 50 lookups = ~0.1ms</td><td>Algorithm change, not hardware change</td></tr>
<tr><td>Memory fragmentation</td><td>Increases over game duration</td><td>Stable (pre-allocated pools)</td><td>Scratch buffers, no per-tick allocation</td></tr>
<tr><td>2-core scaling</td><td>1x (single-threaded, verified for OpenRA)</td><td>~1.5x (work-stealing helps where applicable)</td><td>rayon adaptive</td></tr>
<tr><td>8-core scaling</td><td>1x (single-threaded, verified for OpenRA)</td><td>~3-5x (diminishing returns on game logic)</td><td>rayon work-stealing</td></tr>
</tbody>
</table>
</div>
<h2 id="input-responsiveness-vs-openra"><a class="header" href="#input-responsiveness-vs-openra">Input Responsiveness vs. OpenRA</a></h2>
<p>Beyond raw sim performance, input responsiveness is where players <em>feel</em> the difference. OpenRA’s TCP lockstep model (verified: single-threaded game loop, static <code>OrderLatency</code>, all clients wait for slowest) freezes all players to wait for the slowest connection. Our relay model never stalls — late orders are dropped, not waited for.</p>
<p><em>OpenRA numbers below are estimates based on architectural analysis of their source code, not benchmarks.</em></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Factor</th><th>OpenRA (estimated)</th><th>Iron Curtain</th><th>Why Faster</th></tr>
</thead>
<tbody>
<tr><td>Waiting for slowest client</td><td>Yes — everyone freezes</td><td>No — relay drops late orders</td><td>Relay owns the clock</td></tr>
<tr><td>Order batching interval</td><td>Every N frames (configurable)</td><td>Every tick</td><td>Higher tick rate makes N=1 viable</td></tr>
<tr><td>Tick processing time</td><td>Estimated 30-60ms</td><td>~8ms</td><td>Algorithmic efficiency</td></tr>
<tr><td>Achievable tick rate</td><td>~15 tps</td><td>30+ tps</td><td>4x shorter lockstep window</td></tr>
<tr><td>GC pauses during tick</td><td>5-50ms (C# characteristic)</td><td>0ms</td><td>Rust, zero-allocation</td></tr>
<tr><td>Visual feedback on click</td><td>Waits for confirmation</td><td>Immediate (cosmetic)</td><td>Render-side prediction, no sim dependency</td></tr>
<tr><td>Single-player order delay</td><td>~66ms (1 projected frame)</td><td>~33ms (next tick at 30 tps)</td><td><code>LocalNetwork</code> = zero scheduling delay</td></tr>
<tr><td>Worst-case MP click-to-move</td><td>Estimated 200-400ms</td><td>80-120ms (relay deadline)</td><td>Fixed deadline, no hostage-taking</td></tr>
</tbody>
</table>
</div>
<p><strong>Combined effect:</strong> A single-player click-to-move that takes ~200ms in OpenRA (order latency + tick time + potential GC jank) should take ~33ms in Iron Curtain — imperceptible to human reaction time. Multiplayer improves from “at the mercy of the worst connection” to a fixed, predictable deadline.</p>
<p>See <code>03-NETCODE.md</code> § “Input Responsiveness” for the full architectural analysis, including visual prediction and single-player zero-delay.</p>
<h2 id="gpu--hardware-compatibility-bevywgpu-constraints"><a class="header" href="#gpu--hardware-compatibility-bevywgpu-constraints">GPU &amp; Hardware Compatibility (Bevy/wgpu Constraints)</a></h2>
<p>Bevy renders via <code>wgpu</code>, which translates to native GPU APIs. This creates a <strong>hardware floor</strong> that interacts with our “2012 laptop” performance target.</p>
<h3 id="wgpu-backend-matrix"><a class="header" href="#wgpu-backend-matrix">wgpu Backend Matrix</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Min API Version</th><th>Typical GPU Era</th><th>wgpu Support Level</th></tr>
</thead>
<tbody>
<tr><td>Vulkan</td><td>1.0+</td><td>2016+ (discrete), 2014+ (integrated Haswell)</td><td>First-class</td></tr>
<tr><td>DX12</td><td>Windows 10</td><td>2015+</td><td>First-class</td></tr>
<tr><td>Metal</td><td>macOS 10.14</td><td>2018+ Macs</td><td>First-class</td></tr>
<tr><td>OpenGL</td><td>GL 3.3+ / ES 3.0+</td><td>2010+</td><td><strong>Downlevel / best-effort</strong></td></tr>
<tr><td>WebGPU</td><td>Modern browsers</td><td>2023+</td><td>First-class</td></tr>
<tr><td>WebGL2</td><td>ES 3.0 equiv</td><td>Most browsers</td><td><strong>Downlevel, severe limits</strong></td></tr>
</tbody>
</table>
</div>
<h3 id="the-2012-laptop-problem"><a class="header" href="#the-2012-laptop-problem">The 2012 Laptop Problem</a></h3>
<p>A typical 2012 laptop has an <strong>Intel HD 4000</strong> (Ivy Bridge). This GPU supports OpenGL 4.0 but <strong>has no Vulkan driver</strong>. It falls back to wgpu’s GL 3.3 backend, which is downlevel — meaning reduced resource limits:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Resource</th><th>Vulkan/DX12 (WebGPU defaults)</th><th>GL 3.3 Downlevel</th><th>WebGL2</th></tr>
</thead>
<tbody>
<tr><td>Max texture dimension</td><td>8192×8192</td><td><strong>2048×2048</strong></td><td><strong>2048×2048</strong></td></tr>
<tr><td>Storage buffers per stage</td><td>8</td><td><strong>4</strong></td><td><strong>0</strong></td></tr>
<tr><td>Uniform buffer size</td><td>64 KiB</td><td><strong>16 KiB</strong></td><td><strong>16 KiB</strong></td></tr>
<tr><td>Compute shaders</td><td>Yes</td><td>GL 4.3+ only</td><td><strong>None</strong></td></tr>
<tr><td>Color attachments</td><td>8</td><td><strong>4</strong></td><td><strong>4</strong></td></tr>
<tr><td>Storage textures</td><td>4</td><td>4</td><td><strong>0</strong></td></tr>
</tbody>
</table>
</div>
<h3 id="impact-on-our-feature-plans"><a class="header" href="#impact-on-our-feature-plans">Impact on Our Feature Plans</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Problem on Downlevel Hardware</th><th>Severity</th><th>Mitigation</th></tr>
</thead>
<tbody>
<tr><td>GPU particle weather</td><td>Compute shaders needed; HD 4000 has GL 4.0, compute needs 4.3</td><td>High</td><td>CPU particle fallback (Tier 0)</td></tr>
<tr><td>Shader terrain blending (D022)</td><td>Complex fragment shaders + texture arrays hit uniform/sampler limits</td><td>Medium</td><td>Palette tinting fallback (zero extra resources)</td></tr>
<tr><td>Post-processing chain</td><td>Bloom, color grading, SSR need MRT + decent fill rate</td><td>Medium</td><td>Disable post-FX on Tier 0</td></tr>
<tr><td>Dynamic lighting</td><td>Multiple render targets, shadow maps</td><td>Medium</td><td>Static baked lighting on Tier 0</td></tr>
<tr><td>HD sprite sheets</td><td>2048px max texture on downlevel</td><td>Low</td><td>Split sprite sheets at asset build time</td></tr>
<tr><td>WebGL2/WASM visuals</td><td>Zero compute, zero storage buffers, no GPU particles</td><td>High</td><td>Target WebGPU-only for browser (or accept limits)</td></tr>
<tr><td>Simulation / ECS</td><td><strong>No impact</strong> — pure CPU, no GPU dependency</td><td>None</td><td>—</td></tr>
<tr><td>Audio / Networking / Modding</td><td><strong>No impact</strong> — none touch the GPU</td><td>None</td><td>—</td></tr>
</tbody>
</table>
</div>
<p><strong>Key insight:</strong> The “2012 laptop” target is achievable for the <strong>simulation</strong> (500 units, &lt; 40ms tick) because the sim is pure CPU. The <strong>rendering</strong> must degrade gracefully — reduced visual effects, not broken gameplay.</p>
<h3 id="render-quality-tiers"><a class="header" href="#render-quality-tiers">Render Quality Tiers</a></h3>
<p><code>ra-render</code> queries device capabilities at startup via wgpu’s adapter limits and selects a render tier stored in the <code>RenderSettings</code> resource. All tiers produce an identical, playable game — they differ only in visual richness.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Tier</th><th>Name</th><th>Target Hardware</th><th>GPU Particles</th><th>Post-FX</th><th>Weather Visuals</th><th>Dynamic Lighting</th><th>Texture Limits</th></tr>
</thead>
<tbody>
<tr><td>0</td><td><strong>Baseline</strong></td><td>GL 3.3 (Intel HD 4000), WebGL2</td><td>CPU fallback</td><td>None</td><td>Palette tinting</td><td>None (baked)</td><td>2048×2048 max</td></tr>
<tr><td>1</td><td><strong>Standard</strong></td><td>Vulkan/DX12 basic (Intel HD 5000+, GTX 600+)</td><td>GPU compute</td><td>Basic (bloom)</td><td>Overlay sprites</td><td>Point lights</td><td>8192×8192</td></tr>
<tr><td>2</td><td><strong>Enhanced</strong></td><td>Vulkan/DX12 capable (GTX 900+, RX 400+)</td><td>GPU compute</td><td>Full chain</td><td>Shader blending</td><td>Full + shadows</td><td>8192×8192</td></tr>
<tr><td>3</td><td><strong>Ultra</strong></td><td>High-end desktop</td><td>GPU compute</td><td>Full + SSR</td><td>Shader + accumulation</td><td>Dynamic + cascade shadows</td><td>16384×16384</td></tr>
</tbody>
</table>
</div>
<p><strong>Tier selection is automatic but overridable.</strong> Detected at startup from <code>wgpu::Adapter::limits()</code> and <code>wgpu::Adapter::features()</code>. Players can force a lower tier in settings. Mods can ship tier-specific assets.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ra-render: runtime render configuration
pub struct RenderSettings {
    pub tier: RenderTier,           // Auto-detected or user-forced
    pub fps_cap: u32,               // 30, 60, 144, 240, uncapped
    pub resolution_scale: f32,      // 0.5 - 2.0 (render resolution vs display)
    pub particle_density: f32,      // 0.0 - 1.0 (scales particle count)
    pub post_fx_enabled: bool,      // Master toggle for all post-processing
    pub weather_visual_mode: WeatherVisualMode,  // PaletteTint, Overlay, ShaderBlend
    pub sprite_sheet_max: u32,      // Derived from adapter texture limits
}

pub enum RenderTier {
    Baseline,   // Tier 0: GL 3.3 / WebGL2 — functional but plain
    Standard,   // Tier 1: Basic Vulkan/DX12 — GPU particles, basic post-FX
    Enhanced,   // Tier 2: Capable GPU — full visual pipeline
    Ultra,      // Tier 3: High-end — everything maxed
}
<span class="boring">}</span></code></pre>
<h3 id="mitigation-strategies"><a class="header" href="#mitigation-strategies">Mitigation Strategies</a></h3>
<ol>
<li>
<p><strong>CPU particle fallback:</strong> Bevy supports CPU-side particle emission. Lower particle count but functional. Weather rain/snow works on Tier 0 — just fewer particles.</p>
</li>
<li>
<p><strong>Sprite sheet splitting:</strong> The asset pipeline (Phase 0, <code>ra-formats</code>) splits large sprite sheets into 2048×2048 chunks at build time when targeting downlevel. Zero runtime cost — the splitting is a bake step.</p>
</li>
<li>
<p><strong>WebGPU-first browser strategy:</strong> WebGPU is supported in Chrome, Edge, and Firefox (2023+). Rather than maintaining a severely limited WebGL2 fallback, target WebGPU for the browser build (Phase 7) and document WebGL2 as best-effort.</p>
</li>
<li>
<p><strong>Graceful detection, not crashes:</strong> If the GPU doesn’t meet even Tier 0 requirements, show a clear error message with hardware info and suggest driver updates. Never crash with a raw wgpu error.</p>
</li>
<li>
<p><strong>Shader complexity budget:</strong> All shaders must compile on GL 3.3 (or have a GL 3.3 variant). Complex shaders (terrain blending, weather) provide simplified fallback paths via <code>#ifdef</code> or shader permutations.</p>
</li>
</ol>
<h3 id="hardware-floor-summary"><a class="header" href="#hardware-floor-summary">Hardware Floor Summary</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concern</th><th>Our Minimum</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>GPU API</td><td>OpenGL 3.3 (fallback) / Vulkan 1.0 (preferred)</td><td>wgpu auto-selects best available backend</td></tr>
<tr><td>GPU memory</td><td>256 MB</td><td>Classic RA sprites are tiny; HD sprites need more</td></tr>
<tr><td>OS</td><td>Windows 7 SP1+ / macOS 10.14+ / Linux (X11/Wayland)</td><td>DX12 requires Windows 10; GL 3.3 works on 7</td></tr>
<tr><td>CPU</td><td>2 cores, SSE2</td><td>Sim runs fine; Bevy itself needs ~2 threads minimum</td></tr>
<tr><td>RAM</td><td>4 GB</td><td>Engine targets &lt; 150 MB for 1000 units</td></tr>
<tr><td>Disk</td><td>~500 MB</td><td>Engine + classic assets; HD assets add ~1-2 GB</td></tr>
</tbody>
</table>
</div>
<p><strong>Bottom line:</strong> Bevy/wgpu will run on 2012 hardware, but <strong>visual features must tier down automatically.</strong> The sim is completely unaffected. The architecture already has <code>RenderSettings</code> — we formalize it into the tier system above.</p>
<hr>
<h2 id="profiling--regression-strategy"><a class="header" href="#profiling--regression-strategy">Profiling &amp; Regression Strategy</a></h2>
<h3 id="automated-benchmarks-ci"><a class="header" href="#automated-benchmarks-ci">Automated Benchmarks (CI)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[bench] fn bench_tick_100_units()  { tick_bench(100); }
#[bench] fn bench_tick_500_units()  { tick_bench(500); }
#[bench] fn bench_tick_1000_units() { tick_bench(1000); }
#[bench] fn bench_tick_2000_units() { tick_bench(2000); }

#[bench] fn bench_flowfield_generation() { ... }
#[bench] fn bench_spatial_query_1000() { ... }
#[bench] fn bench_fog_recalc_full_map() { ... }

#[bench] fn bench_snapshot_1000_units() { ... }
#[bench] fn bench_restore_1000_units() { ... }
<span class="boring">}</span></code></pre>
<h3 id="regression-rule"><a class="header" href="#regression-rule">Regression Rule</a></h3>
<p>CI fails if any benchmark regresses &gt; 10% from the rolling average. Performance is a ratchet — it only goes up.</p>
<h3 id="engine-telemetry-d031"><a class="header" href="#engine-telemetry-d031">Engine Telemetry (D031)</a></h3>
<p>Per-system tick timing from the benchmark suite can be exported as OTEL metrics for deeper analysis when the <code>telemetry</code> feature flag is enabled. This bridges offline benchmarks with live system inspection:</p>
<ul>
<li>Per-system execution time histograms (<code>sim.system.&lt;name&gt;_us</code>)</li>
<li>Entity count gauges, pathfinding cache hit rates, memory usage</li>
<li>Gameplay event stream for AI training data collection</li>
<li>Debug overlay (via <code>bevy_egui</code>) reads live telemetry for real-time profiling during development</li>
</ul>
<p>Telemetry is zero-cost when disabled (compile-time feature gate). Release builds intended for players ship without it. Tournament servers, AI training, and development builds enable it. See <code>09-DECISIONS.md</code> § D031 for full design.</p>
<h3 id="profile-before-parallelize"><a class="header" href="#profile-before-parallelize">Profile Before Parallelize</a></h3>
<p>Never add <code>par_iter()</code> without profiling first. Measure single-threaded. If a system takes &gt; 1ms, consider parallelizing. If it takes &lt; 0.1ms, sequential is faster (avoids coordination overhead).</p>
<h2 id="decision-record"><a class="header" href="#decision-record">Decision Record</a></h2>
<h3 id="d015-performance--efficiency-first-not-thread-first-1"><a class="header" href="#d015-performance--efficiency-first-not-thread-first-1">D015: Performance — Efficiency-First, Not Thread-First</a></h3>
<p><strong>Decision:</strong> Performance is achieved through algorithmic efficiency, cache-friendly data layout, adaptive workload, zero allocation, and amortized computation. Multi-core scaling is a bonus layer on top, not the foundation.</p>
<p><strong>Principle:</strong> The engine must run a 500-unit battle smoothly on a 2-core, 4GB machine from 2012. Multi-core machines get higher unit counts as a natural consequence of the work-stealing scheduler.</p>
<p><strong>Inspired by:</strong> Datadog Vector’s pipeline efficiency, Tokio’s work-stealing runtime, axum’s zero-overhead request handling. These systems are fast because they waste nothing, not because they use more hardware.</p>
<p><strong>Anti-pattern:</strong> “Just parallelize it” as the answer to performance questions. Parallelism without algorithmic efficiency is like adding lanes to a highway with broken traffic lights.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="openra-engine--comprehensive-feature-reference"><a class="header" href="#openra-engine--comprehensive-feature-reference">OpenRA Engine — Comprehensive Feature Reference</a></h1>
<blockquote>
<p><strong>Purpose:</strong> Exhaustive catalog of every feature the OpenRA engine provides to modders and game developers.
Sourced directly from the OpenRA/OpenRA GitHub repository (C#/.NET).
Organized by category for Iron Curtain design reference.</p>
</blockquote>
<hr>
<h2 id="1-trait-system-actor-component-architecture"><a class="header" href="#1-trait-system-actor-component-architecture">1. Trait System (Actor Component Architecture)</a></h2>
<p>OpenRA’s core architecture uses a <strong>trait system</strong> — essentially a component-entity model. Every actor (unit, building, prop) is defined by composing traits in YAML. Each trait is a C# class implementing one or more interfaces. Traits attach to actors, players, or the world.</p>
<h3 id="core-trait-infrastructure"><a class="header" href="#core-trait-infrastructure">Core Trait Infrastructure</a></h3>
<ul>
<li><strong>TraitsInterfaces</strong> — Master file defining all trait interfaces (<code>ITraitInfo</code>, <code>IOccupySpace</code>, <code>IPositionable</code>, <code>IMove</code>, <code>IFacing</code>, <code>IHealth</code>, <code>INotifyCreated</code>, <code>INotifyDamage</code>, <code>INotifyKilled</code>, <code>IWorldLoaded</code>, <code>ITick</code>, <code>IRender</code>, <code>IResolveOrder</code>, <code>IOrderVoice</code>, etc.)</li>
<li><strong>ConditionalTrait</strong> — Base class enabling traits to be enabled/disabled by conditions</li>
<li><strong>PausableConditionalTrait</strong> — Conditional trait that can also be paused</li>
<li><strong>Target</strong> — Represents a target for orders/attacks (actor, terrain position, frozen actor)</li>
<li><strong>ActivityUtils</strong> — Utilities for the activity (action queue) system</li>
<li><strong>LintAttributes</strong> — Compile-time validation attributes for trait definitions</li>
</ul>
<h3 id="general-actor-traits-130-traits"><a class="header" href="#general-actor-traits-130-traits">General Actor Traits (~130+ traits)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Health</code></td><td>Hit points (current, max), damage state tracking</td></tr>
<tr><td><code>Armor</code></td><td>Armor type for damage calculation</td></tr>
<tr><td><code>Mobile</code></td><td>Movement capability, speed, locomotor reference</td></tr>
<tr><td><code>Immobile</code></td><td>Cannot move (buildings, props)</td></tr>
<tr><td><code>Selectable</code></td><td>Can be selected by player</td></tr>
<tr><td><code>IsometricSelectable</code></td><td>Selection for isometric maps</td></tr>
<tr><td><code>Interactable</code></td><td>Can be interacted with</td></tr>
<tr><td><code>Tooltip</code></td><td>Name shown on hover</td></tr>
<tr><td><code>TooltipDescription</code></td><td>Extended description text</td></tr>
<tr><td><code>Valued</code></td><td>Cost in credits</td></tr>
<tr><td><code>Voiced</code></td><td>Has voice lines</td></tr>
<tr><td><code>Buildable</code></td><td>Can be produced (cost, time, prerequisites)</td></tr>
<tr><td><code>Encyclopedia</code></td><td>In-game encyclopedia entry</td></tr>
<tr><td><code>MapEditorData</code></td><td>Data for map editor display</td></tr>
<tr><td><code>ScriptTags</code></td><td>Tags for Lua scripting identification</td></tr>
</tbody>
</table>
</div>
<h3 id="combat-traits"><a class="header" href="#combat-traits">Combat Traits</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Armament</code></td><td>Weapon mount (weapon, cooldown, barrel)</td></tr>
<tr><td><code>AttackBase</code></td><td>Base attack logic</td></tr>
<tr><td><code>AttackFollow</code></td><td>Attack while following target</td></tr>
<tr><td><code>AttackFrontal</code></td><td>Attack only from front arc</td></tr>
<tr><td><code>AttackOmni</code></td><td>Attack in any direction</td></tr>
<tr><td><code>AttackTurreted</code></td><td>Attack using turret</td></tr>
<tr><td><code>AttackCharges</code></td><td>Attack with charge mechanic</td></tr>
<tr><td><code>AttackGarrisoned</code></td><td>Attack from inside garrison</td></tr>
<tr><td><code>AutoTarget</code></td><td>Automatic target acquisition</td></tr>
<tr><td><code>AutoTargetPriority</code></td><td>Priority for auto-targeting</td></tr>
<tr><td><code>Turreted</code></td><td>Has rotatable turret</td></tr>
<tr><td><code>AmmoPool</code></td><td>Ammunition system</td></tr>
<tr><td><code>ReloadAmmoPool</code></td><td>Ammo reload behavior</td></tr>
<tr><td><code>Rearmable</code></td><td>Can rearm at specific buildings</td></tr>
<tr><td><code>BlocksProjectiles</code></td><td>Blocks projectile passage</td></tr>
<tr><td><code>JamsMissiles</code></td><td>Missile jamming capability</td></tr>
<tr><td><code>HitShape</code></td><td>Collision shape for hit detection</td></tr>
<tr><td><code>Targetable</code></td><td>Can be targeted by weapons</td></tr>
<tr><td><code>RevealOnFire</code></td><td>Reveals when firing</td></tr>
</tbody>
</table>
</div>
<h3 id="movement--positioning"><a class="header" href="#movement--positioning">Movement &amp; Positioning</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Mobile</code></td><td>Ground movement (speed, locomotor)</td></tr>
<tr><td><code>Aircraft</code></td><td>Air movement (altitude, VTOL, speed, turn)</td></tr>
<tr><td><code>AttackAircraft</code></td><td>Air-to-ground attack patterns</td></tr>
<tr><td><code>AttackBomber</code></td><td>Bombing run behavior</td></tr>
<tr><td><code>FallsToEarth</code></td><td>Crash behavior when killed</td></tr>
<tr><td><code>BodyOrientation</code></td><td>Physical orientation of actor</td></tr>
<tr><td><code>QuantizeFacingsFromSequence</code></td><td>Snap facings to sprite frames</td></tr>
<tr><td><code>Wanders</code></td><td>Random wandering movement</td></tr>
<tr><td><code>AttackMove</code></td><td>Attack-move command support</td></tr>
<tr><td><code>AttackWander</code></td><td>Attack while wandering</td></tr>
<tr><td><code>TurnOnIdle</code></td><td>Turn to face direction when idle</td></tr>
<tr><td><code>Husk</code></td><td>Wreck/corpse behavior</td></tr>
</tbody>
</table>
</div>
<h3 id="transport--cargo"><a class="header" href="#transport--cargo">Transport &amp; Cargo</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Cargo</code></td><td>Can carry passengers</td></tr>
<tr><td><code>Passenger</code></td><td>Can be carried</td></tr>
<tr><td><code>Carryall</code></td><td>Air transport (pick up &amp; carry)</td></tr>
<tr><td><code>Carryable</code></td><td>Can be picked up by carryall</td></tr>
<tr><td><code>AutoCarryall</code></td><td>Automatic carryall dispatch</td></tr>
<tr><td><code>AutoCarryable</code></td><td>Can be auto-carried</td></tr>
<tr><td><code>CarryableHarvester</code></td><td>Harvester carryall integration</td></tr>
<tr><td><code>ParaDrop</code></td><td>Paradrop passengers</td></tr>
<tr><td><code>Parachutable</code></td><td>Can use parachute</td></tr>
<tr><td><code>EjectOnDeath</code></td><td>Eject pilot on destruction</td></tr>
<tr><td><code>EntersTunnels</code></td><td>Can use tunnel network</td></tr>
<tr><td><code>TunnelEntrance</code></td><td>Tunnel entry point</td></tr>
</tbody>
</table>
</div>
<h3 id="economy--harvesting"><a class="header" href="#economy--harvesting">Economy &amp; Harvesting</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Harvester</code></td><td>Resource gathering (capacity, resource type)</td></tr>
<tr><td><code>StoresResources</code></td><td>Local resource storage</td></tr>
<tr><td><code>StoresPlayerResources</code></td><td>Player-wide resource storage</td></tr>
<tr><td><code>SeedsResource</code></td><td>Creates resources on map</td></tr>
<tr><td><code>CashTrickler</code></td><td>Periodic cash generation</td></tr>
<tr><td><code>AcceptsDeliveredCash</code></td><td>Receives cash deliveries</td></tr>
<tr><td><code>DeliversCash</code></td><td>Delivers cash to target</td></tr>
<tr><td><code>AcceptsDeliveredExperience</code></td><td>Receives experience deliveries</td></tr>
<tr><td><code>DeliversExperience</code></td><td>Delivers experience to target</td></tr>
<tr><td><code>GivesBounty</code></td><td>Awards cash on kill</td></tr>
<tr><td><code>GivesCashOnCapture</code></td><td>Awards cash when captured</td></tr>
<tr><td><code>CustomSellValue</code></td><td>Override sell price</td></tr>
</tbody>
</table>
</div>
<h3 id="stealth--detection"><a class="header" href="#stealth--detection">Stealth &amp; Detection</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Cloak</code></td><td>Invisibility system</td></tr>
<tr><td><code>DetectCloaked</code></td><td>Reveals cloaked units</td></tr>
<tr><td><code>IgnoresCloak</code></td><td>Can target cloaked units</td></tr>
<tr><td><code>IgnoresDisguise</code></td><td>Sees through disguises</td></tr>
<tr><td><code>AffectsShroud</code></td><td>Base for shroud/fog traits</td></tr>
<tr><td><code>CreatesShroud</code></td><td>Creates shroud around actor</td></tr>
<tr><td><code>RevealsShroud</code></td><td>Reveals shroud (sight range)</td></tr>
<tr><td><code>RevealsMap</code></td><td>Reveals entire map</td></tr>
<tr><td><code>RevealOnDeath</code></td><td>Reveals area on death</td></tr>
</tbody>
</table>
</div>
<h3 id="capture--ownership"><a class="header" href="#capture--ownership">Capture &amp; Ownership</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Capturable</code></td><td>Can be captured</td></tr>
<tr><td><code>CapturableProgressBar</code></td><td>Shows capture progress</td></tr>
<tr><td><code>CapturableProgressBlink</code></td><td>Blinks during capture</td></tr>
<tr><td><code>CaptureManager</code></td><td>Manages capture state</td></tr>
<tr><td><code>CaptureProgressBar</code></td><td>Progress bar for capturer</td></tr>
<tr><td><code>Captures</code></td><td>Can capture targets</td></tr>
<tr><td><code>ProximityCapturable</code></td><td>Captured by proximity</td></tr>
<tr><td><code>ProximityCaptor</code></td><td>Captures by proximity</td></tr>
<tr><td><code>RegionProximityCapturable</code></td><td>Region-based proximity capture</td></tr>
<tr><td><code>TemporaryOwnerManager</code></td><td>Temporary ownership changes</td></tr>
<tr><td><code>TransformOnCapture</code></td><td>Transform when captured</td></tr>
</tbody>
</table>
</div>
<h3 id="destruction--death"><a class="header" href="#destruction--death">Destruction &amp; Death</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>KillsSelf</code></td><td>Self-destruct timer</td></tr>
<tr><td><code>SpawnActorOnDeath</code></td><td>Spawn actor when killed</td></tr>
<tr><td><code>SpawnActorsOnSell</code></td><td>Spawn actors when sold</td></tr>
<tr><td><code>ShakeOnDeath</code></td><td>Screen shake on death</td></tr>
<tr><td><code>ExplosionOnDamageTransition</code></td><td>Explode at damage thresholds</td></tr>
<tr><td><code>FireWarheadsOnDeath</code></td><td>Apply warheads on death</td></tr>
<tr><td><code>FireProjectilesOnDeath</code></td><td>Fire projectiles on death</td></tr>
<tr><td><code>FireWarheads</code></td><td>General warhead application</td></tr>
<tr><td><code>MustBeDestroyed</code></td><td>Must be destroyed for victory</td></tr>
<tr><td><code>OwnerLostAction</code></td><td>Behavior when owner loses</td></tr>
</tbody>
</table>
</div>
<h3 id="miscellaneous-actor-traits"><a class="header" href="#miscellaneous-actor-traits">Miscellaneous Actor Traits</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>AutoCrusher</code></td><td>Automatically crushes crushable actors</td></tr>
<tr><td><code>Crushable</code></td><td>Can be crushed by vehicles</td></tr>
<tr><td><code>TransformCrusherOnCrush</code></td><td>Transform crusher on crush</td></tr>
<tr><td><code>DamagedByTerrain</code></td><td>Takes terrain damage</td></tr>
<tr><td><code>ChangesHealth</code></td><td>Health change over time</td></tr>
<tr><td><code>ChangesTerrain</code></td><td>Modifies terrain type</td></tr>
<tr><td><code>Demolishable</code></td><td>Can be demolished</td></tr>
<tr><td><code>Demolition</code></td><td>Can demolish buildings</td></tr>
<tr><td><code>Guard</code></td><td>Guard command support</td></tr>
<tr><td><code>Guardable</code></td><td>Can be guarded</td></tr>
<tr><td><code>Huntable</code></td><td>Can be hunted by AI</td></tr>
<tr><td><code>InstantlyRepairable</code></td><td>Can be instantly repaired</td></tr>
<tr><td><code>InstantlyRepairs</code></td><td>Can instantly repair</td></tr>
<tr><td><code>Mine</code></td><td>Land mine</td></tr>
<tr><td><code>Minelayer</code></td><td>Can lay mines</td></tr>
<tr><td><code>Plug</code></td><td>Plugs into pluggable (e.g., bio-reactor)</td></tr>
<tr><td><code>Pluggable</code></td><td>Accepts plug actors</td></tr>
<tr><td><code>Replaceable</code></td><td>Can be replaced by Replacement</td></tr>
<tr><td><code>Replacement</code></td><td>Replaces a Replaceable actor</td></tr>
<tr><td><code>RejectsOrders</code></td><td>Ignores player commands</td></tr>
<tr><td><code>Sellable</code></td><td>Can be sold</td></tr>
<tr><td><code>Transforms</code></td><td>Can transform into another actor</td></tr>
<tr><td><code>ThrowsParticle</code></td><td>Emits particle effects</td></tr>
<tr><td><code>CommandBarBlacklist</code></td><td>Excluded from command bar</td></tr>
<tr><td><code>AppearsOnMapPreview</code></td><td>Visible in map preview</td></tr>
<tr><td><code>Repairable</code></td><td>Can be sent for repair</td></tr>
<tr><td><code>RepairableNear</code></td><td>Can be repaired when nearby</td></tr>
<tr><td><code>RepairsUnits</code></td><td>Repairs nearby units</td></tr>
<tr><td><code>RepairsBridges</code></td><td>Can repair bridges</td></tr>
<tr><td><code>UpdatesDerrickCount</code></td><td>Tracks oil derrick count</td></tr>
<tr><td><code>CombatDebugOverlay</code></td><td>Debug combat visualization</td></tr>
<tr><td><code>ProducibleWithLevel</code></td><td>Produced with veterancy level</td></tr>
<tr><td><code>RequiresSpecificOwners</code></td><td>Only specific owners can use</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="2-building-system"><a class="header" href="#2-building-system">2. Building System</a></h2>
<h3 id="building-traits"><a class="header" href="#building-traits">Building Traits</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Building</code></td><td>Base building trait (footprint, dimensions)</td></tr>
<tr><td><code>BuildingInfluence</code></td><td>Building cell occupation tracking</td></tr>
<tr><td><code>BaseBuilding</code></td><td>Base expansion flag</td></tr>
<tr><td><code>BaseProvider</code></td><td>Provides base build radius</td></tr>
<tr><td><code>GivesBuildableArea</code></td><td>Enables building placement nearby</td></tr>
<tr><td><code>RequiresBuildableArea</code></td><td>Requires buildable area for placement</td></tr>
<tr><td><code>PrimaryBuilding</code></td><td>Can be set as primary</td></tr>
<tr><td><code>RallyPoint</code></td><td>Production rally point</td></tr>
<tr><td><code>Exit</code></td><td>Unit exit points</td></tr>
<tr><td><code>Reservable</code></td><td>Landing pad reservation</td></tr>
<tr><td><code>Refinery</code></td><td>Resource delivery point</td></tr>
<tr><td><code>RepairableBuilding</code></td><td>Can be repaired by player</td></tr>
<tr><td><code>Gate</code></td><td>Openable gate</td></tr>
</tbody>
</table>
</div>
<h3 id="building-placement"><a class="header" href="#building-placement">Building Placement</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>ActorPreviewPlaceBuildingPreview</code></td><td>Actor preview during placement</td></tr>
<tr><td><code>FootprintPlaceBuildingPreview</code></td><td>Footprint overlay during placement</td></tr>
<tr><td><code>SequencePlaceBuildingPreview</code></td><td>Sequence-based placement preview</td></tr>
<tr><td><code>PlaceBuildingVariants</code></td><td>Multiple placement variants</td></tr>
<tr><td><code>LineBuild</code></td><td>Line-building (walls)</td></tr>
<tr><td><code>LineBuildNode</code></td><td>Node for line-building</td></tr>
<tr><td><code>MapBuildRadius</code></td><td>Controls build radius rules</td></tr>
</tbody>
</table>
</div>
<h3 id="bridge-system"><a class="header" href="#bridge-system">Bridge System</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Bridge</code></td><td>Bridge segment</td></tr>
<tr><td><code>BridgeHut</code></td><td>Bridge repair hut</td></tr>
<tr><td><code>BridgePlaceholder</code></td><td>Bridge placeholder</td></tr>
<tr><td><code>BridgeLayer</code></td><td>World bridge management</td></tr>
<tr><td><code>GroundLevelBridge</code></td><td>Ground-level bridge</td></tr>
<tr><td><code>LegacyBridgeHut</code></td><td>Legacy bridge support</td></tr>
<tr><td><code>LegacyBridgeLayer</code></td><td>Legacy bridge management</td></tr>
<tr><td><code>ElevatedBridgeLayer</code></td><td>Elevated bridge system</td></tr>
<tr><td><code>ElevatedBridgePlaceholder</code></td><td>Elevated bridge placeholder</td></tr>
</tbody>
</table>
</div>
<h3 id="building-transforms"><a class="header" href="#building-transforms">Building Transforms</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>TransformsIntoAircraft</code></td><td>Building → aircraft</td></tr>
<tr><td><code>TransformsIntoDockClientManager</code></td><td>Building → dock client</td></tr>
<tr><td><code>TransformsIntoEntersTunnels</code></td><td>Building → tunnel user</td></tr>
<tr><td><code>TransformsIntoMobile</code></td><td>Building → mobile unit</td></tr>
<tr><td><code>TransformsIntoPassenger</code></td><td>Building → passenger</td></tr>
<tr><td><code>TransformsIntoRepairable</code></td><td>Building → repairable</td></tr>
<tr><td><code>TransformsIntoTransforms</code></td><td>Building → transformable</td></tr>
</tbody>
</table>
</div>
<h3 id="docking-system"><a class="header" href="#docking-system">Docking System</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>DockClientBase</code></td><td>Base for dock clients (harvesters, etc.)</td></tr>
<tr><td><code>DockClientManager</code></td><td>Manages dock client behavior</td></tr>
<tr><td><code>DockHost</code></td><td>Building that accepts docks (refinery, repair pad)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="3-production-system"><a class="header" href="#3-production-system">3. Production System</a></h2>
<h3 id="production-traits"><a class="header" href="#production-traits">Production Traits</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Production</code></td><td>Base production capability</td></tr>
<tr><td><code>ProductionQueue</code></td><td>Standard production queue (base class, 25KB)</td></tr>
<tr><td><code>ClassicProductionQueue</code></td><td>C&amp;C-style single queue per type</td></tr>
<tr><td><code>ClassicParallelProductionQueue</code></td><td>Parallel production (RA2 style)</td></tr>
<tr><td><code>ParallelProductionQueue</code></td><td>Modern parallel production</td></tr>
<tr><td><code>BulkProductionQueue</code></td><td>Bulk production variant</td></tr>
<tr><td><code>ProductionQueueFromSelection</code></td><td>Queue from selected factory</td></tr>
<tr><td><code>ProductionAirdrop</code></td><td>Air-delivered production</td></tr>
<tr><td><code>ProductionBulkAirDrop</code></td><td>Bulk airdrop production</td></tr>
<tr><td><code>ProductionFromMapEdge</code></td><td>Units arrive from map edge</td></tr>
<tr><td><code>ProductionParadrop</code></td><td>Paradrop production</td></tr>
<tr><td><code>FreeActor</code></td><td>Spawns free actors</td></tr>
<tr><td><code>FreeActorWithDelivery</code></td><td>Spawns free actors with delivery animation</td></tr>
</tbody>
</table>
</div>
<h3 id="prerequisite-system"><a class="header" href="#prerequisite-system">Prerequisite System</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>TechTree</code></td><td>Tech tree management</td></tr>
<tr><td><code>ProvidesPrerequisite</code></td><td>Building provides prerequisite</td></tr>
<tr><td><code>ProvidesTechPrerequisite</code></td><td>Provides named tech prerequisite</td></tr>
<tr><td><code>GrantConditionOnPrerequisiteManager</code></td><td>Manager for prerequisite conditions</td></tr>
<tr><td><code>LobbyPrerequisiteCheckbox</code></td><td>Lobby toggle for prerequisites</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="4-condition-system-34-traits"><a class="header" href="#4-condition-system-34-traits">4. Condition System (~34 traits)</a></h2>
<p>The condition system is OpenRA’s primary mechanism for dynamic behavior modification. Conditions are boolean flags that enable/disable conditional traits.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>ExternalCondition</code></td><td>Receives conditions from external sources</td></tr>
<tr><td><code>GrantCondition</code></td><td>Always grants a condition</td></tr>
<tr><td><code>GrantConditionOnAttack</code></td><td>Condition on attacking</td></tr>
<tr><td><code>GrantConditionOnBotOwner</code></td><td>Condition when AI-owned</td></tr>
<tr><td><code>GrantConditionOnClientDock</code></td><td>Condition when docked (client)</td></tr>
<tr><td><code>GrantConditionOnCombatantOwner</code></td><td>Condition when combatant owns</td></tr>
<tr><td><code>GrantConditionOnDamageState</code></td><td>Condition at damage thresholds</td></tr>
<tr><td><code>GrantConditionOnDeploy</code></td><td>Condition when deployed</td></tr>
<tr><td><code>GrantConditionOnFaction</code></td><td>Condition for specific factions</td></tr>
<tr><td><code>GrantConditionOnHealth</code></td><td>Condition at health thresholds</td></tr>
<tr><td><code>GrantConditionOnHostDock</code></td><td>Condition when docked (host)</td></tr>
<tr><td><code>GrantConditionOnLayer</code></td><td>Condition on specific layer</td></tr>
<tr><td><code>GrantConditionOnLineBuildDirection</code></td><td>Condition by wall direction</td></tr>
<tr><td><code>GrantConditionOnMinelaying</code></td><td>Condition while laying mines</td></tr>
<tr><td><code>GrantConditionOnMovement</code></td><td>Condition while moving</td></tr>
<tr><td><code>GrantConditionOnPlayerResources</code></td><td>Condition based on resources</td></tr>
<tr><td><code>GrantConditionOnPowerState</code></td><td>Condition based on power</td></tr>
<tr><td><code>GrantConditionOnPrerequisite</code></td><td>Condition when prereq met</td></tr>
<tr><td><code>GrantConditionOnProduction</code></td><td>Condition during production</td></tr>
<tr><td><code>GrantConditionOnSubterraneanLayer</code></td><td>Condition when underground</td></tr>
<tr><td><code>GrantConditionOnTerrain</code></td><td>Condition on terrain type</td></tr>
<tr><td><code>GrantConditionOnTileSet</code></td><td>Condition on tile set</td></tr>
<tr><td><code>GrantConditionOnTunnelLayer</code></td><td>Condition in tunnel</td></tr>
<tr><td><code>GrantConditionWhileAiming</code></td><td>Condition while aiming</td></tr>
<tr><td><code>GrantChargedConditionOnToggle</code></td><td>Charged toggle condition</td></tr>
<tr><td><code>GrantExternalConditionToCrusher</code></td><td>Grant condition to crusher</td></tr>
<tr><td><code>GrantExternalConditionToProduced</code></td><td>Grant condition to produced unit</td></tr>
<tr><td><code>GrantRandomCondition</code></td><td>Random condition selection</td></tr>
<tr><td><code>LineBuildSegmentExternalCondition</code></td><td>Line build segment condition</td></tr>
<tr><td><code>ProximityExternalCondition</code></td><td>Proximity-based condition</td></tr>
<tr><td><code>SpreadsCondition</code></td><td>Condition that spreads to neighbors</td></tr>
<tr><td><code>ToggleConditionOnOrder</code></td><td>Toggle condition via order</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="5-multiplier-system-20-traits"><a class="header" href="#5-multiplier-system-20-traits">5. Multiplier System (~20 traits)</a></h2>
<p>Multipliers modify numeric values on actors. All are conditional traits.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Multiplier</th><th>Affects</th></tr>
</thead>
<tbody>
<tr><td><code>DamageMultiplier</code></td><td>Incoming damage</td></tr>
<tr><td><code>FirepowerMultiplier</code></td><td>Outgoing damage</td></tr>
<tr><td><code>SpeedMultiplier</code></td><td>Movement speed</td></tr>
<tr><td><code>RangeMultiplier</code></td><td>Weapon range</td></tr>
<tr><td><code>InaccuracyMultiplier</code></td><td>Weapon spread</td></tr>
<tr><td><code>ReloadDelayMultiplier</code></td><td>Weapon reload time</td></tr>
<tr><td><code>ReloadAmmoDelayMultiplier</code></td><td>Ammo reload time</td></tr>
<tr><td><code>ProductionCostMultiplier</code></td><td>Build cost</td></tr>
<tr><td><code>ProductionTimeMultiplier</code></td><td>Build time</td></tr>
<tr><td><code>PowerMultiplier</code></td><td>Power consumption/production</td></tr>
<tr><td><code>RevealsShroudMultiplier</code></td><td>Sight range</td></tr>
<tr><td><code>CreatesShroudMultiplier</code></td><td>Shroud creation range</td></tr>
<tr><td><code>DetectCloakedMultiplier</code></td><td>Cloak detection range</td></tr>
<tr><td><code>CashTricklerMultiplier</code></td><td>Cash trickle rate</td></tr>
<tr><td><code>ResourceValueMultiplier</code></td><td>Resource gather value</td></tr>
<tr><td><code>GainsExperienceMultiplier</code></td><td>XP gain rate</td></tr>
<tr><td><code>GivesExperienceMultiplier</code></td><td>XP given on death</td></tr>
<tr><td><code>HandicapDamageMultiplier</code></td><td>Handicap damage received</td></tr>
<tr><td><code>HandicapFirepowerMultiplier</code></td><td>Handicap firepower</td></tr>
<tr><td><code>HandicapProductionTimeMultiplier</code></td><td>Handicap build time</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="6-projectile-system-8-types"><a class="header" href="#6-projectile-system-8-types">6. Projectile System (8 types)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Projectile</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Bullet</code></td><td>Standard ballistic projectile with gravity, speed, inaccuracy</td></tr>
<tr><td><code>Missile</code></td><td>Guided missile with tracking, jinking, terrain following</td></tr>
<tr><td><code>LaserZap</code></td><td>Instant laser beam</td></tr>
<tr><td><code>Railgun</code></td><td>Railgun beam effect</td></tr>
<tr><td><code>AreaBeam</code></td><td>Wide area beam weapon</td></tr>
<tr><td><code>InstantHit</code></td><td>Instant-hit hitscan weapon</td></tr>
<tr><td><code>GravityBomb</code></td><td>Dropped bomb with gravity</td></tr>
<tr><td><code>NukeLaunch</code></td><td>Nuclear missile (special trajectory)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="7-warhead-system-15-types"><a class="header" href="#7-warhead-system-15-types">7. Warhead System (15 types)</a></h2>
<p>Warheads define what happens when a weapon hits. Multiple warheads per weapon.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Warhead</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Warhead</code></td><td>Base warhead class</td></tr>
<tr><td><code>DamageWarhead</code></td><td>Base class for damage-dealing warheads</td></tr>
<tr><td><code>SpreadDamageWarhead</code></td><td>Damage with falloff over radius</td></tr>
<tr><td><code>TargetDamageWarhead</code></td><td>Direct damage to target only</td></tr>
<tr><td><code>HealthPercentageDamageWarhead</code></td><td>Percentage-based damage</td></tr>
<tr><td><code>ChangeOwnerWarhead</code></td><td>Changes actor ownership</td></tr>
<tr><td><code>CreateEffectWarhead</code></td><td>Creates visual/sound effects</td></tr>
<tr><td><code>CreateResourceWarhead</code></td><td>Creates resources (like ore)</td></tr>
<tr><td><code>DestroyResourceWarhead</code></td><td>Destroys resources on ground</td></tr>
<tr><td><code>FireClusterWarhead</code></td><td>Fires cluster submunitions</td></tr>
<tr><td><code>FlashEffectWarhead</code></td><td>Screen flash effect</td></tr>
<tr><td><code>FlashTargetsInRadiusWarhead</code></td><td>Flashes affected targets</td></tr>
<tr><td><code>GrantExternalConditionWarhead</code></td><td>Grants condition to targets</td></tr>
<tr><td><code>LeaveSmudgeWarhead</code></td><td>Creates terrain smudges</td></tr>
<tr><td><code>ShakeScreenWarhead</code></td><td>Screen shake on impact</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="8-render-system-80-traits"><a class="header" href="#8-render-system-80-traits">8. Render System (~80 traits)</a></h2>
<h3 id="sprite-body-types"><a class="header" href="#sprite-body-types">Sprite Body Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>RenderSprites</code></td><td>Base sprite renderer</td></tr>
<tr><td><code>RenderSpritesEditorOnly</code></td><td>Sprites only in editor</td></tr>
<tr><td><code>WithSpriteBody</code></td><td>Standard sprite body</td></tr>
<tr><td><code>WithFacingSpriteBody</code></td><td>Sprite body with facing</td></tr>
<tr><td><code>WithInfantryBody</code></td><td>Infantry-specific animations</td></tr>
<tr><td><code>WithWallSpriteBody</code></td><td>Auto-connecting wall sprites</td></tr>
<tr><td><code>WithBridgeSpriteBody</code></td><td>Bridge sprite</td></tr>
<tr><td><code>WithDeadBridgeSpriteBody</code></td><td>Destroyed bridge sprite</td></tr>
<tr><td><code>WithGateSpriteBody</code></td><td>Gate open/close animation</td></tr>
<tr><td><code>WithCrateBody</code></td><td>Crate sprite</td></tr>
<tr><td><code>WithChargeSpriteBody</code></td><td>Charge-based sprite change</td></tr>
<tr><td><code>WithResourceLevelSpriteBody</code></td><td>Resource level visualization</td></tr>
</tbody>
</table>
</div>
<h3 id="animation-overlays"><a class="header" href="#animation-overlays">Animation Overlays</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>WithMakeAnimation</code></td><td>Construction animation</td></tr>
<tr><td><code>WithMakeOverlay</code></td><td>Construction overlay</td></tr>
<tr><td><code>WithIdleAnimation</code></td><td>Idle animation</td></tr>
<tr><td><code>WithIdleOverlay</code></td><td>Idle overlay</td></tr>
<tr><td><code>WithAttackAnimation</code></td><td>Attack animation</td></tr>
<tr><td><code>WithAttackOverlay</code></td><td>Attack overlay</td></tr>
<tr><td><code>WithMoveAnimation</code></td><td>Movement animation</td></tr>
<tr><td><code>WithHarvestAnimation</code></td><td>Harvesting animation</td></tr>
<tr><td><code>WithHarvestOverlay</code></td><td>Harvesting overlay</td></tr>
<tr><td><code>WithDeathAnimation</code></td><td>Death animation</td></tr>
<tr><td><code>WithDamageOverlay</code></td><td>Damage state overlay</td></tr>
<tr><td><code>WithAimAnimation</code></td><td>Aiming animation</td></tr>
<tr><td><code>WithDockingAnimation</code></td><td>Docking animation</td></tr>
<tr><td><code>WithDockingOverlay</code></td><td>Docking overlay</td></tr>
<tr><td><code>WithDockedOverlay</code></td><td>Docked state overlay</td></tr>
<tr><td><code>WithDeliveryAnimation</code></td><td>Delivery animation</td></tr>
<tr><td><code>WithResupplyAnimation</code></td><td>Resupply animation</td></tr>
<tr><td><code>WithBuildingPlacedAnimation</code></td><td>Placed animation</td></tr>
<tr><td><code>WithBuildingPlacedOverlay</code></td><td>Placed overlay</td></tr>
<tr><td><code>WithChargeOverlay</code></td><td>Charge state overlay</td></tr>
<tr><td><code>WithProductionDoorOverlay</code></td><td>Factory door animation</td></tr>
<tr><td><code>WithProductionOverlay</code></td><td>Production activity overlay</td></tr>
<tr><td><code>WithRepairOverlay</code></td><td>Repair animation</td></tr>
<tr><td><code>WithResourceLevelOverlay</code></td><td>Resource level overlay</td></tr>
<tr><td><code>WithSwitchableOverlay</code></td><td>Toggleable overlay</td></tr>
<tr><td><code>WithSupportPowerActivationAnimation</code></td><td>Superweapon activation</td></tr>
<tr><td><code>WithSupportPowerActivationOverlay</code></td><td>Superweapon overlay</td></tr>
<tr><td><code>WithTurretAimAnimation</code></td><td>Turret aim animation</td></tr>
<tr><td><code>WithTurretAttackAnimation</code></td><td>Turret attack animation</td></tr>
</tbody>
</table>
</div>
<h3 id="weapons--effects-rendering"><a class="header" href="#weapons--effects-rendering">Weapons &amp; Effects Rendering</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>WithMuzzleOverlay</code></td><td>Muzzle flash</td></tr>
<tr><td><code>WithSpriteBarrel</code></td><td>Visible weapon barrel</td></tr>
<tr><td><code>WithSpriteTurret</code></td><td>Visible turret sprite</td></tr>
<tr><td><code>WithParachute</code></td><td>Parachute rendering</td></tr>
<tr><td><code>WithShadow</code></td><td>Shadow rendering</td></tr>
<tr><td><code>Contrail</code></td><td>Contrail effect</td></tr>
<tr><td><code>FloatingSpriteEmitter</code></td><td>Floating sprite particles</td></tr>
<tr><td><code>LeavesTrails</code></td><td>Trail effects</td></tr>
<tr><td><code>Hovers</code></td><td>Hovering animation</td></tr>
<tr><td><code>WithAircraftLandingEffect</code></td><td>Landing dust effect</td></tr>
</tbody>
</table>
</div>
<h3 id="decorations--ui-overlays"><a class="header" href="#decorations--ui-overlays">Decorations &amp; UI Overlays</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>WithDecoration</code></td><td>Generic decoration</td></tr>
<tr><td><code>WithDecorationBase</code></td><td>Base decoration class</td></tr>
<tr><td><code>WithNameTagDecoration</code></td><td>Name tag above actor</td></tr>
<tr><td><code>WithTextDecoration</code></td><td>Text above actor</td></tr>
<tr><td><code>WithTextControlGroupDecoration</code></td><td>Control group number</td></tr>
<tr><td><code>WithSpriteControlGroupDecoration</code></td><td>Control group sprite</td></tr>
<tr><td><code>WithBuildingRepairDecoration</code></td><td>Repair icon</td></tr>
<tr><td><code>WithRangeCircle</code></td><td>Range circle display</td></tr>
<tr><td><code>WithProductionIconOverlay</code></td><td>Production icon modification</td></tr>
<tr><td><code>ProductionIconOverlayManager</code></td><td>Manages production icon overlays</td></tr>
</tbody>
</table>
</div>
<h3 id="status-bars"><a class="header" href="#status-bars">Status Bars</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>CashTricklerBar</code></td><td>Cash trickle progress bar</td></tr>
<tr><td><code>ProductionBar</code></td><td>Production progress</td></tr>
<tr><td><code>ReloadArmamentsBar</code></td><td>Weapon reload progress</td></tr>
<tr><td><code>SupportPowerChargeBar</code></td><td>Superweapon charge progress</td></tr>
<tr><td><code>TimedConditionBar</code></td><td>Timed condition remaining</td></tr>
</tbody>
</table>
</div>
<h3 id="pip-decorations"><a class="header" href="#pip-decorations">Pip Decorations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>WithAmmoPipsDecoration</code></td><td>Ammo pips</td></tr>
<tr><td><code>WithCargoPipsDecoration</code></td><td>Passenger pips</td></tr>
<tr><td><code>WithResourceStoragePipsDecoration</code></td><td>Resource storage pips</td></tr>
<tr><td><code>WithStoresResourcesPipsDecoration</code></td><td>Stored resources pips</td></tr>
</tbody>
</table>
</div>
<h3 id="selection-rendering"><a class="header" href="#selection-rendering">Selection Rendering</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>SelectionDecorations</code></td><td>Selection box rendering</td></tr>
<tr><td><code>SelectionDecorationsBase</code></td><td>Base selection rendering</td></tr>
<tr><td><code>IsometricSelectionDecorations</code></td><td>Isometric selection boxes</td></tr>
</tbody>
</table>
</div>
<h3 id="debug-rendering"><a class="header" href="#debug-rendering">Debug Rendering</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>RenderDebugState</code></td><td>Debug state overlay</td></tr>
<tr><td><code>RenderDetectionCircle</code></td><td>Detection radius</td></tr>
<tr><td><code>RenderJammerCircle</code></td><td>Jammer radius</td></tr>
<tr><td><code>RenderMouseBounds</code></td><td>Mouse bounds debug</td></tr>
<tr><td><code>RenderRangeCircle</code></td><td>Weapon range debug</td></tr>
<tr><td><code>RenderShroudCircle</code></td><td>Shroud range debug</td></tr>
<tr><td><code>CustomTerrainDebugOverlay</code></td><td>Terrain debug overlay</td></tr>
<tr><td><code>DrawLineToTarget</code></td><td>Line to target debug</td></tr>
</tbody>
</table>
</div>
<h3 id="world-rendering"><a class="header" href="#world-rendering">World Rendering</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>TerrainRenderer</code></td><td>Renders terrain tiles</td></tr>
<tr><td><code>ShroudRenderer</code></td><td>Renders fog of war/shroud</td></tr>
<tr><td><code>ResourceRenderer</code></td><td>Renders resource sprites</td></tr>
<tr><td><code>WeatherOverlay</code></td><td>Weather effects (rain, snow)</td></tr>
<tr><td><code>TerrainLighting</code></td><td>Global terrain lighting</td></tr>
<tr><td><code>TerrainGeometryOverlay</code></td><td>Terrain cell debug</td></tr>
<tr><td><code>SmudgeLayer</code></td><td>Terrain smudge rendering</td></tr>
<tr><td><code>RenderPostProcessPassBase</code></td><td>Post-processing base</td></tr>
<tr><td><code>BuildableTerrainOverlay</code></td><td>Buildable area overlay</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="9-palette-system-22-traits"><a class="header" href="#9-palette-system-22-traits">9. Palette System (~22 traits)</a></h2>
<h3 id="palette-sources"><a class="header" href="#palette-sources">Palette Sources</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>PaletteFromFile</code></td><td>Load palette from .pal file</td></tr>
<tr><td><code>PaletteFromPng</code></td><td>Palette from PNG image</td></tr>
<tr><td><code>PaletteFromGimpOrJascFile</code></td><td>GIMP/JASC palette format</td></tr>
<tr><td><code>PaletteFromRGBA</code></td><td>Programmatic RGBA palette</td></tr>
<tr><td><code>PaletteFromGrayscale</code></td><td>Generated grayscale palette</td></tr>
<tr><td><code>PaletteFromEmbeddedSpritePalette</code></td><td>Palette from sprite data</td></tr>
<tr><td><code>PaletteFromPaletteWithAlpha</code></td><td>Palette with alpha modification</td></tr>
<tr><td><code>PaletteFromPlayerPaletteWithAlpha</code></td><td>Player palette + alpha</td></tr>
<tr><td><code>IndexedPalette</code></td><td>Index-based palette</td></tr>
<tr><td><code>IndexedPlayerPalette</code></td><td>Player-colored indexed palette</td></tr>
<tr><td><code>PlayerColorPalette</code></td><td>Player team color palette</td></tr>
<tr><td><code>FixedColorPalette</code></td><td>Fixed color palette</td></tr>
<tr><td><code>ColorPickerPalette</code></td><td>Color picker palette</td></tr>
</tbody>
</table>
</div>
<h3 id="palette-effects--shifts"><a class="header" href="#palette-effects--shifts">Palette Effects &amp; Shifts</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>PlayerColorShift</code></td><td>Player color application</td></tr>
<tr><td><code>FixedPlayerColorShift</code></td><td>Fixed player color shift</td></tr>
<tr><td><code>FixedColorShift</code></td><td>Fixed color modification</td></tr>
<tr><td><code>ColorPickerColorShift</code></td><td>Color picker integration</td></tr>
<tr><td><code>RotationPaletteEffect</code></td><td>Palette rotation animation (e.g., water)</td></tr>
<tr><td><code>CloakPaletteEffect</code></td><td>Cloak shimmer effect</td></tr>
<tr><td><code>FlashPostProcessEffect</code></td><td>Screen flash post-process</td></tr>
<tr><td><code>MenuPostProcessEffect</code></td><td>Menu screen effect</td></tr>
<tr><td><code>TintPostProcessEffect</code></td><td>Color tint post-process</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="10-sound-system-9-traits"><a class="header" href="#10-sound-system-9-traits">10. Sound System (~9 traits)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>AmbientSound</code></td><td>Looping ambient sounds</td></tr>
<tr><td><code>AttackSounds</code></td><td>Weapon fire sounds</td></tr>
<tr><td><code>DeathSounds</code></td><td>Death sounds</td></tr>
<tr><td><code>ActorLostNotification</code></td><td>“Unit lost” notification</td></tr>
<tr><td><code>AnnounceOnKill</code></td><td>Kill announcement</td></tr>
<tr><td><code>AnnounceOnSeen</code></td><td>Sighting announcement</td></tr>
<tr><td><code>CaptureNotification</code></td><td>Capture notification</td></tr>
<tr><td><code>SoundOnDamageTransition</code></td><td>Sound at damage thresholds</td></tr>
<tr><td><code>VoiceAnnouncement</code></td><td>Voice line playback</td></tr>
<tr><td><code>StartGameNotification</code></td><td>Game start sound</td></tr>
<tr><td><code>MusicPlaylist</code></td><td>Music track management</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="11-support-powers-system-10-traits"><a class="header" href="#11-support-powers-system-10-traits">11. Support Powers System (~10 traits)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>SupportPowerManager</code></td><td>Player-level power management</td></tr>
<tr><td><code>SupportPower</code></td><td>Base support power class</td></tr>
<tr><td><code>AirstrikePower</code></td><td>Airstrike superweapon</td></tr>
<tr><td><code>NukePower</code></td><td>Nuclear strike</td></tr>
<tr><td><code>ParatroopersPower</code></td><td>Paradrop reinforcements</td></tr>
<tr><td><code>SpawnActorPower</code></td><td>Spawn actor (e.g., spy plane)</td></tr>
<tr><td><code>ProduceActorPower</code></td><td>Produce actor via power</td></tr>
<tr><td><code>GrantExternalConditionPower</code></td><td>Condition-granting power</td></tr>
<tr><td><code>DirectionalSupportPower</code></td><td>Directional targeting (e.g., airstrike corridor)</td></tr>
<tr><td><code>SelectDirectionalTarget</code></td><td>UI for directional targeting</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="12-crate-system-13-traits"><a class="header" href="#12-crate-system-13-traits">12. Crate System (~13 traits)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Crate</code></td><td>Base crate actor</td></tr>
<tr><td><code>CrateAction</code></td><td>Base crate action class</td></tr>
<tr><td><code>GiveCashCrateAction</code></td><td>Cash bonus</td></tr>
<tr><td><code>GiveUnitCrateAction</code></td><td>Spawn unit</td></tr>
<tr><td><code>GiveBaseBuilderCrateAction</code></td><td>MCV/base builder</td></tr>
<tr><td><code>DuplicateUnitCrateAction</code></td><td>Duplicate collector</td></tr>
<tr><td><code>ExplodeCrateAction</code></td><td>Explosive trap</td></tr>
<tr><td><code>HealActorsCrateAction</code></td><td>Heal nearby units</td></tr>
<tr><td><code>LevelUpCrateAction</code></td><td>Veterancy level up</td></tr>
<tr><td><code>RevealMapCrateAction</code></td><td>Map reveal</td></tr>
<tr><td><code>HideMapCrateAction</code></td><td>Re-hide map</td></tr>
<tr><td><code>GrantExternalConditionCrateAction</code></td><td>Grant condition</td></tr>
<tr><td><code>SupportPowerCrateAction</code></td><td>Grant support power</td></tr>
<tr><td><code>CrateSpawner</code></td><td>World trait: spawns crates</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="13-veterancy--experience-system"><a class="header" href="#13-veterancy--experience-system">13. Veterancy / Experience System</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>GainsExperience</code></td><td>Gains XP from kills</td></tr>
<tr><td><code>GivesExperience</code></td><td>Awards XP to killer</td></tr>
<tr><td><code>ExperienceTrickler</code></td><td>Passive XP gain over time</td></tr>
<tr><td><code>ProducibleWithLevel</code></td><td>Produced at veterancy level</td></tr>
<tr><td><code>PlayerExperience</code></td><td>Player-wide XP pool</td></tr>
<tr><td><code>GainsExperienceMultiplier</code></td><td>XP gain modifier</td></tr>
<tr><td><code>GivesExperienceMultiplier</code></td><td>XP award modifier</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="14-fog-of-war--shroud-system"><a class="header" href="#14-fog-of-war--shroud-system">14. Fog of War / Shroud System</a></h2>
<h3 id="core-engine-openragame"><a class="header" href="#core-engine-openragame">Core Engine (OpenRA.Game)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Shroud</code></td><td>Core shroud/fog state management</td></tr>
<tr><td><code>FrozenActorLayer</code></td><td>Frozen actor ghost rendering</td></tr>
</tbody>
</table>
</div>
<h3 id="modscommon-traits"><a class="header" href="#modscommon-traits">Mods.Common Traits</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>AffectsShroud</code></td><td>Base for shroud-affecting traits</td></tr>
<tr><td><code>CreatesShroud</code></td><td>Creates shroud around actor</td></tr>
<tr><td><code>RevealsShroud</code></td><td>Reveals shroud (sight)</td></tr>
<tr><td><code>FrozenUnderFog</code></td><td>Hidden under fog of war</td></tr>
<tr><td><code>HiddenUnderFog</code></td><td>Invisible under fog</td></tr>
<tr><td><code>HiddenUnderShroud</code></td><td>Invisible under shroud</td></tr>
<tr><td><code>ShroudRenderer</code></td><td>Renders shroud overlay</td></tr>
<tr><td><code>PlayerRadarTerrain</code></td><td>Player-specific radar terrain</td></tr>
<tr><td><code>WithColoredOverlay</code></td><td>Colored overlay (e.g., frozen tint)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="15-power-system"><a class="header" href="#15-power-system">15. Power System</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Power</code></td><td>Provides/consumes power</td></tr>
<tr><td><code>PowerManager</code></td><td>Player-level power tracking</td></tr>
<tr><td><code>PowerMultiplier</code></td><td>Power amount modifier</td></tr>
<tr><td><code>ScalePowerWithHealth</code></td><td>Power scales with damage</td></tr>
<tr><td><code>AffectedByPowerOutage</code></td><td>Disabled during power outage</td></tr>
<tr><td><code>GrantConditionOnPowerState</code></td><td>Condition based on power level</td></tr>
<tr><td><code>PowerTooltip</code></td><td>Shows power info</td></tr>
<tr><td><code>PowerDownBotManager</code></td><td>AI power management</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="16-radar--minimap-system"><a class="header" href="#16-radar--minimap-system">16. Radar / Minimap System</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>AppearsOnRadar</code></td><td>Visible on minimap</td></tr>
<tr><td><code>ProvidesRadar</code></td><td>Enables minimap</td></tr>
<tr><td><code>RadarColorFromTerrain</code></td><td>Radar color from terrain type</td></tr>
<tr><td><code>RadarPings</code></td><td>Radar ping markers</td></tr>
<tr><td><code>RadarWidget</code></td><td>Minimap UI widget</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="17-locomotor-system"><a class="header" href="#17-locomotor-system">17. Locomotor System</a></h2>
<p>Locomotors define how actors interact with terrain for movement.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Locomotor</code></td><td>Base locomotor (17KB) — terrain cost tables, movement class, crushes, speed modifiers per terrain type</td></tr>
<tr><td><code>SubterraneanLocomotor</code></td><td>Underground movement</td></tr>
<tr><td><code>SubterraneanActorLayer</code></td><td>Underground layer management</td></tr>
<tr><td><code>Mobile</code></td><td>Actor-level movement using a locomotor</td></tr>
<tr><td><code>Aircraft</code></td><td>Air locomotor variant</td></tr>
</tbody>
</table>
</div>
<p>Key Locomotor features:</p>
<ul>
<li><strong>Terrain cost tables</strong> — per-terrain-type movement cost</li>
<li><strong>Movement classes</strong> — define pathfinding categories</li>
<li><strong>Crush classes</strong> — what can be crushed</li>
<li><strong>Share cells</strong> — whether units can share cells</li>
<li><strong>Speed modifiers</strong> — per-terrain speed modification</li>
</ul>
<hr>
<h2 id="18-pathfinding-system"><a class="header" href="#18-pathfinding-system">18. Pathfinding System</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>PathFinder</code></td><td>Main pathfinding implementation (14KB)</td></tr>
<tr><td><code>HierarchicalPathFinderOverlay</code></td><td>Hierarchical pathfinder debug visualization</td></tr>
<tr><td><code>PathFinderOverlay</code></td><td>Standard pathfinder debug</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="19-ai--bot-system"><a class="header" href="#19-ai--bot-system">19. AI / Bot System</a></h2>
<h3 id="bot-framework"><a class="header" href="#bot-framework">Bot Framework</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>ModularBot</code></td><td>Modular bot framework (player trait)</td></tr>
<tr><td><code>DummyBot</code></td><td>Placeholder bot</td></tr>
</tbody>
</table>
</div>
<h3 id="bot-modules-12-modules"><a class="header" href="#bot-modules-12-modules">Bot Modules (~12 modules)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Module</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>BaseBuilderBotModule</code></td><td>Base construction AI</td></tr>
<tr><td><code>BuildingRepairBotModule</code></td><td>Auto-repair buildings</td></tr>
<tr><td><code>CaptureManagerBotModule</code></td><td>Capture neutral/enemy buildings</td></tr>
<tr><td><code>HarvesterBotModule</code></td><td>Resource gathering AI</td></tr>
<tr><td><code>McvManagerBotModule</code></td><td>MCV deployment AI</td></tr>
<tr><td><code>McvExpansionManagerBotModule</code></td><td>Base expansion AI</td></tr>
<tr><td><code>PowerDownBotManager</code></td><td>Power management AI</td></tr>
<tr><td><code>ResourceMapBotModule</code></td><td>Resource mapping</td></tr>
<tr><td><code>SquadManagerBotModule</code></td><td>Military squad management</td></tr>
<tr><td><code>SupportPowerBotModule</code></td><td>Superweapon usage AI</td></tr>
<tr><td><code>UnitBuilderBotModule</code></td><td>Unit production AI</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="20-infantry-system"><a class="header" href="#20-infantry-system">20. Infantry System</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>WithInfantryBody</code></td><td>Infantry sprite rendering with multiple sub-positions</td></tr>
<tr><td><code>ScaredyCat</code></td><td>Panic flee behavior</td></tr>
<tr><td><code>TakeCover</code></td><td>Prone/cover behavior</td></tr>
<tr><td><code>TerrainModifiesDamage</code></td><td>Terrain affects damage received</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="21-terrain-system"><a class="header" href="#21-terrain-system">21. Terrain System</a></h2>
<h3 id="world-terrain-traits"><a class="header" href="#world-terrain-traits">World Terrain Traits</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>TerrainRenderer</code></td><td>Renders terrain tiles</td></tr>
<tr><td><code>ResourceLayer</code></td><td>Resource cell management</td></tr>
<tr><td><code>ResourceRenderer</code></td><td>Resource sprite rendering</td></tr>
<tr><td><code>ResourceClaimLayer</code></td><td>Resource claim tracking for harvesters</td></tr>
<tr><td><code>EditorResourceLayer</code></td><td>Editor resource placement</td></tr>
<tr><td><code>SmudgeLayer</code></td><td>Terrain smudges (craters, scorch marks)</td></tr>
<tr><td><code>TerrainLighting</code></td><td>Per-cell terrain lighting</td></tr>
<tr><td><code>TerrainGeometryOverlay</code></td><td>Debug geometry</td></tr>
<tr><td><code>TerrainTunnel</code></td><td>Terrain tunnel definition</td></tr>
<tr><td><code>TerrainTunnelLayer</code></td><td>Tunnel management</td></tr>
<tr><td><code>CliffBackImpassabilityLayer</code></td><td>Cliff impassability</td></tr>
<tr><td><code>DamagedByTerrain</code></td><td>Terrain damage (tiberium, etc.)</td></tr>
<tr><td><code>ChangesTerrain</code></td><td>Actor modifies terrain</td></tr>
<tr><td><code>SeedsResource</code></td><td>Creates new resources</td></tr>
</tbody>
</table>
</div>
<h3 id="tile-sets-ra-mod-example"><a class="header" href="#tile-sets-ra-mod-example">Tile Sets (RA mod example)</a></h3>
<ul>
<li><code>snow</code> — Snow terrain</li>
<li><code>interior</code> — Interior/building tiles</li>
<li><code>temperat</code> — Temperate terrain</li>
<li><code>desert</code> — Desert terrain</li>
</ul>
<hr>
<h2 id="22-map-system"><a class="header" href="#22-map-system">22. Map System</a></h2>
<h3 id="map-traits"><a class="header" href="#map-traits">Map Traits</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>MapOptions</code></td><td>Game speed, tech level, starting cash, fog/shroud toggles, short game</td></tr>
<tr><td><code>MapStartingLocations</code></td><td>Spawn point placement</td></tr>
<tr><td><code>MapStartingUnits</code></td><td>Starting unit set per faction</td></tr>
<tr><td><code>MapBuildRadius</code></td><td>Initial build radius rules</td></tr>
<tr><td><code>MapCreeps</code></td><td>Enable/disable ambient wildlife</td></tr>
<tr><td><code>MissionData</code></td><td>Mission briefing, objectives</td></tr>
<tr><td><code>CreateMapPlayers</code></td><td>Initial player creation</td></tr>
<tr><td><code>SpawnMapActors</code></td><td>Spawn pre-placed map actors</td></tr>
<tr><td><code>SpawnStartingUnits</code></td><td>Spawn starting units at locations</td></tr>
</tbody>
</table>
</div>
<h3 id="map-generation"><a class="header" href="#map-generation">Map Generation</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>ClassicMapGenerator</code></td><td>Procedural map generation (38KB)</td></tr>
<tr><td><code>ClearMapGenerator</code></td><td>Empty/clear map generation</td></tr>
</tbody>
</table>
</div>
<h3 id="actor-spawn"><a class="header" href="#actor-spawn">Actor Spawn</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>ActorSpawnManager</code></td><td>Manages ambient actor spawning</td></tr>
<tr><td><code>ActorSpawner</code></td><td>Spawn point for spawned actors</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="23-map-editor-system"><a class="header" href="#23-map-editor-system">23. Map Editor System</a></h2>
<h3 id="editor-world-traits"><a class="header" href="#editor-world-traits">Editor World Traits</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>EditorActionManager</code></td><td>Undo/redo action management</td></tr>
<tr><td><code>EditorActorLayer</code></td><td>Manages placed actors in editor (15KB)</td></tr>
<tr><td><code>EditorActorPreview</code></td><td>Actor preview rendering in editor</td></tr>
<tr><td><code>EditorCursorLayer</code></td><td>Editor cursor management</td></tr>
<tr><td><code>EditorResourceLayer</code></td><td>Resource painting</td></tr>
<tr><td><code>MarkerLayerOverlay</code></td><td>Marker layer visualization</td></tr>
<tr><td><code>TilingPathTool</code></td><td>Path/road tiling tool (14KB)</td></tr>
</tbody>
</table>
</div>
<h3 id="editor-widgets"><a class="header" href="#editor-widgets">Editor Widgets</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Widget</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>EditorViewportControllerWidget</code></td><td>Editor viewport input handling</td></tr>
</tbody>
</table>
</div>
<h3 id="editor-widget-logic-separate-directory"><a class="header" href="#editor-widget-logic-separate-directory">Editor Widget Logic (separate directory)</a></h3>
<ul>
<li><code>Editor/</code> subdirectory with editor-specific UI logic files</li>
</ul>
<hr>
<h2 id="24-widget--ui-system-60-widgets"><a class="header" href="#24-widget--ui-system-60-widgets">24. Widget / UI System (~60+ widgets)</a></h2>
<h3 id="layout-widgets"><a class="header" href="#layout-widgets">Layout Widgets</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Widget</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>BackgroundWidget</code></td><td>Background panel</td></tr>
<tr><td><code>ScrollPanelWidget</code></td><td>Scrollable container</td></tr>
<tr><td><code>ScrollItemWidget</code></td><td>Item in scroll panel</td></tr>
<tr><td><code>GridLayout</code></td><td>Grid layout container</td></tr>
<tr><td><code>ListLayout</code></td><td>List layout container</td></tr>
</tbody>
</table>
</div>
<h3 id="input-widgets"><a class="header" href="#input-widgets">Input Widgets</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Widget</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>ButtonWidget</code></td><td>Clickable button</td></tr>
<tr><td><code>CheckboxWidget</code></td><td>Toggle checkbox</td></tr>
<tr><td><code>DropDownButtonWidget</code></td><td>Dropdown selection</td></tr>
<tr><td><code>TextFieldWidget</code></td><td>Text input field</td></tr>
<tr><td><code>PasswordFieldWidget</code></td><td>Password input</td></tr>
<tr><td><code>SliderWidget</code></td><td>Slider control</td></tr>
<tr><td><code>ExponentialSliderWidget</code></td><td>Exponential slider</td></tr>
<tr><td><code>HueSliderWidget</code></td><td>Hue selection slider</td></tr>
<tr><td><code>HotkeyEntryWidget</code></td><td>Hotkey binding input</td></tr>
<tr><td><code>MenuButtonWidget</code></td><td>Menu-style button</td></tr>
</tbody>
</table>
</div>
<h3 id="display-widgets"><a class="header" href="#display-widgets">Display Widgets</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Widget</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>LabelWidget</code></td><td>Text label</td></tr>
<tr><td><code>LabelWithHighlightWidget</code></td><td>Label with highlights</td></tr>
<tr><td><code>LabelWithTooltipWidget</code></td><td>Label with tooltip</td></tr>
<tr><td><code>LabelForInputWidget</code></td><td>Label for form input</td></tr>
<tr><td><code>ImageWidget</code></td><td>Image display</td></tr>
<tr><td><code>SpriteWidget</code></td><td>Sprite display</td></tr>
<tr><td><code>RGBASpriteWidget</code></td><td>RGBA sprite</td></tr>
<tr><td><code>VideoPlayerWidget</code></td><td>Video playback</td></tr>
<tr><td><code>ColorBlockWidget</code></td><td>Solid color block</td></tr>
<tr><td><code>ColorMixerWidget</code></td><td>Color mixer</td></tr>
<tr><td><code>GradientColorBlockWidget</code></td><td>Gradient color</td></tr>
</tbody>
</table>
</div>
<h3 id="game-specific-widgets"><a class="header" href="#game-specific-widgets">Game-Specific Widgets</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Widget</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>RadarWidget</code></td><td>Minimap</td></tr>
<tr><td><code>ProductionPaletteWidget</code></td><td>Build palette</td></tr>
<tr><td><code>ProductionTabsWidget</code></td><td>Build tabs</td></tr>
<tr><td><code>ProductionTypeButtonWidget</code></td><td>Build category buttons</td></tr>
<tr><td><code>SupportPowersWidget</code></td><td>Superweapon panel</td></tr>
<tr><td><code>SupportPowerTimerWidget</code></td><td>Superweapon timers</td></tr>
<tr><td><code>ResourceBarWidget</code></td><td>Resource/money display</td></tr>
<tr><td><code>ControlGroupsWidget</code></td><td>Control group buttons</td></tr>
<tr><td><code>WorldInteractionControllerWidget</code></td><td>World click handling</td></tr>
<tr><td><code>ViewportControllerWidget</code></td><td>Camera control</td></tr>
<tr><td><code>WorldButtonWidget</code></td><td>Click on world</td></tr>
<tr><td><code>WorldLabelWithTooltipWidget</code></td><td>World-space label</td></tr>
</tbody>
</table>
</div>
<h3 id="observer-widgets"><a class="header" href="#observer-widgets">Observer Widgets</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Widget</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>ObserverArmyIconsWidget</code></td><td>Observer army composition</td></tr>
<tr><td><code>ObserverProductionIconsWidget</code></td><td>Observer production tracking</td></tr>
<tr><td><code>ObserverSupportPowerIconsWidget</code></td><td>Observer superweapon tracking</td></tr>
<tr><td><code>StrategicProgressWidget</code></td><td>Strategic score display</td></tr>
</tbody>
</table>
</div>
<h3 id="preview-widgets"><a class="header" href="#preview-widgets">Preview Widgets</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Widget</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>MapPreviewWidget</code></td><td>Map thumbnail</td></tr>
<tr><td><code>ActorPreviewWidget</code></td><td>Actor preview</td></tr>
<tr><td><code>GeneratedMapPreviewWidget</code></td><td>Generated map preview</td></tr>
<tr><td><code>TerrainTemplatePreviewWidget</code></td><td>Terrain template preview</td></tr>
<tr><td><code>ResourcePreviewWidget</code></td><td>Resource type preview</td></tr>
</tbody>
</table>
</div>
<h3 id="utility-widgets"><a class="header" href="#utility-widgets">Utility Widgets</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Widget</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>TooltipContainerWidget</code></td><td>Tooltip container</td></tr>
<tr><td><code>ClientTooltipRegionWidget</code></td><td>Client tooltip region</td></tr>
<tr><td><code>MouseAttachmentWidget</code></td><td>Mouse-attached element</td></tr>
<tr><td><code>LogicKeyListenerWidget</code></td><td>Key event listener</td></tr>
<tr><td><code>LogicTickerWidget</code></td><td>Tick event listener</td></tr>
<tr><td><code>ProgressBarWidget</code></td><td>Progress bar</td></tr>
<tr><td><code>BadgeWidget</code></td><td>Badge display</td></tr>
<tr><td><code>TextNotificationsDisplayWidget</code></td><td>Text notification area</td></tr>
<tr><td><code>ConfirmationDialogs</code></td><td>Confirmation dialog helper</td></tr>
<tr><td><code>SelectionUtils</code></td><td>Selection helper utils</td></tr>
<tr><td><code>WidgetUtils</code></td><td>Widget utility functions</td></tr>
</tbody>
</table>
</div>
<h3 id="graphdebug-widgets"><a class="header" href="#graphdebug-widgets">Graph/Debug Widgets</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Widget</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>PerfGraphWidget</code></td><td>Performance graph</td></tr>
<tr><td><code>LineGraphWidget</code></td><td>Line graph</td></tr>
<tr><td><code>ScrollableLineGraphWidget</code></td><td>Scrollable line graph</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="25-widget-logic-system-40-logic-classes"><a class="header" href="#25-widget-logic-system-40-logic-classes">25. Widget Logic System (~40+ logic classes)</a></h2>
<p>Logic classes bind widgets to game state and user actions.</p>
<h3 id="menu-logic"><a class="header" href="#menu-logic">Menu Logic</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Logic</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>MainMenuLogic</code></td><td>Main menu flow</td></tr>
<tr><td><code>CreditsLogic</code></td><td>Credits screen</td></tr>
<tr><td><code>IntroductionPromptLogic</code></td><td>First-run intro</td></tr>
<tr><td><code>SystemInfoPromptLogic</code></td><td>System info display</td></tr>
<tr><td><code>VersionLabelLogic</code></td><td>Version display</td></tr>
</tbody>
</table>
</div>
<h3 id="game-browser-logic"><a class="header" href="#game-browser-logic">Game Browser Logic</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Logic</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>ServerListLogic</code></td><td>Server browser (29KB)</td></tr>
<tr><td><code>ServerCreationLogic</code></td><td>Create game dialog</td></tr>
<tr><td><code>MultiplayerLogic</code></td><td>Multiplayer menu</td></tr>
<tr><td><code>DirectConnectLogic</code></td><td>Direct IP connect</td></tr>
<tr><td><code>ConnectionLogic</code></td><td>Connection status</td></tr>
<tr><td><code>DisconnectWatcherLogic</code></td><td>Disconnect detection</td></tr>
<tr><td><code>MapChooserLogic</code></td><td>Map selection (20KB)</td></tr>
<tr><td><code>MapGeneratorLogic</code></td><td>Map generator UI (15KB)</td></tr>
<tr><td><code>MissionBrowserLogic</code></td><td>Single player missions (19KB)</td></tr>
<tr><td><code>GameSaveBrowserLogic</code></td><td>Save game browser</td></tr>
<tr><td><code>EncyclopediaLogic</code></td><td>In-game encyclopedia</td></tr>
</tbody>
</table>
</div>
<h3 id="replay-logic"><a class="header" href="#replay-logic">Replay Logic</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Logic</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>ReplayBrowserLogic</code></td><td>Replay browser (26KB)</td></tr>
<tr><td><code>ReplayUtils</code></td><td>Replay utility functions</td></tr>
</tbody>
</table>
</div>
<h3 id="profile-logic"><a class="header" href="#profile-logic">Profile Logic</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Logic</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>LocalProfileLogic</code></td><td>Local player profile</td></tr>
<tr><td><code>LoadLocalPlayerProfileLogic</code></td><td>Profile loading</td></tr>
<tr><td><code>RegisteredProfileTooltipLogic</code></td><td>Registered player tooltip</td></tr>
<tr><td><code>AnonymousProfileTooltipLogic</code></td><td>Anonymous player tooltip</td></tr>
<tr><td><code>PlayerProfileBadgesLogic</code></td><td>Badge display</td></tr>
<tr><td><code>BotTooltipLogic</code></td><td>AI bot tooltip</td></tr>
</tbody>
</table>
</div>
<h3 id="assetcontent-logic"><a class="header" href="#assetcontent-logic">Asset/Content Logic</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Logic</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>AssetBrowserLogic</code></td><td>Asset browser (23KB)</td></tr>
<tr><td><code>ColorPickerLogic</code></td><td>Color picker dialog</td></tr>
</tbody>
</table>
</div>
<h3 id="hotkey-logic"><a class="header" href="#hotkey-logic">Hotkey Logic</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Logic</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>SingleHotkeyBaseLogic</code></td><td>Base hotkey handler</td></tr>
<tr><td><code>MusicHotkeyLogic</code></td><td>Music hotkeys</td></tr>
<tr><td><code>MuteHotkeyLogic</code></td><td>Mute toggle</td></tr>
<tr><td><code>MuteIndicatorLogic</code></td><td>Mute indicator</td></tr>
<tr><td><code>ScreenshotHotkeyLogic</code></td><td>Screenshot capture</td></tr>
<tr><td><code>DepthPreviewHotkeysLogic</code></td><td>Depth preview</td></tr>
<tr><td><code>MusicPlayerLogic</code></td><td>Music player UI</td></tr>
</tbody>
</table>
</div>
<h3 id="settings-logic"><a class="header" href="#settings-logic">Settings Logic</a></h3>
<ul>
<li><code>Settings/</code> subdirectory — audio, display, input, game settings panels</li>
</ul>
<h3 id="lobby-logic"><a class="header" href="#lobby-logic">Lobby Logic</a></h3>
<ul>
<li><code>Lobby/</code> subdirectory — lobby UI, player slots, options, chat</li>
</ul>
<h3 id="ingame-logic"><a class="header" href="#ingame-logic">Ingame Logic</a></h3>
<ul>
<li><code>Ingame/</code> subdirectory — in-game HUD, observer panels, chat</li>
</ul>
<h3 id="editor-logic"><a class="header" href="#editor-logic">Editor Logic</a></h3>
<ul>
<li><code>Editor/</code> subdirectory — map editor tools, actors, terrain</li>
</ul>
<h3 id="installation-logic"><a class="header" href="#installation-logic">Installation Logic</a></h3>
<ul>
<li><code>Installation/</code> subdirectory — content installation, mod download</li>
</ul>
<h3 id="debug-logic"><a class="header" href="#debug-logic">Debug Logic</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Logic</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>PerfDebugLogic</code></td><td>Performance debug panel</td></tr>
<tr><td><code>TabCompletionLogic</code></td><td>Chat/console tab completion</td></tr>
<tr><td><code>SimpleTooltipLogic</code></td><td>Basic tooltip</td></tr>
<tr><td><code>ButtonTooltipLogic</code></td><td>Button tooltip</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="26-order-system"><a class="header" href="#26-order-system">26. Order System</a></h2>
<h3 id="order-generators"><a class="header" href="#order-generators">Order Generators</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Generator</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>UnitOrderGenerator</code></td><td>Default unit command processing (8KB)</td></tr>
<tr><td><code>OrderGenerator</code></td><td>Base order generator class</td></tr>
<tr><td><code>PlaceBuildingOrderGenerator</code></td><td>Building placement orders (11KB)</td></tr>
<tr><td><code>GuardOrderGenerator</code></td><td>Guard command orders</td></tr>
<tr><td><code>BeaconOrderGenerator</code></td><td>Map beacon placement</td></tr>
<tr><td><code>RepairOrderGenerator</code></td><td>Repair command orders</td></tr>
<tr><td><code>GlobalButtonOrderGenerator</code></td><td>Global button commands</td></tr>
<tr><td><code>ForceModifiersOrderGenerator</code></td><td>Force-attack/force-move modifiers</td></tr>
</tbody>
</table>
</div>
<h3 id="order-targeters"><a class="header" href="#order-targeters">Order Targeters</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Targeter</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>UnitOrderTargeter</code></td><td>Standard unit targeting</td></tr>
<tr><td><code>DeployOrderTargeter</code></td><td>Deploy/unpack targeting</td></tr>
<tr><td><code>EnterAlliedActorTargeter</code></td><td>Enter allied actor targeting</td></tr>
</tbody>
</table>
</div>
<h3 id="order-validation"><a class="header" href="#order-validation">Order Validation</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>ValidateOrder</code></td><td>World-level order validation</td></tr>
<tr><td><code>OrderEffects</code></td><td>Visual/audio feedback for orders</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="27-lua-scripting-api-mission-scripting"><a class="header" href="#27-lua-scripting-api-mission-scripting">27. Lua Scripting API (Mission Scripting)</a></h2>
<h3 id="global-apis-16-modules"><a class="header" href="#global-apis-16-modules">Global APIs (16 modules)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Global</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Actor</code></td><td>Create actors, get actors by name/tag</td></tr>
<tr><td><code>Angle</code></td><td>Angle type helpers</td></tr>
<tr><td><code>Beacon</code></td><td>Map beacon placement</td></tr>
<tr><td><code>Camera</code></td><td>Camera position &amp; movement</td></tr>
<tr><td><code>Color</code></td><td>Color construction</td></tr>
<tr><td><code>CoordinateGlobals</code></td><td>CPos, WPos, WVec, WDist, WAngle construction</td></tr>
<tr><td><code>DateTime</code></td><td>Game time queries</td></tr>
<tr><td><code>Lighting</code></td><td>Global lighting control</td></tr>
<tr><td><code>Map</code></td><td>Map queries (terrain, actors in area, center, bounds)</td></tr>
<tr><td><code>Media</code></td><td>Play speech, sound, music, display messages</td></tr>
<tr><td><code>Player</code></td><td>Get player objects</td></tr>
<tr><td><code>Radar</code></td><td>Radar ping creation</td></tr>
<tr><td><code>Reinforcements</code></td><td>Spawn reinforcements (ground, air, paradrop)</td></tr>
<tr><td><code>Trigger</code></td><td>Event triggers (on killed, on idle, on timer, etc.)</td></tr>
<tr><td><code>UserInterface</code></td><td>UI manipulation</td></tr>
<tr><td><code>Utils</code></td><td>Utility functions (random, do, skip)</td></tr>
</tbody>
</table>
</div>
<h3 id="actor-properties-34-property-groups"><a class="header" href="#actor-properties-34-property-groups">Actor Properties (34 property groups)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Properties</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>AircraftProperties</code></td><td>Aircraft control (land, resupply, return)</td></tr>
<tr><td><code>AirstrikeProperties</code></td><td>Airstrike targeting</td></tr>
<tr><td><code>AmmoPoolProperties</code></td><td>Ammo management</td></tr>
<tr><td><code>CaptureProperties</code></td><td>Capture commands</td></tr>
<tr><td><code>CarryallProperties</code></td><td>Carryall commands</td></tr>
<tr><td><code>CloakProperties</code></td><td>Cloak control</td></tr>
<tr><td><code>CombatProperties</code></td><td>Attack, stop, guard commands</td></tr>
<tr><td><code>ConditionProperties</code></td><td>Grant/revoke conditions</td></tr>
<tr><td><code>DeliveryProperties</code></td><td>Delivery commands</td></tr>
<tr><td><code>DemolitionProperties</code></td><td>Demolition commands</td></tr>
<tr><td><code>DiplomacyProperties</code></td><td>Stance changes</td></tr>
<tr><td><code>GainsExperienceProperties</code></td><td>XP management</td></tr>
<tr><td><code>GeneralProperties</code></td><td>Common properties (owner, type, location, health, kill, destroy, etc.)</td></tr>
<tr><td><code>GuardProperties</code></td><td>Guard commands</td></tr>
<tr><td><code>HarvesterProperties</code></td><td>Harvest, find resources</td></tr>
<tr><td><code>HealthProperties</code></td><td>Health queries and modification</td></tr>
<tr><td><code>InstantlyRepairsProperties</code></td><td>Instant repair commands</td></tr>
<tr><td><code>MissionObjectiveProperties</code></td><td>Add/complete objectives</td></tr>
<tr><td><code>MobileProperties</code></td><td>Move, patrol, scatter, stop</td></tr>
<tr><td><code>NukeProperties</code></td><td>Nuke launch</td></tr>
<tr><td><code>ParadropProperties</code></td><td>Paradrop execution</td></tr>
<tr><td><code>ParatroopersProperties</code></td><td>Paratroopers power activation</td></tr>
<tr><td><code>PlayerConditionProperties</code></td><td>Player-level conditions</td></tr>
<tr><td><code>PlayerExperienceProperties</code></td><td>Player XP</td></tr>
<tr><td><code>PlayerProperties</code></td><td>Player queries (faction, cash, color, team, etc.)</td></tr>
<tr><td><code>PlayerStatsProperties</code></td><td>Game statistics</td></tr>
<tr><td><code>PowerProperties</code></td><td>Power queries</td></tr>
<tr><td><code>ProductionProperties</code></td><td>Build/produce commands</td></tr>
<tr><td><code>RepairableBuildingProperties</code></td><td>Building repair</td></tr>
<tr><td><code>ResourceProperties</code></td><td>Resource queries</td></tr>
<tr><td><code>ScaredCatProperties</code></td><td>Panic command</td></tr>
<tr><td><code>SellableProperties</code></td><td>Sell command</td></tr>
<tr><td><code>TransformProperties</code></td><td>Transform command</td></tr>
<tr><td><code>TransportProperties</code></td><td>Load, unload, passenger queries</td></tr>
</tbody>
</table>
</div>
<h3 id="script-infrastructure"><a class="header" href="#script-infrastructure">Script Infrastructure</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Class</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>LuaScript</code></td><td>Script loading and execution</td></tr>
<tr><td><code>ScriptTriggers</code></td><td>Trigger implementations</td></tr>
<tr><td><code>CallLuaFunc</code></td><td>Lua function invocation</td></tr>
<tr><td><code>Media</code></td><td>Media playback API</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="28-player-system"><a class="header" href="#28-player-system">28. Player System</a></h2>
<h3 id="player-traits"><a class="header" href="#player-traits">Player Traits</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>PlayerResources</code></td><td>Cash, resources, income tracking</td></tr>
<tr><td><code>PlayerStatistics</code></td><td>Kill/death/build statistics</td></tr>
<tr><td><code>PlayerExperience</code></td><td>Player-wide experience points</td></tr>
<tr><td><code>PlayerRadarTerrain</code></td><td>Per-player radar terrain state</td></tr>
<tr><td><code>PlaceBuilding</code></td><td>Building placement handler</td></tr>
<tr><td><code>PlaceBeacon</code></td><td>Map beacon placement</td></tr>
<tr><td><code>DamageNotifier</code></td><td>Under attack notifications</td></tr>
<tr><td><code>HarvesterAttackNotifier</code></td><td>Harvester attack notifications</td></tr>
<tr><td><code>EnemyWatcher</code></td><td>Enemy unit detection</td></tr>
<tr><td><code>GameSaveViewportManager</code></td><td>Save game viewport state</td></tr>
<tr><td><code>ResourceStorageWarning</code></td><td>Storage full warning</td></tr>
<tr><td><code>AllyRepair</code></td><td>Allied repair permission</td></tr>
</tbody>
</table>
</div>
<h3 id="victory-conditions"><a class="header" href="#victory-conditions">Victory Conditions</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>ConquestVictoryConditions</code></td><td>Destroy all to win</td></tr>
<tr><td><code>StrategicVictoryConditions</code></td><td>Strategic point control</td></tr>
<tr><td><code>MissionObjectives</code></td><td>Scripted mission objectives</td></tr>
<tr><td><code>TimeLimitManager</code></td><td>Game time limit</td></tr>
</tbody>
</table>
</div>
<h3 id="developer-mode"><a class="header" href="#developer-mode">Developer Mode</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>DeveloperMode</code></td><td>Cheat commands (instant build, unlimited power, etc.)</td></tr>
</tbody>
</table>
</div>
<h3 id="faction-system"><a class="header" href="#faction-system">Faction System</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Faction</code></td><td>Faction definition (name, internal name, side)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="29-selection-system"><a class="header" href="#29-selection-system">29. Selection System</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Selection</code></td><td>World-level selection management (5.4KB)</td></tr>
<tr><td><code>Selectable</code></td><td>Actor can be selected (bounds, priority, voice)</td></tr>
<tr><td><code>IsometricSelectable</code></td><td>Isometric selection variant</td></tr>
<tr><td><code>SelectionDecorations</code></td><td>Selection box rendering</td></tr>
<tr><td><code>IsometricSelectionDecorations</code></td><td>Isometric selection boxes</td></tr>
<tr><td><code>ControlGroups</code></td><td>Ctrl+number group management</td></tr>
<tr><td><code>ControlGroupsWidget</code></td><td>Control group UI</td></tr>
<tr><td><code>SelectionUtils</code></td><td>Selection utility helpers</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="30-hotkey-system"><a class="header" href="#30-hotkey-system">30. Hotkey System</a></h2>
<h3 id="mod-level-hotkey-configuration-ra-mod"><a class="header" href="#mod-level-hotkey-configuration-ra-mod">Mod-level Hotkey Configuration (RA mod)</a></h3>
<ul>
<li><code>hotkeys/common.yaml</code> — Shared hotkeys</li>
<li><code>hotkeys/mapcreation.yaml</code> — Map creation hotkeys</li>
<li><code>hotkeys/observer-replay.yaml</code> — Observer &amp; replay hotkeys</li>
<li><code>hotkeys/player.yaml</code> — Player hotkeys</li>
<li><code>hotkeys/control-groups.yaml</code> — Control group bindings</li>
<li><code>hotkeys/production.yaml</code> — Production hotkeys</li>
<li><code>hotkeys/music.yaml</code> — Music control</li>
<li><code>hotkeys/chat.yaml</code> — Chat hotkeys</li>
</ul>
<h3 id="hotkey-logic-classes"><a class="header" href="#hotkey-logic-classes">Hotkey Logic Classes</a></h3>
<ul>
<li><code>SingleHotkeyBaseLogic</code> — Base hotkey handler</li>
<li><code>MusicHotkeyLogic</code>, <code>MuteHotkeyLogic</code>, <code>ScreenshotHotkeyLogic</code></li>
</ul>
<hr>
<h2 id="31-cursor-system"><a class="header" href="#31-cursor-system">31. Cursor System</a></h2>
<p>Configured via <code>Cursors:</code> section in mod.yaml, defining cursor sprites, hotspots, and frame counts. The mod references a cursors YAML file that maps cursor names to sprite definitions.</p>
<hr>
<h2 id="32-notification-system"><a class="header" href="#32-notification-system">32. Notification System</a></h2>
<h3 id="sound-notifications"><a class="header" href="#sound-notifications">Sound Notifications</a></h3>
<p>Configured via <code>Notifications:</code> section referencing YAML files that map event names to audio files.</p>
<h3 id="text-notifications"><a class="header" href="#text-notifications">Text Notifications</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Widget</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>TextNotificationsDisplayWidget</code></td><td>On-screen text notification display</td></tr>
</tbody>
</table>
</div>
<h3 id="actor-notifications"><a class="header" href="#actor-notifications">Actor Notifications</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>ActorLostNotification</code></td><td>“Unit lost”</td></tr>
<tr><td><code>AnnounceOnKill</code></td><td>Kill notification</td></tr>
<tr><td><code>AnnounceOnSeen</code></td><td>Enemy spotted</td></tr>
<tr><td><code>CaptureNotification</code></td><td>Building captured</td></tr>
<tr><td><code>DamageNotifier</code></td><td>Under attack (player-level)</td></tr>
<tr><td><code>HarvesterAttackNotifier</code></td><td>Harvester under attack</td></tr>
<tr><td><code>ResourceStorageWarning</code></td><td>Silos needed</td></tr>
<tr><td><code>StartGameNotification</code></td><td>Battle control online</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="33-replay-system"><a class="header" href="#33-replay-system">33. Replay System</a></h2>
<h3 id="replay-infrastructure"><a class="header" href="#replay-infrastructure">Replay Infrastructure</a></h3>
<ul>
<li><code>ReplayBrowserLogic</code> — Full replay browser with filtering, sorting</li>
<li><code>ReplayUtils</code> — Replay file parsing utilities</li>
<li><code>ReplayPlayback</code> (in core engine) — Replay playback as network model</li>
</ul>
<h3 id="replay-features"><a class="header" href="#replay-features">Replay Features</a></h3>
<ul>
<li>Order recording (all player orders per tick)</li>
<li>Desync detection via state hashing</li>
<li>Observer mode with full visibility</li>
<li>Speed control during playback</li>
<li>Metadata: players, map, mod version, duration, outcome</li>
</ul>
<hr>
<h2 id="34-lobby-system"><a class="header" href="#34-lobby-system">34. Lobby System</a></h2>
<h3 id="lobby-widget-logic"><a class="header" href="#lobby-widget-logic">Lobby Widget Logic</a></h3>
<ul>
<li><code>Lobby/</code> directory contains all lobby UI logic</li>
<li>Player slot management, faction selection, team assignment</li>
<li>Color picker integration</li>
<li>Map selection integration</li>
<li>Game options (tech level, starting cash, short game, etc.)</li>
<li>Chat functionality</li>
<li>Ready state management</li>
</ul>
<h3 id="lobby-configurable-options"><a class="header" href="#lobby-configurable-options">Lobby-Configurable Options</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Lobby Control</th></tr>
</thead>
<tbody>
<tr><td><code>MapOptions</code></td><td>Game speed, tech, cash, fog, shroud</td></tr>
<tr><td><code>LobbyPrerequisiteCheckbox</code></td><td>Toggle prerequisites</td></tr>
<tr><td><code>ScriptLobbyDropdown</code></td><td>Script-defined dropdown options</td></tr>
<tr><td><code>MapCreeps</code></td><td>Ambient creeps toggle</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="35-mod-manifest-system-modyaml"><a class="header" href="#35-mod-manifest-system-modyaml">35. Mod Manifest System (mod.yaml)</a></h2>
<p>The mod manifest defines all mod content via YAML sections:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Section</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Metadata</code></td><td>Mod title, version, website</td></tr>
<tr><td><code>PackageFormats</code></td><td>Archive format handlers (Mix, etc.)</td></tr>
<tr><td><code>Packages</code></td><td>File system mount points</td></tr>
<tr><td><code>MapFolders</code></td><td>Map directory locations</td></tr>
<tr><td><code>Rules</code></td><td>Actor rules YAML files (15 files for RA)</td></tr>
<tr><td><code>Sequences</code></td><td>Sprite sequence definitions (7 files)</td></tr>
<tr><td><code>TileSets</code></td><td>Terrain tile sets</td></tr>
<tr><td><code>Cursors</code></td><td>Cursor definitions</td></tr>
<tr><td><code>Chrome</code></td><td>UI chrome YAML</td></tr>
<tr><td><code>Assemblies</code></td><td>.NET assembly references</td></tr>
<tr><td><code>ChromeLayout</code></td><td>UI layout files (~50 files)</td></tr>
<tr><td><code>FluentMessages</code></td><td>Localization strings</td></tr>
<tr><td><code>Weapons</code></td><td>Weapon definition files (6 files: ballistics, explosions, missiles, smallcaliber, superweapons, other)</td></tr>
<tr><td><code>Voices</code></td><td>Voice line definitions</td></tr>
<tr><td><code>Notifications</code></td><td>Audio notification mapping</td></tr>
<tr><td><code>Music</code></td><td>Music track definitions</td></tr>
<tr><td><code>Hotkeys</code></td><td>Hotkey binding files (8 files)</td></tr>
<tr><td><code>LoadScreen</code></td><td>Loading screen class</td></tr>
<tr><td><code>ServerTraits</code></td><td>Server-side trait list</td></tr>
<tr><td><code>Fonts</code></td><td>Font definitions (8 sizes)</td></tr>
<tr><td><code>MapGrid</code></td><td>Map grid type (Rectangular/Isometric)</td></tr>
<tr><td><code>DefaultOrderGenerator</code></td><td>Default order handler class</td></tr>
<tr><td><code>SpriteFormats</code></td><td>Supported sprite formats</td></tr>
<tr><td><code>SoundFormats</code></td><td>Supported audio formats</td></tr>
<tr><td><code>VideoFormats</code></td><td>Supported video formats</td></tr>
<tr><td><code>TerrainFormat</code></td><td>Terrain format handler</td></tr>
<tr><td><code>SpriteSequenceFormat</code></td><td>Sprite sequence handler</td></tr>
<tr><td><code>GameSpeeds</code></td><td>Speed presets (slowest→fastest, 80ms→20ms)</td></tr>
<tr><td><code>AssetBrowser</code></td><td>Asset browser extensions</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="36-world-traits-global-game-state"><a class="header" href="#36-world-traits-global-game-state">36. World Traits (Global Game State)</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>ActorMap</code></td><td>Spatial index of all actors (19KB)</td></tr>
<tr><td><code>ActorMapOverlay</code></td><td>ActorMap debug visualization</td></tr>
<tr><td><code>ScreenMap</code></td><td>Screen-space actor lookup</td></tr>
<tr><td><code>ScreenShaker</code></td><td>Screen shake effects</td></tr>
<tr><td><code>DebugVisualizations</code></td><td>Debug rendering toggles</td></tr>
<tr><td><code>ColorPickerManager</code></td><td>Player color management</td></tr>
<tr><td><code>ValidationOrder</code></td><td>Order validation pipeline</td></tr>
<tr><td><code>OrderEffects</code></td><td>Order visual/audio feedback</td></tr>
<tr><td><code>AutoSave</code></td><td>Automatic save game</td></tr>
<tr><td><code>LoadWidgetAtGameStart</code></td><td>Initial widget loading</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="37-game-speed-configuration"><a class="header" href="#37-game-speed-configuration">37. Game Speed Configuration</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Speed</th><th>Tick Interval</th></tr>
</thead>
<tbody>
<tr><td>Slowest</td><td>80ms</td></tr>
<tr><td>Slower</td><td>50ms</td></tr>
<tr><td>Default</td><td>40ms</td></tr>
<tr><td>Fast</td><td>35ms</td></tr>
<tr><td>Faster</td><td>30ms</td></tr>
<tr><td>Fastest</td><td>20ms</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="38-damage-model"><a class="header" href="#38-damage-model">38. Damage Model</a></h2>
<h3 id="damage-flow"><a class="header" href="#damage-flow">Damage Flow</a></h3>
<ol>
<li><strong>Armament</strong> fires <strong>Projectile</strong> at target</li>
<li><strong>Projectile</strong> travels/hits using projectile-specific behavior</li>
<li><strong>Warhead(s)</strong> applied at impact point</li>
<li><strong>Warhead</strong> checks target validity (target types, stances)</li>
<li><strong>DamageWarhead</strong> / <strong>SpreadDamageWarhead</strong> calculates raw damage</li>
<li><strong>Armor</strong> type lookup against weapon’s <strong>Versus</strong> table</li>
<li><strong>DamageMultiplier</strong> traits modify final damage</li>
<li><strong>Health</strong> reduced</li>
</ol>
<h3 id="key-damage-types"><a class="header" href="#key-damage-types">Key Damage Types</a></h3>
<ul>
<li><strong>Spread damage</strong> — Falloff over radius</li>
<li><strong>Target damage</strong> — Direct damage to specific target</li>
<li><strong>Health percentage</strong> — Percentage-based damage</li>
<li><strong>Terrain damage</strong> — <code>DamagedByTerrain</code> for standing in hazards</li>
</ul>
<h3 id="damage-modifiers"><a class="header" href="#damage-modifiers">Damage Modifiers</a></h3>
<ul>
<li><code>DamageMultiplier</code> — Generic incoming damage modifier</li>
<li><code>HandicapDamageMultiplier</code> — Player handicap</li>
<li><code>FirepowerMultiplier</code> — Outgoing damage modifier</li>
<li><code>HandicapFirepowerMultiplier</code> — Player handicap firepower</li>
<li><code>TerrainModifiesDamage</code> — Infantry terrain modifier (prone, etc.)</li>
</ul>
<hr>
<h2 id="39-developer--debug-tools"><a class="header" href="#39-developer--debug-tools">39. Developer / Debug Tools</a></h2>
<h3 id="in-game-debug"><a class="header" href="#in-game-debug">In-Game Debug</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>DeveloperMode</code></td><td>Instant build, give cash, unlimited power, build anywhere, fast charge, etc.</td></tr>
<tr><td><code>CombatDebugOverlay</code></td><td>Combat range and target debug</td></tr>
<tr><td><code>ExitsDebugOverlay</code></td><td>Building exit debug</td></tr>
<tr><td><code>ExitsDebugOverlayManager</code></td><td>Manages exit overlays</td></tr>
<tr><td><code>WarheadDebugOverlay</code></td><td>Warhead impact debug</td></tr>
<tr><td><code>DebugVisualizations</code></td><td>Master debug toggle</td></tr>
<tr><td><code>RenderDebugState</code></td><td>Actor state text debug</td></tr>
<tr><td><code>DebugPauseState</code></td><td>Pause state debugging</td></tr>
</tbody>
</table>
</div>
<h3 id="debug-overlays"><a class="header" href="#debug-overlays">Debug Overlays</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Overlay</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>ActorMapOverlay</code></td><td>Actor spatial grid</td></tr>
<tr><td><code>TerrainGeometryOverlay</code></td><td>Terrain cell borders</td></tr>
<tr><td><code>CustomTerrainDebugOverlay</code></td><td>Custom terrain types</td></tr>
<tr><td><code>BuildableTerrainOverlay</code></td><td>Buildable cells</td></tr>
<tr><td><code>CellTriggerOverlay</code></td><td>Script cell triggers</td></tr>
<tr><td><code>HierarchicalPathFinderOverlay</code></td><td>Pathfinder hierarchy</td></tr>
<tr><td><code>PathFinderOverlay</code></td><td>Path search debug</td></tr>
<tr><td><code>MarkerLayerOverlay</code></td><td>Map markers</td></tr>
</tbody>
</table>
</div>
<h3 id="performance-debug"><a class="header" href="#performance-debug">Performance Debug</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Widget/Logic</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>PerfGraphWidget</code></td><td>Render/tick performance graph</td></tr>
<tr><td><code>PerfDebugLogic</code></td><td>Performance statistics display</td></tr>
</tbody>
</table>
</div>
<h3 id="asset-browser"><a class="header" href="#asset-browser">Asset Browser</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Logic</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>AssetBrowserLogic</code></td><td>Browse all mod sprites, audio, video assets</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="summary-statistics"><a class="header" href="#summary-statistics">Summary Statistics</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Count</th></tr>
</thead>
<tbody>
<tr><td>Actor Traits (root)</td><td>~130</td></tr>
<tr><td>Render Traits</td><td>~80</td></tr>
<tr><td>Condition Traits</td><td>~34</td></tr>
<tr><td>Multiplier Traits</td><td>~20</td></tr>
<tr><td>Building Traits</td><td>~35</td></tr>
<tr><td>Player Traits</td><td>~27</td></tr>
<tr><td>World Traits</td><td>~55</td></tr>
<tr><td>Attack Traits</td><td>7</td></tr>
<tr><td>Air Traits</td><td>4</td></tr>
<tr><td>Infantry Traits</td><td>3</td></tr>
<tr><td>Sound Traits</td><td>9</td></tr>
<tr><td>Palette Traits</td><td>17</td></tr>
<tr><td>Palette Effects</td><td>5</td></tr>
<tr><td>Power Traits</td><td>5</td></tr>
<tr><td>Radar Traits</td><td>3</td></tr>
<tr><td>Support Power Traits</td><td>10</td></tr>
<tr><td>Crate Traits</td><td>13</td></tr>
<tr><td>Bot Modules</td><td>12</td></tr>
<tr><td>Projectile Types</td><td>8</td></tr>
<tr><td>Warhead Types</td><td>15</td></tr>
<tr><td>Widget Types</td><td>~60</td></tr>
<tr><td>Widget Logic Classes</td><td>~40+</td></tr>
<tr><td>Lua Global APIs</td><td>16</td></tr>
<tr><td>Lua Actor Properties</td><td>34</td></tr>
<tr><td>Order Generators/Targeters</td><td>11</td></tr>
<tr><td><strong>Total Cataloged Features</strong></td><td><strong>~700+</strong></td></tr>
</tbody>
</table>
</div>
<hr>
<hr>
<h1 id="iron-curtain-gap-analysis"><a class="header" href="#iron-curtain-gap-analysis">Iron Curtain Gap Analysis</a></h1>
<blockquote>
<p><strong>Purpose:</strong> Cross-reference every OpenRA feature against Iron Curtain’s design docs.
Identify what’s covered, what’s partially covered, and what’s completely missing.
The goal: an OpenRA modder should feel <strong>at home</strong> — every concept they know has an equivalent.</p>
</blockquote>
<h2 id="coverage-legend"><a class="header" href="#coverage-legend">Coverage Legend</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Symbol</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td>✅</td><td><strong>Fully covered</strong> — designed at equivalent or better detail than OpenRA</td></tr>
<tr><td>⚠️</td><td><strong>Partially covered</strong> — mentioned or implied, but not designed as a standalone system</td></tr>
<tr><td>❌</td><td><strong>Missing</strong> — not addressed in any design doc; needs design work</td></tr>
<tr><td>🔄</td><td><strong>Different by design</strong> — our architecture handles this differently (explained)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="1-trait-system--ecs-components--structurally-different-equivalent-power"><a class="header" href="#1-trait-system--ecs-components--structurally-different-equivalent-power">1. Trait System → ECS Components ✅ (structurally different, equivalent power)</a></h2>
<p><strong>OpenRA:</strong> ~130 C# trait classes attached to actors via MiniYAML. Modders compose actor behavior by listing traits.</p>
<p><strong>Iron Curtain:</strong> Bevy ECS components attached to entities. Modders compose entity behavior by listing components in YAML. The <code>GameModule</code> trait registers components dynamically.</p>
<p><strong>Modder experience:</strong> Nearly identical. Instead of:</p>
<pre><code class="language-yaml"># OpenRA MiniYAML
rifle_infantry:
    Health:
        HP: 50
    Mobile:
        Speed: 56
    Armament:
        Weapon: M1Carbine
</code></pre>
<p>They write:</p>
<pre><code class="language-yaml"># Iron Curtain YAML
rifle_infantry:
    health:
        current: 50
        max: 50
    mobile:
        speed: 56
        locomotor: foot
    combat:
        weapon: m1_carbine
</code></pre>
<p><strong>Gap:</strong> Our design docs only map ~9 components (Health, Mobile, Attackable, Armament, Building, Buildable, Selectable, Harvester, LlmMeta). OpenRA has ~130 traits. Many are render traits (covered by Bevy), but the following gameplay traits need explicit ECS component designs — see the per-system analysis below.</p>
<hr>
<h2 id="2-condition-system--designed-d028--phase-2-hard-requirement"><a class="header" href="#2-condition-system--designed-d028--phase-2-hard-requirement">2. Condition System ✅ DESIGNED (D028 — Phase 2 Hard Requirement)</a></h2>
<p><strong>OpenRA:</strong> 34 <code>GrantCondition*</code> traits. This is <strong>the #1 modding tool</strong>. Modders create dynamic behavior by granting/revoking named boolean conditions that enable/disable <code>ConditionalTrait</code>-based components.</p>
<p>Example: a unit becomes stealthed when stationary, gains a damage bonus when veterancy reaches level 2, deploys into a stationary turret — all done purely in YAML by composing condition traits.</p>
<pre><code class="language-yaml"># OpenRA — no code needed for complex behaviors
Cloak:
    RequiresCondition: !moving
GrantConditionOnMovement:
    Condition: moving
GrantConditionOnDamageState:
    Condition: damaged
    ValidDamageStates: Critical
DamageMultiplier@CRITICAL:
    RequiresCondition: damaged
    Modifier: 150
</code></pre>
<p><strong>Iron Curtain status:</strong> <strong>Designed and scheduled as Phase 2 exit criterion (D028).</strong> The condition system is a core modding primitive:</p>
<ul>
<li><code>Conditions</code> component: <code>HashMap&lt;ConditionId, u32&gt;</code> (ref-counted named conditions per entity)</li>
<li>Condition sources: <code>GrantConditionOnMovement</code>, <code>GrantConditionOnDamageState</code>, <code>GrantConditionOnDeploy</code>, <code>GrantConditionOnAttack</code>, <code>GrantConditionOnTerrain</code>, <code>GrantConditionOnVeterancy</code> — all exposed in YAML</li>
<li>Condition consumers: any component field can declare <code>requires:</code> or <code>disabled_by:</code> conditions</li>
<li>Runtime: systems check <code>conditions.is_active("deployed")</code> via fast bitset or hash lookup</li>
<li>OpenRA trait names accepted as aliases (D023) — <code>GrantConditionOnMovement</code> works in IC YAML</li>
</ul>
<p><strong>Design sketch:</strong></p>
<pre><code class="language-yaml"># Iron Curtain equivalent
rifle_infantry:
    conditions:
        moving:
            granted_by: [on_movement]
        deployed:
            granted_by: [on_deploy]
        elite:
            granted_by: [on_veterancy, { level: 3 }]
    cloak:
        disabled_by: moving      # conditional — disabled when "moving" condition is active
    damage_multiplier:
        requires: deployed
        modifier: 1.5
</code></pre>
<p>ECS implementation: a <code>Conditions</code> component holding a <code>HashMap&lt;ConditionId, u32&gt;</code> (ref-counted). Systems check <code>conditions.is_active("deployed")</code>. YAML <code>disabled_by</code> / <code>requires</code> fields map to runtime condition checks.</p>
<hr>
<h2 id="3-multiplier-system--designed-d028--phase-2-hard-requirement"><a class="header" href="#3-multiplier-system--designed-d028--phase-2-hard-requirement">3. Multiplier System ✅ DESIGNED (D028 — Phase 2 Hard Requirement)</a></h2>
<p><strong>OpenRA:</strong> ~20 multiplier traits that modify numeric values. All conditional. Modders stack multipliers from veterancy, terrain, crates, conditions, player handicaps.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Multiplier</th><th>Affects</th></tr>
</thead>
<tbody>
<tr><td><code>DamageMultiplier</code></td><td>Incoming damage</td></tr>
<tr><td><code>FirepowerMultiplier</code></td><td>Outgoing damage</td></tr>
<tr><td><code>SpeedMultiplier</code></td><td>Movement speed</td></tr>
<tr><td><code>RangeMultiplier</code></td><td>Weapon range</td></tr>
<tr><td><code>ReloadDelayMultiplier</code></td><td>Weapon reload</td></tr>
<tr><td><code>ProductionCostMultiplier</code></td><td>Build cost</td></tr>
<tr><td><code>ProductionTimeMultiplier</code></td><td>Build time</td></tr>
<tr><td><code>RevealsShroudMultiplier</code></td><td>Sight range</td></tr>
<tr><td>…</td><td>(20 total)</td></tr>
</tbody>
</table>
</div>
<p><strong>Iron Curtain status:</strong> <strong>Designed and scheduled as Phase 2 exit criterion (D028).</strong> The multiplier system:</p>
<ul>
<li><code>StatModifiers</code> component: per-entity stack of <code>(source, stat, modifier_value, condition)</code> tuples</li>
<li>Every numeric stat (speed, damage, range, reload, build time, cost, sight range) resolves through the modifier stack</li>
<li>Modifiers from: veterancy, terrain, crates, conditions, player handicaps</li>
<li>Fixed-point multiplication (no floats) — respects invariant #1</li>
<li>YAML-configurable: modders add multipliers without code</li>
<li>Integrates with condition system: multipliers can be conditional (<code>requires: elite</code>)</li>
</ul>
<hr>
<h2 id="4-projectile-system--partial"><a class="header" href="#4-projectile-system--partial">4. Projectile System ⚠️ PARTIAL</a></h2>
<p><strong>OpenRA:</strong> 8 projectile types (Bullet, Missile, LaserZap, Railgun, AreaBeam, InstantHit, GravityBomb, NukeLaunch) — each with distinct physics, rendering, and behavior.</p>
<p><strong>Iron Curtain status:</strong> Weapons are mentioned (weapon definitions in YAML with range, damage, fire rate, AoE). But the <strong>projectile</strong> as a simulation entity with travel time, tracking, gravity, jinking, etc. is not designed.</p>
<p><strong>Gap:</strong> Need to design:</p>
<ul>
<li>Projectile entity lifecycle (spawn → travel → impact → warhead application)</li>
<li>Projectile types and their physics (ballistic arc, guided tracking, instant hit, beam)</li>
<li>Projectile rendering (sprite, beam, trail, contrail)</li>
<li>Missile guidance (homing, jinking, terrain following)</li>
</ul>
<hr>
<h2 id="5-warhead-system--designed-d028--phase-2-hard-requirement"><a class="header" href="#5-warhead-system--designed-d028--phase-2-hard-requirement">5. Warhead System ✅ DESIGNED (D028 — Phase 2 Hard Requirement)</a></h2>
<p><strong>OpenRA:</strong> 15 warhead types. Multiple warheads per weapon. Warheads define <em>what happens on impact</em> — damage, terrain modification, condition application, screen effects, resource creation/destruction.</p>
<p><strong>Iron Curtain status:</strong> <strong>Designed as part of the full damage pipeline in D028 (Phase 2 exit criterion).</strong> The warhead system:</p>
<ul>
<li>Each weapon references one or more warheads — composable effects</li>
<li>Warheads define: damage (with Versus table lookup), condition application, terrain effects, screen effects, resource modification</li>
<li>Full pipeline: Armament → Projectile entity → travel → impact → Warhead(s) → Versus table → DamageMultiplier → Health</li>
<li>Extensible via WASM for novel warhead types (WarpDamage, TintedCells, etc.)</li>
</ul>
<p>Warheads are how modders create multi-effect weapons, percentage-based damage, condition-applying attacks, and terrain-modifying impacts.</p>
<hr>
<h2 id="6-building-system--partial--multiple-gaps"><a class="header" href="#6-building-system--partial--multiple-gaps">6. Building System ⚠️ PARTIAL — MULTIPLE GAPS</a></h2>
<p><strong>OpenRA has:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>IC Status</th></tr>
</thead>
<tbody>
<tr><td>Building footprint / cell occupation</td><td>✅ <code>Building { footprint }</code> component</td></tr>
<tr><td>Build radius / base expansion</td><td>❌ Not designed</td></tr>
<tr><td>Building placement preview</td><td>❌ Not designed</td></tr>
<tr><td>Line building (walls)</td><td>❌ Not designed</td></tr>
<tr><td>Primary building designation</td><td>❌ Not designed</td></tr>
<tr><td>Rally points</td><td>⚠️ Mentioned in <code>PlayerOrder::SetRallyPoint</code>, not designed as component</td></tr>
<tr><td>Building exits (unit spawn points)</td><td>❌ Not designed</td></tr>
<tr><td>Sell mechanic</td><td>⚠️ Mentioned as <code>PlayerOrder::Sell</code>, not designed</td></tr>
<tr><td>Building repair</td><td>❌ Not designed</td></tr>
<tr><td>Landing pad reservation</td><td>❌ Not designed</td></tr>
<tr><td>Gate (openable barriers)</td><td>❌ Not designed</td></tr>
<tr><td>Building transforms</td><td>❌ Not designed (MCV deploy, etc.)</td></tr>
</tbody>
</table>
</div>
<p><strong>Recommendation:</strong> Building mechanics are foundational to C&amp;C gameplay. Design:</p>
<ul>
<li><code>BaseProvider</code> / <code>GivesBuildableArea</code> equivalent (build radius)</li>
<li><code>PlacementValidator</code> system (footprint checking, terrain validity, build radius)</li>
<li><code>LineBuild</code> system for walls and fences</li>
<li><code>PrimaryBuilding</code> marker component</li>
<li><code>RallyPoint</code> component with waypoint storage</li>
<li><code>Exit</code> component (spawn offset positions)</li>
<li><code>Sellable</code> component and sell order processing</li>
<li><code>RepairableBuilding</code> component and repair system</li>
<li><code>Gate</code> component with open/close state</li>
</ul>
<hr>
<h2 id="7-power-system--significant-gap"><a class="header" href="#7-power-system--significant-gap">7. Power System ❌ SIGNIFICANT GAP</a></h2>
<p><strong>OpenRA:</strong> <code>Power</code> trait (provides/consumes), <code>PowerManager</code> (player-level tracking), <code>AffectedByPowerOutage</code> (buildings go offline), <code>ScalePowerWithHealth</code>, power bar in UI.</p>
<p><strong>Iron Curtain status:</strong> “Power bar” mentioned in Phase 3 sidebar design. No system designed.</p>
<p><strong>This is fundamental C&amp;C gameplay.</strong> Every building generates or consumes power. Power deficit disables defenses and production. Players optimize power balance. Modders need:</p>
<ul>
<li><code>Power { provides: i32, consumes: i32 }</code> component</li>
<li><code>PowerManager</code> player resource (total capacity, total drain)</li>
<li><code>AffectedByPowerOutage</code> conditional behavior</li>
<li>Power bar UI</li>
</ul>
<hr>
<h2 id="8-support-powers--superweapons--significant-gap"><a class="header" href="#8-support-powers--superweapons--significant-gap">8. Support Powers / Superweapons ❌ SIGNIFICANT GAP</a></h2>
<p><strong>OpenRA:</strong> <code>SupportPowerManager</code>, <code>AirstrikePower</code>, <code>NukePower</code>, <code>ParatroopersPower</code>, <code>SpawnActorPower</code>, <code>GrantExternalConditionPower</code>, directional targeting.</p>
<p><strong>Iron Curtain status:</strong> Chronoshift, Iron Curtain, and nukes are mentioned as visual/shader effects. The actual <strong>superweapon system</strong> (charge timer, targeting UI, activation logic) is not designed.</p>
<p><strong>Modders need:</strong></p>
<ul>
<li><code>SupportPower</code> component (charge time, range, cooldown)</li>
<li><code>SupportPowerManager</code> player-level system</li>
<li>Charge bar UI</li>
<li>Targeting mode (point, directional, area)</li>
<li>Power activation pipeline (validate → deduct → apply warheads/effects)</li>
<li>Extensibility for custom powers via Lua/WASM</li>
</ul>
<hr>
<h2 id="9-transport--cargo-system--missing"><a class="header" href="#9-transport--cargo-system--missing">9. Transport / Cargo System ❌ MISSING</a></h2>
<p><strong>OpenRA:</strong> <code>Cargo</code> (carries passengers), <code>Passenger</code> (can be carried), <code>Carryall</code> (air transport), <code>ParaDrop</code>, <code>EjectOnDeath</code>, <code>EntersTunnels</code>.</p>
<p><strong>Iron Curtain status:</strong> Mentioned only in a campaign example (extraction). No transport mechanics designed.</p>
<p><strong>Needed:</strong></p>
<ul>
<li><code>Cargo { capacity: u32, slots: Vec&lt;EntityId&gt; }</code> component</li>
<li><code>Passenger { weight: u32 }</code> component</li>
<li>Load/unload orders and animations</li>
<li>Garrisoning buildings (shared mechanic)</li>
<li>Air transport (carryall pick up &amp; drop)</li>
<li>Paradrop mechanic</li>
<li>Eject-on-death behavior</li>
<li>Tunnel network traversal</li>
</ul>
<hr>
<h2 id="10-capture--ownership-system--missing"><a class="header" href="#10-capture--ownership-system--missing">10. Capture / Ownership System ❌ MISSING</a></h2>
<p><strong>OpenRA:</strong> <code>Capturable</code>, <code>Captures</code>, <code>ProximityCapturable</code>, <code>CaptureManager</code>, capture progress bar, <code>TransformOnCapture</code>, <code>TemporaryOwnerManager</code>.</p>
<p><strong>Iron Curtain status:</strong> Engineers capturing buildings mentioned only as a netcode edge case example. No system design.</p>
<p><strong>Needed:</strong></p>
<ul>
<li><code>Capturable { progress: i32, threshold: i32 }</code> component</li>
<li><code>Captures { types: Vec&lt;TargetType&gt;, speed: i32 }</code> component</li>
<li>Capture progress system</li>
<li>Ownership transfer logic</li>
<li>Visual feedback (progress bar, color change)</li>
<li>Proximity capture variant (for neutral tech buildings)</li>
</ul>
<hr>
<h2 id="11-stealth--detection-system--missing"><a class="header" href="#11-stealth--detection-system--missing">11. Stealth / Detection System ❌ MISSING</a></h2>
<p><strong>OpenRA:</strong> <code>Cloak</code>, <code>DetectCloaked</code>, <code>IgnoresCloak</code>, <code>IgnoresDisguise</code>, <code>RevealOnFire</code>.</p>
<p><strong>Iron Curtain status:</strong> Gap generators mentioned as a Phase 7 shader effect. No stealth system designed.</p>
<p><strong>Fundamental to RA gameplay</strong> (submarines, spies, gap generators). Needed:</p>
<ul>
<li><code>Cloak { delay: u32, detection_types: Vec&lt;CloakType&gt; }</code> component</li>
<li><code>DetectCloaked { range: i32, types: Vec&lt;CloakType&gt; }</code> component</li>
<li>Cloak/uncloak triggers (on attack, on movement, timed)</li>
<li>Integration with fog system (cloaked units hidden even in revealed area unless detector present)</li>
<li>Disguise mechanic (spy)</li>
</ul>
<hr>
<h2 id="12-crate-system--missing"><a class="header" href="#12-crate-system--missing">12. Crate System ❌ MISSING</a></h2>
<p><strong>OpenRA:</strong> 13 crate action types — cash, units, veterancy, heal, map reveal, explosions, conditions.</p>
<p><strong>Iron Curtain status:</strong> Crates mentioned only in a netcode edge case (two players racing for the same crate). No crate system designed.</p>
<p><strong>Needed:</strong></p>
<ul>
<li><code>Crate</code> entity with randomized action on pickup</li>
<li><code>CrateSpawner</code> world system (periodic spawning, max count)</li>
<li>Crate action types (cash, unit, heal, reveal, levelup, explode, cloak, etc.)</li>
<li>Configurable crate tables in YAML (modders customize what crates give)</li>
</ul>
<hr>
<h2 id="13-veterancy--experience-system--partial"><a class="header" href="#13-veterancy--experience-system--partial">13. Veterancy / Experience System ⚠️ PARTIAL</a></h2>
<p><strong>OpenRA:</strong> <code>GainsExperience</code>, <code>GivesExperience</code>, <code>ProducibleWithLevel</code>, <code>ExperienceTrickler</code>, XP multipliers. Veterancy grants conditions which enable multipliers — deeply integrated with the condition system.</p>
<p><strong>Iron Curtain status:</strong> Veterancy levels mentioned (rookie → veteran → elite → heroic), kill counts tracked, veterancy carries over in campaigns (D021). But the actual <strong>XP system mechanics</strong> are not designed:</p>
<ul>
<li>How is XP earned? (kill value, damage dealt, etc.)</li>
<li>What thresholds trigger level-ups?</li>
<li>What bonuses does each level grant? (via condition system + multipliers)</li>
<li>How does <code>ProducibleWithLevel</code> work? (barracks with veterancy upgrade)</li>
<li>XP trickler (passive XP over time)</li>
</ul>
<p><strong>Recommendation:</strong> Design this after the condition and multiplier systems, since veterancy relies on both.</p>
<hr>
<h2 id="14-damage-model--partial"><a class="header" href="#14-damage-model--partial">14. Damage Model ⚠️ PARTIAL</a></h2>
<p><strong>OpenRA damage flow:</strong></p>
<pre><code>Armament → fires → Projectile → travels → hits → Warhead(s) applied
    → target validity check (target types, stances)
    → spread damage with falloff
    → armor type lookup (Versus table)
    → DamageMultiplier traits
    → Health reduced
</code></pre>
<p><strong>Iron Curtain status:</strong> We have <code>Armament</code>, <code>Health</code>, <code>Attackable { armor }</code>, and a <code>combat_system()</code> in the pipeline. But the intermediate steps (projectile entity, warhead application, armor-versus-weapon table, damage falloff, multiple warheads) are not designed.</p>
<p><strong>Recommendation:</strong> Design the full damage pipeline. This is core to balance modding. Modders spend most of their time tuning:</p>
<ul>
<li>Weapon → Projectile → Warhead chain</li>
<li><code>Versus</code> table (armor type × weapon damage modifier)</li>
<li>Spread/falloff curves</li>
<li>Multiple warheads per weapon</li>
</ul>
<hr>
<h2 id="15-death--destruction-mechanics--missing"><a class="header" href="#15-death--destruction-mechanics--missing">15. Death &amp; Destruction Mechanics ❌ MISSING</a></h2>
<p><strong>OpenRA:</strong> <code>SpawnActorOnDeath</code> (husks, pilots), <code>ShakeOnDeath</code>, <code>ExplosionOnDamageTransition</code>, <code>FireWarheadsOnDeath</code>, <code>KillsSelf</code> (timed self-destruct), <code>EjectOnDeath</code>, <code>MustBeDestroyed</code> (victory condition).</p>
<p><strong>Iron Curtain status:</strong> <code>death_system()</code> exists in the pipeline but only described as “remove destroyed entities.” The rich on-death behaviors are not designed.</p>
<p><strong>Needed:</strong></p>
<ul>
<li><code>SpawnOnDeath { actor: ActorId }</code> — spawn husks, eject pilots</li>
<li><code>ExplodeOnDeath { warhead: WarheadId }</code> — explosion on destruction</li>
<li><code>SelfDestruct { timer: u32 }</code> — timed self-destruct (demo trucks, C4)</li>
<li><code>MustBeDestroyed</code> — victory condition marker</li>
<li><code>DamageState</code> thresholds (light → medium → heavy → critical) with visual/behavioral changes at each stage</li>
</ul>
<hr>
<h2 id="16-docking-system--missing"><a class="header" href="#16-docking-system--missing">16. Docking System ❌ MISSING</a></h2>
<p><strong>OpenRA:</strong> <code>DockHost</code> (refinery, repair pad, helipad), <code>DockClientBase</code>/<code>DockClientManager</code> (harvesters, aircraft).</p>
<p><strong>Iron Curtain status:</strong> Harvesters mentioned but the docking/delivery mechanic isn’t designed — how does a harvester deliver ore to a refinery? How does an aircraft land on a helipad?</p>
<p><strong>Needed:</strong></p>
<ul>
<li><code>DockHost { dock_type: DockType, queue: Vec&lt;EntityId&gt; }</code> — refinery, helipad, repair pad</li>
<li><code>DockClient { dock_type: DockType }</code> — harvester, aircraft</li>
<li>Docking queue system (one unit docks at a time, others wait)</li>
<li>Dock assignment (nearest available dock)</li>
</ul>
<hr>
<h2 id="17-palette-system--partial"><a class="header" href="#17-palette-system--partial">17. Palette System ⚠️ PARTIAL</a></h2>
<p><strong>OpenRA:</strong> 13 palette source types + 9 palette effect types. Runtime palette manipulation for player colors, cloak shimmer, screen flash, palette rotation (water animation).</p>
<p><strong>Iron Curtain status:</strong> <code>.pal</code> file loading designed in <code>ra-formats</code>. But runtime palette effects are not designed — these are critical for the classic RA visual style.</p>
<p><strong>Key palette effects needed:</strong></p>
<ul>
<li>Player color remapping (faction colors on units)</li>
<li>Palette rotation animation (water, ore sparkle)</li>
<li>Cloak shimmer effect</li>
<li>Screen flash (nuke, chronoshift)</li>
<li>Damage tinting</li>
</ul>
<p><strong>Note:</strong> Some of these may be handled differently with modern shaders (Bevy’s material system), but the modder-facing configuration should be equivalent.</p>
<hr>
<h2 id="18-radar--minimap-system--partial"><a class="header" href="#18-radar--minimap-system--partial">18. Radar / Minimap System ⚠️ PARTIAL</a></h2>
<p><strong>OpenRA:</strong> <code>AppearsOnRadar</code>, <code>ProvidesRadar</code>, <code>RadarColorFromTerrain</code>, <code>RadarPings</code>, <code>RadarWidget</code>.</p>
<p><strong>Iron Curtain status:</strong> Minimap mentioned in Phase 3 sidebar. “Radar as multi-mode display” is an innovative addition. But the underlying systems aren’t designed:</p>
<ul>
<li>Which units appear on radar? (controlled by <code>AppearsOnRadar</code>)</li>
<li><code>ProvidesRadar</code> — radar only works when a radar building exists</li>
<li>Radar pings (alert markers)</li>
<li>Radar rendering (terrain colors, unit dots, fog overlay)</li>
</ul>
<hr>
<h2 id="19-infantry-mechanics--missing"><a class="header" href="#19-infantry-mechanics--missing">19. Infantry Mechanics ❌ MISSING</a></h2>
<p><strong>OpenRA:</strong> <code>WithInfantryBody</code> (sub-cell positioning — 5 infantry share one cell), <code>ScaredyCat</code> (panic flee), <code>TakeCover</code> (prone behavior), <code>TerrainModifiesDamage</code> (infantry in cover).</p>
<p><strong>Iron Curtain status:</strong> Not designed. Infantry sub-cell positioning is a fundamental C&amp;C visual and gameplay mechanic — up to 5 infantry occupy one cell in different sub-positions.</p>
<p><strong>Needed:</strong></p>
<ul>
<li>Sub-cell positioning system (5 slots per cell for infantry)</li>
<li>Prone/cover behavior (reduces damage, reduces speed)</li>
<li>Scatter behavior (infantry scatter when attacked)</li>
<li>Panic behavior (run away when overwhelmed)</li>
</ul>
<hr>
<h2 id="20-mine-system--missing"><a class="header" href="#20-mine-system--missing">20. Mine System ❌ MISSING</a></h2>
<p><strong>OpenRA:</strong> <code>Mine</code>, <code>Minelayer</code>, mine detonation on contact.</p>
<p><strong>Iron Curtain status:</strong> Not mentioned.</p>
<p><strong>Needed:</strong></p>
<ul>
<li><code>Mine { trigger_types: Vec&lt;TargetType&gt;, warhead: WarheadId }</code> — detonates on contact</li>
<li><code>Minelayer { mine_type: ActorId }</code> — can lay mines</li>
<li>Mine placement order</li>
<li>Mine detection (engineer/mine-sweeper reveals mines)</li>
</ul>
<hr>
<h2 id="21-guard-command--missing"><a class="header" href="#21-guard-command--missing">21. Guard Command ❌ MISSING</a></h2>
<p><strong>OpenRA:</strong> <code>Guard</code>, <code>Guardable</code> — unit follows and protects a target, engaging threats within range.</p>
<p><strong>Iron Curtain status:</strong> Not mentioned. Guard is a fundamental RTS command.</p>
<p><strong>Needed:</strong></p>
<ul>
<li><code>Guard { target: EntityId, leash_range: i32 }</code> behavior</li>
<li>Guard order processing</li>
<li>Auto-engage threats near guarded target</li>
</ul>
<hr>
<h2 id="22-crush-mechanics--missing"><a class="header" href="#22-crush-mechanics--missing">22. Crush Mechanics ❌ MISSING</a></h2>
<p><strong>OpenRA:</strong> <code>Crushable</code>, <code>AutoCrusher</code> — vehicles crush infantry, walls.</p>
<p><strong>Iron Curtain status:</strong> Not mentioned.</p>
<p><strong>Needed:</strong></p>
<ul>
<li><code>Crushable { crush_class: CrushClass }</code> — can be crushed</li>
<li>Crush behavior on movement collision</li>
<li>Crush classes (infantry, walls, hedgehogs)</li>
</ul>
<hr>
<h2 id="23-demolition-mechanics--missing"><a class="header" href="#23-demolition-mechanics--missing">23. Demolition Mechanics ❌ MISSING</a></h2>
<p><strong>OpenRA:</strong> <code>Demolition</code>, <code>Demolishable</code> — C4 charges on buildings.</p>
<p><strong>Iron Curtain status:</strong> Not mentioned.</p>
<p><strong>Needed:</strong></p>
<ul>
<li><code>Demolition { delay: u32, warhead: WarheadId }</code> — places C4</li>
<li>Demolition order for engineer-type units</li>
</ul>
<hr>
<h2 id="24-plug-system--missing"><a class="header" href="#24-plug-system--missing">24. Plug System ❌ MISSING</a></h2>
<p><strong>OpenRA:</strong> <code>Plug</code>, <code>Pluggable</code> — actors that plug into buildings (e.g., bio-reactor accepting infantry for power).</p>
<p><strong>Iron Curtain status:</strong> Not mentioned. Primarily an RA2 mechanic but used by modders extensively.</p>
<hr>
<h2 id="25-transform-mechanics--missing"><a class="header" href="#25-transform-mechanics--missing">25. Transform Mechanics ❌ MISSING</a></h2>
<p><strong>OpenRA:</strong> <code>Transforms</code> — actor transforms into another type (MCV ↔ Construction Yard, siege tank deploy/undeploy).</p>
<p><strong>Iron Curtain status:</strong> Not designed as a system. MCV deployment is implied but not specified.</p>
<p><strong>Needed:</strong></p>
<ul>
<li><code>Transforms { into: ActorId, delay: u32, condition: Option&lt;ConditionId&gt; }</code> component</li>
<li>Deploy/undeploy orders</li>
<li>Transform animation handling</li>
</ul>
<hr>
<h2 id="26-notification-system--partial"><a class="header" href="#26-notification-system--partial">26. Notification System ⚠️ PARTIAL</a></h2>
<p><strong>OpenRA:</strong> <code>ActorLostNotification</code> (“Unit lost”), <code>AnnounceOnSeen</code> (“Enemy unit spotted”), <code>DamageNotifier</code> (“Our base is under attack”), <code>HarvesterAttackNotifier</code>, <code>ResourceStorageWarning</code> (“Silos needed”), <code>StartGameNotification</code>, <code>CaptureNotification</code>.</p>
<p><strong>Iron Curtain status:</strong> EVA voice lines and audio mentioned in Phase 3. But the notification <em>framework</em> (when to trigger which notification, cooldowns, priority) is not designed.</p>
<p><strong>Needed:</strong></p>
<ul>
<li>Notification event system with types (unit_lost, base_under_attack, harvester_attacked, silos_needed, building_captured, enemy_spotted, low_power)</li>
<li>Cooldown system (don’t spam “under attack” every frame)</li>
<li>Audio notification mapping (event → audio file)</li>
<li>Text notification display</li>
</ul>
<hr>
<h2 id="27-cursor-system--missing"><a class="header" href="#27-cursor-system--missing">27. Cursor System ❌ MISSING</a></h2>
<p><strong>OpenRA:</strong> Contextual cursors — different cursor sprites for move, attack, capture, enter, deploy, sell, repair, chronoshift, nuke, etc.</p>
<p><strong>Iron Curtain status:</strong> Not mentioned anywhere.</p>
<p><strong>Needed:</strong></p>
<ul>
<li>Cursor context system (hover over enemy = attack cursor, hover over allied building = enter/repair cursor)</li>
<li>Cursor sprite definitions in YAML</li>
<li>Cursor hotspot configuration</li>
<li>Force-modifier cursors (force-fire, force-move)</li>
</ul>
<hr>
<h2 id="28-hotkey-system--missing"><a class="header" href="#28-hotkey-system--missing">28. Hotkey System ❌ MISSING</a></h2>
<p><strong>OpenRA:</strong> 8 hotkey config files. Fully rebindable. Categories: common, player, production, control-groups, observer, chat, music, map creation.</p>
<p><strong>Iron Curtain status:</strong> Not mentioned.</p>
<p><strong>Needed:</strong></p>
<ul>
<li>Rebindable hotkey system with categories</li>
<li>Default hotkey profiles (classic RA, modern RTS)</li>
<li>Hotkey configuration UI</li>
<li>Hotkey categories: unit commands, production, control groups, camera, chat, debug</li>
</ul>
<hr>
<h2 id="29-lua-scripting-api--designed-d024--strict-superset"><a class="header" href="#29-lua-scripting-api--designed-d024--strict-superset">29. Lua Scripting API ✅ DESIGNED (D024 — Strict Superset)</a></h2>
<p><strong>OpenRA:</strong> 16 global APIs + 34 actor property groups = comprehensive mission scripting.</p>
<p><strong>Iron Curtain status:</strong> <strong>Lua API is a strict superset of OpenRA’s (D024).</strong> All 16 OpenRA globals (<code>Actor</code>, <code>Map</code>, <code>Trigger</code>, <code>Media</code>, <code>Player</code>, <code>Reinforcements</code>, <code>Camera</code>, <code>DateTime</code>, <code>Objectives</code>, <code>Lighting</code>, <code>UserInterface</code>, <code>Utils</code>, <code>Beacon</code>, <code>Radar</code>, <code>HSLColor</code>, <code>WDist</code>) are supported with identical function signatures and return types. OpenRA Lua missions run unmodified.</p>
<p>IC extends with additional globals: <code>Campaign</code> (D021 branching campaigns), <code>Weather</code> (D022 dynamic weather), <code>Workshop</code> (mod queries), <code>LLM</code> (Phase 7 integration).</p>
<p>Each actor reference exposes properties matching its components (<code>.Health</code>, <code>.Location</code>, <code>.Owner</code>, <code>.Move()</code>, <code>.Attack()</code>, <code>.Stop()</code>, <code>.Guard()</code>, <code>.Deploy()</code>, etc.) — identical to OpenRA’s actor property groups.</p>
<hr>
<h2 id="30-map-editor--deferred-p005"><a class="header" href="#30-map-editor--deferred-p005">30. Map Editor ⚠️ DEFERRED (P005)</a></h2>
<p><strong>OpenRA:</strong> Full in-engine map editor with actor placement, terrain painting, resource placement, tile editing, undo/redo, script cell triggers, marker layers, road/path tiling tool.</p>
<p><strong>Iron Curtain status:</strong> Acknowledged as pending decision P005 (Phase 6). Architecture decision: in-engine vs separate process.</p>
<p><strong>Recommendation:</strong> The in-engine approach is better for modder UX (they already have the game running, instant preview). OpenRA’s integrated editor is one of its biggest strengths.</p>
<hr>
<h2 id="31-debug--developer-tools--partial"><a class="header" href="#31-debug--developer-tools--partial">31. Debug / Developer Tools ⚠️ PARTIAL</a></h2>
<p><strong>OpenRA:</strong> <code>DeveloperMode</code> (instant build, give cash, unlimited power, build anywhere), combat debug overlay, pathfinder overlay, actor map overlay, performance graph, asset browser.</p>
<p><strong>Iron Curtain status:</strong> <code>egui</code> via <code>bevy_egui</code> mentioned for debug overlays. No specific developer mode or debug tools designed.</p>
<p><strong>Needed for modders:</strong></p>
<ul>
<li>Developer mode (toggle: instant build, free units, reveal map, unlimited power, invincibility)</li>
<li>Combat debug overlay (weapon ranges, target lines, damage numbers)</li>
<li>Pathfinding debug overlay (flowfield visualization, path cost)</li>
<li>Performance profiler (tick time, system time breakdown, entity count)</li>
<li>Asset browser (preview sprites, sounds, palettes)</li>
</ul>
<hr>
<h2 id="32-selection-system--partial"><a class="header" href="#32-selection-system--partial">32. Selection System ⚠️ PARTIAL</a></h2>
<p><strong>OpenRA:</strong> <code>Selection</code>, <code>Selectable</code> (bounds, priority, voice), <code>IsometricSelectable</code>, <code>ControlGroups</code>, selection decorations, double-click select-all-of-type, tab cycling.</p>
<p><strong>Iron Curtain status:</strong> <code>Selectable { bounds, priority }</code> component exists. Control groups mentioned in Phase 3. But detailed selection mechanics aren’t designed:</p>
<ul>
<li>Selection priority (prefer combat units over harvesters)</li>
<li>Double-click to select all of type on screen</li>
<li>Tab cycling through selected unit types</li>
<li>Box selection edge cases (what happens when box covers 200 units?)</li>
<li><code>IsometricSelectable</code> for proper diamond-shaped selection boxes</li>
</ul>
<hr>
<h2 id="33-observer--spectator-system--partial"><a class="header" href="#33-observer--spectator-system--partial">33. Observer / Spectator System ⚠️ PARTIAL</a></h2>
<p><strong>OpenRA:</strong> Observer widgets for army composition, production tracking, superweapon timers, strategic progress score.</p>
<p><strong>Iron Curtain status:</strong> Observer mode and broadcast delay mentioned in competitive design. But the observer <strong>UI</strong> (what information is shown, how) isn’t designed.</p>
<p><strong>Needed:</strong></p>
<ul>
<li>Army composition overlay (unit counts per player)</li>
<li>Production tracking overlay (what each player is building)</li>
<li>Economy overlay (income rate, resource count per player)</li>
<li>Support power timer overlay</li>
<li>Strategic score tracker</li>
</ul>
<hr>
<h2 id="34-game-speed-system--partial"><a class="header" href="#34-game-speed-system--partial">34. Game Speed System ⚠️ PARTIAL</a></h2>
<p><strong>OpenRA:</strong> 6 game speed presets (Slowest 80ms → Fastest 20ms). Configurable in lobby.</p>
<p><strong>Iron Curtain status:</strong> Sim tick rate is mentioned (15/sec = 67ms default). Game speed as a lobby option isn’t designed.</p>
<p><strong>Needed:</strong></p>
<ul>
<li>Game speed presets in lobby</li>
<li>Speed adjustment during single-player</li>
<li>Speed affects tick interval, not system behavior</li>
</ul>
<hr>
<h2 id="35-faction-system--partial"><a class="header" href="#35-faction-system--partial">35. Faction System ⚠️ PARTIAL</a></h2>
<p><strong>OpenRA:</strong> <code>Faction</code> trait (name, internal name, side). Factions determine tech trees, unit availability, starting configurations.</p>
<p><strong>Iron Curtain status:</strong> Factions mentioned (Allied, Soviet) but the faction system isn’t designed as a formal component:</p>
<ul>
<li>Faction → available tech tree mapping</li>
<li>Faction → player color defaults</li>
<li>Faction → starting unit configurations</li>
<li>Faction selection in lobby</li>
<li>Side grouping (Allies has multiple subfactions in RA2)</li>
</ul>
<hr>
<h2 id="36-replay-browser--partial"><a class="header" href="#36-replay-browser--partial">36. Replay Browser ⚠️ PARTIAL</a></h2>
<p><strong>OpenRA:</strong> Full replay browser with filtering (by map, players, date), sorting, metadata display, replay playback with speed control.</p>
<p><strong>Iron Curtain status:</strong> <code>ReplayPlayback</code> NetworkModel designed. Signed replays with hash chains. But the <strong>replay browser UI</strong> and metadata storage aren’t designed.</p>
<hr>
<h2 id="37-encyclopedia--asset-browser--missing"><a class="header" href="#37-encyclopedia--asset-browser--missing">37. Encyclopedia / Asset Browser ❌ MISSING</a></h2>
<p><strong>OpenRA:</strong> In-game encyclopedia with unit descriptions, stats, and previews. Asset browser for modders to preview sprites, sounds, videos.</p>
<p><strong>Iron Curtain status:</strong> Not mentioned.</p>
<p><strong>Recommended:</strong> An in-game encyclopedia improves discoverability. The asset browser is essential for mod development.</p>
<hr>
<h2 id="38-procedural-map-generation--partial"><a class="header" href="#38-procedural-map-generation--partial">38. Procedural Map Generation ⚠️ PARTIAL</a></h2>
<p><strong>OpenRA:</strong> <code>ClassicMapGenerator</code> (38KB) — procedural map generation with terrain types, resource placement, spawn points.</p>
<p><strong>Iron Curtain status:</strong> Not explicitly designed, though LLM-generated missions (Phase 7) may cover this. The map editor (P005) should include generation tools.</p>
<hr>
<h2 id="39-localization--i18n--missing"><a class="header" href="#39-localization--i18n--missing">39. Localization / i18n ❌ MISSING</a></h2>
<p><strong>OpenRA:</strong> <code>FluentMessages</code> section in mod manifest — full localization support using Project Fluent.</p>
<p><strong>Iron Curtain status:</strong> Not mentioned anywhere.</p>
<p><strong>Needed:</strong></p>
<ul>
<li>Localization framework (string tables, parameterized messages)</li>
<li>Multiple language support</li>
<li>Font handling for non-Latin scripts</li>
<li>Mod-provided translations</li>
</ul>
<hr>
<h2 id="priority-assessment-for-modder-familiarity"><a class="header" href="#priority-assessment-for-modder-familiarity">Priority Assessment for Modder Familiarity</a></h2>
<h3 id="p0--critical-modders-cannot-work-without-these"><a class="header" href="#p0--critical-modders-cannot-work-without-these">P0 — CRITICAL (Modders cannot work without these)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>#</th><th>System</th><th>Impact</th><th>Effort</th></tr>
</thead>
<tbody>
<tr><td>1</td><td><strong>Condition System</strong></td><td>Core modding primitive — 80% of OpenRA mods use it</td><td>High</td></tr>
<tr><td>2</td><td><strong>Multiplier System</strong></td><td>All numeric modifiers (veterancy, terrain, crates) depend on it</td><td>Medium</td></tr>
<tr><td>3</td><td><strong>Warhead System</strong></td><td>Weapons don’t work properly without composable warheads</td><td>Medium</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>✅ Items 1–3 are now Phase 2 hard exit criteria (D028).</strong> Items 6–7 are Phase 2 deliverables (D029).</p>
</blockquote>
<p>| 4   | <strong>Building mechanics</strong> (power, placement, sell, repair, build radius) | Fundamental C&amp;C gameplay                                        | High   |
| 5   | <strong>Support Powers</strong>                                                    | Superweapons are iconic RA gameplay                             | Medium |
| 6   | <strong>Damage Model</strong> (full pipeline)                                      | Core balance modding                                            | Medium |
| 7   | <strong>Projectile System</strong> (travel, tracking, types)                       | Weapons need physical projectiles                               | Medium |</p>
<h3 id="p1--high-core-gameplay-gaps--noticeable-to-players-immediately"><a class="header" href="#p1--high-core-gameplay-gaps--noticeable-to-players-immediately">P1 — HIGH (Core gameplay gaps — noticeable to players immediately)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>#</th><th>System</th><th>Impact</th><th>Effort</th></tr>
</thead>
<tbody>
<tr><td>8</td><td><strong>Transport / Cargo</strong></td><td>APCs, helicopters, naval transports</td><td>Medium</td></tr>
<tr><td>9</td><td><strong>Capture / Engineers</strong></td><td>Fundamental C&amp;C mechanic</td><td>Low</td></tr>
<tr><td>10</td><td><strong>Stealth / Cloak</strong></td><td>Subs, spies, gap generators</td><td>Medium</td></tr>
<tr><td>11</td><td><strong>Death mechanics</strong> (husks, spawn-on-death, explosions)</td><td>Visual polish + gameplay</td><td>Low</td></tr>
<tr><td>12</td><td><strong>Infantry sub-cell positioning</strong></td><td>Visual authenticity + gameplay</td><td>Medium</td></tr>
<tr><td>13</td><td><strong>Veterancy system</strong> (full)</td><td>Depth of gameplay</td><td>Medium</td></tr>
<tr><td>14</td><td><strong>Docking system</strong></td><td>Harvester-refinery, helipad</td><td>Medium</td></tr>
<tr><td>15</td><td><strong>Transform / Deploy</strong></td><td>MCV, siege units</td><td>Low</td></tr>
<tr><td>16</td><td><strong>Power System</strong></td><td>Core economy mechanic</td><td>Low</td></tr>
</tbody>
</table>
</div>
<h3 id="p2--medium-important-for-full-experience"><a class="header" href="#p2--medium-important-for-full-experience">P2 — MEDIUM (Important for full experience)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>#</th><th>System</th><th>Impact</th><th>Effort</th></tr>
</thead>
<tbody>
<tr><td>17</td><td><strong>Crate System</strong></td><td>Standard skirmish feature</td><td>Low</td></tr>
<tr><td>18</td><td><strong>Mine System</strong></td><td>Defensive gameplay</td><td>Low</td></tr>
<tr><td>19</td><td><strong>Guard Command</strong></td><td>Fundamental order type</td><td>Low</td></tr>
<tr><td>20</td><td><strong>Crush Mechanics</strong></td><td>Vehicle vs infantry interaction</td><td>Low</td></tr>
<tr><td>21</td><td><strong>Notification System</strong> (framework)</td><td>Audio/visual feedback</td><td>Medium</td></tr>
<tr><td>22</td><td><strong>Cursor System</strong></td><td>UX polish, essential for usability</td><td>Low</td></tr>
<tr><td>23</td><td><strong>Hotkey System</strong></td><td>UX — rebindable keys</td><td>Low</td></tr>
<tr><td>24</td><td><strong>Lua API</strong> (detailed)</td><td>Mission scripters need this</td><td>High</td></tr>
<tr><td>25</td><td><strong>Selection system</strong> (detailed)</td><td>UX polish</td><td>Low</td></tr>
<tr><td>26</td><td><strong>Palette effects</strong> (runtime)</td><td>Classic RA visual style</td><td>Medium</td></tr>
<tr><td>27</td><td><strong>Game speed presets</strong></td><td>Lobby option</td><td>Low</td></tr>
</tbody>
</table>
</div>
<h3 id="p3--lower-nice-to-have-can-defer"><a class="header" href="#p3--lower-nice-to-have-can-defer">P3 — LOWER (Nice to have, can defer)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>#</th><th>System</th><th>Impact</th><th>Effort</th></tr>
</thead>
<tbody>
<tr><td>28</td><td><strong>Demolition / C4</strong></td><td>Engineer ability</td><td>Low</td></tr>
<tr><td>29</td><td><strong>Plug System</strong></td><td>Primarily RA2</td><td>Low</td></tr>
<tr><td>30</td><td><strong>Encyclopedia</strong></td><td>Discoverability</td><td>Low</td></tr>
<tr><td>31</td><td><strong>Localization</strong></td><td>Multi-language support</td><td>Medium</td></tr>
<tr><td>32</td><td><strong>Observer UI</strong> (detailed)</td><td>Spectator experience</td><td>Medium</td></tr>
<tr><td>33</td><td><strong>Replay browser UI</strong></td><td>Replay management</td><td>Low</td></tr>
<tr><td>34</td><td><strong>Debug tools</strong> (detailed)</td><td>Developer experience</td><td>Medium</td></tr>
<tr><td>35</td><td><strong>Procedural map gen</strong></td><td>Map variety</td><td>High</td></tr>
<tr><td>36</td><td><strong>Faction system</strong> (formal)</td><td>Multi-faction support</td><td>Low</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="what-iron-curtain-has-that-openra-doesnt"><a class="header" href="#what-iron-curtain-has-that-openra-doesnt">What Iron Curtain Has That OpenRA Doesn’t</a></h2>
<p>The gap analysis is not one-directional. Iron Curtain’s design docs include features OpenRA lacks:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>IC Design Doc</th><th>OpenRA Status</th></tr>
</thead>
<tbody>
<tr><td><strong>LLM-generated missions &amp; campaigns</strong></td><td><code>04-MODDING.md</code>, Phase 7</td><td>Not present</td></tr>
<tr><td><strong>Branching campaigns with persistent state</strong></td><td>D021, <code>04-MODDING.md</code></td><td>Not present (linear campaigns only)</td></tr>
<tr><td><strong>WASM mod runtime</strong></td><td><code>04-MODDING.md</code> Tier 3</td><td>Not present (C# DLLs only)</td></tr>
<tr><td><strong>Switchable balance presets</strong></td><td>D019</td><td>Not present (one balance per mod)</td></tr>
<tr><td><strong>Sub-tick timestamped orders</strong></td><td>D008, <code>03-NETCODE.md</code></td><td>Not present</td></tr>
<tr><td><strong>Relay server architecture</strong></td><td>D007, <code>03-NETCODE.md</code></td><td>Not present (P2P only)</td></tr>
<tr><td><strong>Cross-engine compatibility</strong></td><td><code>07-CROSS-ENGINE.md</code></td><td>Not present</td></tr>
<tr><td><strong>Multi-game engine</strong> (RA1+RA2+TD on one engine)</td><td>D018, <code>02-ARCHITECTURE.md</code></td><td>Partial (3 games but tightly coupled)</td></tr>
<tr><td><strong><code>llm:</code> metadata on all resources</strong></td><td><code>04-MODDING.md</code></td><td>Not present</td></tr>
<tr><td><strong>Weather system</strong> (with sim effects)</td><td><code>04-MODDING.md</code></td><td>Visual only (WeatherOverlay trait)</td></tr>
<tr><td><strong>Workshop with semantic search</strong></td><td><code>04-MODDING.md</code></td><td>Forum-based mod sharing</td></tr>
<tr><td><strong>Mod SDK with CLI tool</strong></td><td>D020, <code>04-MODDING.md</code></td><td>Exists but requires .NET</td></tr>
<tr><td><strong>Competitive infrastructure</strong> (rated, ranked, tournaments)</td><td><code>01-VISION.md</code></td><td>Basic (no ranked, no leagues)</td></tr>
<tr><td><strong>Platform portability</strong> (WASM, mobile, console)</td><td><code>02-ARCHITECTURE.md</code></td><td>Desktop only</td></tr>
<tr><td><strong>3D rendering mod support</strong></td><td><code>02-ARCHITECTURE.md</code></td><td>Not architecturally possible</td></tr>
<tr><td><strong>Signed/certified match results</strong></td><td><code>06-SECURITY.md</code></td><td>Not present</td></tr>
<tr><td><strong>Video as workshop resource</strong></td><td><code>04-MODDING.md</code></td><td>Not present</td></tr>
<tr><td><strong>Scene templates</strong> (parameterized mission building blocks)</td><td><code>04-MODDING.md</code></td><td>Not present</td></tr>
<tr><td><strong>Adaptive difficulty</strong> (via campaign state or LLM)</td><td><code>04-MODDING.md</code>, <code>01-VISION.md</code></td><td>Not present</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="mapping-table-openra-trait--iron-curtain-equivalent"><a class="header" href="#mapping-table-openra-trait--iron-curtain-equivalent">Mapping Table: OpenRA Trait → Iron Curtain Equivalent</a></h2>
<p>For modders migrating from OpenRA, this table shows where each familiar trait maps. Items marked “NEEDS DESIGN” are the gaps identified above.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>OpenRA Trait</th><th>Iron Curtain Equivalent</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td><code>Health</code></td><td><code>Health { current, max }</code></td><td>✅</td></tr>
<tr><td><code>Armor</code></td><td><code>Attackable { armor }</code></td><td>✅</td></tr>
<tr><td><code>Mobile</code></td><td><code>Mobile { speed, locomotor }</code></td><td>✅</td></tr>
<tr><td><code>Building</code></td><td><code>Building { footprint }</code></td><td>✅</td></tr>
<tr><td><code>Buildable</code></td><td><code>Buildable { cost, time, prereqs }</code></td><td>✅</td></tr>
<tr><td><code>Selectable</code></td><td><code>Selectable { bounds, priority }</code></td><td>✅</td></tr>
<tr><td><code>Harvester</code></td><td><code>Harvester { capacity, resource }</code></td><td>✅</td></tr>
<tr><td><code>Armament</code></td><td><code>Armament { weapon, cooldown }</code></td><td>✅</td></tr>
<tr><td><code>Valued</code></td><td>Part of <code>Buildable.cost</code></td><td>✅</td></tr>
<tr><td><code>Tooltip</code></td><td><code>display.name</code> in YAML</td><td>✅</td></tr>
<tr><td><code>Voiced</code></td><td><code>display.voice</code> (implied)</td><td>⚠️</td></tr>
<tr><td><code>ConditionalTrait</code></td><td><code>Conditions</code> component (D028)</td><td>✅</td></tr>
<tr><td><code>GrantConditionOn*</code></td><td>Condition sources in YAML (D028)</td><td>✅</td></tr>
<tr><td><code>*Multiplier</code></td><td><code>StatModifiers</code> component (D028)</td><td>✅</td></tr>
<tr><td><code>AttackBase/Follow/Frontal/Omni/Turreted</code></td><td>Part of <code>combat</code> YAML section</td><td>⚠️</td></tr>
<tr><td><code>AutoTarget</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>Turreted</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>AmmoPool</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>Cargo</code> / <code>Passenger</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>Capturable</code> / <code>Captures</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>Cloak</code> / <code>DetectCloaked</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>Power</code> / <code>PowerManager</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>SupportPower*</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>GainsExperience</code> / <code>GivesExperience</code></td><td>NEEDS DESIGN (partially mentioned)</td><td>⚠️</td></tr>
<tr><td><code>Locomotor</code></td><td><code>locomotor</code> field in <code>Mobile</code></td><td>✅</td></tr>
<tr><td><code>Aircraft</code></td><td>NEEDS DESIGN (air movement)</td><td>❌</td></tr>
<tr><td><code>ProductionQueue</code></td><td>Mentioned, not fully designed</td><td>⚠️</td></tr>
<tr><td><code>Crate</code> / <code>CrateAction*</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>Mine</code> / <code>Minelayer</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>Guard</code> / <code>Guardable</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>Crushable</code> / <code>AutoCrusher</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>Transforms</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>Sellable</code></td><td>Mentioned as order, not as component</td><td>⚠️</td></tr>
<tr><td><code>RepairableBuilding</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>RallyPoint</code></td><td>Mentioned as order, not as component</td><td>⚠️</td></tr>
<tr><td><code>PrimaryBuilding</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>Gate</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>LineBuild</code> (walls)</td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>BaseProvider</code> / <code>GivesBuildableArea</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>Faction</code></td><td>Implied, not formalized</td><td>⚠️</td></tr>
<tr><td><code>Encyclopedia</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>DeveloperMode</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>WithInfantryBody</code> (sub-cell)</td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>ScaredyCat</code> / <code>TakeCover</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>KillsSelf</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>SpawnActorOnDeath</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
<tr><td><code>Husk</code></td><td>NEEDS DESIGN</td><td>❌</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="recommended-action-plan"><a class="header" href="#recommended-action-plan">Recommended Action Plan</a></h2>
<h3 id="phase-2-additions-sim--months-612"><a class="header" href="#phase-2-additions-sim--months-612">Phase 2 Additions (Sim — Months 6–12)</a></h3>
<p>These gaps need to be designed <em>before or during</em> Phase 2 since they’re core simulation mechanics.</p>
<blockquote>
<p><strong>NOTE:</strong> Items 1–3 are now <strong>Phase 2 hard exit criteria</strong> per D028. Items marked with (D029) are Phase 2 deliverables per D029. The Lua API (#24) is specified per D024.</p>
</blockquote>
<ol>
<li><strong>Condition system</strong> — ✅ DESIGNED (D028) — Phase 2 exit criterion</li>
<li><strong>Multiplier system</strong> — ✅ DESIGNED (D028) — Phase 2 exit criterion</li>
<li><strong>Full damage pipeline</strong> — ✅ DESIGNED (D028) — Phase 2 exit criterion (Projectile → Warhead → Armor table → Modifiers → Health)</li>
<li><strong>Power system</strong> — Affects building behavior</li>
<li><strong>Building mechanics</strong> — Placement, sell, repair, build radius, rally points</li>
<li><strong>Transport/Cargo</strong> — Core unit type</li>
<li><strong>Capture</strong> — Core unit type (engineers)</li>
<li><strong>Stealth/Cloak</strong> — Core mechanic (subs, spies)</li>
<li><strong>Infantry sub-cell</strong> — Core visual/gameplay mechanic</li>
<li><strong>Death mechanics</strong> — Husks, spawn-on-death</li>
<li><strong>Transform/Deploy</strong> — MCV, siege units</li>
<li><strong>Veterancy</strong> (full system) — XP → conditions → multipliers</li>
<li><strong>Guard command</strong> — Fundamental order type</li>
<li><strong>Crush mechanics</strong> — Vehicle/infantry interaction</li>
</ol>
<h3 id="phase-3-additions-ui--months-1216"><a class="header" href="#phase-3-additions-ui--months-1216">Phase 3 Additions (UI — Months 12–16)</a></h3>
<ol start="15">
<li><strong>Support Powers</strong> — UI + sim system</li>
<li><strong>Cursor system</strong> — Contextual cursors</li>
<li><strong>Hotkey system</strong> — Rebindable keys</li>
<li><strong>Notification framework</strong> — EVA event → audio mapping</li>
<li><strong>Selection details</strong> — Priority, double-click, tab cycle</li>
<li><strong>Game speed presets</strong> — Lobby option</li>
<li><strong>Radar system</strong> (detailed) — ProvidesRadar, AppearsOnRadar</li>
<li><strong>Power bar UI</strong> — Visualization</li>
<li><strong>Observer UI</strong> — Army/production/economy overlays</li>
</ol>
<h3 id="phase-4-additions-scripting--months-1620"><a class="header" href="#phase-4-additions-scripting--months-1620">Phase 4 Additions (Scripting — Months 16–20)</a></h3>
<ol start="24">
<li><strong>Lua API specification</strong> — ✅ DESIGNED (D024) — strict superset of OpenRA’s 16 globals, identical signatures</li>
<li><strong>Crate system</strong> — Skirmish feature</li>
<li><strong>Mine system</strong> — Tactical gameplay</li>
<li><strong>Demolition/C4</strong> — Engineer ability</li>
</ol>
<h3 id="phase-6-additions-modding--months-2632"><a class="header" href="#phase-6-additions-modding--months-2632">Phase 6 Additions (Modding — Months 26–32)</a></h3>
<ol start="28">
<li><strong>Debug/developer tools</strong> — Modder essential</li>
<li><strong>Encyclopedia</strong> — Discoverability</li>
<li><strong>Localization framework</strong> — i18n</li>
<li><strong>Faction system</strong> (formal) — Multi-faction support</li>
<li><strong>Palette effects</strong> (runtime) — Classic visual style</li>
<li><strong>Asset browser</strong> — Mod development</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mod-migration-case-studies"><a class="header" href="#mod-migration-case-studies">Mod Migration Case Studies</a></h1>
<blockquote>
<p><strong>Purpose:</strong> Validate Iron Curtain’s modding architecture against real-world OpenRA mods and official C&amp;C products. These case studies answer: “Can the most ambitious community work actually run on our engine?”</p>
</blockquote>
<hr>
<h2 id="case-study-1-combined-arms-openras-most-ambitious-mod"><a class="header" href="#case-study-1-combined-arms-openras-most-ambitious-mod">Case Study 1: Combined Arms (OpenRA’s Most Ambitious Mod)</a></h2>
<h3 id="what-combined-arms-is"><a class="header" href="#what-combined-arms-is">What Combined Arms Is</a></h3>
<p><a href="https://github.com/Inq8/CAmod">Combined Arms</a> (CA) is the largest and most ambitious OpenRA mod in existence. It is effectively a standalone game:</p>
<ul>
<li><strong>5 factions</strong> — Allies, Soviets, GDI, Nod, Scrin</li>
<li><strong>20 sub-factions</strong> — 4 unique variants per faction, each with distinct units, powers, and upgrades</li>
<li><strong>34 campaign missions</strong> — Lua-scripted narrative across 8+ chapters, with co-op support</li>
<li><strong>450+ maps</strong> — including competitive maps from base RA</li>
<li><strong>Competitive ladder</strong> — 1v1 ranked play with player statistics</li>
<li><strong>86 releases</strong> — actively maintained, v1.08.1 released January 2026</li>
<li><strong>9.3/10 ModDB rating</strong> — 45 reviews, 60K downloads, 482 watchers</li>
</ul>
<p>CA represents the upper bound of what the OpenRA modding ecosystem has produced. If IC can support CA, it can support anything.</p>
<h3 id="cas-technical-composition"><a class="header" href="#cas-technical-composition">CA’s Technical Composition</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Language</th><th>Share</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>C#</td><td>67.7%</td><td>Custom engine traits (compiled DLLs)</td></tr>
<tr><td>Lua</td><td>29.4%</td><td>Campaign missions, scripted events</td></tr>
<tr><td>YAML (MiniYAML)</td><td>~3%</td><td>Unit definitions, weapon stats, rules</td></tr>
</tbody>
</table>
</div>
<p>CA’s heavy C# usage is significant — it means CA has outgrown OpenRA’s data-driven modding and needed to extend the engine itself. This is exactly the scenario IC’s three-tier modding architecture is designed to handle.</p>
<h3 id="cas-custom-code-inventory"><a class="header" href="#cas-custom-code-inventory">CA’s Custom Code Inventory</a></h3>
<p>Surveyed from <code>OpenRA.Mods.CA/</code> — <strong>~150+ custom C# files</strong> organized into:</p>
<h4 id="custom-traits-90-files-in-traits"><a class="header" href="#custom-traits-90-files-in-traits">Custom Traits (~90 files in <code>Traits/</code>)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Custom Traits</th><th>Examples</th><th>IC Equivalent</th></tr>
</thead>
<tbody>
<tr><td>Mind Control</td><td>5</td><td><code>MindController</code>, <code>MindControllable</code>, <code>MindControllerCapacityModifier</code></td><td>Built-in ECS component or WASM</td></tr>
<tr><td>Spawner/Carrier</td><td>8</td><td><code>CarrierMaster</code>/<code>Slave</code>, <code>AirstrikeMaster</code>/<code>Slave</code>, <code>SpawnerMasterBase</code></td><td>Built-in (needed for RA2/Scrin)</td></tr>
<tr><td>Teleport Network</td><td>3</td><td><code>TeleportNetwork</code>, <code>TeleportNetworkPrimaryExit</code>, <code>TeleportNetworkTransportable</code></td><td>Built-in or WASM</td></tr>
<tr><td>Upgrades</td><td>4</td><td><code>Upgradeable</code>, <code>ProvidesUpgrade</code>, <code>RearmsToUpgrade</code></td><td>YAML conditions system</td></tr>
<tr><td>Unit Abilities</td><td>5</td><td><code>TargetedAttackAbility</code>, <code>TargetedLeapAbility</code>, <code>TargetedDiveAbility</code>, <code>SpawnActorAbility</code></td><td>Lua or WASM</td></tr>
<tr><td>Shields/Defense</td><td>4</td><td><code>Shielded</code>, <code>PointDefense</code>, <code>ReflectsDamage</code>, <code>ConvertsDamageToHealth</code></td><td>Built-in or WASM</td></tr>
<tr><td>Missiles</td><td>4</td><td><code>BallisticMissile</code>, <code>CruiseMissile</code>, <code>GuidedMissile</code>, <code>MissileBase</code></td><td>Built-in projectile system</td></tr>
<tr><td>Transport/Cargo</td><td>6</td><td><code>CargoBlocked</code>, <code>CargoCloner</code>, <code>MassEntersCargo</code>, <code>PassengerBlocked</code></td><td>Built-in + YAML</td></tr>
<tr><td>Deploy/Transform</td><td>6</td><td><code>DeployOnAttack</code>, <code>InstantTransforms</code>, <code>DetonateWeaponOnDeploy</code>, <code>AutoDeployer</code></td><td>Conditions + YAML</td></tr>
<tr><td>Resources</td><td>6</td><td><code>ChronoResourceDelivery</code>, <code>HarvesterBalancer</code>, <code>ConvertsResources</code></td><td>YAML + Lua</td></tr>
<tr><td>Death/Spawn</td><td>6</td><td><code>SpawnActorOnDeath</code>, <code>SpawnRandomActorOnDeath</code>, <code>SpawnHuskEffectOnDeath</code></td><td>Built-in + YAML</td></tr>
<tr><td>Experience</td><td>5</td><td><code>GivesBountyCA</code>, <code>GivesExperienceCA</code>, <code>GivesExperienceToMaster</code></td><td>Built-in veterancy</td></tr>
<tr><td>Infiltration</td><td>4+</td><td>Subdirectory with multiple infiltration traits</td><td>Built-in + YAML</td></tr>
<tr><td>Berserk/Warp</td><td>2</td><td><code>Berserkable</code>, <code>Warpable</code></td><td>WASM</td></tr>
<tr><td>Production</td><td>4</td><td><code>LinkedProducerSource</code>/<code>Target</code>, <code>PeriodicProducerCA</code>, <code>ProductionAirdropCA</code></td><td>Built-in + YAML</td></tr>
<tr><td>Attachable</td><td>5</td><td><code>Attachable</code>, <code>AttachableTo</code>, <code>AttachOnCreation</code>, <code>AttachOnTransform</code></td><td>WASM</td></tr>
<tr><td>Stealth</td><td>1</td><td><code>Mirage</code> (disguise as props)</td><td>Built-in cloak system</td></tr>
<tr><td>Misc</td><td>20+</td><td><code>PopControlled</code>, <code>MadTankCA</code>, <code>KeepsDistance</code>, <code>LaysMinefield</code>, <code>Convertible</code>, <code>ChronoshiftableCA</code></td><td>Mixed</td></tr>
</tbody>
</table>
</div>
<p>Also includes subdirectories: <code>Air/</code>, <code>Attack/</code>, <code>BotModules/</code>, <code>Conditions/</code>, <code>Infiltration/</code>, <code>Modifiers/</code>, <code>Multipliers/</code>, <code>PaletteEffects/</code>, <code>Palettes/</code>, <code>Player/</code>, <code>Render/</code>, <code>Sound/</code>, <code>SupportPowers/</code>, <code>World/</code></p>
<h4 id="custom-warheads-24-files-in-warheads"><a class="header" href="#custom-warheads-24-files-in-warheads">Custom Warheads (24 files in <code>Warheads/</code>)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Warhead</th><th>Purpose</th><th>IC Equivalent</th></tr>
</thead>
<tbody>
<tr><td><code>FireShrapnelWarhead</code></td><td>Secondary projectiles on impact</td><td>Built-in warhead pipeline</td></tr>
<tr><td><code>FireFragmentWarhead</code></td><td>Fragment weapons on detonation</td><td>Built-in warhead pipeline</td></tr>
<tr><td><code>WarpDamageWarhead</code></td><td>Temporal displacement damage</td><td>WASM warhead module</td></tr>
<tr><td><code>SpawnActorWarhead</code></td><td>Spawn units on detonation</td><td>Built-in</td></tr>
<tr><td><code>SpawnBuildingWarhead</code></td><td>Create buildings on impact</td><td>Built-in</td></tr>
<tr><td><code>AttachActorWarhead</code></td><td>Attach parasites/bombs</td><td>WASM</td></tr>
<tr><td><code>AttachDelayedWeaponWarhead</code></td><td>Time-delayed weapon effects</td><td>Built-in timer system</td></tr>
<tr><td><code>InfiltrateWarhead</code></td><td>Spy-type infiltration on hit</td><td>Built-in infiltration</td></tr>
<tr><td><code>CreateTintedCellsWarhead</code></td><td>Tiberium-style terrain damage</td><td>Built-in terrain system</td></tr>
<tr><td><code>SendAirstrikeWarhead</code></td><td>Trigger airstrike on impact</td><td>Lua or WASM</td></tr>
<tr><td><code>HealthPercentageSpreadDamageWarhead</code></td><td>%-based area damage</td><td>Built-in damage pipeline</td></tr>
<tr><td>Others (13)</td><td>Flash effects, condition grants, etc.</td><td>Mixed</td></tr>
</tbody>
</table>
</div>
<h4 id="custom-projectiles-16-files-in-projectiles"><a class="header" href="#custom-projectiles-16-files-in-projectiles">Custom Projectiles (16 files in <code>Projectiles/</code>)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Projectile</th><th>Size</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>LinearPulse</code></td><td>65KB</td><td>Complex line-based energy weapon</td></tr>
<tr><td><code>MissileCA</code></td><td>40KB</td><td>Heavily customized missile behavior</td></tr>
<tr><td><code>BulletCA</code></td><td>17KB</td><td>Extended bullet with tracking/effects</td></tr>
<tr><td><code>PlasmaBeam</code></td><td>14KB</td><td>Scrin-style plasma weapon</td></tr>
<tr><td><code>RailgunCA</code></td><td>11KB</td><td>Railgun visual effect</td></tr>
<tr><td><code>ElectricBolt</code></td><td>9KB</td><td>Tesla-style electrical discharge</td></tr>
<tr><td><code>AreaBeamCA</code></td><td>10KB</td><td>Area-effect beam weapon</td></tr>
<tr><td><code>ArcLaserZap</code></td><td>5KB</td><td>Curved laser visual</td></tr>
<tr><td>Others (8)</td><td>Varies</td><td>RadBeam, TeslaZapCA, KKNDLaser, etc.</td></tr>
</tbody>
</table>
</div>
<p>Custom projectiles are primarily <strong>render code</strong> — visual effects for weapon impacts. In IC, these map to shader effects and particle systems in <code>ra-render</code>, not simulation code.</p>
<h4 id="custom-activities-24-files-in-activities"><a class="header" href="#custom-activities-24-files-in-activities">Custom Activities (24 files in <code>Activities/</code>)</a></h4>
<p>Activities are unit behaviors — the “verbs” that units perform:</p>
<ul>
<li><code>Attach</code>, <code>Dive</code>, <code>DiveApproach</code>, <code>TargetedLeap</code> — special movement/attack patterns</li>
<li><code>BallisticMissileFly</code>, <code>CruiseMissileFly</code>, <code>GuidedMissileFly</code> — missile flight paths</li>
<li><code>EnterTeleportNetwork</code>, <code>TeleportCA</code> — teleportation mechanics</li>
<li><code>InstantTransform</code>, <code>Upgrade</code> — unit transformation</li>
<li><code>ChronoResourceTeleport</code> — chronoshift-style harvesting</li>
<li><code>MassRideTransport</code>, <code>ParadropCargo</code> — transport mechanics</li>
</ul>
<p>In IC, activities map to ECS system behaviors, triggered by conditions or orders.</p>
<h3 id="migration-assessment"><a class="header" href="#migration-assessment">Migration Assessment</a></h3>
<h4 id="what-migrates-automatically-zero-effort"><a class="header" href="#what-migrates-automatically-zero-effort">What Migrates Automatically (Zero Effort)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Asset Type</th><th>Volume</th><th>Method</th></tr>
</thead>
<tbody>
<tr><td>Sprite assets (.shp)</td><td>Hundreds</td><td>IC loads natively (invariant #8)</td></tr>
<tr><td>Palette files (.pal)</td><td>Dozens</td><td>IC loads natively</td></tr>
<tr><td>Sound effects (.aud)</td><td>Hundreds</td><td>IC loads natively</td></tr>
<tr><td>Map files (.oramap)</td><td>450+</td><td>IC loads natively</td></tr>
<tr><td>MiniYAML rules</td><td>Thousands of entries</td><td><strong>Loads directly at runtime (D025)</strong> — no conversion step</td></tr>
<tr><td>OpenRA YAML keys</td><td>All trait names</td><td><strong>Accepted as aliases (D023)</strong> — <code>Armament</code> and <code>combat</code> both work</td></tr>
<tr><td>OpenRA mod manifest</td><td><code>mod.yaml</code></td><td><strong>Parsed directly (D026)</strong> — point IC at OpenRA mod dir</td></tr>
<tr><td>Lua mission scripts</td><td>34 missions</td><td><strong>Run unmodified (D024)</strong> — IC Lua API is strict superset</td></tr>
</tbody>
</table>
</div>
<h4 id="what-migrates-with-effort"><a class="header" href="#what-migrates-with-effort">What Migrates with Effort</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Effort</th><th>Details</th></tr>
</thead>
<tbody>
<tr><td><strong>YAML unit definitions</strong></td><td><strong>Zero</strong></td><td>MiniYAML loads at runtime (D025), OpenRA trait names accepted as aliases (D023) — no conversion needed</td></tr>
<tr><td><strong>Lua campaign missions</strong></td><td><strong>Zero</strong></td><td>IC Lua API is a strict superset of OpenRA’s (D024) — same 16 globals, same signatures, same return types; missions run unmodified</td></tr>
<tr><td><strong>Custom traits → Built-in</strong></td><td>None</td><td>IC builds mind control, carriers, shields, teleport networks, upgrades, delayed weapons as Phase 2 first-party components (D029)</td></tr>
<tr><td><strong>Custom traits → YAML conditions</strong></td><td>Low</td><td>Deploy mechanics, upgrade toggles, transform states map to IC’s condition system (D028)</td></tr>
<tr><td><strong>Custom traits → WASM</strong></td><td>Significant</td><td>~20 truly novel traits need WASM rewrite: Berserkable, Warpable, KeepsDistance, Attachable system, custom ability targeting</td></tr>
<tr><td><strong>Custom warheads</strong></td><td>Low</td><td>Many become built-in warhead pipeline extensions (D028); novel ones (WarpDamage, TintedCells) need WASM</td></tr>
<tr><td><strong>Custom projectiles</strong></td><td>Moderate</td><td>These are primarily render code; rewrite as <code>ra-render</code> shader effects and particle systems</td></tr>
<tr><td><strong>Custom UI widgets</strong></td><td>Moderate</td><td>CA has custom widgets; these need Bevy UI reimplementation</td></tr>
<tr><td><strong>Bot modules</strong></td><td>Low-Moderate</td><td>Map to <code>ra-ai</code> crate’s bot system</td></tr>
</tbody>
</table>
</div>
<h4 id="migration-tier-breakdown"><a class="header" href="#migration-tier-breakdown">Migration Tier Breakdown</a></h4>
<pre><code>┌─────────────────────────────────────────────────┐
│     Combined Arms → Iron Curtain Migration      │
│           (after D023–D029)                      │
├─────────────────────────────────────────────────┤
│                                                 │
│  Tier 1 (YAML)  ██████████████████████ ~45%    │
│  No code change needed. Unit stats, weapons,    │
│  armor tables, build trees, faction setup.       │
│  MiniYAML loads directly (D025).                 │
│  OpenRA trait names accepted as aliases (D023).  │
│                                                 │
│  Built-in       ████████████████████  ~40%    │
│  IC includes as first-party ECS components       │
│  (D029). Mind control, carriers, shields,        │
│  teleport, upgrades, delayed weapons,            │
│  veterancy, infiltration, damage pipeline.       │
│                                                 │
│  Tier 2 (Lua)   ██████              ~10%      │
│  Campaign missions run unmodified (D024).        │
│  IC Lua API is strict superset of OpenRA's.      │
│                                                 │
│  Tier 3 (WASM)  ███                ~5%       │
│  Truly novel mechanics only: Berserkable,        │
│  Warpable, KeepsDistance, Attachable.             │
│                                                 │
└─────────────────────────────────────────────────┘
</code></pre>
<h3 id="what-ca-gains-by-migrating"><a class="header" href="#what-ca-gains-by-migrating">What CA Gains by Migrating</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Benefit</th><th>Details</th></tr>
</thead>
<tbody>
<tr><td><strong>No more engine version treadmill</strong></td><td>CA currently pins to OpenRA releases, rebasing C# against every engine update. IC’s mod API is versioned and stable.</td></tr>
<tr><td><strong>Better performance</strong></td><td>CA with 5 factions pushes OpenRA hard. IC’s efficiency pyramid (flowfields, spatial hashing, sim LOD) handles large battles better.</td></tr>
<tr><td><strong>Better multiplayer</strong></td><td>Relay server, sub-tick ordering, signed replays, ranked infrastructure built in — no custom ladder server needed.</td></tr>
<tr><td><strong>Hot-reloadable mods</strong></td><td>Change YAML, see results immediately. No recompilation ever.</td></tr>
<tr><td><strong>Workshop distribution</strong></td><td><code>ic</code> CLI tool packages and publishes mods. No manual download/install.</td></tr>
<tr><td><strong>Branching campaigns (D021)</strong></td><td>IC’s narrative graph with persistent unit roster would elevate CA’s 34 missions significantly.</td></tr>
<tr><td><strong>WASM sandboxing</strong></td><td>Custom code runs in a sandbox with capability-based API — no risk of mods crashing the engine or accessing filesystem.</td></tr>
<tr><td><strong>Cross-platform for free</strong></td><td>CA currently packages per-platform. IC runs on Windows/Mac/Linux/Browser/Mobile from one codebase.</td></tr>
</tbody>
</table>
</div>
<h3 id="verdict"><a class="header" href="#verdict">Verdict</a></h3>
<p><strong>Not plug-and-play, but a realistic and beneficial migration — dramatically improved by D023–D029.</strong></p>
<ul>
<li><strong>~95% of content</strong> (YAML rules via D025 runtime loading + D023 aliases, assets, maps, Lua missions via D024 superset API, built-in mechanics via D029) migrates with <strong>zero effort</strong> — no conversion tools, no code changes.</li>
<li><strong>~5% of content</strong> (~20 truly novel C# traits) requires WASM rewrites — bounded and well-identified.</li>
<li>The migration is a <strong>net positive</strong>: CA ends up with better performance, multiplayer, distribution, and maintainability.</li>
<li><strong>Zero-friction evaluation:</strong> Point IC at an OpenRA mod directory (D026) and it loads. No commitment required to test.</li>
<li>IC <strong>benefits too</strong>: CA’s requirements for mind control, teleport networks, carriers, shields, and upgrades validate and drive our component library design. If IC supports CA, it supports any OpenRA mod.</li>
</ul>
<h3 id="lessons-for-ic-design"><a class="header" href="#lessons-for-ic-design">Lessons for IC Design</a></h3>
<p>CA’s codebase reveals which OpenRA gaps force modders into C#. These should become first-party IC features:</p>
<ol>
<li><strong>Mind Control</strong> — Full system: controller, controllable, capacity limits, progress bars, spawn-on-mind-controlled. Needed for Yuri/Scrin in future game modules.</li>
<li><strong>Carrier/Spawner</strong> — Master/slave with drone AI, return-to-carrier, respawn timers. Needed for Kirov, Aircraft Carriers, Scrin Mothership.</li>
<li><strong>Teleport Networks</strong> — Enter any, exit at primary. Needed for Nod tunnels in TD/TS.</li>
<li><strong>Shield Systems</strong> — Absorb damage, recharge, deplete. Needed for Scrin and RA2 force shields.</li>
<li><strong>Upgrade System</strong> — Per-unit tech upgrades purchased at buildings. Needed for C&amp;C3-style gameplay.</li>
<li><strong>Delayed Weapons</strong> — Attach timers to targets. Common RTS mechanic (poison, radiation, time bombs).</li>
<li><strong>Attachable Actors</strong> — Parasite/bomb attachment. Terror drones in RA2.</li>
</ol>
<p>These seven systems cover ~60% of CA’s custom C# code and are universally useful across C&amp;C game modules.</p>
<hr>
<h2 id="case-study-2-cc-remastered-collection"><a class="header" href="#case-study-2-cc-remastered-collection">Case Study 2: C&amp;C Remastered Collection</a></h2>
<h3 id="what-remastered-delivers"><a class="header" href="#what-remastered-delivers">What Remastered Delivers</a></h3>
<p>The C&amp;C Remastered Collection (Petroglyph/EA, 2020) modernized C&amp;C95 and Red Alert with:</p>
<ul>
<li><strong>HD/SD toggle</strong> — Press F1 to instantly swap between classic 320×200 sprites and remastered HD art (4096-color, hand-painted)</li>
<li><strong>4K support</strong> — HD assets render at native resolution up to 3840×2160</li>
<li><strong>Zoom</strong> — Camera zoom in/out (not in original)</li>
<li><strong>Modern UI</strong> — Cleaner sidebar, rally points, attack-move, queued production</li>
<li><strong>Remastered audio</strong> — Frank Klepacki re-recorded the entire soundtrack; jukebox mode</li>
<li><strong>Classic gameplay</strong> — Deliberately preserved original balance and feel</li>
<li><strong>Bonus gallery</strong> — Concept art, behind-the-scenes, FMV jukebox</li>
</ul>
<p>This is the gold standard for C&amp;C modernization. The question: could someone achieve this on IC?</p>
<h3 id="how-ics-architecture-supports-each-feature"><a class="header" href="#how-ics-architecture-supports-each-feature">How IC’s Architecture Supports Each Feature</a></h3>
<h4 id="hdsd-graphics-toggle"><a class="header" href="#hdsd-graphics-toggle">HD/SD Graphics Toggle</a></h4>
<p>IC handles this through three converging architectural decisions:</p>
<p><strong>Invariant #9</strong> (game-agnostic renderer): The engine uses a <code>Renderable</code> trait. The RA1 game module registers sprite rendering, but the engine doesn’t know what format the sprites are. A game module can register <em>two</em> asset sets and swap at runtime.</p>
<p><strong>Invariant #10</strong> (platform-agnostic): “Render quality is runtime-configurable.” This is literally the HD/SD toggle stated as an architectural requirement.</p>
<p><strong>Bevy’s asset system</strong>: Both classic <code>.shp</code> sprites and HD texture atlases load as Bevy asset handles. The toggle swaps which handle the <code>Renderable</code> component references. This is a frame-instant operation — no loading screen required.</p>
<p><strong>Implementation sketch:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Component that tracks which asset quality to render
#[derive(Component)]
struct RenderQuality {
    classic: Handle&lt;SpriteSheet&gt;,
    hd: Option&lt;Handle&lt;SpriteSheet&gt;&gt;,
    active: Quality, // Classic | HD
}

/// System: swap sprite sheet on toggle
fn toggle_render_quality(
    input: Res&lt;Input&gt;,
    mut query: Query&lt;&amp;mut RenderQuality&gt;,
) {
    if input.just_pressed(KeyCode::F1) {
        for mut rq in &amp;mut query {
            rq.active = match rq.active {
                Quality::Classic =&gt; Quality::HD,
                Quality::HD =&gt; Quality::Classic,
            };
        }
    }
}
<span class="boring">}</span></code></pre>
<p><strong>YAML-level support:</strong></p>
<pre><code class="language-yaml"># Unit definition with dual asset sets
e1:
  render:
    sprite:
      classic: infantry/e1.shp
      hd: infantry/e1_hd.png
    palette:
      classic: temperat.pal
      hd: null  # HD uses embedded color
    shadow:
      classic: infantry/e1_shadow.shp
      hd: infantry/e1_shadow_hd.png
</code></pre>
<h4 id="4k-native-rendering"><a class="header" href="#4k-native-rendering">4K Native Rendering</a></h4>
<p>Bevy + wgpu handle arbitrary resolutions natively. The isometric renderer in <code>ra-render</code> would:</p>
<ul>
<li>Detect native display resolution via Bevy’s window system</li>
<li>Classify into <code>ScreenClass</code> (our responsive UI system from invariant #10)</li>
<li>Classic sprites: integer-scaled (2×, 3×, 4×, 6×) with nearest-neighbor filtering to preserve pixel art</li>
<li>HD sprites: render at native resolution, no scaling artifacts</li>
<li>UI elements: adapt layout per <code>ScreenClass</code> (phone → tablet → laptop → desktop → 4K)</li>
</ul>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Display</th><th>Classic Mode</th><th>HD Mode</th></tr>
</thead>
<tbody>
<tr><td>1080p</td><td>3× integer scale</td><td>Native HD</td></tr>
<tr><td>1440p</td><td>4× integer scale</td><td>Native HD</td></tr>
<tr><td>4K</td><td>6× integer scale</td><td>Native HD</td></tr>
<tr><td>Ultrawide</td><td>Scale + letterbox options</td><td>Native HD, wider viewport</td></tr>
</tbody>
</table>
</div>
<h4 id="camera-zoom"><a class="header" href="#camera-zoom">Camera Zoom</a></h4>
<p>Standard Bevy camera parameter. The isometric renderer already needs to handle different view distances for the minimap and observer mode. Zoom is a single <code>f32</code> on the camera entity — trivial to expose as scroll-wheel or keybind.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn camera_zoom(
    input: Res&lt;Input&gt;,
    mut camera: Query&lt;&amp;mut OrthographicProjection, With&lt;GameCamera&gt;&gt;,
) {
    let scroll = input.mouse_scroll_delta();
    for mut proj in &amp;mut camera {
        proj.scale = (proj.scale - scroll.y * 0.1).clamp(0.5, 3.0);
    }
}
<span class="boring">}</span></code></pre>
<h4 id="modern-ui--sidebar"><a class="header" href="#modern-ui--sidebar">Modern UI / Sidebar</a></h4>
<ul>
<li>IC’s <code>ra-ui</code> crate uses Bevy UI — not locked to OpenRA’s widget system</li>
<li>The Remastered sidebar layout is our explicit UX reference (AGENTS.md: “EA Remastered Collection — UI/UX gold standard. Cleanest, least cluttered C&amp;C interface.”)</li>
<li>Rally points, attack-move, queued production are standard Phase 3 deliverables</li>
<li>A <code>remastered</code> UI theme could coexist with a <code>classic</code> theme — switchable in settings</li>
</ul>
<h4 id="remastered-audio"><a class="header" href="#remastered-audio">Remastered Audio</a></h4>
<p>IC’s <code>ra-audio</code> crate supports:</p>
<ul>
<li>Classic <code>.aud</code> format (loaded natively per invariant #8)</li>
<li>Modern audio formats (WAV, OGG, FLAC) via Bevy’s audio plugin</li>
<li>Jukebox mode is a UI feature — trivial playlist management</li>
<li>EVA voice system supports multiple voice packs</li>
<li>Spatial audio for positional effects (explosions, gunfire)</li>
</ul>
<p>A “Remastered audio pack” would be a mod containing high-quality re-recordings alongside classic <code>.aud</code> files, with a toggle in audio settings.</p>
<h4 id="balance-preservation"><a class="header" href="#balance-preservation">Balance Preservation</a></h4>
<p><strong>D019 (Switchable Balance Presets)</strong> explicitly defines <code>remastered</code> as a preset:</p>
<pre><code class="language-yaml"># rules/presets/remastered.yaml
# Any balance changes from the EA Remastered Collection.
# Selected in lobby alongside "classic" and "openra" presets.
preset: remastered
source: "C&amp;C Remastered Collection (2020)"
inherit: classic
overrides:
  # Document specific deviations from original balance here
</code></pre>
<p>Players choose in lobby: Classic (EA source values), OpenRA (OpenRA balance), or Remastered.</p>
<h3 id="what-it-would-take"><a class="header" href="#what-it-would-take">What It Would Take</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Effort</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><strong>Classic assets</strong></td><td>Zero</td><td>IC loads .shp, .pal, .aud, .tmp natively (invariant #8)</td></tr>
<tr><td><strong>HD art assets</strong></td><td><strong>Major art effort</strong></td><td>EA’s HD sprites are copyrighted; must be created independently</td></tr>
<tr><td><strong>HD/SD toggle system</strong></td><td>Moderate</td><td>Dual asset handles per entity, runtime swap, ~2 weeks engineering</td></tr>
<tr><td><strong>4K rendering</strong></td><td>Free</td><td>Bevy/wgpu handles natively</td></tr>
<tr><td><strong>Integer scaling</strong></td><td>Low</td><td>Nearest-neighbor upscale for classic sprites, configurable scale factor</td></tr>
<tr><td><strong>Camera zoom</strong></td><td>Trivial</td><td>Single camera parameter, hours of work</td></tr>
<tr><td><strong>Remastered UI theme</strong></td><td>Moderate</td><td>Bevy UI layout, reference EA Remastered screenshots</td></tr>
<tr><td><strong>Remastered balance preset</strong></td><td>Low</td><td>YAML data file comparing EA Remastered balance to original</td></tr>
<tr><td><strong>Remastered audio pack</strong></td><td>Art effort</td><td>Community re-recordings or licensed audio</td></tr>
<tr><td><strong>Bonus gallery</strong></td><td>Low</td><td>Image viewer + FMV player (IC already plans .vqa support)</td></tr>
</tbody>
</table>
</div>
<h3 id="the-art-bottleneck"><a class="header" href="#the-art-bottleneck">The Art Bottleneck</a></h3>
<p>The engineering is straightforward. The bottleneck is <strong>art assets</strong>:</p>
<p>EA’s HD sprites for the Remastered Collection are copyrighted and cannot be redistributed. A community-driven Remastered experience on IC would need:</p>
<ol>
<li><strong>Commission original HD art</strong> in the Remastered style — expensive but legally clear</li>
<li><strong>AI upscaling</strong> of classic sprites — lower quality, fast, legally ambiguous</li>
<li><strong>Community art packs</strong> distributed via workshop — distributed effort, curated quality</li>
<li><strong>Open-source HD asset projects</strong> — several community efforts exist for C&amp;C sprite HD conversions</li>
</ol>
<p>IC’s architecture makes the <em>engine</em> part trivial. The <code>GameModule</code> trait (D018) means a <code>remastered</code> module can register HD asset loaders, the dual-render toggle, UI theme, and balance preset. The engine doesn’t care — it’s game-agnostic.</p>
<h3 id="implementation-as-a-game-module"><a class="header" href="#implementation-as-a-game-module">Implementation as a Game Module</a></h3>
<p>The full Remastered experience would be a game module (D018):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RemasteredModule;

impl GameModule for RemasteredModule {
    fn name(&amp;self) -&gt; &amp;str { "C&amp;C Remastered" }

    fn register_systems(&amp;self, app: &amp;mut App) {
        // Everything from RA1Module, plus:
        app.add_systems(Update, toggle_render_quality);
        app.add_systems(Update, camera_zoom);

        // Register HD asset loaders alongside classic ones
        app.add_plugins(HdSpritePlugin);
        app.add_plugins(HdAudioPlugin);

        // Remastered UI theme
        app.insert_resource(UiTheme::Remastered);

        // Balance preset
        app.insert_resource(BalancePreset::Remastered);
    }

    fn register_assets(&amp;self, server: &amp;AssetServer) {
        // Load both classic and HD asset sets
        server.register_loader::&lt;ShpLoader&gt;();   // Classic
        server.register_loader::&lt;HdPngLoader&gt;(); // HD
    }
}
<span class="boring">}</span></code></pre>
<h3 id="verdict-1"><a class="header" href="#verdict-1">Verdict</a></h3>
<p><strong>Yes, someone could recreate the Remastered experience on IC.</strong> The architecture explicitly supports it:</p>
<ul>
<li>Game-agnostic engine with <code>GameModule</code> trait (D018) — Remastered becomes a module</li>
<li>Runtime-configurable render quality (invariant #10) — the HD/SD toggle</li>
<li>Switchable balance presets (D019) — <code>remastered</code> preset alongside <code>classic</code> and <code>openra</code></li>
<li>Full original format compatibility (invariant #8) — classic assets load unchanged</li>
<li>Bevy/wgpu for modern rendering — 4K, zoom, post-processing, all native</li>
</ul>
<p><strong>The bottleneck is art, not engineering.</strong> If someone produced HD sprite assets compatible with IC’s asset system, the engine work for the HD/SD toggle, 4K rendering, zoom, and modern UI is straightforward Bevy development — estimated at 4-6 weeks of focused engineering on top of the base RA1 game module.</p>
<p>This case study validates IC’s multi-game architecture: the same engine that runs classic RA1 can deliver a Remastered-quality experience as a different game module, with zero changes to the engine core.</p>
<hr>
<h2 id="cross-cutting-insights"><a class="header" href="#cross-cutting-insights">Cross-Cutting Insights</a></h2>
<p>Both case studies validate the same architectural decisions:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Decision</th><th>CA Validation</th><th>Remastered Validation</th></tr>
</thead>
<tbody>
<tr><td><strong>D018 (Game Modules)</strong></td><td>CA’s 5 factions = a game module that registers more components than base RA1</td><td>Remastered = a module that registers dual asset loaders</td></tr>
<tr><td><strong>Tiered Modding</strong></td><td>40% YAML + 15% Lua + 15% WASM + 30% built-in</td><td>95% data/asset-driven, 5% module code</td></tr>
<tr><td><strong>Invariant #8 (Format Compat)</strong></td><td>450+ maps, all sprites, all audio load natively</td><td>All classic assets load natively</td></tr>
<tr><td><strong>Invariant #9 (Game-Agnostic)</strong></td><td>Scrin/GDI/Nod require engine-agnostic component design</td><td>HD renderer is game-agnostic</td></tr>
<tr><td><strong>Invariant #10 (Platform-Agnostic)</strong></td><td>Must run on all platforms with same mod content</td><td>Runtime render quality = HD/SD toggle</td></tr>
<tr><td><strong>D019 (Balance Presets)</strong></td><td>CA’s custom balance is just another preset</td><td><code>remastered</code> preset</td></tr>
<tr><td><strong>D021 (Campaigns)</strong></td><td>CA’s 34 missions benefit from branching narrative graph</td><td>Remastered’s campaigns could use persistent roster</td></tr>
</tbody>
</table>
</div>
<h3 id="seven-built-in-systems-driven-by-these-case-studies"><a class="header" href="#seven-built-in-systems-driven-by-these-case-studies">Seven Built-In Systems Driven by These Case Studies</a></h3>
<p>Based on CA’s custom C# requirements and Remastered’s features, IC should include these as first-party engine components (not mod-level WASM):</p>
<ol>
<li><strong>Mind Control</strong> — Controller/controllable with capacity limits, progress indication, spawn-on-override</li>
<li><strong>Carrier/Spawner</strong> — Master/slave drone management with respawn, recall, autonomous attack</li>
<li><strong>Teleport Network</strong> — Multi-node network with primary exit designation</li>
<li><strong>Shield System</strong> — Absorb damage before health, recharge timer, visual effects</li>
<li><strong>Upgrade System</strong> — Per-unit tech upgrades via building research, with conditions</li>
<li><strong>Delayed Weapons</strong> — Time-delayed effects attached to targets (poison, radiation, bombs)</li>
<li><strong>Dual Asset Rendering</strong> — Runtime-switchable asset quality (classic/HD) per entity</li>
</ol>
<p>These seven systems serve both case studies, all future C&amp;C game modules (RA2, TS, C&amp;C3), and the broader RTS modding community.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
